<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  <subtitle>满招损 谦受益</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.studyfe.cn/"/>
  <updated>2019-11-14T08:46:04.631Z</updated>
  <id>https://www.studyfe.cn/</id>
  
  <author>
    <name>任博</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 原理之 hook</title>
    <link href="https://www.studyfe.cn/2019/11/09/react/library-react-hook/"/>
    <id>https://www.studyfe.cn/2019/11/09/react/library-react-hook/</id>
    <published>2019-11-09T11:12:35.000Z</published>
    <updated>2019-11-14T08:46:04.631Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;什么是-hook&quot;&gt;&lt;a href=&quot;#什么是-hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 hook&quot;&gt;&lt;/a&gt;什么是 hook&lt;hr&gt;&lt;/h3&gt;&lt;p&gt;hook 意为钩子，当代码执行特定的时期时会自动调用 hook
        
      
    
    </summary>
    
      <category term="react" scheme="https://www.studyfe.cn/categories/react/"/>
    
    
      <category term="react" scheme="https://www.studyfe.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 原理之 setState 执行机制</title>
    <link href="https://www.studyfe.cn/2019/10/09/react/library-react-state/"/>
    <id>https://www.studyfe.cn/2019/10/09/react/library-react-state/</id>
    <published>2019-10-09T13:10:35.000Z</published>
    <updated>2019-11-05T14:29:54.683Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;提到 react 的 setState 大家应该都很熟悉，那么下面我们以实际开发中遇到的几个问题，来引入 setState 的机制&lt;/p&gt;
&lt;h2 id=&quot;问题集合&quot;&gt;&lt;a href=&quot;#问题集合&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="react" scheme="https://www.studyfe.cn/categories/react/"/>
    
    
      <category term="react" scheme="https://www.studyfe.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 原理之 FiberRoot 调度过程</title>
    <link href="https://www.studyfe.cn/2019/10/06/react/library-react-fiber02/"/>
    <id>https://www.studyfe.cn/2019/10/06/react/library-react-fiber02/</id>
    <published>2019-10-06T11:20:25.000Z</published>
    <updated>2019-10-31T15:56:25.632Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;上篇文章我们对 fiber 的创建做了大概的了解，并且还引入了 scheduleWork 函数。scheduleWork 函数实际执行了如下几个重要的函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;checkForNestedUpdates 判断是否有无限循环的
        
      
    
    </summary>
    
      <category term="react" scheme="https://www.studyfe.cn/categories/react/"/>
    
    
      <category term="react" scheme="https://www.studyfe.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 原理之 FiberRoot 构建过程</title>
    <link href="https://www.studyfe.cn/2019/10/04/react/library-react-fiber01/"/>
    <id>https://www.studyfe.cn/2019/10/04/react/library-react-fiber01/</id>
    <published>2019-10-04T05:20:25.000Z</published>
    <updated>2019-10-17T10:25:07.123Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;fiber 是当前整个 react 核心部分，其中包含了大量的计算机知识。如果阅读 react 的源码能让人感觉到无力。&lt;/p&gt;
&lt;p&gt;每次版本更新，核心部分的函数总是要动那么一动。从 15, 到 16 到 16.8、16.9 到现在的 16.10，包括现在已经改版的
        
      
    
    </summary>
    
      <category term="react" scheme="https://www.studyfe.cn/categories/react/"/>
    
    
      <category term="react" scheme="https://www.studyfe.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 之生命周期使用</title>
    <link href="https://www.studyfe.cn/2019/10/02/react/library-react-lifecycle/"/>
    <id>https://www.studyfe.cn/2019/10/02/react/library-react-lifecycle/</id>
    <published>2019-10-02T05:20:25.000Z</published>
    <updated>2019-10-09T10:03:14.407Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;和 Vue 一样 React 也会有对应的生命周期钩子函数，在相对应的钩子函数内，分别在不同时机处理相对应的逻辑，贴一张来至官网&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;
        
      
    
    </summary>
    
      <category term="react" scheme="https://www.studyfe.cn/categories/react/"/>
    
    
      <category term="react" scheme="https://www.studyfe.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 原理之 JSX 转换</title>
    <link href="https://www.studyfe.cn/2019/10/01/react/library-react-jsx/"/>
    <id>https://www.studyfe.cn/2019/10/01/react/library-react-jsx/</id>
    <published>2019-10-01T10:06:25.000Z</published>
    <updated>2019-10-14T10:16:33.708Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;JSX-转换&quot;&gt;&lt;a href=&quot;#JSX-转换&quot; class=&quot;headerlink&quot; title=&quot;JSX 转换&quot;&gt;&lt;/a&gt;JSX 转换&lt;/h2&gt;&lt;p&gt;在我们写 react 组件的时候都会去写 jsx，那么 jsx 在 react
        
      
    
    </summary>
    
      <category term="react" scheme="https://www.studyfe.cn/categories/react/"/>
    
    
      <category term="react" scheme="https://www.studyfe.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之keep-alive</title>
    <link href="https://www.studyfe.cn/2019/09/22/vue/vuekeepalive/"/>
    <id>https://www.studyfe.cn/2019/09/22/vue/vuekeepalive/</id>
    <published>2019-09-22T12:55:12.000Z</published>
    <updated>2019-09-28T08:46:42.043Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在我们的平时开发工作中，有很多组件没有必要多次初始化，通过缓存组件的状态减少性能上的开销。而 vue 的组件缓存优化则使用内置组件 &lt;keep-alive&gt;&lt;/keep-alive&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot;
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之生命周期</title>
    <link href="https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/"/>
    <id>https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/</id>
    <published>2019-09-21T05:50:28.000Z</published>
    <updated>2019-10-08T07:36:21.434Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;每一个 vue 的实例在创建的时候都经过一系列的初始化操作，在每一个阶段都会有相对应的生命周期钩子函数，来在特定的场景实现一些功能&lt;/p&gt;
&lt;h3 id=&quot;生命周期方法&quot;&gt;&lt;a href=&quot;#生命周期方法&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之组件化</title>
    <link href="https://www.studyfe.cn/2019/09/21/vue/vuecomponents/"/>
    <id>https://www.studyfe.cn/2019/09/21/vue/vuecomponents/</id>
    <published>2019-09-21T02:50:28.000Z</published>
    <updated>2019-09-29T04:06:29.855Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/&quot;&gt;生命周期&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之编译</title>
    <link href="https://www.studyfe.cn/2019/09/19/vue/vuecompile/"/>
    <id>https://www.studyfe.cn/2019/09/19/vue/vuecompile/</id>
    <published>2019-09-19T07:02:12.000Z</published>
    <updated>2019-09-19T12:39:44.440Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;编译入口&quot;&gt;&lt;a href=&quot;#编译入口&quot; class=&quot;headerlink&quot; title=&quot;编译入口&quot;&gt;&lt;/a&gt;编译入口&lt;/h2&gt;&lt;p&gt;还记得我们在第一篇文章介绍整理的执行过程的时候通过，在 $mount 这个函数内调用 compileToFunctions
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之组件更新</title>
    <link href="https://www.studyfe.cn/2019/09/18/vue/vuecomupdate/"/>
    <id>https://www.studyfe.cn/2019/09/18/vue/vuecomupdate/</id>
    <published>2019-09-18T02:50:28.000Z</published>
    <updated>2019-09-19T06:45:00.363Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;上一篇文章我们对响应式原理进行了梳理，知道了当数据发生变化会触发 watcher 的回调，进行组件更新，那么接下来我们看看更新的操作是怎么进行了。&lt;code&gt;src/core/instance/lifecycle.js&lt;/code&gt; 中
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之 v-model</title>
    <link href="https://www.studyfe.cn/2019/09/12/vue/vuevmodel/"/>
    <id>https://www.studyfe.cn/2019/09/12/vue/vuevmodel/</id>
    <published>2019-09-12T12:20:12.000Z</published>
    <updated>2019-09-22T10:51:06.876Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在日常开发中我们使用 v-model 来实现数据的双向绑定，那么接下来我们通过一张流程图来大概的看看它实现的流程。具体源码解析请参考&lt;a
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之异步组件</title>
    <link href="https://www.studyfe.cn/2019/09/10/vue/vueasync-component/"/>
    <id>https://www.studyfe.cn/2019/09/10/vue/vueasync-component/</id>
    <published>2019-09-10T10:06:25.000Z</published>
    <updated>2019-09-22T09:15:23.124Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，有三种实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通的异步组件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-numbers
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理之组件注册</title>
    <link href="https://www.studyfe.cn/2019/09/08/vue/vuecomponentregister/"/>
    <id>https://www.studyfe.cn/2019/09/08/vue/vuecomponentregister/</id>
    <published>2019-09-08T04:08:25.000Z</published>
    <updated>2019-09-22T08:29:53.948Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在日常开发中我们经常会用到许多自定义的组件，除了内置组件自定义组件用的时候必须注册，否则会提示如下信息&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-md&quot;&gt;&lt;code class=&quot;language-md&quot;&gt;&#39;Unknown custom
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>computed 和 watcher</title>
    <link href="https://www.studyfe.cn/2019/09/07/vue/vuecomputedwatcher/"/>
    <id>https://www.studyfe.cn/2019/09/07/vue/vuecomputedwatcher/</id>
    <published>2019-09-07T14:25:12.000Z</published>
    <updated>2019-09-29T04:05:34.477Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;vue 的 computed 和 watch 是我们在开发中经常用的方法，从而实现数据的响应与监听，下面我们从使用和源码来分析一下这两个属性的实现原理是什么。&lt;/p&gt;
&lt;h3 id=&quot;computed-和-watch-使用&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理解析之响应式</title>
    <link href="https://www.studyfe.cn/2019/09/05/vue/vueobserve/"/>
    <id>https://www.studyfe.cn/2019/09/05/vue/vueobserve/</id>
    <published>2019-09-05T08:45:09.000Z</published>
    <updated>2019-09-10T08:06:43.348Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;响应式对象&quot;&gt;&lt;a href=&quot;#响应式对象&quot; class=&quot;headerlink&quot; title=&quot;响应式对象&quot;&gt;&lt;/a&gt;响应式对象&lt;/h2&gt;&lt;p&gt;提到 vue 的双向数据绑定原理，我们都知道是利用了
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 原理解析之主线流程</title>
    <link href="https://www.studyfe.cn/2019/08/27/vue/vueprinciple/"/>
    <id>https://www.studyfe.cn/2019/08/27/vue/vueprinciple/</id>
    <published>2019-08-27T15:12:09.000Z</published>
    <updated>2019-09-10T09:42:18.047Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;div align=&quot;middle&quot;&gt;
  &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot;
        
      
    
    </summary>
    
      <category term="vue" scheme="https://www.studyfe.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.studyfe.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>generator 与 async</title>
    <link href="https://www.studyfe.cn/2019/08/26/javascript/generator-async/"/>
    <id>https://www.studyfe.cn/2019/08/26/javascript/generator-async/</id>
    <published>2019-08-26T08:22:09.000Z</published>
    <updated>2019-09-09T06:39:32.487Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在前端中异步编程一直是前端开发的一个痛点，因为 JavaScript 语法的灵活性和特殊性导致前端开发的困难（因为 JavaScript
        
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.studyfe.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.studyfe.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>global.d.ts</title>
    <link href="https://www.studyfe.cn/2019/08/15/typescript/global.d.ts/"/>
    <id>https://www.studyfe.cn/2019/08/15/typescript/global.d.ts/</id>
    <published>2019-08-15T10:20:27.000Z</published>
    <updated>2019-09-05T03:41:37.959Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;pre&gt;&lt;code&gt;// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]
// Project: [~THE PROJECT NAME~]
// Definitions by:
        
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://www.studyfe.cn/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://www.studyfe.cn/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>class.d.ts</title>
    <link href="https://www.studyfe.cn/2019/08/15/typescript/module-class.d.ts/"/>
    <id>https://www.studyfe.cn/2019/08/15/typescript/module-class.d.ts/</id>
    <published>2019-08-15T10:20:27.000Z</published>
    <updated>2019-09-05T03:41:37.959Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;// Type definitions for [&lt;del&gt;THE LIBRARY NAME&lt;/del&gt;] [&lt;del&gt;OPTIONAL VERSION NUMBER&lt;/del&gt;]&lt;br&gt;// Project: [&lt;del&gt;THE PROJECT
        
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://www.studyfe.cn/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://www.studyfe.cn/tags/TypeScript/"/>
    
  </entry>
  
</feed>
