<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>global.d.ts</title>
      <link href="/2019/08/15/typescript/global.d.ts/"/>
      <url>/2019/08/15/typescript/global.d.ts/</url>
      
        <content type="html"><![CDATA[<pre><code>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ If this library is callable (e.g. can be invoked as myLib(3)), *~ include those call signatures here. *~ Otherwise, delete this section. */declare function myLib(a: string): string;declare function myLib(a: number): number;/*~ If you want the name of this library to be a valid type name, *~ you can do so here. *~ *~ For example, this allows us to write &#39;var x: myLib&#39;; *~ Be sure this actually makes sense! If it doesn&#39;t, just *~ delete this declaration and add types inside the namespace below. */interface myLib {    name: string;    length: number;    extras?: string[];}/*~ If your library has properties exposed on a global variable, *~ place them here. *~ You should also place types (interfaces and type alias) here. */declare namespace myLib {    //~ We can write &#39;myLib.timeout = 50;&#39;    let timeout: number;    //~ We can access &#39;myLib.version&#39;, but not change it    const version: string;    //~ There&#39;s some class we can create via &#39;let c = new myLib.Cat(42)&#39;    //~ Or reference e.g. &#39;function f(c: myLib.Cat) { ... }    class Cat {        constructor(n: number);        //~ We can read &#39;c.age&#39; from a &#39;Cat&#39; instance        readonly age: number;        //~ We can invoke &#39;c.purr()&#39; from a &#39;Cat&#39; instance        purr(): void;    }    //~ We can declare a variable as    //~   &#39;var s: myLib.CatSettings = { weight: 5, name: &quot;Maru&quot; };&#39;    interface CatSettings {        weight: number;        name: string;        tailLength?: number;    }    //~ We can write &#39;const v: myLib.VetID = 42;&#39;    //~  or &#39;const v: myLib.VetID = &quot;bob&quot;;&#39;    type VetID = string | number;    //~ We can invoke &#39;myLib.checkCat(c)&#39; or &#39;myLib.checkCat(c, v);&#39;    function checkCat(c: Cat, s?: VetID);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class.d.ts</title>
      <link href="/2019/08/15/typescript/module-class.d.ts/"/>
      <url>/2019/08/15/typescript/module-class.d.ts/</url>
      
        <content type="html"><![CDATA[<p>// Type definitions for [<del>THE LIBRARY NAME</del>] [<del>OPTIONAL VERSION NUMBER</del>]<br>// Project: [<del>THE PROJECT NAME</del>]<br>// Definitions by: [<del>YOUR NAME</del>] &lt;[<del>A URL FOR YOU</del>]&gt;</p><p>/<em>~ This is the module template file for class modules. </em>~ You should rename it to index.d.ts and place it in a folder with the same name as the module.<br> <em>~ For example, if you were writing a file for “super-greeter”, this </em>~ file should be ‘super-greeter/index.d.ts’<br> */</p><p>/<em>~ Note that ES6 modules cannot directly export class objects. </em>~ This file should be imported using the CommonJS-style:<br> <em>~   import x = require(‘someLibrary’); </em>~<br> <em>~ Refer to the documentation to understand common </em>~ workarounds for this limitation of ES6 modules.<br> */</p><p>/<em>~ If this module is a UMD module that exposes a global variable ‘myClassLib’ when </em>~ loaded outside a module loader environment, declare that global here.<br> <em>~ Otherwise, delete this declaration. </em>/<br>export as namespace myClassLib;</p><p>/<em>~ This declaration specifies that the class constructor function </em>~ is the exported object from the file<br> */<br>export = MyClass;</p><p>/<em>~ Write your module’s methods and properties in this class </em>/<br>declare class MyClass {<br>    constructor(someParam?: string);</p><pre><code>someProperty: string[];myMethod(opts: MyClass.MyClassMethodOptions): number;</code></pre><p>}</p><p>/<em>~ If you want to expose types from your module as well, you can </em>~ place them in this block.<br> */<br>declare namespace MyClass {<br>    export interface MyClassMethodOptions {<br>        width?: number;<br>        height?: number;<br>    }<br>}</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function.d.ts</title>
      <link href="/2019/08/15/typescript/module-function.d.ts/"/>
      <url>/2019/08/15/typescript/module-function.d.ts/</url>
      
        <content type="html"><![CDATA[<p>// Type definitions for [<del>THE LIBRARY NAME</del>] [<del>OPTIONAL VERSION NUMBER</del>]<br>// Project: [<del>THE PROJECT NAME</del>]<br>// Definitions by: [<del>YOUR NAME</del>] &lt;[<del>A URL FOR YOU</del>]&gt;</p><p>/<em>~ This is the module template file for function modules. </em>~ You should rename it to index.d.ts and place it in a folder with the same name as the module.<br> <em>~ For example, if you were writing a file for “super-greeter”, this </em>~ file should be ‘super-greeter/index.d.ts’<br> */</p><p>/<em>~ Note that ES6 modules cannot directly export callable functions. </em>~ This file should be imported using the CommonJS-style:<br> <em>~   import x = require(‘someLibrary’); </em>~<br> <em>~ Refer to the documentation to understand common </em>~ workarounds for this limitation of ES6 modules.<br> */</p><p>/<em>~ If this module is a UMD module that exposes a global variable ‘myFuncLib’ when </em>~ loaded outside a module loader environment, declare that global here.<br> <em>~ Otherwise, delete this declaration. </em>/<br>export as namespace myFuncLib;</p><p>/<em>~ This declaration specifies that the function </em>~ is the exported object from the file<br> */<br>export = MyFunction;</p><p>/<em>~ This example shows how to have multiple overloads for your function </em>/<br>declare function MyFunction(name: string): MyFunction.NamedReturnType;<br>declare function MyFunction(length: number): MyFunction.LengthReturnType;</p><p>/<em>~ If you want to expose types from your module as well, you can </em>~ place them in this block. Often you will want to describe the<br> <em>~ shape of the return type of the function; that type should </em>~ be declared in here, as this example shows.<br> */<br>declare namespace MyFunction {<br>    export interface LengthReturnType {<br>        width: number;<br>        height: number;<br>    }<br>    export interface NamedReturnType {<br>        firstName: string;<br>        lastName: string;<br>    }</p><pre><code>/*~ If the module also has properties, declare them here. For example, *~ this declaration says that this code is legal: *~   import f = require(&#39;myFuncLibrary&#39;); *~   console.log(f.defaultName); */export const defaultName: string;export let defaultLength: number;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module.d.ts</title>
      <link href="/2019/08/15/typescript/module.d.ts/"/>
      <url>/2019/08/15/typescript/module.d.ts/</url>
      
        <content type="html"><![CDATA[<pre><code>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;/*~ This is the module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for &quot;super-greeter&quot;, this *~ file should be &#39;super-greeter/index.d.ts&#39; *//*~ If this module is a UMD module that exposes a global variable &#39;myLib&#39; when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myLib;/*~ If this module has methods, declare them as functions like so. */export function myMethod(a: string): string;export function myOtherMethod(a: number): number;/*~ You can declare types that are available via importing the module */export interface someType {    name: string;    length: number;    extras?: string[];}/*~ You can declare properties of the module using const, let, or var */export const myField: number;/*~ If there are types, properties, or methods inside dotted names *~ of the module, declare them inside a &#39;namespace&#39;. */export namespace subProp {    /*~ For example, given this definition, someone could write:     *~   import { subProp } from &#39;yourModule&#39;;     *~   subProp.foo();     *~ or     *~   import * as yourMod from &#39;yourModule&#39;;     *~   yourMod.subProp.foo();     */    export function foo(): void;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript编译原理</title>
      <link href="/2019/08/05/typescript/compilationprinciple/"/>
      <url>/2019/08/05/typescript/compilationprinciple/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 编译器源文件位于 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/compiler" target="_blank" rel="noopener">src/compiler </a> 目录下</p><p>主要的应用文件</p><image src="/images/TypeScript 编译原理.png"><h3 id="编译器的大概工作流"><a href="#编译器的大概工作流" class="headerlink" title="编译器的大概工作流"></a>编译器的大概工作流</h3><pre><code>SourceCode（源码） ~~ 扫描器 ~~&gt; Token 流</code></pre><pre><code>Token 流 ~~ 解析器 ~~&gt; AST（抽象语法树）</code></pre><pre><code>AST ~~ 绑定器 ~~&gt; Symbols（符号）</code></pre><pre><code>AST + 符号 ~~ 检查器 ~~&gt; 类型验证</code></pre><pre><code>AST + 检查器 ~~ 发射器 ~~&gt; JavaScript 代码</code></pre></image>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程-Point Free</title>
      <link href="/2019/07/25/javascript/functionalpoint/"/>
      <url>/2019/07/25/javascript/functionalpoint/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Point-free 是一种编程风格，其中函数定义不引用函数的参数。不用关心将要操作的数据是什样的。我们来看看 JavaScript 中的函数定义</p><pre><code>// 表达式function foo (/* parameters are declared here*/) {}// 声明式const foo = (/* parameters are declared here */) =&gt; // ...const foo = function (/* parameters are declared here */) {}</code></pre><p>如何在不引用所需参数的情况下在 JavaScript 中定义函数？我们不能使用 functionkeyword，也不能使用箭头函数（=&gt;），因为它们需要声明形参（这将引用它的参数）。所以我们需要做的是调用一个返回函数的函数<br></p><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><pre><code>// 非 Point-free. 因为函数引用了参数namevar greet = function(name) {  return (&#39;hello &#39; + name).toUpperCase();}// Point-free 先定义基本的函数，不用关心中间变量str是什么，抽象基本结构var toUpperCase = str =&gt; str.toUpperCase();var hello = str =&gt; `hello ${str}`; var greet = compose(hello, toUpperCase);greet(&#39;renbo&#39;);</code></pre><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h3><p>这个例子来自于<a href="https://fr.umio.us/favoring-curry/" target="_blank" rel="noopener">Favoring Curry</a><br><br>假设我们从服务器获取这样的数据：</p><pre><code>var data = {  result: &quot;SUCCESS&quot;,  tasks: [    {id: 104, complete: false,            priority: &quot;high&quot;,              dueDate: &quot;2013-11-29&quot;,      username: &quot;Scott&quot;,              title: &quot;Do something&quot;,      created: &quot;9/22/2013&quot;},    {id: 105, complete: false,            priority: &quot;medium&quot;,              dueDate: &quot;2013-11-22&quot;,      username: &quot;Lena&quot;,              title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;},    {id: 107, complete: true,             priority: &quot;high&quot;,              dueDate: &quot;2013-11-22&quot;,      username: &quot;Mike&quot;,              title: &quot;Fix the foo&quot;,       created: &quot;9/22/2013&quot;},    {id: 108, complete: false,            priority: &quot;low&quot;,              dueDate: &quot;2013-11-15&quot;,      username: &quot;Punam&quot;,              title: &quot;Adjust the bar&quot;,    created: &quot;9/25/2013&quot;},    {id: 110, complete: false,            priority: &quot;medium&quot;,              dueDate: &quot;2013-11-15&quot;,      username: &quot;Scott&quot;,              title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;},    {id: 112, complete: true,             priority: &quot;high&quot;,              dueDate: &quot;2013-11-27&quot;,      username: &quot;Lena&quot;,              title: &quot;Alter all quuxes&quot;,  created: &quot;10/5/2013&quot;}  ]};</code></pre><h3 id="getIncompleteTaskSummaries-函数"><a href="#getIncompleteTaskSummaries-函数" class="headerlink" title="getIncompleteTaskSummaries 函数"></a>getIncompleteTaskSummaries 函数</h3><p>我们需要一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据之后筛选出这个用户未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。<br></p><p>以 Scott 为例，最终筛选出的数据为<br></p><pre><code>[    {id: 110, title: &quot;Rename everything&quot;,         dueDate: &quot;2013-11-15&quot;, priority: &quot;medium&quot;},    {id: 104, title: &quot;Do something&quot;,         dueDate: &quot;2013-11-29&quot;, priority: &quot;high&quot;}]</code></pre><pre><code>var getIncompleteTaskSummaries = function(membername) {     return fetchData()         .then(function(data) {             return data.tasks;         })         .then(function(tasks) {             return tasks.filter(function(task) {                 return task.username == membername             })         })         .then(function(tasks) {             return tasks.filter(function(task) {                 return !task.complete             })         })         .then(function(tasks) {             return tasks.map(function(task) {                 return {                     id: task.id,                     dueDate: task.dueDate,                     title: task.title,                     priority: task.priority                 }             })         })         .then(function(tasks) {             return tasks.sort(function(first, second) {                 var a = first.dueDate,                     b = second.dueDate;                 return a &lt; b ? -1 : a &gt; b ? 1 : 0;             });         })         .then(function(task) {             console.log(task)         })};getIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre><h3 id="Point-free-模式"><a href="#Point-free-模式" class="headerlink" title="Point-free 模式"></a>Point-free 模式<br></h3><pre><code>// 拆分基础函数curry 为封装的通用 curry 韩式var prop = curry(function(name, obj) {    return obj[name];});var propEq = curry(function(name, val, obj) {    return obj[name] === val;});var filter = curry(function(fn, arr) {    return arr.filter(fn)});var map = curry(function(fn, arr) {    return arr.map(fn)});var pick = curry(function(args, obj){    var result = {};    for (var i = 0; i &lt; args.length; i++) {        result[args[i]] = obj[args[i]]    }    return result;});var sortBy = curry(function(fn, arr) {    return arr.sort(function(a, b){        var a = fn(a),            b = fn(b);        return a &lt; b ? -1 : a &gt; b ? 1 : 0;    })});// 拼装var getIncompleteTaskSummaries = function(membername) {    return fetchData()        .then(prop(&#39;tasks&#39;))        .then(filter(propEq(&#39;username&#39;, membername)))        .then(filter(propEq(&#39;complete&#39;, false)))        .then(map(pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;])))        .then(sortBy(prop(&#39;dueDate&#39;)))};getIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre><h3 id="利用-ramda-js-实现-getIncompleteTaskSummarie"><a href="#利用-ramda-js-实现-getIncompleteTaskSummarie" class="headerlink" title="利用 ramda.js 实现 getIncompleteTaskSummarie"></a>利用 ramda.js 实现 getIncompleteTaskSummarie</h3><p>如果直接使用 ramda.js，你可以省去编写基本函数<br></p><pre><code>var getIncompleteTaskSummaries = function(membername) {    return fetchData()        .then(R.prop(&#39;tasks&#39;))        .then(R.filter(R.propEq(&#39;username&#39;, membername)))        .then(R.filter(R.propEq(&#39;complete&#39;, false)))        .then(R.map(R.pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;])))        .then(R.sortBy(R.prop(&#39;dueDate&#39;)))};getIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre><h3 id="利用-compose-实现-getIncompleteTaskSummaries"><a href="#利用-compose-实现-getIncompleteTaskSummaries" class="headerlink" title="利用 compose 实现 getIncompleteTaskSummaries"></a>利用 compose 实现 getIncompleteTaskSummaries</h3><p>可以从左到右</p><pre><code>var getIncompleteTaskSummaries = function(membername) {    return fetchData()        .then(R.compose(            R.sortBy(R.prop(&#39;dueDate&#39;)),            R.map(R.pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;])),            R.filter(R.propEq(&#39;complete&#39;, false)),            R.filter(R.propEq(&#39;username&#39;, membername)),            R.prop(&#39;tasks&#39;)        ))};getIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre><h3 id="利用-ramda-js-提供的-R-pipe-函数"><a href="#利用-ramda-js-提供的-R-pipe-函数" class="headerlink" title="利用 ramda.js 提供的 R.pipe 函数"></a>利用 ramda.js 提供的 R.pipe 函数</h3><p>可以从左到右</p><pre><code>var getIncompleteTaskSummaries = function(membername) {    return fetchData()      .then(R.pipe(          R.prop(&#39;tasks&#39;),          R.filter(R.propEq(&#39;username&#39;, membername)),          R.filter(R.propEq(&#39;complete&#39;, false)),          R.map(R.pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;]),          R.sortBy(R.prop(&#39;dueDate&#39;))      ))};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程-函数组合</title>
      <link href="/2019/07/22/javascript/functionalcombination/"/>
      <url>/2019/07/22/javascript/functionalcombination/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>函数组合是将两个或多个函数组合以产生新函数的过程。将功能组合在一起就像将一系列管道拼凑在一起，以便我们的数据流过<br></p><p>简而言之，函数<code>f</code>和<code>g</code>的组合可以定义为<code>f（g（x））</code>，它从内到外 - 从右到左进行求值<br></p><h3 id="demo-toSlug"><a href="#demo-toSlug" class="headerlink" title="demo toSlug"></a>demo toSlug</h3><p>举例子，想象一个场景，想要将用户的全名转换为URL slugs，以便为每个用户提供个人资料页面。为此，需要完成一系列步骤：</p><ol><li>将名称拆分为空格中的数组</li><li>将名称映射到小写</li><li>加入破折号</li><li>编码URI组件</li></ol><pre><code>// toslug.js hosted with ❤ by GitHubconst toSlug = input =&gt; encodeURIComponent(  input.split(&#39; &#39;)    .map(str =&gt; str.toLowerCase())    .join(&#39;-&#39;));</code></pre><h3 id="组合功能"><a href="#组合功能" class="headerlink" title="组合功能"></a>组合功能</h3><p>不错……但如果我告诉你它可能更具可读性呢？想象一下，这些操作中的每一个都具有相应的可组合功能。可以写成<br></p><pre><code>// nesting-composition.js hosted with ❤ by GitHubconst toSlug = input =&gt; encodeURIComponent(  join(&#39;-&#39;)(    map(toLowerCase)(      split(&#39; &#39;)(        input      )    )  ));console.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre><h3 id="简单的偏应用函数"><a href="#简单的偏应用函数" class="headerlink" title="简单的偏应用函数"></a>简单的偏应用函数</h3><p>这看起来比我们的第一次尝试更难阅读，但先放在这，我们继续以可组合形式的常用实用程序，如<code>split（）</code>，<code>join（）</code>和<code>map（）</code>。来实现<br></p><pre><code>// composables.js hosted with ❤ by GitHubconst curry = fn =&gt; (...args) =&gt; fn.bind(null, ...args);const map = curry((fn, arr) =&gt; arr.map(fn));const join = curry((str, arr) =&gt; arr.join(str));const toLowerCase = str =&gt; str.toLowerCase();const split = curry((splitOn, str) =&gt; str.split(splitOn));</code></pre><p>上面的例子在技术上并不是真的柯里化，它总能产生一元函数，但是它是一个简单的偏应用函数。请参考<a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8" target="_blank" rel="noopener">有关偏应用函数和柯里化的区别</a> <br></p><p>回到我们的<code>toSlug（）</code>实现</p><pre><code>// nesting-composition.js hosted with ❤ by GitHubconst toSlug = input =&gt; encodeURIComponent(  join(&#39;-&#39;)(    map(toLowerCase)(      split(&#39; &#39;)(        input      )    )  ));console.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre><h3 id="compose（）"><a href="#compose（）" class="headerlink" title="compose（）"></a>compose（）</h3><p>我们可以使用一个自动组合这些函数的函数来展平嵌套，这意味着它将从一个函数获取输出并自动将其到下一个函数的输入，直到它输出最终值<br><br>想象一下我们实现函数 <code>reduce（）</code> 的功能，但为了匹配上面的compose行为，我们需要它从右到左，而不是从左到右<br></p><pre><code>// compose.js hosted with ❤ by GitHubconst compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x);const compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x);</code></pre><p>上面的 <code>.reduceRight()</code> 与<code>.reduce（）</code>一样，数组<code>.reduceRight（）</code>方法采用reducer函数和初始值（<code>x</code>）。我们迭代数组函数（从右到左），依次将每个函数应用于累加值（<code>v</code>）<br></p><p>使用compose，我们可以在没有嵌套的情况下重写 toSlug 的组合<br></p><pre><code>// using-compose.js hosted with ❤ by GitHubconst toSlug = compose(  encodeURIComponent,  join(&#39;-&#39;),  map(toLowerCase),  split(&#39; &#39;));console.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre><h3 id="pipe（）"><a href="#pipe（）" class="headerlink" title="pipe（）"></a>pipe（）</h3><p>还有另一种通常称为“pipe（）”的形式。 Lodash称之为<code>flow（）</code><br></p><pre><code>// pipe.js hosted with ❤ by GitHubconst pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x);const fn1 = s =&gt; s.toLowerCase();const fn2 = s =&gt; s.split(&#39;&#39;).reverse().join(&#39;&#39;);const fn3 = s =&gt; s + &#39;!&#39;const newFunc = pipe(fn1, fn2, fn3);const result = newFunc(&#39;Time&#39;); // emit!</code></pre><p>我们看看用<code>pipe（）</code>实现的<code>toSlug（）</code>函数<br></p><pre><code>// using-pipe.js hosted with ❤ by GitHubconst toSlug = pipe(  split(&#39; &#39;),  map(toLowerCase),  join(&#39;-&#39;),  encodeURIComponent);console.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre><p>在命令式编程中，当您对某个变量执行转换时，您将在转换的每个步骤中找到对该变量的引用。上面的<code>pipe（）</code>实现是以无点的方式编写的，这意味着它根本不识别它运行的参数。<br></p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>我经常在单元测试和Redux状态之类的东西中使用管道来消除对中间变量的需要，这些中间变量只存在于一个操作和下一个操作之间的瞬态值。<br></p><pre><code>// using-trace.js hosted with ❤ by GitHubconst trace = curry((label, x) =&gt; {  console.log(`== ${ label }:  ${ x }`);  return x;});const toSlug = pipe(  trace(&#39;input&#39;),  split(&#39; &#39;),  map(toLowerCase),  trace(&#39;after map&#39;),  join(&#39;-&#39;),  encodeURIComponent);console.log(toSlug(&#39;JS Cheerleader&#39;));// &#39;== input:  JS Cheerleader&#39;// &#39;== after map:  js,cheerleader&#39;// &#39;js-cheerleader&#39;</code></pre><p><code>trace（）</code>只是更通用的<code>tap（）</code>的一种特殊形式，它允许你为流经管道的每个值执行一些操作<br></p><pre><code>// tap.js hosted with ❤ by GitHubconst tap = curry((fn, x) =&gt; {  fn(x);  return x;});</code></pre><p>现在可以看到<code>trace（）</code>是一个特殊的<code>tap（）</code></p><pre><code>const trace = label =&gt; {  return tap(x =&gt; console.log(`== ${ label }:  ${ x }`));};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器</title>
      <link href="/2019/07/18/typescript/decorators/"/>
      <url>/2019/07/18/typescript/decorators/</url>
      
        <content type="html"><![CDATA[<p>装饰器是一种为类声明和成员添加注释和元编程语法的方法，用于在编译时对类、类的方法、类的属性、类的方法的参数进行处理，通俗的讲就是在原有代码外层包装了一层处理逻辑，这样就可以在不改变原方法、函数等逻辑功能的基础上增加额外的处理行为</p><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a><strong>使用装饰器</strong></h3><p>要启用装饰器功能需要开始experimentalDecorators选项，两种方式</p><p>命令行</p><pre><code>tsc --target ES5 --experimentalDecorators</code></pre><p>tsconfig.json配置</p><pre><code>{    &quot;compilerOptions&quot;: {        &quot;target&quot;: &quot;ES5&quot;,        &quot;experimentalDecorators&quot;: true    }}</code></pre><h3 id="装饰器的简单应用"><a href="#装饰器的简单应用" class="headerlink" title="装饰器的简单应用"></a><strong>装饰器的简单应用</strong></h3><p>定义一个装饰器</p><pre><code>function people (target) {  console.log(target)}</code></pre><p>在类中使用装饰器（@Decorator的语法是通过 @ 符号后边跟一个装饰器函数的引用）</p><pre><code>@peopleclass People {  constructor(){}} </code></pre><h3 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h3><p>解决在类中调用装饰器传参数的场景</p><pre><code>// 装饰器工厂function people(name : string) {     // 装饰器  return function(target){           console.log(target);  }}// 调用装饰器工厂@people(&#39;zhangsan&#39;)class People{  constructor(){}} </code></pre><h3 id="多个装饰器应用"><a href="#多个装饰器应用" class="headerlink" title="多个装饰器应用"></a>多个装饰器应用</h3><p>当在一个类上由多个装饰器调用的时候，类似于<a href="functionalCombination.md">函数组合</a></p><p>定义多个装饰器</p><pre><code>function decorator1() {  console.log(&quot;decorator1(): start&quot;);  return function (target) {    console.log(&quot;decorator1(): end&quot;);  }}function decorator2() {    console.log(&quot;decorator2(): start&quot;);    return function (target) {      console.log(&quot;decorator2(): end&quot;);    }}</code></pre><p>调用装饰器</p><pre><code>class C {  @decorator1()  @decorator2()  method() {}}</code></pre><p>输出结果为(可以看作组合函数调用 decorator1(decorator2()))</p><pre><code>decorator1(): startdecorator2(): startdecorator2(): enddecorator1(): end</code></pre><h3 id="类装饰器（Class）"><a href="#类装饰器（Class）" class="headerlink" title="类装饰器（Class）"></a>类装饰器（Class）</h3><ul><li>类装饰器应用于类的构造函数，用于观察，修改或替换类定义 </li><li>类会在class定义前调用，如果函数有返回值，它将使用提供的构造函数替换之前的构造函数</li><li>函数接收一个参数 <code>constructor</code> 之前的构造函数</li><li>如果返回新的构造函数，则必须维护原始原型</li></ul><p>我们定义一个类，继承原有的类并对这个类增加一些属性</p><pre><code>// 定义类装饰器function personName&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T){  return class extends constructor {    name = &quot;zhangsan&quot;;  }}// 使用类装饰器@personNameclass Person { public name: string;  constructor (name: string) {    this.name = name    console.log(`Hi, my name is ${this.name}`) // Hi, my name is wangwu  }}console.log(new Person(&#39;wangwu&#39;)) // class_1 {name: &quot;zhangsan&quot;,__proto__:Person}</code></pre><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法，属性，get、set访问器，都可以认为是类成员。所以被分为了Method Decorator、Accessor Decorator和Property Decorator 这三个参数 </p><p>方法装饰只是一个方法声明之前声明，方法装饰器不能用于声明文件，重载或任何其他环境上下文（例如declare类中）</p><p>方法装饰器的表达式将在运行时作为函数调用，具有以下三个参数：</p><ul><li>如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型</li><li>装饰器挂载的成员名称</li><li>方法成员的属性描述对象（Object.getOwnPropertyDescriptor 的返回值）</li></ul><p>所谓的访问器也就是有 get set 前缀的函数，方法是控制属性的赋值及取值，访问器装饰器和方法装饰器一样因为和下面要说到的属性装饰器一样都是类的成员具有三个参数</p><p>Method Decorator、Accessor Decorator和Property Decorator<br>使用方法装饰器</p><pre><code>class Greeter {  greeting: string;  constructor(message: string) {    this.greeting = message;  }  @enumerable(false)  greet() {    return &quot;Hello, &quot; + this.greeting;  }}</code></pre><pre><code>function enumerable(value: boolean) {  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor{    descriptor.enumerable = value;  };}</code></pre><p>明确一下静态成员与实例成员在返回值上的区别</p><pre><code>class Func {  // 静态成员  static method1 () {}  static method2 = () =&gt; {}  // 实例成员  method3 () {}  method4 = () =&gt; {}}</code></pre><p>静态成员 method1 和 method2 都是定义在 Func 构造函数上，method3 和 method4 区别在于 method3 定义在原型链之上 method4 只有在 Func 类实例化对象之后才有，转化ES5代码之后的样子</p><pre><code>var Func = /** @class */ (function () {    function Func() {      this.method4 = function () { };    }    // 静态成员    Func.method1 = function () { };    // 实例成员    Func.prototype.method3 = function () { };    Func.method2 = function () { };    return Func;}());</code></pre><p>通过函数可以证明上述论点装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型 而且 method4 在实例化之前是一个不存在的属性所以没有 descriptor，就是为什么TS在针对Property Decorator不传递第三个参数的原因</p><h3 id="访问器装饰器（get-set）"><a href="#访问器装饰器（get-set）" class="headerlink" title="访问器装饰器（get set）"></a>访问器装饰器（get set）</h3><p>访问器装饰器就是有get、set前缀的函数，用于控制属性的赋值及取值操作。上面说到和方法装饰器一样有三个参数</p><p>定义装饰器三个参数</p><pre><code>function configurable(value: boolean) {  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {    descriptor.configurable = value;  };}</code></pre><p>定义带有get，set的类</p><pre><code>class Point {  private _x: number;  private _y: number;  constructor(x: number, y: number) {      this._x = x;      this._y = y;  }  @configurable(false)  get x() { return this._x; }  @configurable(false)  get y() { return this._y; }}</code></pre><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器由于没有返回 descriptor 所以只有两个参数，没有方法成员的属性描述对象，如果想要修改某一个静态属性，可以通过 Object.getOwnPropertyDescriptor 获取 descriptor</p><p><em>注意在TypeScript中如何初始化属性修饰符，因此不提供属性描述符作为属性修饰符的参数。这是因为当定义原型的成员时，当前没有机制来描述实例属性，也无法观察或修改属性的初始化器。返回值也被忽略。因此，属性装饰器只能用于观察已为类声明特定名称的属性。</em></p><p>定义类</p><pre><code>class Point {  @configurable  static x = 1;}</code></pre><p>定义属性装饰器获取类属性上的值进行更改</p><pre><code>function configurable(target,x) {  let descriptor = Object.getOwnPropertyDescriptor(target, x)  Object.defineProperty(target, x, {    ...descriptor,    value: 2  })}console.log(Point.x) // 2 </code></pre><p>也可以使用 reflect-metadata 这个库它主要用来在声明的时候添加和读取元数据<br>使用的时候需要安装</p><pre><code>npm i reflect-metadata --save</code></pre><p>之后在tsconfig.json 中配置emitDecoratorMetadata选项</p><pre><code>{  &quot;compilerOptions&quot;: {    &quot;target&quot;: &quot;ES5&quot;,    &quot;experimentalDecorators&quot;: true,    &quot;emitDecoratorMetadata&quot;: true  }}</code></pre><p>定义类</p><pre><code>class Greeter {    @format(&quot;Hello, %s&quot;)    greeting: string;    constructor(message: string) {        this.greeting = message;    }    greet() {        let formatString = getFormat(this, &quot;greeting&quot;);        return formatString.replace(&quot;%s&quot;, this.greeting);    }}</code></pre><p>// 利用 reflect-metadata 定义装饰器</p><p>Reflect.metadata 当作 Decorator 使用，当修饰类时，在类上添加元数据，当修饰类属性时，在类原型的属性上添加元数据</p><p>Reflect.getMetadata 能获取属性</p><pre><code>import &quot;reflect-metadata&quot;;const formatMetadataKey = Symbol(&quot;format&quot;);function format(formatString: string) {  return Reflect.metadata(formatMetadataKey, formatString);}function getFormat(target: any, propertyKey: string) {  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);}</code></pre><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>参数装饰器和属性装饰器一样都是在函数运行时调用的，它接收3个参数</p><ul><li>如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型</li><li>参数所处的函数名称</li><li>参数在函数中形参中的位置</li></ul><pre><code>const obj = []function require (value : string) {  return function (target : any , propertyKey : string ,parameterIndex : number) {    obj[parameterIndex] = value  }}class Hello{  method(@require(&#39;lisi&#39;) name : string){    console.log(name)  }}console.log(obj) // [&#39;lisi&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>偏应用函数、函数的柯里化</title>
      <link href="/2019/07/17/javascript/functioncurrying/"/>
      <url>/2019/07/17/javascript/functioncurrying/</url>
      
        <content type="html"><![CDATA[<p>偏应用函数简称偏函数，在模拟 bind 的时候已经说明其概念和作为主要 bind 的实现<br></p><p>函数柯里化主要是通过偏应用函数的实现，把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数<br></p><pre><code>// 柯里化之前function add (a, b) {  return a + b;}// 柯里化之后function add (a) {  return function (b) {    return a+b  }}// 等同于const add = a =&gt; b =&gt; a + b;const result = add(2)(3); // =&gt; 5</code></pre><ol><li>首先函数接受 a 参数 然后返回一个新的匿名函数体确定了新的词法作用域,在该词法作用域中也拥有 a 参数</li><li>该匿名函数调用传入参数 3 返回 a+b 的和</li><li>通过上面程序了解到柯里化函数的特点是总是返回一个一元的函数：一个带有一个参数的新函数，不同的是普通函数可以根据需要一次获取尽可能多的参数</li></ol><h3 id="为什么要柯里化"><a href="#为什么要柯里化" class="headerlink" title="为什么要柯里化"></a>为什么要柯里化</h3><ol><li>柯里化在函数组合的上下文中起到关键的作用,能够让你重新组合你的应用，将复杂的功能拆分成一个个简单的部分，这样容易更改，理解</li><li>柯里化也是一种函数预加载的方法，通过传递较少的参数得到一个在相同词法作用域当中缓存了这些参数的新函数，其实这也是一种对参数的缓存</li></ol><h3 id="如何柯里化"><a href="#如何柯里化" class="headerlink" title="如何柯里化"></a>如何柯里化</h3><pre><code>// 普通const sayName = name =&gt; age =&gt; `my name is ${name}, Im years old ${age}` ;let name = sayName(&#39;zhangsan&#39;);let age = name(27);// 利用bindfunction person (name, age, height) {  console.log(`my name is ${name}, I,m years old ${age}, my height is ${height} meters`)}let info = person.bind(null, &#39;zhangsan&#39;);console.log(info(27, 175));</code></pre><h3 id="柯里化函数的应用场景"><a href="#柯里化函数的应用场景" class="headerlink" title="柯里化函数的应用场景"></a>柯里化函数的应用场景</h3><ol><li>延迟计算</li><li>参数复用</li><li>动态创建函数</li></ol><p>延迟计算<br></p><pre><code>// 普通实现var sum = function(args){  return args.reduce(function(a,b){      return a+b  });};var result = sum([1,2,3,4,5]); // 15// 柯里化实现function add() {  var _args = [].slice.call(arguments);  var adder = function () {      // 利用闭包特性保存_args的值      var _adder = function() {          [].push.apply(_args, [].slice.call(arguments));          return _adder;      };      // 利用隐式转换的特性，计算最终的值返回      _adder.toString = function () {          return _args.reduce(function (a, b) {              return a + b;          });      }      return _adder;  }  return adder.apply(null, [].slice.call(arguments));}var sum = add();sum(1,2,3)(4);sum(5);sum() // 15优点：调用灵活，参数定义随意充分利用了柯里化提延迟执行的特点延迟执行 – 返回新函数可以进行任意调用</code></pre><p>DOM操作中的事件绑定(动态创建函数)<br><br>当在多次调用同一个函数，并且传递的参数绝大多数是相同的。</p><pre><code>// 普通版本var addEvent = function(el, type, fn, capture) {    if (window.addEventListener) {      el.addEventListener(type, function(e) {        fn.call(el, e);      }, capture);    } else if (window.attachEvent) {      el.attachEvent(&quot;on&quot; + type, function(e) {        fn.call(el, e);      });    }  }; // 柯里化版本 var addEvent = (function(){    if (window.addEventListener) {      return function(el, type, fn, capture) {        el.addEventListener(type, function(e) {          fn.call(el, e);        }, (capture));      };    } else if (window.attachEvent) {      return function(el, type, fn, capture) {        el.attachEvent(&quot;on&quot; + type, function(e) {            fn.call(el, e);        });      };    }})();优点：不用每次调用进行 if () {}else {} 判断兼容性问题充分利用了柯里化提前返回和延迟执行的特点提前返回 – 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法延迟执行 – 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行</code></pre><p>当然应用场景还有很多，比如我们经常提到的防抖和节流问题，充分的利用了函数式编程的延迟执行特性，将多个间隔接近的函数执行合并成一次函数执行来提高性能问题。<br><br>关于事件节流和防抖动将会在后续的专题中单独指出<br></p>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tsconfig.json</title>
      <link href="/2019/07/15/typescript/tsconfig/"/>
      <url>/2019/07/15/typescript/tsconfig/</url>
      
        <content type="html"><![CDATA[<p>## </p><p>如果一个目录下存在一个tsconfig.json文件，它会把一个文件夹转换为项目，也意味着这个目录是TypeScript项目的根目录</p><h3 id="使用tsconfig-json"><a href="#使用tsconfig-json" class="headerlink" title="使用tsconfig.json"></a>使用tsconfig.json</h3><p>初始化 tsconfig.json 或者手动建立文件tsconfig.json</p><pre><code>tsc --init</code></pre><p>如果项目配置了tsconfig.json，那么在进行转换的时候可以在命令行直接输入</p><pre><code>tsc </code></pre><p>编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录</p><p>否则就需要在编译时加上文件及目录</p><pre><code>tsc test.ts</code></pre><p>默认在当前目录生成test.js</p><h3 id="编写需要的配置项"><a href="#编写需要的配置项" class="headerlink" title="编写需要的配置项"></a>编写需要的配置项</h3><p>下面这个例子是列举了在项目中经常用到的配置，当前根据项目的不同会有区别</p><pre><code>{  &quot;compileOnSave&quot;: true, //让IDE在保存文件的时候根据tsconfig.json重新生成文件  &quot;compilerOptions&quot;: {    &quot;target&quot;: &quot;ES5&quot;, // 目标代码类型版本    &quot;outDir&quot;:&quot;build/&quot;, // 重定向输出目录    &quot;baseUrl&quot;:  &quot;https://test.file.com&quot;, // 解析非相对模块名的基准目录    &quot;noImplicitAny&quot;:true, // 在表达式和声明上有隐含的&#39;any&#39;类型时报错    &quot;removeComments&quot;:true, //编译 js 的时候，删除掉注释    &quot;preserveConstEnums&quot;:true, // 保留const和enum声明    &quot;experimentalDecorators&quot;: true, // 使用装饰器要开始此选项    &quot;emitDecoratorMetadata&quot;: true, // 在使用reflect-metadata库时候需要添加，给源码里的装饰器声明加上设计类型元数据    &quot;declaration&quot;: true, // 编译时候是否同时产生一份 声明文件    &quot;strict&quot;: true, // 编译时开启严格模式    &quot;sourceMap&quot;: true, // 生成相应的.map文件    &quot;module&quot;: &quot;commonjs&quot;, //生成哪种模块系统代码    &quot;watch&quot;: true, //会在文件改变时候监视输出文件，重新进行编译  },  &quot;include&quot;: [ // 编译时包含的目录及文件    &quot;test.ts&quot;   ],  &quot;exclude&quot;: [ // 编译时排除的目录及文件    &quot;node_modules&quot;,     &quot;dist&quot;,      &quot;mock&quot;    &quot;build&quot;  ],  &quot;lib&quot;: [ // 需编译过程中需要引入的库文件的列表，不然编译器识别错误报错    &quot;es2017&quot;,    &quot;dom&quot;  ]}</code></pre><p><em>注意使用”include”引入的文件可以使用”exclude”属性过滤。 然而，通过 “files”属性明确指定的文件不管”exclude”如何设置却总是会被包含在内。 如果没有特殊指定， “exclude”默认情况下会排除node_modules，bower_components，jspm_packages和outDir目录。</em></p><p>更多参数请参考官网<a href="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener"> tsconfig配置列表 </a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程-纯函数</title>
      <link href="/2019/07/15/javascript/functionalpurity/"/>
      <url>/2019/07/15/javascript/functionalpurity/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>说纯函数概念之前我们再来复习一下什么是函数</p><p>函数是一个方法，有一些输入，称为变量，并产生一些输出称为返回值</p><p>函数可以用于以下目的</p><ol><li>映射：根据给定的输入生成一些输出，函数将输入值映射到输出值上</li><li>过程：调用函数按照一系列的步骤来执行。这就是我们说的过程编程</li><li>I/O：与系统其他部分通信的功能。如存储系统日志，网络等</li></ol><p>纯函数都是关于映射的所以对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p><pre><code>// 纯函数const double = x =&gt; x * 2;console.log（double（5））// 不纯let val = 2;const double = x =&gt; x * val;console.log（double（5））// 不纯Math.random()Math.random()</code></pre><h3 id="函数式编程-纯函数"><a href="#函数式编程-纯函数" class="headerlink" title="函数式编程-纯函数"></a>函数式编程-纯函数</h3><p>纯函数的优点<br></p><ol><li>独立于外部状态，所以不会受外部全局环境的影响而产生的错误或者副作用</li><li>由于其独立，所以易于重构和重组和重用，使程序更加灵活</li></ol><h3 id="函数式编程-幂等性"><a href="#函数式编程-幂等性" class="headerlink" title="函数式编程-幂等性"></a>函数式编程-幂等性</h3><p>执行多次所产生的影响均与一次执行的影响相同，也就是说执行一次和执行多次对系统内部的状态影响是一样的 <br></p><pre><code>class Person {  constructor () {    this.name = name;  },  sayName () {    console.log(my name is + this.name);  } }var person = new Person(zhangsan)person.sayName();person.sayName();</code></pre><h3 id="纯函数和幂等性的区别"><a href="#纯函数和幂等性的区别" class="headerlink" title="纯函数和幂等性的区别"></a>纯函数和幂等性的区别</h3><ol><li>法调用多次对内部的状态影响是一样的，则这么方法就具有幂等性，在函数式编程中，纯函数也具有幂等性，但具有幂等性的函数却不一定是纯函数。</li><li>纯函数主要强调相同的输入，多次调用，输出也相同且无副作用，而幂等主要强调多次调用，对内部的状态的影响是一样的，调用返回值可能不同。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程-基本理论</title>
      <link href="/2019/07/12/javascript/functionalbase/"/>
      <url>/2019/07/12/javascript/functionalbase/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><p>函数式编程主要是范畴论数学中的一个分支，它认为所有的概念体系都可以抽象成一个个范畴，属于结构化编程的一种。运算过程尽量写成一系列嵌套的函数调用 <br></p><pre><code>//  函数式编程var result = subtract(multiply(add(1,2), 3), 4);// 过程编程var a = add(1,2);var b = multiply(a, 3);var c = subtract(b, 4);</code></pre><h3 id="为什么学习函数式编程"><a href="#为什么学习函数式编程" class="headerlink" title="为什么学习函数式编程"></a>为什么学习函数式编程</h3><p>其实个人觉的学习函数式编程就是为了更好的模块化，使其看起来更简洁。这也是<a href="http://en.wikipedia.org/wiki/Programming_paradigm" target="_blank" rel="noopener">范式编程</a>和<a href="http://en.wikipedia.org/wiki/Structured_programming" target="_blank" rel="noopener">结构化编程</a>的主要思想</p><h3 id="函数式编程特点"><a href="#函数式编程特点" class="headerlink" title="函数式编程特点"></a>函数式编程特点</h3><ol><li>函数是”第一等公民”</li><li>只用表达式，不用语句</li><li>没有副作用（函数要保持独立，所有功能就是返回一个新的值，没有其他行为，更不能修改外部状态的值）</li><li>不修改状态（可以使用参数来保存状态，不可以使用变量来保存状态）</li><li>引用透明（函数运行只靠参数）</li></ol><h3 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a>函数式编程的优点</h3><ol><li>代码更简洁，易于理解，维护更方便</li><li>易于并发编程（由于不修改变量所以不存在锁线程的问题）</li><li>代码的热升级</li></ol>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mixinx</title>
      <link href="/2019/07/02/typescript/mixinx/"/>
      <url>/2019/07/02/typescript/mixinx/</url>
      
        <content type="html"><![CDATA[<p> 一般情况下，我们已经习惯了用面向对象的继承方式，比如在 JS ES5中用 prototype， 在 ES6 和 TS 中 用extends,然而用 mixinx 也是一种通过可重用组件创建类的方式，来进行混用，混合多个类的方法到一个类上</p><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><pre><code>// Disposable Mixinclass Disposable {    isDisposed!: boolean;    dispose() {    console.log(this.isDisposed);    }}// Activatable Mixinclass Activatable {    isActive!: boolean;    activate() {       console.log(this.isActive)    }}// 没使用 extends 而是使用 implementsclass SmartObject implements Disposable,Activatable {    // Disposable    isDisposed: boolean = false;    dispose!: () =&gt; void;    // Activatable    isActive: boolean = false;    activate!: () =&gt; void;}// mixins混入定义的类，完成全部实现部分applyMixins(SmartObject, [Disposable, Activatable]);// 创建 applyMixins 混用函数，作用是遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。function applyMixins(derivedCtor: any, baseCtors: any[]) {    baseCtors.forEach(baseCtor =&gt; {        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {            derivedCtor.prototype[name] = baseCtor.prototype[name];        });    });}let smartObject = new SmartObject()smartObject.dispose() // falsesmartObject.activate() // false</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>声明文件</title>
      <link href="/2019/06/20/typescript/declarefile/"/>
      <url>/2019/06/20/typescript/declarefile/</url>
      
        <content type="html"><![CDATA[<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><h3 id="识别库的类型"><a href="#识别库的类型" class="headerlink" title="识别库的类型"></a>识别库的类型</h3><p>全局库(全局命名空间下能访问)</p><ul><li>顶级的var语句或function声明</li><li>一个或多个赋值语句到window上</li><li>假设DOM原始值像document或window是存在的</li></ul><pre><code>&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;window.test = function(){    console.log(&#39;1111&#39;)}</code></pre><p>模块化库（只能工作在模块加载器的环境下）</p><ul><li>无条件的调用require或define</li><li>像import * as a from ‘b’; or export c;这样的声明</li><li>赋值给exports或module.exports</li></ul><p>UMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块</p><pre><code>import moment = require(&quot;moment&quot;);console.log(moment.format());</code></pre><p>在浏览器环境内也可以这样使用</p><pre><code>console.log(moment.format());</code></pre><p>识别UMD库</p><pre><code>(function (root, factory) {    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {        define([&quot;libName&quot;], factory);    } else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) {        module.exports = factory(require(&quot;libName&quot;));    } else {        root.returnExports = factory(root.libName);    }}(this, function (b) {}))</code></pre><h3 id="使用依赖"><a href="#使用依赖" class="headerlink" title="使用依赖"></a>使用依赖</h3><p>依赖全局库</p><pre><code>/// &lt;reference types=&quot;someLib&quot; /&gt;function getThing(): someLib.thing;</code></pre><p>依赖模块</p><pre><code>import * as moment from &quot;moment&quot;;function getThing(): moment;</code></pre><p>依赖UMD库</p><pre><code>// &lt;reference types=&quot;moment&quot; /&gt;function getThing(): moment;</code></pre><p>如果你的模块或UMD库依赖于一个UMD库</p><p>不要使用/// &lt;reference指令去声明UMD库的依赖！</p><pre><code>import * as someLib from &#39;someLib&#39;;</code></pre><h3 id="防止命名冲突"><a href="#防止命名冲突" class="headerlink" title="防止命名冲突"></a>防止命名冲突</h3><p>在书写全局声明文件时，使用库定义的全局变量名来声明命名空间类型</p><pre><code>declare namespace cats {    interface KittySettings { }}</code></pre><h3 id="定义全局库模版"><a href="#定义全局库模版" class="headerlink" title="定义全局库模版"></a>定义全局库模版</h3><p>模版文件<a href="global.d.ts.md"> global.d.ts </a>定义了myLib库作为例子</p><h3 id="定义模块化库模版"><a href="#定义模块化库模版" class="headerlink" title="定义模块化库模版"></a>定义模块化库模版</h3><p>针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-fun</p><p><a href="module.d.ts.md"> module.d.ts </a> 作为函数调用</p><pre><code>var x = require(&quot;foo&quot;);// Note: calling &#39;x&#39; as a functionvar y = x(42);</code></pre><p><a href="module-class.d.ts.md">module-class.d.ts </a>使用new来构造调用</p><pre><code>var x = require(&quot;bar&quot;);// Note: using &#39;new&#39; operator on the imported variablevar y = new x(&quot;hello&quot;);</code></pre><p>如果模块不能被调用或构造，使用<a href="module.d.ts.md"> module.d.ts </a>文件</p><h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。</p><pre><code>npm install --save @types/lodashimport * as _ from &quot;lodash&quot;;_.padStart(&quot;Hello TypeScript!&quot;, 20, &quot; &quot;);</code></pre><p>如果npm包没有包含它的声明文件，那就必须下载相应的@types包</p><p>大多数类型声明包的名字总是与它们在npm上的包的名字相同，但是有@types/前缀</p><p>查找更多typeScript 库请前往 <a href="https://aka.ms/types" target="_blank" rel="noopener">https://aka.ms/types</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块与命名空间</title>
      <link href="/2019/06/15/typescript/module/"/>
      <url>/2019/06/15/typescript/module/</url>
      
        <content type="html"><![CDATA[<p>在 JS 中 有 module 模块机制，和 TS 类似，在 TS 中内部模块命名空间为关键字namespaces。外部模块现在只是modules</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间 "></a>使用命名空间 <br></h3><ul><li>命名空间只是全局命名空间中的JavaScript对象</li><li>使用 namespace 关键字</li><li>跨多个文件，并且可以使用连接–outFile</li><li>不使用require关键字</li></ul><p><strong>1.单文件命名空间</strong></p><pre><code>  namespace Validation {    export interface StringValidator {      isAcceptable(s: string): boolean;    }    const lettersRegexp = /^[A-Za-z]+$/;    const numberRegexp = /^[0-9]+$/;    export class LettersOnlyValidator implements StringValidator {        isAcceptable(s: string) {            return lettersRegexp.test(s);        }    }    export class ZipCodeValidator implements StringValidator {        isAcceptable(s: string) {            return s.length === 5 &amp;&amp; numberRegexp.test(s);        }    }  }</code></pre><p><strong>2.多文件命名空间及引入</strong></p><p>Validation.ts</p><pre><code>namespace Validation {  export interface StringValidator {    isAcceptable(s: string): boolean;  }}</code></pre><p>LettersOnlyValidator.ts</p><pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;namespace Validation {    const lettersRegexp = /^[A-Za-z]+$/;    export class LettersOnlyValidator implements StringValidator {        isAcceptable(s: string) {            return lettersRegexp.test(s);        }    }}</code></pre><p>ZipCodeValidator.ts</p><pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;namespace Validation {    const numberRegexp = /^[0-9]+$/;    export class ZipCodeValidator implements StringValidator {        isAcceptable(s: string) {            return s.length === 5 &amp;&amp; numberRegexp.test(s);        }    }}</code></pre><p>Test.ts</p><pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;// Some samples to trylet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// Validators to uselet validators: { [s: string]: Validation.StringValidator; } = {};validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) {  for (let name in validators) {    console.log(`&quot;${ s }&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${ name }`);  }}</code></pre><p>涉及多个文件，我们需要确保加载所有已编译的代码。有两种方法可以做到这一点。</p><ol><li><strong>–outFile 编译器将根据文件中存在的引用标记自动排序输出文件</strong><pre><code>tsc --outFile sample.js Test.ts</code></pre></li><li><strong>为每一个文件编译一个 JS 文件利用 Script 按照顺序引入</strong><pre><code>&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</code></pre></li></ol><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块 "></a>使用模块 <br></h3><ul><li>模块在自己的范围内执行，而不是在全局范围内执行</li><li>模块中声明的变量，函数，类等在模块外部不可见,除非使用其中一个export显式导出</li><li>模块是声明性的; 模块之间的关系是根据文件级别的导入和导出来指定的</li><li>模块文件之间引用用关键字 import 或被 export</li></ul><p><strong>1.使用 export 关键字来导出声明</strong></p><p>单模块导出</p><pre><code>export interface StringValidator {  isAcceptable(s: string): boolean;}</code></pre><p>重命名导出</p><pre><code>class ZipCodeValidator implements StringValidator {  isAcceptable(s: string) {    return s.length === 5 &amp;&amp; numberRegexp.test(s);  }}export { ZipCodeValidator };export { ZipCodeValidator as mainValidator };</code></pre><p>导出所有模块</p><pre><code>export * from &quot;./StringValidator&quot;;export * from &quot;./ZipCodeValidator&quot;;</code></pre><p><strong>2.使用 import 关键字来导入声明</strong></p><p>从模块导入单个导出</p><pre><code>import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;;let myValidator = new ZipCodeValidator();</code></pre><p>重命名导入</p><pre><code>import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;;let myValidator = new ZCV();</code></pre><p>将整个模块导入单个变量，并使用它来访问模块导出</p><pre><code>import * as validator from &quot;./ZipCodeValidator&quot;;let myValidator = new validator.ZipCodeValidator();</code></pre><p>仅使用这个文件</p><pre><code>import &quot;./my-module.js&quot;;</code></pre><p><strong>3.模块的代码生成</strong></p><p>编译器将为Node.js（CommonJS），require.js（AMD），UMD，SystemJS或ECMAScript 2015本机模块（ES6）模块加载系统生成适当的代码</p><p>编译 commonjs 规范</p><pre><code>tsc --module commonjs Test.ts</code></pre><p>编译 amd 规范</p><pre><code>tsc --module amd Test.ts</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 promise</title>
      <link href="/2019/06/11/javascript/promise/"/>
      <url>/2019/06/11/javascript/promise/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是实现 Promise 的原理, 具体 API 用法不在本文中做介绍。可以查看阮一峰老师的 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 Promise教程</a><br></p><p>实现 Promise 首先要知道它的执行特点<br></p><ol><li>Promise 是一个构造函数，接受函数作为参数(resolve(),reject()) </li><li>Promise 对象有三种状态 pending(进行中), fulfilled(成功), rejected(失败)</li><li>Promise 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve() </li><li>Promise 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()</li><li>Promise 状态无法中途取消，一旦建立立即执行，会一直保持这个结果，这时也叫 resolved(已定型状态)</li><li>Promise 状态改变时 then 方法支持多次链式调用 </li><li>Promise 如果不设置回调函数内部会抛异常</li></ol><h3 id="定义构造函数"><a href="#定义构造函数" class="headerlink" title="定义构造函数"></a>定义构造函数</h3><p>构造函数 Promise 必须接受函数作为参数</p><ol><li>定义构造函数</li><li>判断一个参数是否为函数</li></ol><pre><code>/** * 封装判断参数是够是函数 */function isFunction(fn) {  return Object.prototype.toString.call(fn) === &#39;[object Function]&#39;;}/** * 定义构造函数 * @param {*} fn  */function Promise(fn) {  if (!isFunction(fn)) {    throw new Error(&#39;Promise must accept a function as a parameter&#39;)  }}</code></pre><h3 id="定义-resolve"><a href="#定义-resolve" class="headerlink" title="定义 resolve"></a>定义 resolve</h3><p>在内部定义 resolve 方法作为参数传到 fn 中，fn 调用成功后会调用 resolve 方法，之后在执行 then 中注册的回调函数</p><pre><code>/** * 定义构造函数 * @param {*} fn  */function Promise(fn) {  // 判断是否是函数  var _isFunction = Object.prototype.toString.call(fn) === &#39;[object Function]&#39;;  // 如果不是函数抛出异常  if (!_isFunction) {    throw new Error(&#39;Promise must accept a function as a parameter&#39;)  }  // 定义回调状态  var __callback  this.then = function (status) {    __callback = status  }  // 定义 resolve 函数传入成功的数据  function resolve (data) {    __callback(data)  }  fn(resolve)}</code></pre><p>调用例子</p><pre><code>function request () {  return new Promise(function(resolve){    if (true) {      setTimeout(function() {        resolve(&quot;renbo&quot;);      }, 0);    }  })}request().then(function(data){  console.log(data)  console.log(&#39;success&#39;)})// 输出renbosuccess</code></pre><p>上面的例子我们已经简单的实现了 promise 的基础回调，接下来我们完成链式语法调用以及then队列管理</p><h3 id="链式语法及队列管理"><a href="#链式语法及队列管理" class="headerlink" title="链式语法及队列管理"></a>链式语法及队列管理</h3><pre><code>function Promise (fn) {  var _isFunction = Object.prototype.toString.call(fn) === &#39;[object Function]&#39;;  if (!_isFunction) {    throw new Error(&#39;Promise must accept a function as a parameter&#39;)  }  var _this = this,      _value = null;      _this._resolves = [];  this.then = function (status) {    _this._resolves.push(status);    return this;  }  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾  function resolve (val) {     setTimeout(function() {      _this._resolves.forEach(function (callback) {        _value = val        callback(_value)      })    },0);  }  fn (resolve)}</code></pre><h3 id="加入状态并串行Promise"><a href="#加入状态并串行Promise" class="headerlink" title="加入状态并串行Promise"></a>加入状态并串行Promise</h3><p>Promise 对象有三种状态 <br></p><ol><li>pending(进行中) 立即执行</li><li>从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve(‘fulfilled’) </li><li>从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject(‘rejected’)</li></ol><p><code>promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变</code></p><p>我们加入上面的状态并串行Promise</p><pre><code>function Promise (fn) {  function _isFunction (func) {    return Object.prototype.toString.call(func) === &#39;[object Function]&#39;;  }  if (!_isFunction(fn)) {    throw new Error(&#39;Promise must accept a function as a parameter&#39;)  }  var _this = this,      _val = null;      _this._resolves = [];      _this._status = &#39;PENDING&#39;;  this.then = function (onFulfilled) {    return new Promise(function (resolve) {      // handle 函数对上一个 promise 的 then 中回调进行了处理，并且调用当前的 promise 中的 resolve 方法。      function handle(_val) {        var ret = _isFunction(onFulfilled) &amp;&amp; onFulfilled(_val) || _val        // 如果是⼀一个 promise 对象，就会调⽤ then 方法，形成一个嵌套        if (ret &amp;&amp; _isFunction(ret[&#39;then&#39;])) {          ret.then(function (value) {            resolve(value);          })        } else {          resolve(ret)        }      }      if (_this._status === &#39;PENDING&#39;) {       _this._resolves.push(handle);      } else if(promise._status === &#39;FULFILLED&#39;){        handle(value);      }           })  }  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾  function resolve (val) {     setTimeout(function() {       _this.status = &quot;FULFILLED&quot;;      _this._resolves.forEach(function (callback) {        _val = val        callback(_val)      })    },0);  }  fn (resolve)}</code></pre><h3 id="错误处理reject"><a href="#错误处理reject" class="headerlink" title="错误处理reject"></a>错误处理reject</h3><p>在异步操作中，操作可能失败，执行失败的回调函数，上面已经说到从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()</p><pre><code>function Promise(fn) {  /**   * 工具函数判断是否是 function   * @param {*} func    */  function _isFunction(func) {    return Object.prototype.toString.call(func) === &#39;[object Function]&#39;;  }  if (!_isFunction(fn)) {    throw new Error(&#39;Promise must accept a function as a parameter&#39;)  }  var _this = this;  _this._value;  _this._reason;  _this._resolves = [];  _this._rejects = [];  _this._status = &quot;PENDING&quot;;  /**   * promise then回调   * @onFulfilled 执行成功状态的处理函数   * @onRejected 执行失败状态处理函数   */  this.then = function (onFulfilled, onRejected) {    return new Promise(function (resolve, reject) {      /**       * 对上一个 promise 的 then 中回调进行了处理       * 并且调用当前的 promise 中的 resolve 方法       */      function handle(value) {        var ret = _isFunction(onFulfilled) &amp;&amp; onFulfilled(value) || value        if (ret &amp;&amp; _isFunction(ret[&#39;then&#39;])) {          ret.then(            function (value) {              resolve(value);            },            function (reason) {              reject(reason);            }          )        } else {          resolve(ret)        }      }      /**       * 错误处理回调函数       */      function errback(reason) {        reason = _isFunction(onRejected) &amp;&amp; onRejected(reason) || reason;        reject(reason);      }      /**       * 根据当前异步状态执行操作       */      var config = {        &#39;PENDING&#39;: function () {          _this._resolves.push(handle);          _this._rejects.push(errback);        },        &#39;FULFILLED&#39;: function () {          handle(value);        },        &#39;REJECTED&#39;: function () {          errback(_this._reason);        }      }      config[_this._status]()    })  }  /**   * 成功的回调函数   * setTimeout作用是将resolve    * 执行回调的逻辑放置到 JS 任务队列列末尾   * 防止then执行在resolve之前   * @FULFILLED 状态   * @param {*} value    */  function resolve(value) {    setTimeout(function () {      _this.status = &quot;FULFILLED&quot;      _this._resolves.forEach(function (callback) {       _this._value = callback(value)      })    }, 0)  }  /**   * 错误处理回调函数   * @REJECTED 状态   * @param {*} value    */  function reject(value) {    setTimeout(function () {      _this._status = &quot;REJECTED&quot;      _this._rejects.forEach(function (callback) {        _this._reason = callback(value);      })    }, 0)  }  fn(resolve, reject)}</code></pre><h3 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all"></a>实现Promise.all</h3><p>实现Promise.all函数</p><pre><code>/** * Promise.all * 接收一个元素为 Promise 对象的数组作为参数 * 返回一个Promise实例 * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回 */Promise.all = function(promiseArr) {  if (!Array.isArray(promiseArr)) {    throw new TypeError(&#39;You must pass an array to all.&#39;);  }  // 返回 promise 实例  return new Promise(function (resolve, reject) {    let done = gen(promiseArr.length, resolve);    promiseArr.forEach(function (promise, index) {      promise.then(function (value) {        done(index, value)      },reject)    })  })}function gen(length, resolve) {  let count = 0;  let result = [];  return function(i, value) {    result[i] = value;    if (++count === length) {      resolve(result);    }  }}</code></pre><h3 id="实现Promise-race"><a href="#实现Promise-race" class="headerlink" title="实现Promise.race"></a>实现Promise.race</h3><p>实现Promise.race函数</p><pre><code>/** * Promise.race * 接收一个元素为 Promise 对象的数组作为参数 * 返回一个Promise实例 * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回 */Promise.race = function(promiseArr) {  if (!Array.isArray(promiseArr)) {    throw new TypeError(&#39;You must pass an array to all.&#39;);  }  // 返回 promise 实例  return new Promise(function(resolve, reject){    promiseArr.forEach(function (promise, index) {      promise.then(resolve,reject)    })  })}</code></pre><h3 id="实现-catch"><a href="#实现-catch" class="headerlink" title="实现 catch "></a>实现 catch <br></h3><p>实现 catch </p><pre><code>/** * 链式写法中可以捕获前面then中发送的异常 */function Promise () {  var _this = this  ...  this.catch = function (onRejected) {    return _this.then(null, onRejected);  }}</code></pre><h3 id="代码封装"><a href="#代码封装" class="headerlink" title="代码封装"></a>代码封装</h3><p>经过上面的几个步骤我们基本实现了 promise 的几个重要特性，下面我们将代码整理一下</p><pre><code>/* * @Description: promise  * @Author: renbo * @Date: 2019-08-12 15:13:40 * @LastEditTime: 2019-08-15 10:34:44 */var Promise = /** @class */ (function () {  function Promise (fn) {    var _this = this;    _this._status = &#39;PENDING&#39;;    _this._value = undefined;    _this._reason = undefined;    //存储状态    _this._resolves = [];    _this._rejects = [];    // 异常处理    if (!(typeof fn === &#39;function&#39; )) {      throw new TypeError(&#39;Promise must accept a function as a parameter&#39;);    }    if(!(this instanceof Promise)) return new Promise(fn);   function resolve(value) {      //由於apply參數是數組      _this.final.apply(_this,[&#39;FULFILLED&#39;].concat([value]));    }    function reject(reason){      _this.final.apply(_this,[&#39;REJECTED&#39;].concat([reason]));    }    fn(resolve,reject);  }  /**   * 用于resolve 和 reject    * 异步调用，保证then是先执行的   * @param {*} status    * @param {*} value    */  Promise.prototype.final = function (status,value) {    var _this = this, fn, st;    if(_this._status !== &#39;PENDING&#39;) return;    setTimeout(function(){      _this._status = status;      st = _this._status === &#39;FULFILLED&#39;      queue = _this[st ? &#39;_resolves&#39; : &#39;_rejects&#39;];      while(fn = queue.shift()) {        value = fn.call(_this, value) || value;      }      _this[st ? &#39;_value&#39; : &#39;_reason&#39;] = value;      _this[&#39;_resolves&#39;] = _this[&#39;_rejects&#39;] = undefined;    });  }  /**   * then    * @params onFulfilled   * @params onRejected   */  Promise.prototype.then = function (onFulfilled,onRejected) {    var _this = this;    // 每次返回一个promise，保证是可thenable的    return new Promise(function(resolve,reject){      function handle(value) {        // 這一步很關鍵，只有這樣才可以將值傳遞給下一個resolve        var ret = typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(value) || value;        //判断是不是promise 对象        if (ret &amp;&amp; typeof ret [&#39;then&#39;] == &#39;function&#39;) {            ret.then(function(value) {                resolve(value);            }, function(reason) {                reject(reason);            });        } else {          resolve(ret);        }      }      function errback(reason){        reason = typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(reason) || reason;        reject(reason);      }      // 根据当前异步状态执行操作      var config = {        &#39;PENDING&#39;: function () {          _this._resolves.push(handle);          _this._rejects.push(errback);        },        &#39;FULFILLED&#39;: function () {          handle(value);        },        &#39;REJECTED&#39;: function () {          errback(_this._reason);        }      }      config[_this._status]()    });  }  /**   * 链式写法中可以捕获前面then中发送的异常   */  Promise.prototype.catch = function(onRejected){    return this.then(undefined, onRejected)  }  /**   * Promise.race   * 接收一个元素为 Promise 对象的数组作为参数   * 返回一个Promise实例   * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回   */  Promise.race = function(promiseArr) {    if (!Array.isArray(promiseArr)) {      throw new TypeError(&#39;You must pass an array to all.&#39;);    }    // 返回 promise 实例    return new Promise(function(resolve, reject){      promiseArr.forEach(function (promise, index) {        promise.then(resolve,reject)      })    })  }  /**   * Promise.all   * 接收一个元素为 Promise 对象的数组作为参数   * 返回一个Promise实例   * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回   */  Promise.all = function(promiseArr) {    if (!Array.isArray(promiseArr)) {      throw new TypeError(&#39;You must pass an array to all.&#39;);    }    // 返回 promise 实例    return new Promise(function (resolve, reject) {      let done = gen(promiseArr.length, resolve);      promiseArr.forEach(function (promise, index) {        promise.then(function (value) {          done(index, value)        },reject)      })    })    // 判断 promise 状态是否全部 resolve    function gen(length, resolve) {      let count = 0;      let result = [];      return function(i, value) {        result[i] = value;        if (++count === length) {          resolve(result);        }      }    }  }  Promise.resolve = function(arg){    return new Promise(function(resolve,reject){        resolve(arg)    })  }  Promise.reject = function(arg){    return Promise(function(resolve,reject){      reject(arg)    })  }  return Promise;}())</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/2019/05/23/typescript/basedatatype/"/>
      <url>/2019/05/23/typescript/basedatatype/</url>
      
        <content type="html"><![CDATA[<p>每种语言都会有属于自己的数据类型，ts的基本数据类型基本上是继承了js，但也在基础之上增加了几个不一样的类型</p><h3 id="布尔型-true／false"><a href="#布尔型-true／false" class="headerlink" title="布尔型 true／false "></a>布尔型 true／false <br></h3><pre><code>//在js中声明boolean型的方法和ts中的不同之处let flag = true;let flag: boolean = true;</code></pre><h3 id="float-数值型（在js和ts中数字型都是float）"><a href="#float-数值型（在js和ts中数字型都是float）" class="headerlink" title="float,数值型（在js和ts中数字型都是float）"></a>float,数值型（在js和ts中数字型都是float）<br></h3><pre><code>//在js中声明number型的方法和ts中的不同之处let age = 26;let age: number = 26;</code></pre><h3 id="字符型-String"><a href="#字符型-String" class="headerlink" title="字符型 String "></a>字符型 String <br></h3><pre><code>//在js中声明number型的方法和ts中的不同之处let name = &#39;boren&#39;;let name: string = &#39;boren&#39;;</code></pre><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array "></a>数组 Array <br></h3><pre><code>//在js中声明数组的方法和ts中的不同之处//1.js中声明数组的两种方式let city = [];let city = new Array();//2.ts中声明数组的两种方式let city: string[] = [];let city:Array&lt;string&gt; = []//在ts中声明数组必须提前指定其数据类型，如果其数组中的元素其数据类型不相同，声明的方式会在后面介绍</code></pre><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple "></a>元组 Tuple <br></h3><pre><code>//可以定义数组中元素不相同的数据类型let people = [&#39;boren&#39;,26];//jslet people:[string,number];people = [&#39;boren&#39;,26];//ts</code></pre><h3 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum "></a>枚举 Enum <br></h3><pre><code>//js中没有此方法，都是以object或者json的形式去实现枚举的特性如：let school = {     teacherOne : &#39;Mars&#39;,     teacherTwo:&#39;yupeng&#39;,     teacherThree:&#39;luxuesong&#39;} console.log(school.teacherOne)//Mars在ECMA2015，简称es5中Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象Object.getOwnPropertyDescriptor（school,‘teacherOne’）// {// value: Mars,// writable: true,// enumerable: true,// configurable: true// }其中这么方法打印出来的对象中key enumerable属性，为可枚举性，在js es5中有三个操作会忽略枚举为 false，for...in、 Object...keys()、 JSON.stringify()；在es6中新增一个方法Object.assign()会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。关于更多js中对枚举属性的支持，在这里就不一一介绍，例如toString()和length等等其枚举属性为false//ts中枚举类型的用法enum classMember = {chenchao,rongbin,chenhua,liurui,luxuesong};let teacher:classMember = classMember.luxuesong我们也可以给枚举中的成员进行编号等等，以便于更方便的去找到相应的对象元素</code></pre><h3 id="通用数据类型-Any"><a href="#通用数据类型-Any" class="headerlink" title="通用数据类型 Any"></a>通用数据类型 Any<br></h3><pre><code>这种数据类型个人认为是万能的，它可以在你不知道这个变量为什么数据类型的情况下，并且项目比较急的时候标注为Any，它可以通过编译时的类型检查，有人会说那我所有的类型都写Any，如果你非要这么干，也无妨，那就失去了ts这么语言本身的意义所在，可以用这种方法去解决一个上述声明数组类型时很麻烦的问题let lists: any[] = [&#39;boren&#39;,26,&#39;body&#39;]; let age: any = 26;let name: any = &#39;boren&#39;;</code></pre><h3 id="空值Void"><a href="#空值Void" class="headerlink" title="空值Void "></a>空值Void <br></h3><pre><code>在js中我们其实对void不是那么的陌生，它被认为是一个操作符，这个操作符可以计算表达式但不会返回任何值，在js中常常出现的位置就是在a标签的链接中，我们不想让页面刷新，更不想链接到某些位置只是简简单单的a标签，有时候会调用一个简单的函数，仅此而已，那么我们就会&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;people()&quot;&gt;点我&lt;/a&gt;//在ts中，void类型像是与any类型相反，它表示没有任何类型。function student(): void{   console.log(&#39;my name is renbo&#39;)}在上述函数中没有返回任何值，所以类型为void，其实void的变量没什么用处和null,undefined一样职能作为数据的类型的判断。</code></pre><h3 id="永不存在值的类型Never"><a href="#永不存在值的类型Never" class="headerlink" title="永不存在值的类型Never"></a>永不存在值的类型Never<br></h3><pre><code>官网解释never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns;Variables also acquire the type never when narrowed by any type guards that can never be true. never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。个人觉得没什么太大用这里就不做深究。</code></pre><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言 "></a>类型断言 <br></h3><pre><code>在ts中类型断言这种方式还是比较有用处的，其相当于js中的类型转换。但是只在编译的时候起作用。并不会改变其数据的本身结构。let city: any = &quot;beijing&quot;;let strLength: number = (city as string).length;另外一种写法：let city: any = &quot;beijing&quot;;let strLength: number = (&lt;string&gt;city).length;</code></pre><hr>总结：通过以上的介绍相信大家对ts的数据类型已经有了大概的了解，其实相对于js,ts的数据类型并没有做什么变更，只是在声明其数据类型的时候必须明确的指定其相应的数据类型，否则代码编译会报错。虽然 ts的文件是xxx.ts 但由于编译过后和js 没有什么大的不同点，能够很好的运行在浏览器端，其中class、public等等函数及模块编译过后的js能后让你更深入的了解js]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2019/05/22/typescript/generics/"/>
      <url>/2019/05/22/typescript/generics/</url>
      
        <content type="html"><![CDATA[<p>泛型（Generics）就是不提前指定接口、变量、函数等的类型，在使用的时候再指定类型</p><h3 id="定义泛型"><a href="#定义泛型" class="headerlink" title="定义泛型 "></a>定义泛型 <br></h3><pre><code>// 定义类型function identity(arg: number): number {  return arg;}// 定义 any 类型function identity(arg: any): any {  return arg;}</code></pre><p>如果所有的接口、变量、函数等都用 any 类型，那么写 TS 和写 JS 一样将失去意义，因为你可能像 JS 一样造成许多未知的错误，那么解决这样的问题我们使用一种特殊的变量T，来表示返回的内容。</p><pre><code>function identity&lt;T&gt;(arg: T): T {  return arg;}</code></pre><h3 id="调用泛型"><a href="#调用泛型" class="headerlink" title="调用泛型"></a>调用泛型<br></h3><pre><code>let output = identity&lt;string&gt;(&quot;myString&quot;);</code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束<br></h3><p>在函数内部使用泛型变量的时候，因为不知道它是哪种类型，所以不能随意的操作它的属性或方法</p><pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {  console.log(arg.length);  // Error: T doesn&#39;t have .length  return arg;}</code></pre><p>由于上面的泛型 T 中不一定包含属性.length, 所以会抛出异常。</p><p>这时我们可以创建一个具有单个.length属性的接口，然后我们将使用此接口和extends关键字来表示我们的约束：</p><pre><code>interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {  console.log(arg.length);   return arg;}</code></pre><p>上面的例子如果在调用的时候传入的参数不符合定义的约束，那么就会抛出异常</p><pre><code>interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {  console.log(arg.length);   return arg;}loggingIdentity(5) // Argument of type &#39;5&#39; is not assignable to parameter of type &#39;Lengthwise&#39;</code></pre><p>相反如果定义了正确的类型</p><pre><code>interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {  console.log(arg.length);   return arg;}loggingIdentity([1,2]) // 2loggingIdentity({length: 5, value: 1}) // 5</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口<br></h3><pre><code>// 定义泛型结构interface CreatePeopleFunc {  &lt;T&gt;(name: string, age: T): Array&lt;T&gt;;}// 创建泛型let createPeople:CreatePeopleFunc;createPeople = function&lt;T&gt;(name: string, age: T): Array&lt;T&gt; {  let people: T[] = []  let temp:any = {    name : name,    age: age  }  people.push(temp)  return people}// 调用函数createPeople(&#39;zhangsan&#39;, 28)</code></pre><p>上面例子我们定义了一个泛型，创建了函数，在函数内创建数组并添加了一个元素 name, age</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类<br></h3><p>泛型类具有与通用接口类似的形状。泛型类&lt;&gt;在类名称后面的尖括号（）中有一个泛型类型参数列表</p><pre><code>class GenericNumber&lt;T&gt; {    zeroValue: T;    add: (x: T, y: T) =&gt; T;}let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) { return x + y; };</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2019/05/18/typescript/interfaces/"/>
      <url>/2019/05/18/typescript/interfaces/</url>
      
        <content type="html"><![CDATA[<p>##</p><p>在面向对象语言中接口 (Interfaces) 是对类的行为的抽象，在TypeScript中也常用于定义结构子类型，方便进行类型检查</p><h3 id="定义一个简单的接口"><a href="#定义一个简单的接口" class="headerlink" title="定义一个简单的接口"></a>定义一个简单的接口<br></h3><pre><code>interface IPeople {  name: string;  age: number}let zhangsan: IPeople = {  name: &#39;zhangsan&#39;,  age: 25};</code></pre><p>上面的例子我定义了一个接口 IPeople，并且定义了一个变量 zhangsan，它的类型是 IPerson，zhangsan的数据结构类型必须与 IPeople 一致否则会报错例如下面</p><pre><code>interface IPeople {  name: string;  age: number}let zhangsan: IPeople = {  name: &#39;zhangsan&#39;,};Property &#39;age&#39; is missing in type &#39;{ name: string; }&#39; but required in type &#39;IPeople&#39;</code></pre><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性 "></a>可选属性 <br></h3><p>当我们定义接口属性的时候不是必须的那么可选属性就起到了作用</p><pre><code>interface IPeople {  name: string;  age?: number}let zhangsan: IPeople = {  name: &#39;zhangsan&#39;,};</code></pre><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性<br></h3><p>当我们需要定义或增加一些未知的属性，那么任意属性就起到了作用</p><pre><code>interface IPeople {  name: string;  age?: number  [propName: string]: any;}let zhangsan: IPeople = {  name: &#39;zhangsan&#39;,  age: 28,  gender: &#39;m&#39;};</code></pre><p>上述例子中需要注意的是一旦定义了任意属性，那么可选属性和确定属性的类型必须是它的的类型的子集，否则会报错，例如</p><pre><code>interface IPeople {  name: string;  age?: number  [propName: string]: string;}let zhangsan: IPeople = {  name: &#39;zhangsan&#39;,  age: 28,  gender: &#39;m&#39;};Type &#39;{ name: string; age: number; gender: string; }&#39; is not assignable to type &#39;IPeople&#39;.Property &#39;age&#39; is incompatible with index signature.Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性<br></h3><p>当我们需要对象中字段只能在创建的时候被赋值，那么只读属性就起到了作用</p><pre><code>interface IPerson {  readonly id: number;  name: string;  age?: number;  [propName: string]: any;}let zhangsan: IPerson = {  id: 1,  name: &#39;zhangsan&#39;,  gender: &#39;m&#39;};zhangsan.id = 2;Cannot assign to &#39;id&#39; because it is a read-only property.</code></pre><h3 id="可以为接口定义函数类型"><a href="#可以为接口定义函数类型" class="headerlink" title="可以为接口定义函数类型"></a>可以为接口定义函数类型<br></h3><pre><code>interface IPeople {  (name: string, age: number): string;}let hello: IPeople;hello = function(name: string, age: number): string {  return `my name is ${name} I,m years old ${age}`}hello(&#39;zhangsan&#39;, 28) //my name is zhangsan I,m years old 28</code></pre><p>上面简单的介绍了接口的基本用法，也就是对对象的结构进行性约定，接下来我们来用 Interface 对类的行为进行抽象</p><h3 id="用类实现接口"><a href="#用类实现接口" class="headerlink" title="用类实现接口"></a>用类实现接口<br></h3><p>用类实现接口主要应用的场景就是类与类之间有一些公有的功能及特性，要实现高度抽象这也是面向对象的基本。在 TypeScript 中用关键字 implements 去实现。</p><pre><code>// 定义接口，接口中有一个公共的方法eatinterface People{  eat(food: string)}// 实现接口的方法class Boy implements People {  constructor () {}  eat (food: string): string {   return food   }}// 实现接口方法class Girl implements People {  constructor () {}  eat (food: string):string {    return food  }}let boy = new Boy()console.log(boy.eat(&#39;apple&#39;))let girl = new Girl()console.log(girl.eat(&#39;banana&#39;))</code></pre><p>一个类也可以实现多个接口</p><pre><code>interface Eat{  food (food: string)}interface Drink{  drink()}// 实现接口的方法class People implements Eat, Drink {  constructor () {}  food (food: string): string {   return food   }  drink ():string {    return `小明跑步中吃${this.food(&#39;apple&#39;)}是不健康的`  }}let people = new People()console.log(people.drink())</code></pre><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承<br></h3><p>在 JS ECMA6 中类的继承用 extends 关键字， 那么在 TS 中我们依然同样用这个关键字</p><pre><code>interface Eat {  eat ()}interface People extends Eat {  eat()  run ()}</code></pre><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型<br></h3><p>混合类型实际上就是在接口中存在多种规则，利用这种规则去实现自己的属性和方法</p><pre><code>// 定义规则interface Counter {  (start: number): string;  interval: number;  reset(): void;}// 实现规则function getCounter(): Counter {  let counter = &lt;Counter&gt;function (start: number) {     console.log(start)  };  counter.interval = 0;  counter.reset = function () {    console.log(&#39;reset&#39;)  };  return counter;}let counter = getCounter()counter(20); // 20counter.reset(); // reset counter.interval = 5; // 5</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2019/05/17/typescript/class/"/>
      <url>/2019/05/17/typescript/class/</url>
      
        <content type="html"><![CDATA[<h2 id="TS基础系列之-类"><a href="#TS基础系列之-类" class="headerlink" title="TS基础系列之-类"></a>TS基础系列之-类</h2><p>在JavaScript 通过构造函数和原型链来实现类和继承。而在 ES6 中，也用语法糖实现了class，下面介绍一下在 ts 中的类。</p><h3 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念 "></a>类的概念 <br><hr></h3><p>类是面向对象程序设计中的概念，是面向对象编程的基础，由于是一种数据类型，而不是数据，所以不存在于内存中。</p><ul><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 new 生成，类是概念，对象是实体</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。</li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h3 id="ES6中类的用法"><a href="#ES6中类的用法" class="headerlink" title="ES6中类的用法 "></a>ES6中类的用法 <br><hr></h3><ol><li><p><strong>定义属性和方法</strong></p><pre><code> // 定义类 class Parent{   // 定义构造函数   constructor(name=&#39;wang&#39;,age=&#39;27&#39;){     // 定义属性     this.name = name;     this.age = age;   }   // 定义方法   eat(){     console.log(`${this.name} ${this.age} eat food`)   } }</code></pre></li><li><p><strong>利用关键字extends 和 super 继承</strong></p><pre><code> class Child extends Parent{      constructor(name = &#39;ren&#39;,age = &#39;27&#39;){        //继承父类属性       super(name, age);      }        eat(){        //继承父类方法         super.eat()        }    }    let child =new Child(&#39;xiaoxiami&#39;);    child.eat();</code></pre></li><li><p><strong>存储器getter,setter改变属性和读取</strong></p><pre><code> class People{   // 定义构造函数   constructor(name){     // 定义属性     this.name = name;   }   get name () {     return &#39;renbo&#39;;   }   set name (value) {     console.log(&#39;setter: &#39; + value);   }   // 定义方法   eat(){     console.log(`${this.name}  eat food`)   } } let people = new People(&#39;lisi&#39;); // setter: lisi people.name = &#39;zhangsan&#39;; // setter: zhangsan console.log(people.name); // renbo</code></pre></li><li><p><strong>静态方法使用static修饰符（由于分配在静态内存空间中，所以不需要实例化，只需要吊影即可）</strong></p><pre><code> class People{   // 定义静态方法   static eat(name){     console.log(`${name} eat food`)   } } console.log(People.eat(&#39;renbo&#39;)) // renbo eat food</code></pre></li></ol><h3 id="ES7中类的用法"><a href="#ES7中类的用法" class="headerlink" title="ES7中类的用法 "></a>ES7中类的用法 <br><hr></h3><ol><li><p><strong>定义属性可以直接在类中定义</strong></p><pre><code> class People{   name = &#39;zhangsan&#39;   constructor () {     //    } } let people = new People(); console.log(npeople.name) // zhangsan</code></pre></li><li><p><strong>定义静态属性</strong></p><pre><code>class People{static  name = &#39;zhangsan&#39; constructor () {   //  }}console.log(People.name) // zhangsan</code></pre></li></ol><h3 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法 "></a>TypeScript 中类的用法 <br><hr></h3><ol><li><strong>说起 ts 中的类不得不说访问修饰符 public private protected</strong></li></ol><ul><li>public 说明属性或方法是公有的，在任何地方被访问到，在 ts 中方法和属性默认的是 public</li><li>private 说明属性或方法是私有的，不能在类的外部访问</li><li>protected 说明属性或方法是受保护的，和 private 类似，但是 protected 也可以在子类中访问</li></ul><p><strong>public 修饰符</strong></p><pre><code>class People {  public name;  public constructor(name) {    this.name = name;  }}let people = new People(&#39;renbo&#39;);console.log(people.name); // renbo</code></pre><p><strong>private 修饰符</strong></p><pre><code>class People {  private  name;  public constructor(name) {    this.name = name;  }}let people = new People(&#39;renbo&#39;);console.log(people.name); // Property &#39;name&#39; is private and only accessible within class &#39;People&#39;.// 在子类中也不允许访问，只是私有class People {  private  name: string;  public constructor(name: string) {    this.name = name;  }}class SmilePeople extends People {  public constructor (name:string) {    super(name)    console.log(this.name); // Property &#39;name&#39; is private and only accessible within class &#39;People&#39;.  }}</code></pre><p><strong>protected 修饰符</strong></p><pre><code>class People {  protected  name;  public constructor(name) {    this.name = name;  }}let people = new People(&#39;renbo&#39;);console.log(people.name); // Property &#39;name&#39; is protected and only accessible within class &#39;People&#39; and its subclasses.ts</code></pre><p><strong>protected 修饰符(子类访问)</strong></p><pre><code>class People {  protected  name: string;  public constructor(name: string) {    this.name = name;  }}class SmilePeople extends People {  public constructor (name:string) {    super(name)    console.log(this.name)  }}let people  = new People (&#39;zhangsna&#39;)let smilePeople = new SmilePeople(&#39;wangwu&#39;); // wangwu</code></pre><ol start="2"><li><strong>抽象类（ abstract 用于定义抽象类以及抽象类中的抽象方法）</strong></li></ol><ul><li>抽象类可以作为派生其他类的基类</li><li>抽象类中的抽象方法必须被子类实现</li><li>抽象类无法直接实例化</li><li>与接口不同，抽象类可以包含其成员的实现细节</li></ul><pre><code>// 上述1，2abstract class People {  public name:string;  public constructor (name:string) {    this.name = name;  }  public abstract eat():string}// 派生类class SmilePeople extends People {  static food: string = &#39;apple&#39;  // eat 方法必须在子类中实现  public eat ():string {    return `my name is ${this.name} I,m eating ${SmilePeople.food}`  }}let smilePeople = new SmilePeople(&#39;zhangsan&#39;);smilePeople.eat()// 无法直接实例化abstract class People {  public name:string;  public constructor (name:string) {    this.name = name;  }  public abstract eat ():void}let people = new People(&#39;zhangsan&#39;) // Cannot create an instance of an abstract class.</code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2019/05/16/typescript/function/"/>
      <url>/2019/05/16/typescript/function/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的创建"><a href="#函数的创建" class="headerlink" title="函数的创建 "></a>函数的创建 <br></h3><p>在 ts 中函数创建也氛围两种匿名函数和有命名的函数</p><pre><code>// 有名字的函数function people () {}// 匿名函数const people = function () {}</code></pre><h3 id="函数的参数类型和返回值类型"><a href="#函数的参数类型和返回值类型" class="headerlink" title="函数的参数类型和返回值类型 "></a>函数的参数类型和返回值类型 <br></h3><ul><li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正</li><li>设定了类型之后必须要返回相对应的类型，否则会报错</li><li>如果函数没有返回任何值，也必须指定返回值类型为 void而不能留空<pre><code>/*** * @param {*} x number* @param {*} y number*  return add number */</code></pre></li></ul><p>const add = (x: number, y: number): number =&gt; x + y;<br>// 书写完整的函数类型<br>const add: (x: number, y: number) =&gt; number = (x: number, y: number):number =&gt; x + y </p><pre><code>### 函数的可选参数和默认参数&lt;br/&gt;- 传递给一个函数的参数个数必须与函数期望的参数个数一致，否则会报错- 可选参数用`?argname`表示，必须跟在必须参数后面- 没有传递参数或传递的值是undefined，这种叫做默认初始化值的参数- 所有必须参数**后面**的带默认初始化的参数都是可选的，调用时可省略- 带默认值的参数如果出现在必须参数**前面**，用户必须明确的传入 undefined 值来获得默认值- 当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）</code></pre><p>// 上述1<br>const add: (x: number, y: number) =&gt; number = (x: number, y: number):number =&gt; x + y<br>add(1, 2) // 3<br>add(1) // 报错<br>add(1,2,3) // 报错</p><p>// 上述2<br>const yourName = (firstName: string, lastName?: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’)) // ren+undefined</p><p>// 上述3<br>const yourName = (firstName: string, lastName?: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’, undefined)) // ren+undefined</p><p>//上述4<br>const yourName = (firstName: string, lastName=’bo’): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’)) // ren+bo</p><p>// 上述5<br>const yourName = ( lastName=’bo’, firstName: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //bo+ren<br>console.log(yourName(undefined, ‘ren’)) // ren+bo</p><p>// 上述6<br>const people = ( name: string, …otherProperty: string[]): string =&gt; {<br>  return name + “ “ + otherProperty.join(“ “);<br>}<br>console.log(people(‘renbo’, ‘28’,’170’))  // renbo 28 170 </p><pre><code>### 函数的重载 &lt;br/&gt;重载允许一个函数接受不同数量或类型的参数时，作出不同的处理</code></pre><p>// 我们来实现一下通过传入不同的 type 来实现函数的加操作和乘法操作并返回相应的类型<br>const compute = (type: number, …resetData: number[]):number | string =&gt; {<br>  if (type === 1 ) {<br>    return resetData.reduce((a:number, b:number):number =&gt; a + b);<br>  } else if (type === 2) {<br>    return String(resetData.reduce((a:number, b:number):number =&gt; a * b));<br>  }<br>}<br>console.log(compute(1, 3, 4, 5, 6)) // 18<br>console.log(compute(2, 3, 4, 5, 6)) // ‘360’</p><p>// 通过上面的实现唯一的缺点就是不能明确通过type返回的相对应的计算的值和类型</p><p>const compute = (type: number, …resetData: number[]):number;<br>const compute = (type: number, …resetData: number[]):string;<br>const compute = (type: number, …resetData: number[]):number | string =&gt; {<br>  if (type === 1 ) {<br>    return resetData.reduce((a:number, b:number):number =&gt; a + b);<br>  } else if (type === 2) {<br>    return String(resetData.reduce((a:number, b:number):number =&gt; a * b));<br>  }<br>}<br>console.log(compute(1, 3, 4, 5, 6)) // 18<br>console.log(compute(2, 3, 4, 5, 6)) // ‘360’</p><p>// 上例中，我们重复定义了多次函数 compute，前几次都是函数定义，最后一次是函数实现。</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础之概述和环境配置</title>
      <link href="/2019/05/15/typescript/envconfig/"/>
      <url>/2019/05/15/typescript/envconfig/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？<br></h3><p>  ts是一种的开源的编程语言，是由Microsoft主导研发。从工作机制上讲，它就像javaScript的超集。这个语言添加了可选的静态类型和基于类的面向对象编程。2012年首个版本公布</p><h3 id="TypeScript的特点"><a href="#TypeScript的特点" class="headerlink" title="TypeScript的特点?"></a>TypeScript的特点?</h3><ul><li>JavaScript可以使用TypeScript。所有TypeScript代码也都转换为它的JavaScript等效代码</li><li>TypeScript支持其他JS库</li><li>TypeScript是可移植的。TypeScript可跨浏览器，设备和操作系统的移植</li><li>TypeScript与ECMAScript6规范一致</li></ul><h3 id="为什么要使用TypeScript？"><a href="#为什么要使用TypeScript？" class="headerlink" title="为什么要使用TypeScript？"></a>为什么要使用TypeScript？<br></h3><p>  作为前端开发人员我们都知道，从本质上讲，JavaScript是一种自由语言，也叫弱类型的语言，它的语法规则并不是那么严格。正因为如此，我们就更容易犯错，而且，即使是在运行的时候，我们也不能找到所有的错误。鉴于此，TypeScript作为JavaScript的超集，它的语法更严格，我们在编写代码的时候就能够发现大部分错误。不仅如此，按照TypeScript官方的说法，TypeScript使得我们能够以JavaScript的方式实现自己的构思。TypeScript对面向对象的支持也非常完善，它拥有面向对象编程语言的所有特性。如果你想要获取有关TypeScript的更多信息，可以前往TypeScript的官方网站: <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript - JavaScript that scales.</a></p><h3 id="TypeScript的组成部分"><a href="#TypeScript的组成部分" class="headerlink" title="TypeScript的组成部分?"></a>TypeScript的组成部分?</h3><ul><li>语言层 - 它包括语法，关键字和类型注释</li><li>编译器层 - TypeScript编译器（TSC）将使用TypeScript编写的指令转换为其等效的JavaScript</li><li>语言服务层 - “语言服务”在核心编译管道周围公开了一个额外的层，它是类似编辑器的应用程序。ts编译核心(core.ts,program.ts,scanner.ts,parser.ts,checker,emitter.ts)<br><br><image src="images/ts-lang.png" width="350"></image></li></ul><h3 id="TypeScript-环境配置（本文不讨论-windows-安装过程和-mac-类似）"><a href="#TypeScript-环境配置（本文不讨论-windows-安装过程和-mac-类似）" class="headerlink" title="TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）"></a>TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）</h3><ul><li>下载并安装 node <a href="https://nodejs.org/en/" target="_blank" rel="noopener">相关 node 官网</a></li><li>查看 node 是否安装成功，在命令行中执行 <code>node -v</code> 如果出现版本号则证明 node 安装成功 </li><li>通过 npm 安装 typescript <code>npm install -g typescript</code> </li><li>创建 filename.ts 文件在文件中书写相应ts代码</li><li>执行 <code>tsc filename.ts</code> 编译过后默认会在当前目录产生js文件,在页面中引入js文件即可</li><li>后续在tsconfig.json 中讨论配置监听属性</li></ul>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数节流与抖动</title>
      <link href="/2019/05/15/javascript/debounce/"/>
      <url>/2019/05/15/javascript/debounce/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p>说起函数的节流与抖动这个老生长谈的话题，我们就需要了解一下关于浏览器的知识</p><p>浏览器有各种进程，来保证浏览器正常的、流畅的呈现在用户的眼前。例如渲染进程（也就是浏览器的内核）是非常重要的一个进程，其中包含了很多的线程</p><pre><code>GUI渲染线程(负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等)JS引擎线程(JS内核，负责处理JavaScript脚本程序)事件触发线程(归属于浏览器而不是JS引擎，用来控制事件循环)定时触发器线程(传说中的setTimeout和setInterval所在的线程)异步http请求线程(在XMLHttpRequest在连接后是通过浏览器新型一个线程请求)</code></pre><p>这里我们大概了解一下着几个概念，关于更过的相关知识会在后续的文章中介绍</p><h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h3><p>我们先来看下面一张来至 W3C 的图</p><p><img src="/images/timestamp-diagram.svg"></p><p>从图中我们看到处理模型大概分为如下几个阶段</p><ul><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染</li></ul><p>这篇文章我们不讨论 Resource Timing 阶段，会在后续文章前端性能的时候重新提起</p><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>通过第五个阶段客户端渲染简单的回忆一下网页的生成过程，大致分为几个步骤</p><ul><li>HTML解析器解析成DOM 树</li><li>CSS解析器解析成CSSOM 树</li><li>结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)</li><li>生成布局（Layout），根据渲染树来布局，以计算每个节点的几何信息</li><li>最后一步是绘制（Paint），使用最终渲染树将像素渲染到在屏幕上</li></ul><img src="/images/render-process.jpg"><p>通过上面的总结我们解析每一个步骤能更加深入的了解浏览器渲染过程</p><h3 id="HTML-解析器解析过程"><a href="#HTML-解析器解析过程" class="headerlink" title="HTML 解析器解析过程"></a>HTML 解析器解析过程</h3><p>HTML 解析器构建 DOM 树，实际上是经过下面几个步骤</p><pre><code>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型编码阶段将 HTML 的原始字节数据转换为文件指定编码令牌阶段根据HTML规范来将字符串转换成各种令牌也就是标签节点生成节点对象阶段是根据每个令牌转换定义其属性和规则的对象（节点对象）最后阶段 DOM 树构建完成，整个对象集合就像是一棵树形结构（对象模型）</code></pre><p>下面通过代码和图片来解释上面的步骤</p><pre><code>&lt;html&gt;  &lt;head&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;title&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;    &lt;div&gt;&lt;img src=&quot;&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><img src="/images/dom-render.jpg"><h3 id="CSS-解析过程"><a href="#CSS-解析过程" class="headerlink" title="CSS 解析过程"></a>CSS 解析过程</h3><p>浏览器获得 CSS 文件的数据后 CSS 解析器根据具体的样式将渲染 CSSDOM 树</p><img src="/images/css-dom-render.jpg"><h3 id="渲染树渲染"><a href="#渲染树渲染" class="headerlink" title="渲染树渲染"></a>渲染树渲染</h3><p>构建 两个树之后渲染树出场，浏览器会先从DOM树的根节点开始遍历，对每个可见节点，找到对应的 CSS 样式规则，进行匹配形成构建完成的渲染树</p><img src="/images/render-tree.jpg"><p>渲染树构建后浏览器根据节点对象的规则进行flow（布局）阶段，布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置最后生成我们大家知道的浏览器盒模型</p><p>最后当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，最后渲染到在屏幕上</p><p>通过上面大致的流程我们知道了浏览器的渲染过程，我们知道网页在生成的时候，至少会渲染一次执行css之后 load 对应 JS 也会进行重新渲染</p><p>重新渲染就可能会 reflow + repaint</p><h3 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h3><p>回流(reflow)： 当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建</p><p>重绘(repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘</p><p>回流必定会发生重绘，重绘不一定会引发回流</p><p>浏览器的reflow + repaint 在我们设置节点样式时频繁出现，对性能是个巨大的消耗，因为回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流，所以我们经常说尽可能的减少重排次数、重排范围，这样就能呈现给用户更改的感官（关于优化手段会在后续的性能优化文章中介绍）</p><p>根据上面说了这么多，我们来进入文章的主题<strong>防抖和节流</strong>当我们窗口发生改变，浏览器的滚动条执行scroll，输入框校验，搜索请求接口等这些都会使页面频繁重新渲染，加重浏览器的负担，这是我们通过<strong>防抖和节流</strong>的方式减少触发频率，这样就会大大的提高用户体验</p><h3 id="debounce（防抖）"><a href="#debounce（防抖）" class="headerlink" title="debounce（防抖）"></a>debounce（防抖）</h3><p>动作发生一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。</p><p>html </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;防抖&lt;/title&gt;  &lt;style&gt;    #container{      width: 100%;       height: 500px;       background: #000;       font-size: 50px;      color: #fff;      line-height: 500px;       text-align: center;     }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;content&quot;&gt;&lt;div&gt;  &lt;script src=&quot;debounce.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var count = 1;    var container = document.getElementById(&#39;container&#39;);    function getContent(e) {      container.innerHTML = count++;    };    // container.onmousemove = getContent    container.onmousemove = debounce(getContent, 500, true);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>debounce.js </p><pre><code>@underscore.jsvar debounce = /** @class */ (function () {  /**   * @desc 函数防抖   * @param {*} func 回调函数   * @param {*} wait 延迟执行毫秒数   * @param {*} immediate  true 表立即执行，false 表非立即执行   */  function debounce(func, wait, immediate) {    // 创建一个标记用来存放定时器的返回值    var timeout,result;    return function () {      // 指定this 作用域      var context = this;      // event 对象      var args = arguments;      // 再次执行事件的时候，清除上一个定时器      if (timeout) clearTimeout(timeout);      if (immediate) {        // 如果已经执行过，将不再执行        var callNow = !timeout;        timeout = setTimeout(function(){          timeout = null;        }, wait)        if (callNow) result = func.apply(context, args)      }      else {        timeout = setTimeout(function(){          func.apply(context, args)        }, wait);      }      // func 这个函数，可能有返回值      return result;    }  }  return debounce;}())</code></pre><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>动作执行一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新执行</p><p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器</p><p>使用时间戳</p><p>当触发事件的时候，取出当前的时间戳，之后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，执行函数并更新当前时间戳，反之就不执行。</p><pre><code>var throttle = /** @class */ (function () {  function throttle(func, wait) {    var args;    var previous = 0;    return function() {      var now = +new Date();      args = arguments;      if (now - previous &gt; wait) {        func.apply(this, args);        previous = now;      }    }  }  return throttle}())</code></pre><p>使用定时器</p><p>事件触发的时候，设置一个定时器，如果定时器存在，就不执行，等定时器到指定的时间，清空定时器，执行事件</p><pre><code>function throttle(func, wait) {  var timeout;  var previous = 0;  return function() {    context = this;    args = arguments;    if (!timeout) {      timeout = setTimeout(function(){        timeout = null;        func.apply(context, args)      }, wait)    }  }}</code></pre><p>对比两种实现方式</p><ul><li>第一种会立刻执行，第二种会在设定的时间后第一次执行</li><li>第一种停止触发后不会再执行，第二种停止触发后依然会再执行一次</li></ul><p>现在我们要结合上面两种方式实现一个开始触发立刻执行，停止触发的时候还能再执行一次</p><pre><code>@underscore.jsvar throttle = /** @class */ (function () {  /**   * throttle 节流   * @param {*} func  回调函数   * @param {*} wait  执行时间间隔   * @param {*} options  如果想忽略开始函数的的调用，传入{leading: false}   *                     如果想忽略结尾函数的调用，传入{trailing: false}   *                     两者不能共存，否则函数不能执行   */  function throttle(func, wait, options) {    var timeout, context, args;    var previous = 0;    if (!options) options = {};    var later = function() {      // 如果设置了 leading，就将 previous 设为 0      previous = options.leading === false ? 0 : new Date().getTime();      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断      timeout = null;      func.apply(context, args);      if (!timeout) context = args = null;    };    var throttled = function() {      var now = new Date().getTime();      if (!previous &amp;&amp; options.leading === false) previous = now;      // 计算剩余时间      var remaining = wait - (now - previous);      context = this;      args = arguments;      if (remaining &lt;= 0 || remaining &gt; wait) {        // 如果存在定时器就清理掉否则会调用二次回调        if (timeout) {          clearTimeout(timeout);          timeout = null;        }        previous = now;        func.apply(context, args);        if (!timeout) context = args = null;      } else if (!timeout &amp;&amp; options.trailing !== false) {        // 判断是否设置了定时器和 trailing，没有就开启一个定时器        timeout = setTimeout(later, remaining);      }    };    return throttled;}  return throttle}())</code></pre><p>调用例子</p><pre><code>ontainer.onmousemove = throttle(getContent, 1000);container.onmousemove = throttle(getContent, 1000, {  leading: false});container.onmousemove = throttle(getContent, 1000, {  trailing: false});</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的就是函数的节流与抖动的全部，我们在面试和工作中会经常的遇到。这也是性能优化的一种方案。当然还有很多版本比如多 promise 版本的就不再这里叙述了，有兴趣的可以找找技术论坛</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 new 运算符</title>
      <link href="/2019/04/27/javascript/new/"/>
      <url>/2019/04/27/javascript/new/</url>
      
        <content type="html"><![CDATA[<p>实现 new 运算符也算是 JS 中经典的面试题了。在实际应用中其实 new 运算符的应用场景是定义对象类型的实例</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code>/** * 定义构造函数 * @param {*} name  * @param {*} age  */function Person(name, age) {  this.name = name;  this.age = age;}Person.prototype.sayName = function () {  console.log(`my name is ${this.name}, I&#39;m ${this.age} years old`);}Person.prototype.study = function () {  console.log(`my name is ${this.name}, I&#39;m learning to swim`);}let person = new Person(&#39;renbo&#39;, 28);console.log(person.name)console.log(person.sayName())// 调用内置函数let array = new Array();let obj = new Object();</code></pre><h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>用构造函数实际上会经历以下4个步骤（实现思路）</p><ul><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ul><pre><code>function newFun (constructor) {  var o = {};  // 将 o 的原型指向构造函数，这样 o 就可以访问到构造函数原型中的属性  o.__proto__ = constructor.prototype;  // 改变构造函数 this 的指向到新建的对象，这样 o 就可以访问到构造函数中的属性  var ret = constructor.apply(o, Array.prototype.slice.call(arguments, 1));  // 需要判断返回的值是否是对象，如果不是对象返回正常数据类型  return typeof ret === &#39;object&#39; ? ret : o;}// 再次使用上面的例子function Person(name, age) {  this.name = name;  this.age = age;}Person.prototype.sayName = function () {  return `my name is ${this.name}, I&#39;m ${this.age} years old`;}Person.prototype.study = function () {  return `my name is ${this.name}, I&#39;m learning to swim`;}let person =  newFun(Person, &#39;renbo&#39;, 28);console.log(person.name); // renboconsole.log(person.sayName()); // my name is renbo, I&#39;m 28 years oldconsole.log(person.study()); // my name is renbo, I&#39;m learning to swim</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call 和 apply</title>
      <link href="/2019/04/22/javascript/call/"/>
      <url>/2019/04/22/javascript/call/</url>
      
        <content type="html"><![CDATA[<p>谈起 call 和 apply 这两个 Function.prototype 上的方法可能很熟悉了，它在继承，改变this指针上有很多的应用场景。接下来我们简单的来重新回忆一下 call 和 apply 这两个函数的功能 <br></p><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><pre><code>let obj = {  value : 20}function fun () {  console.log(this.value)}fun.call(obj) //20</code></pre><h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><pre><code>document.getElementById( &#39;element&#39; ).onclick = function(){  let func = function(){       console.log ( this ); // 指向element元素  }   func.call(this);}; </code></pre><h3 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h3><pre><code>function FunA (val) {  this.value = val;}function FunB () {  FunA.apply(this, arguments);}FunB.prototype.getValue = function () {  return this.value}let funb = new FunB(20);console.log(funb.getValue()) //20</code></pre><p>经过上面的例子我们可以直观的知道call apply 的作用大部分都是用作改变this的指针。那么接下来我们来模拟 call apply 实现简单的一下这两个函数<br></p><h3 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h3><p>实现思路<br><br>1、将函数设为对象的属性用来改变 this 指向<br><br>2、调用对应函数<br><br>3、删除对象的函数<br></p><p>接下来我们改造一下例子一的函数<br></p><pre><code>let obj = {  value: 20,  fun: function () {    this.value  }}obj.fun() // 20delete obj.funconsole.log(obj) // {value: 20}</code></pre><p>接下来简单的把上面的函数封装一下<br></p><pre><code>Function.prototype.newCall = function (context) {  context.fn = this;  context.fn();  delete context.fn;}// 通过例子一测试let obj = {  value : 20}function fun () {  console.log(this.value)}fun.newCall(obj) // 20</code></pre><h3 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h3><p>第一步的我们只实现了基础。没有考虑参数的情况。call，apply 的基本区别就是在参数上 call 参数数量不确定，apply 只接受两个参数。接下来我们继续优化上面的例子</p><p>1、将函数设为对象的属性用来改变 this 指向<br><br>2、调用对应函数<br><br>3、删除对象的函数<br><br>4、取出不定长的参数放到执行的函数里面<br></p><pre><code>Function.prototype.newCall = function (context, ...args) {  // 如果传入参数 this 为 null，则默认为当前宿主环境  let ec = typeof window === &#39;object&#39; ? window : global;  // 防止方法冲突覆盖  let fn = Symbol();  context = context || ec;  // 改变 this  context[fn] = this;  // 将参数放入函数内  let result = context[fn](...args);  // 删除对象中的函数  delete context[fn];  return result;}// 测试一下let obj = {  value: 1};function bar(name, age) {  console.log(name);  console.log(age);  console.log(this.value);}bar.newCall(obj, &#39;renbo&#39;, 27); </code></pre><p>通过以上 call 的实现我们对apply的实现应该说也清楚了， 上述说过call 和 apply 的区别就在与参数上面，通过ES6实现的方法实际上 call, apply 一样<br></p><h3 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h3><pre><code>Function.prototype.newApply = function (context, args) {  // 如果传入参数 this 为 null，则默认为当前宿主环境  let ec = typeof window === &#39;object&#39; ? window : global;  // 防止方法冲突覆盖  let fn = Symbol();  context = context || ec;  // 改变 this  context[fn] = this;  // 将参数放入函数内  let result = context[fn](...args);  // 删除对象中的函数  delete context[fn];  return result;}// 测试一下let obj = {  value: 1};function bar(name, age) {  console.log(name);  console.log(age);  console.log(this.value);}bar.newApply(obj, [&#39;renbo&#39;, 27]); </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bind 函数的实现</title>
      <link href="/2019/04/21/javascript/bind/"/>
      <url>/2019/04/21/javascript/bind/</url>
      
        <content type="html"><![CDATA[<p>bind 方法其实和 call apply 功能上差不多，只不过 bind() 方法会绑定一个新的函数，通过这个新的函数我们可以当作构造函数、偏函数等等去使用</p><h3 id="作为绑定函数使用"><a href="#作为绑定函数使用" class="headerlink" title="作为绑定函数使用"></a>作为绑定函数使用</h3><p>demo1</p><pre><code>this.value = 20;let obj = {  value: 29,  getValue:function () {    return this.value;  }}// 直接调用 this 指向 objobj.getValue()  // 29// obj.getValue 是一个函数体，在全局作用域中调用，所以 this 指向 windowlet valFun = obj.getValue;valFun(); // 20// 使用 bind 将当前的 this 指针指向 obj 对象上let boundGetValue = valFun.bind(obj);boundGetValue(); // 29</code></pre><p>demo2</p><pre><code>/** * obj.getValue() 返回的是一个匿名函数 * obj.getValue()() 立即执行函数 * 匿名函数上下文执行环境具有全局性，所以 this 通常指向 window */this.value = 20;let obj = {  value: 29,  getValue:function () {    return function () {      return this.value    }.bind(this);  }}obj.getValue()() // 20// 利用bind我们可以使匿名函数的 this 指针指向当前对象（当然还有很多方法比如在匿名函数内增加变量 _this = this）this.value = 20;let obj = {  value: 29,  getValue:function () {    return function () {      return this.value    }.bind(this);  }}obj.getValue()() // 29// 当然要是改变上述 this 指针不只用 bind 可以如下方法(还有很多方法 比如 apply call)this.value = 20;let obj = {  value: 29,  getValue:function () {    let _this = this;    return function () {      return _this.value    }  }}obj.getValue()() // 29</code></pre><h3 id="作为偏函数使用"><a href="#作为偏函数使用" class="headerlink" title="作为偏函数使用"></a>作为偏函数使用</h3><p>使一个函数拥有预设的初始参数，这就是偏函数。比如函数A已经拥有参数或者变量，此时我们通过调用函数A，产生函数B，我们就说B为偏函数</p><p>在这里我们不展开说明偏函数，柯里化一些函数式编程的概念，在 <strong>JS 高级系列</strong> 函数式编程中会有详细介绍</p><pre><code>/** * 插入到目标函数的参数列表的开始位置 * 传递给绑定函数的参数会跟在它们后面 */function list() {  return Array.prototype.slice.call(arguments);}// 偏函数let listArr = list.bind(null, 28);console.log(listArr()); // [28]console.log(listArr(1, 2, 3)); // [28, 1, 2, 3]/** * 多次 bind 无效 只能执行一次 * bind 内部 使用call apply 实现 */function bar () {  console.log(this.value);}let foo = {  value: 1}let foo1 = {  value: 2}let func = bar.bind(foo).bind(foo1);console.log(func()); // 1</code></pre><h3 id="模拟第一步"><a href="#模拟第一步" class="headerlink" title="模拟第一步"></a>模拟第一步</h3><p>通过上面的应用我们实现 bind 有几个条件</p><ul><li>bind 会返回一个新的函数</li><li>可以传递任意参数</li><li>绑定 bind 的函数可以有返回值</li></ul><pre><code>Function.prototype.newBind = function (context) {  var _this = this;  // 获取 bind 的参数，如上面偏函数的例子  var _args = Array.prototype.slice.call(arguments, 1);  // 返回新函数  return function () {    // bind 返回函数传入的参数    var _bindArgs = Array.prototype.slice.call(arguments);    // 合并参数返回    return self.apply(context, _args.concat(_bindArgs));  }}</code></pre><h3 id="模拟第二步"><a href="#模拟第二步" class="headerlink" title="模拟第二步"></a>模拟第二步</h3><p>通过第一步其实我们已经模拟了 bind 的大部分功能，但是在 JS 中也可以把函数当成构造函数来用 可以使用 new 关键字， 这个时候 bind 绑定的函数的 this 就会失效，因为在构造函数中 this 永远指向的是它的实例，关于 new 会在下篇文章中作出解释<br></p><ul><li>通过修改返回的函数的原型，来改变 this 指向问题</li><li>调用 bind 一定是函数，否则提示错误</li></ul><pre><code>Function.prototype.newBind  = function (context) {  // 提示错误信息  if (typeof this != &#39;function&#39;) {    throw new TypeError(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;);  }  var _this = this;  // 获取参数  var _args = Array.prototype.slice.call(arguments, 1);  // 利用空函数来防止修改绑定函数的原型，关于 prototype 请查看 prototype 章节  var _fNOP = function () {};  // bind 返回的新函数  var _fBound = function () {    var _bindArgs = Array.prototype.slice.call(arguments);    // 如果返回的 _fBound 被当做 new 的构造函数调用    return _this.apply(this instanceof _fBound ? this : context, args.concat(_bindArgs));  }  // 让 _fBound 构造的实例继承绑定函数原型中的值，否则会修改绑定函数的原型的值  _fNOP.prototype = this.prototype;  _fBound.prototype = new _fNOP();  return _fBound;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error 异常模块</title>
      <link href="/2019/04/14/node/error/"/>
      <url>/2019/04/14/node/error/</url>
      
        <content type="html"><![CDATA[<p>错误处理是所有应用程序的重要组成部分。要抛出异常，请使用 JavaScript 的 throw  关键字。在 JavaScript 中，通常使用 Error 对象和消息来表示错误<br></p><p><strong>捕获异常try/catch</strong><br></p><pre><code>  function fun () {    throw new Error(&quot;error!&quot;);  }  try {    fun();  } catch (e) {    console.log(e.message);  }</code></pre><p><strong>finally关键字</strong><br></p><p>catch部分只有在抛出错误时才执行。finally部分仍然执行，尽管在try部分中抛出了任何错误<br></p><pre><code>try {   throw new Error(&quot;throw error&quot;); } catch (e) {   console.log(e.message); } finally {   console.log(&quot;不论抛出什么错误，我依然会执行&quot;); } </code></pre>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>process进程</title>
      <link href="/2019/04/12/node/process/"/>
      <url>/2019/04/12/node/process/</url>
      
        <content type="html"><![CDATA[<p>process 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()<br></p><p>上文中提到过事件队列调度可以通过process的.nextTick()来实现<br></p><p>上述文章中说到过 Node 是单进程单线程架构，对多核使用不足，所以启动多进程。每个进程一个 CPU 以此实现多核 CPU 的利用<br></p><p><strong>Master-Worker模式（主从模式）</strong></p><p>主从模式主要用于在分布式架构中并行处理业务的模式，具备良好的可伸缩性和稳定性，主进程（master）负责和管理工作进程（worker），工作进程（worker）负责具体的业务逻辑<br></p><p><img src="/images/master-worker.png"><br></p><pre><code>/** * 创建工作进程 * worker.js */// 引入核心模块httplet http = require(&#39;http&#39;);// 创建服务let server = http.createServer(function (req, res) {  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});  res.end(&#39;Hello World !&#39;)})// 指定域名let domain = &#39;127.0.0.1&#39;;// 随机创建端口let port = Math.round((1 + Math.random()) * 1000);// 监听启动服务server.listen(port, domain)</code></pre><pre><code>/** * 创建主进程 * master.js */// 引入核心模块child_process 创建子进程let childProcess = require(&#39;child_process&#39;);引入核心模块os，得到cpu数量let cpus = require(&#39;os&#39;).cpus();// 根据cpu数量取复制对应的 node 的进程数量for (let i = 0; i &lt; cpus.length; i++) {  childProcess.fork(&#39;./worker.js&#39;)}</code></pre><p><strong>进程间通信</strong><br></p><p>说起进程通信，其实我们都熟悉浏览器的 Javascript 主线程与 UI 渲染，共用一个线程。两个是互斥关系，当 UI 渲染时Js引擎线程暂时挂起。所以为了解决这个问题 HTML5 提出WebWork API 主线程与工作线程之间通过onmessage()和postMessage()进行通讯，使 JS 阻塞较为严重的计算不影响主线程上的UI渲染<br></p><p>在 node 中为了实现父子进程通讯，父子之间将会创建IPC通道，通过IPC通道，父子进程才能通过message和send()传递函数<br></p><p>IPC原理创建实现示意图<br></p><p><img src="/images/ipc.png"><br></p><p>IPC通道创建、连接<br></p><p>1、父进程在实际创建子进程之前，首先创建IPC通道并监听，然后在创建子进程<br><br>2、通过环境变量（NODE_CHAMMEL_FD）通知子进程 IPC 通道的文件描述符<br><br>3、子进程启动过程中通过文件描述符连接已经存在的 IPC 通道<br><br>4、建立连接后就可以在内核中完成双向通信，不经过网络层<br><br>5、在 Node 中，IPC 被抽象成为 Stream 对象，调用 send（）发送数据，通过 message 事件接收数据<br></p><p><img src="/images/ipc-create.png"><br></p><pre><code>/** * 创建父线程 * master.js */// 引入核心模块child_process 创建子进程let childProcess = require(&#39;child_process&#39;);// 复制进程let n = childProcess.fork(__dirname + &#39;/worker.js&#39;);// 监听messagen.on(&#39;messge&#39;, function (m) {  console.log(m)})// 发送数据n.send({hello: &#39;&#39;world});</code></pre><pre><code>/** * 创建子线程 * worker.js */// 监听messageprocess.on(&#39;message&#39;, function (m) {  console.log(m)});// 发送数据process.send({foo: &#39;bar&#39;});</code></pre><p><strong>句柄传递</strong><br></p><p>通过上述我们简单的了解到进程之间通信原理，但是我们想要通过监听一个端口，主进程将所有的请求交由子进程处理，上述通信远远不够的，所以可以通过 <strong>Node句柄传递</strong> 来实现<br></p><p>主进程将请求发送给工作进程<br></p><p><img src="/images/process-send.png"><br></p><p>主进程发送完句柄并关闭监听<br></p><p><img src="/images/process-on.png"><br></p><pre><code>/** * 创建主进程 * master.js */// 引入核心模块child_process 创建子进程let cp = require(&#39;child_process&#39;);// 复制进程let child1 = cp.fork(__dirname + &#39;/worker.js&#39;);let child2 = cp.fork(__dirname + &#39;/worker.js&#39;);// 打开服务使用得服务对象发送数据let server = require(&#39;net&#39;).createServer();server.listen(1337 ,function () {  child1.send(&#39;server&#39;, server);  child2.send(&#39;server&#39;, server);  // 主进程发送完成句柄关闭监听  server.close();});</code></pre><pre><code>/** * 创建子进程 * worker.js */// 引入核心模块httplet http = require(&#39;http&#39;);// 创建服务let server = http.createServer(function (req, res) {  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});  res.end(&#39;pid is&#39; + process.pid)});// 子进程监听端口process.on(&#39;message&#39;, function (m, tcp) {  if (m === &#39;server&#39;) {    tcp.on(&#39;connection&#39;, function (socket) {      server.emit(&#39;connection&#39;, socket);    });  }}};</code></pre><p>通过上述几个例子我们基本基本了解 Node 的进程。当然还有很多需要在事件中摸索例如集群的稳定，包括自动重启，负载均衡，状态共享等等。当然创建 Node 集群也可以用cluster模块，实现起来更轻松方便<br></p><h2 id="更多方法参考"><a href="#更多方法参考" class="headerlink" title="更多方法参考"></a>更多方法参考<br></h2><p><a href="http://nodejs.cn/api/process.html" target="_blank" rel="noopener">Node Api process</a><br><br><a href="http://nodejs.cn/api/child_process.html" target="_blank" rel="noopener">Node Api child_process</a><br><br><a href="http://nodejs.cn/api/cluster.html" target="_blank" rel="noopener">Node Api cluster</a><br></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>event 事件驱动模型</title>
      <link href="/2019/04/10/node/event/"/>
      <url>/2019/04/10/node/event/</url>
      
        <content type="html"><![CDATA[<p>说起node的事件驱动模型首先我们来搞清楚几个概念CPU，线程、进程、调度、事件驱动<br></p><p><strong>CPU</strong><br></p><p>1、CPU 是中央处理器，是计算机的核心<br><br>2、CPU 通过和寄存器，高速缓存，以及内存交互来执行程序<br><br>3、32位 CPU 最多寻址4g内存，而64位 CPU 目前来说没有上限<br></p><p><strong>进程（Process）</strong><br></p><p>1、进程是资源分配最小单位，对于操作系统而言打开一个浏览器就是启动一个浏览器进程，打开 QQ 就是一个 QQ 进程<br><br>2、操作系统为进程开辟一段内存空间，每个进程占用一个进程表项，包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、帐号和调度信息等，cpu根据这些信息配合寄存器进行函数调用和程序执行<br></p><p>3、 CPU利用率=1－pⁿ<br></p><ul><li>一个进程等待I/O操作的时间与其停留在内存中的时间比为p<br></li><li>内存中同时有n个进程<br></li></ul><p><strong>线程（Thread）</strong><br></p><p>线程是程序执行的最小单位，比如打开一个 QQ 进程在里面可以打字，发表情同时和很多人聊天。同时运行多个子任务，这样的子任务就可以成为线程，每一个进程中至少有一个线程。<br></p><p><strong>调度</strong><br></p><p>1、 <em>调度程序（scheduler）</em>-多进程同时竞争CPU时，超过两个的进程处于就绪态，那么单CPU必须选择下一个要运行的进程，完成选择工作的程序称为调度程序（另称CPU调度器）<br><br>2、 <em>CPU分配器（Dispatcher</em>- 决定了将CPU分配给谁，然后分配器将CPU控制权交给该进程<br><br>3、 <em>进程行为</em> - 一般分为I/O和计算（CPU），根据占用时间不同，分为I/O密集型（I/O burst）进程和CPU密集型（CPU burst）进程<br><br>4、 当然调度是一个复杂的操作会有调度算法具体请参考<a href="https://yq.aliyun.com/articles/278727" target="_blank" rel="noopener">阿里云社区博客</a></p><p><strong>计算密集型和IO密集型</strong><br></p><p>1、计算密集型任务的特点是要进行大量的计算，消耗CPU资源，计算密集型任务同时进行的数量应当等于CPU的核心数<br></p><p>2、IO密集型特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用<br></p><p><strong>多进程-多线程</strong><br></p><p>1、多进程模式最大的优点就是稳定性高，因为子进程崩溃，不会影响主进程和其他子进程。著名的Apache最早就是采用多进程模式，多进程模式的缺点是创建进程的代价大<br></p><p>2、多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存，但创建线程相对于进程开销较小，，所以运行速度较比多进程快，并且线程之间可以共享数据。可以有效解决多进程内存浪费问题。但由于每个线程都拥有自己独立的堆栈，需要占用一定的内存空间，而且操作系统内核在切换线程时也要切换线程上下文。所以在大并发量时，多线程结构无法做到强大的伸缩性<br></p><p><strong>异步I/O</strong><br></p><p>1、一个任务在执行的过程中大部分时间都在等待 I/O 操作，单进程单线程模型会导致别的任务无法并行执行<br><br>2、充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种模型称为事件驱动模型<br><br>3、在单核CPU上采用单进程模型可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效<br></p><p><strong>事件驱动模型</strong><br></p><p>1、事件驱动模型是为了解决高并发（如Node，Nginx)<br><br>2、操作系统在调度时较少的切换上下文，没有线程同步等问题<br><br>3、所有处理都在单线程上进行，所以影响性能的点都在 CPU 的计算能力上，由于不受多进程或多线程模式中资源上线的影响，可伸缩性较强<br></p><p><strong>Node事件驱动模型</strong></p><p>1、每一个 I/O 工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用<br></p><p><img src="/master/images/event.png"><br></p><p>2、Node 在启动进程中会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，直到事件队列全部执行完毕，node应用就会终<br><br>3、Node 对于堵塞 I/O 使用线程池来在操作，通过取其中一个子线程线程来执行复杂任务，而不占用主循环线程。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作，这样就防止堵塞 I/O 占用空闲资源，这就是所谓的非阻塞式 I/O<br></p><p><img src="/master/images/event-loop.png"><br></p><p><strong>事件队列调度（通过回调函数将任务添加事件队列中）</strong><br><br>1、内置的事件和事件监听器（http、server的一些事件）<br><br>2、异步堵塞 I/O 库(db处理、fs处理等)<br><br>3、定时器setTimeout、setInterval<br><br>4、全局对象process的.nextTick()API<br><br>5、自定义的事件和监听器<br></p><p><strong>内置事件(举例)</strong><br></p><pre><code>// 引入 events 模块let events = require(&#39;events&#39;);// 创建事件对象let eventEmitter = new events.EventEmitter();// 创建事件处理程序let connectHandler = function connected() {   // 开始触发事件    eventEmitter.emit(&#39;start&#39;);}// 绑定事件处理程序eventEmitter.on(&#39;connection&#39;, connectHandler);eventEmitter.on(&#39;start&#39;, function(){});// 触发事件处理程序eventEmitter.emit(&#39;connection&#39;);console.log(&quot;程序执行完毕。&quot;);</code></pre><p>以上是Node 事件驱动模型的基本概念。在下篇进程文章中会介绍在 Node 中怎样创建多进程架构，也会在<strong>node高级系列-v8与异步I/O</strong>中详细介绍 Node的异步 I/O <br></p><h2 id="更多方法参考"><a href="#更多方法参考" class="headerlink" title="更多方法参考"></a>更多方法参考<br></h2><p><a href="http://nodejs.cn/api/events.html" target="_blank" rel="noopener">Node Api events 事件模块 </a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crypto 加密模块</title>
      <link href="/2019/04/08/node/crypto/"/>
      <url>/2019/04/08/node/crypto/</url>
      
        <content type="html"><![CDATA[<p>crypto 模块也是核心模块之一，提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。上文中提到过核心 C/C++ 模块运行速度比其他模块要快。<br></p><p><strong>MD5和SHA1</strong><br><br>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：<br></p><pre><code>// 引入加密模块const crypto = require(&#39;crypto&#39;);// 创建 Hash 实例const hash = crypto.createHash(&#39;md5&#39;);// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Bufferhash.update(&#39;Hello, nodejs!&#39;);// encoding 值可以是 &#39;hex&#39;, &#39;latin1&#39; 或者 &#39;base64&#39;.   如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.console.log(hash.digest(&#39;hex&#39;));Hash 对象在 hash.digest() 方法调用之后不能再次被使用。多次的调用会引发错误并抛出</code></pre><p><strong>Hmac</strong><br><br>Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：<br></p><pre><code>// 引入加密模块const crypto = require(&#39;crypto&#39;);// 创建 hmac 实例const hmac = crypto.createHmac(&#39;sha256&#39;, &#39;secret-key&#39;);// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Bufferhmac.update(&#39;Hello, nodejs!&#39;);// encoding 值可以是 &#39;hex&#39;, &#39;latin1&#39; 或者 &#39;base64&#39;.   如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.console.log(hmac.digest(&#39;hex&#39;));只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法</code></pre><p><strong>AES</strong><br><br>AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：<br></p><pre><code>// 引入加密模块const crypto = require(&#39;crypto&#39;);// 加密函数function aesEncrypt(data, key) {  const cipher = crypto.createCipher(&#39;aes192&#39;, key);  let crypted = cipher.update(data, &#39;utf8&#39;, &#39;hex&#39;);  crypted += cipher.final(&#39;hex&#39;);  return crypted;}// 解密函数function aesDecrypt(encrypted, key) {  const decipher = crypto.createDecipher(&#39;aes192&#39;, key);  let decrypted = decipher.update(encrypted, &#39;hex&#39;, &#39;utf8&#39;);  decrypted += decipher.final(&#39;utf8&#39;);  return decrypted;}let data = &#39;Hello, this is a secret message!&#39;;let key = &#39;Password!&#39;;let encrypted = aesEncrypt(data, key);let decrypted = aesDecrypt(encrypted, key);console.log(&#39;Plain text: &#39; + data);console.log(&#39;Encrypted text: &#39; + encrypted);console.log(&#39;Decrypted text: &#39; + decrypted);</code></pre><p>运行结果如下：<br></p><pre><code>Plain text: Hello, this is a secret message!Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...Decrypted text: Hello, this is a secret message!</code></pre><p><strong>Diffie-Hellman</strong><br></p><p>DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于离散对数数学原理<br></p><pre><code>// 引入加密模块const crypto = require(&#39;crypto&#39;);// 进行加密交换 crypto_alet crypto_a = crypto.createDiffieHellman(512);let crypto_a_keys = crypto_a.generateKeys();let prime = crypto_a.getPrime();let generator = crypto_a.getGenerator();console.log(&#39;Prime: &#39; + prime.toString(&#39;hex&#39;));console.log(&#39;Generator: &#39; + generator.toString(&#39;hex&#39;));// 进行加密交换 crypto_blet crypto_b = crypto.createDiffieHellman(prime, generator);let crypto_b_keys = crypto_b.generateKeys();// 交换生成密钥let a_secret = crypto_a.computeSecret(crypto_b_keys);let b_secret = crypto_b.computeSecret(crypto_a_keys);</code></pre><p><strong>RSA</strong></p><p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密<br></p><p>1、生成一个RSA密钥对：<br></p><pre><code>openssl genrsa -aes256 -out rsa-key.pem 2048</code></pre><p>2、通过上面的rsa-key.pem加密文件，导出原始的私钥<br></p><pre><code>openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem</code></pre><p>3、命令导出原始的公钥<br></p><pre><code>openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM</code></pre><p>使用crypto模块提供的方法，即可实现非对称加解密<br></p><pre><code>const fs = require(&#39;fs&#39;);const crypto = require(&#39;crypto&#39;);// 从文件加载key:function loadKey(file) {  // key实际上就是PEM编码的字符串:  return fs.readFileSync(file, &#39;utf8&#39;);}let prvKey = loadKey(&#39;./rsa-prv.pem&#39;);let pubKey = loadKey(&#39;./rsa-pub.pem&#39;);let message = &#39;Hello, world!&#39;;// 使用私钥加密:let enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, &#39;utf8&#39;));console.log(&#39;encrypted by private key: &#39; + enc_by_prv.toString(&#39;hex&#39;));let dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);console.log(&#39;decrypted by public key: &#39; + dec_by_pub.toString(&#39;utf8&#39;));执行后，可以得到解密后的消息，与原始消息相同。接下来我们使用公钥加密，私钥解密：// 使用公钥加密:let enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, &#39;utf8&#39;));console.log(&#39;encrypted by public key: &#39; + enc_by_pub.toString(&#39;hex&#39;));// 使用私钥解密:let dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);console.log(&#39;decrypted by private key: &#39; + dec_by_prv.toString(&#39;utf8&#39;));执行得到的解密后的消息仍与原始消息相同。</code></pre><p><strong>证书</strong><br>crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。<br></p><h2 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考<br></h2><p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000" target="_blank" rel="noopener">廖雪峰老师的Crypto</a></p><p><a href="http://nodejs.cn/api/crypto.html" target="_blank" rel="noopener">Node Api crypto 加密模块 </a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module 模块机制</title>
      <link href="/2019/04/05/node/module/"/>
      <url>/2019/04/05/node/module/</url>
      
        <content type="html"><![CDATA[<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。前端模块化组件化也是在这几年逐渐的流行，在 web2.0 发展过程如下<br></p><p><image src="/master/images/module.png" width="300"></image><br></p><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范<br></h3><p>CommonJS（<a href="http://www.commonjs.org" target="_blank" rel="noopener">http://www.commonjs.org</a>）规范的出现解决了JavaScript 没有模块系统，标准库等等问题，而 Node.js 自身实现了 require 作为其引入模块的方法，同时 NPM 也基于 CommonJS 定义的包规范，实现了依赖管理和模块自动安装等功能。下图展现Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系<br></p><p><image src="/master/images/commonjs.png" width="550"></image><br></p><h3 id="CommonJS-模块"><a href="#CommonJS-模块" class="headerlink" title="CommonJS 模块"></a>CommonJS 模块</h3><p>1、模块引用 require 关键字 <br></p><pre><code>const math = require(&#39;math&#39;); </code></pre><p>2、模块定义导出 exports 关键字<br></p><pre><code>exports.area = function (r) {    return Math.PI * r * r;};</code></pre><p>3、模块标识<br><br>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径，每个模块都有独立的空间。防止虑变量污染。<br></p><h3 id="Node-模块实现"><a href="#Node-模块实现" class="headerlink" title="Node 模块实现"></a>Node 模块实现<br></h3><p>1、引入模块三个步骤(分为核心模块和文件模块)<br></p><pre><code>(1) 路径分析(2) 文件定位(3) 编译执行</code></pre><p>核心模块和文件模块的区别在于加载的时机，核心模块在 Node 进程启动时被直接加载到内存中比文件模块省略了文件定位和编译执行过程<br></p><h3 id="Node-模块载入策略"><a href="#Node-模块载入策略" class="headerlink" title="Node 模块载入策略"></a>Node 模块载入策略<br></h3><p>1、不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先，以减少二次引入时的开销<br><br>2、模块引用的过程由于标识符不同在路径分析和文件定位中有一定的差异<br></p><pre><code>// 路径分析核心模块，如http、fs、path等(加载最快).或..开始的相对路径文件模块(慢于核心模块)以/开始的绝对路径文件模块(慢于核心模块)自定义模块（最慢-由于沿路径向上逐级递归，直到根目录下的node_modules目录，层级越多越耗时// 文件定位由于其扩展名不同 Node 会按 .js、.json、.node 的次序补、足扩展名，依次尝试调用fs模块同步阻塞式地判断文件是否存在如果文件不是 .js 可以在加载的时候写上文件的扩展名，可以加快文件定位速度，配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷</code></pre><p>3、模块编译</p><pre><code>function Module(id, parent) {  this.id = id;  this.exports = {};  this.parent = parent;  if (parent &amp;&amp; parent.children) {    parent.children.push(this);  }  this.filename = null;  this.loaded = false;  this.children = [];} 对于不同的文件扩展名，其载入方法也有所不同.js 文件  通过fs模块同步读取文件后编译执行。在编译过程中进行了头尾包装。在头部添加了  (function (exports, require, module, __filename, __dirname) {    \n，在尾部添加了\n  });。  通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的  function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），  以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。.node 文件。用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。  Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows  和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装.json 文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。其余扩展名文件。它们都被当做.js文件载入。每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</code></pre><h3 id="Node-核心模块的编译、引入、加载过程"><a href="#Node-核心模块的编译、引入、加载过程" class="headerlink" title="Node 核心模块的编译、引入、加载过程"></a>Node 核心模块的编译、引入、加载过程<br></h3><p><strong>模块调用栈</strong><br></p><p>1、C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。<br><br>2、JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要<br></p><p><image src="/master/images/module-p.png" width="350"></image><br></p><p><strong>核心模块调用流程</strong><br></p><p>1、 JavaScript 核心模块编译过程<br></p><ul><li><p>转存为转存为C/C++代码（Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，生成node_natives.h头文件，以字符串的形式存储在 node 的命令空间中）<br></p></li><li><p>启动 node 进程 JavaScript 代码直接加载进内存中<br></p></li><li><p>编译 JavaScript 核心模块（lib目录下的所有模块文件也没有定义require、module、exports这些变量。上面说过在引入 JavaScript 核心模块过程进行头尾包装，才可以执行exports对象）<br></p><pre><code>// node_natives.h 头文件代码namespace node {const char node_native[] = { 47, 47, ..};const char dgram_native[] = { 47, 47, ..};const char console_native[] = { 47, 47, ..};const char buffer_native[] = { 47, 47, ..};const char querystring_native[] = { 47, 47, ..};const char punycode_native[] = { 47, 42, ..};...struct _native {  const char* name;  const char* source;  size_t source_len;};static const struct _native natives[] = {  { &quot;node&quot;, node_native, sizeof(node_native)-1 },  { &quot;dgram&quot;, dgram_native, sizeof(dgram_native)-1 },  ...};}// JavaScript 核心模块通过process.binding(&#39;natives&#39;)取出，编译成功的模块缓存到 NativeModule._cache 对象上，文件模块则缓存到 Module._cache 对象上function NativeModule(id) {this.filename = id + &#39;.js&#39;;this.id = id;this.exports = {};this.loaded = false;}NativeModule._source = process.binding(&#39;natives&#39;);NativeModule._cache = {}; </code></pre></li></ul><p>2、 C/C++核心模块的编译过程<br></p><ul><li><p>定义内建模块内部结构</p></li><li><p>通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br></p></li><li><p>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中<br></p></li><li><p>Node 通过 get_builtin_module() 方法从 node_module_list 数组中取出这些模块<br></p><pre><code>// 内建模块的内部结构定义struct node_module_struct {int version;void *dso_handle;const char *filename;void (*register_func) (v8::Handle&lt;v8::Object&gt; target);const char *modname;};// 挂载为结构的register_func成员#define NODE_MODULE(modname, regfunc) extern &quot;C&quot; {  NODE_MODULE_EXPORT node::node_module_struct modname ## _module =  {    NODE_STANDARD_MODULE_STUFF,    regfunc,    NODE_STRINGIFY(modname)  }; } </code></pre></li></ul><p>3、核心模块的引入流程<br><br>如 os 原生模块的引入流程<br><br><image src="/master/images/module-os.png" width="350"></image><br></p><p>通过以上我们大致了解了 Node 中模块的编译、加载、引入流程。当然还有核心模块的编写，在这里就不过多的阐述了。更多请参考朴灵老师编著的《深入浅出 node》，相信会有更多的收获。<br></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>querystring 路径操作</title>
      <link href="/2019/04/04/node/querystring/"/>
      <url>/2019/04/04/node/querystring/</url>
      
        <content type="html"><![CDATA[<p>querystring 模块提供用于解析和格式化 URL 查询字符串<br></p><h3 id="解析-URL-字符串-querystring-parse-str-sep-eq-options"><a href="#解析-URL-字符串-querystring-parse-str-sep-eq-options" class="headerlink" title="解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) "></a>解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) <br></h3><pre><code>// 引入模块const querystring = require(&#39;querystring&#39;);querystring.parse(&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;)输出为：{  foo: &#39;bar&#39;,  abc: [&#39;xyz&#39;, &#39;123&#39;]}</code></pre><p>默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项：<br></p><pre><code>// 假设 gbkEncodeURIComponent 函数已存在。querystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null,{ decodeURIComponent: gbkDecodeURIComponent });</code></pre><h3 id="序列化-URL-字符串-querystring-stringify-obj-sep-eq-options"><a href="#序列化-URL-字符串-querystring-stringify-obj-sep-eq-options" class="headerlink" title="序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) "></a>序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) <br></h3><pre><code>// 引入模块const querystring = require(&#39;querystring&#39;);// 输出为 &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;querystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; });// 输出为 &#39;foo:bar;baz:qux&#39;querystring.stringify({ foo: &#39;bar&#39;, baz: &#39;qux&#39; }, &#39;;&#39;, &#39;:&#39;);</code></pre><p>默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项：</p><pre><code>// 假设 gbkEncodeURIComponent 函数已存在。querystring.stringify({ w: &#39;中文&#39;, foo: &#39;bar&#39; }, null, null,{ encodeURIComponent: gbkEncodeURIComponent })</code></pre><p><a href="https://nodejs.org/docs/latest-v9.x/api/querystring.html" target="_blank" rel="noopener">其他方法请参考 Node Api </a><br></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>path 路径操作</title>
      <link href="/2019/04/02/node/path/"/>
      <url>/2019/04/02/node/path/</url>
      
        <content type="html"><![CDATA[<p>path 模块提供用于处理文件路径和目录路径的实用工具<br></p><h3 id="path使用特点"><a href="#path使用特点" class="headerlink" title="path使用特点"></a>path使用特点</h3><p>path 模块的默认操作因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， path 模块将假定正在使用 Windows 风格的路径。<br></p><h3 id="获取路径-path-dirname-p"><a href="#获取路径-path-dirname-p" class="headerlink" title="获取路径    path.dirname(p) "></a>获取路径    path.dirname(p) <br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);// 输出 /demo/js/test.jsconsole.log(path.dirname(&#39;/demo/js/test.js&#39;));</code></pre><h3 id="获取文件名-path-basename-p"><a href="#获取文件名-path-basename-p" class="headerlink" title="获取文件名 path.basename(p) "></a>获取文件名 path.basename(p) <br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);/ 输出：test.jsconsole.log( path.basename(&#39;/demo/js/test.js&#39;) );// 输出：testconsole.log( path.basename(&#39;/demo/js/test/&#39;) );// 输出：testconsole.log( path.basename(&#39;/demo/js/test&#39;) );</code></pre><h3 id="获取文件扩展名-path-extname-p"><a href="#获取文件扩展名-path-extname-p" class="headerlink" title="获取文件扩展名 path.extname(p) "></a>获取文件扩展名 path.extname(p) <br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);// 输出 .jsconsole.log(path.extname(&#39;/demo/js/test.js&#39;));</code></pre><h3 id="拼接文件路径-path-join-…paths"><a href="#拼接文件路径-path-join-…paths" class="headerlink" title="拼接文件路径 path.join([…paths])"></a>拼接文件路径 path.join([…paths])<br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);// /demo/js/test.jsconsole.log(path.join(&#39;/demo&#39;, &#39;js&#39;, &#39;test.js&#39;));</code></pre><h3 id="获取的绝对路径-文件名-path-reslove-from-…-to"><a href="#获取的绝对路径-文件名-path-reslove-from-…-to" class="headerlink" title="获取的绝对路径/文件名 path.reslove([from …], to)"></a>获取的绝对路径/文件名 path.reslove([from …], to)<br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);// 输出当前项目的绝对路径console.log(path.reslove(&#39;&#39;));// 输出当前项目的绝对路径console.log(path.reslove(&#39;.&#39;));// 输出 /foo/bar/bazconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;) );// 输出 /baz/fileconsole.log(path.resolve(&#39;/foo/bar&#39;, &#39;/baz/file/&#39;);)</code></pre><h3 id="获取路径字符串的对象-path-parse-p"><a href="#获取路径字符串的对象-path-parse-p" class="headerlink" title="获取路径字符串的对象 path.parse(p)"></a>获取路径字符串的对象 path.parse(p)<br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);path.parse(&#39;/home/user/dir/file.txt&#39;);// 返回:// { root: &#39;/&#39;,//   dir: &#39;/home/user/dir&#39;,//   base: &#39;file.txt&#39;,//   ext: &#39;.txt&#39;,//   name: &#39;file&#39; }</code></pre><h3 id="获取规范化路径-path-normalize-p"><a href="#获取规范化路径-path-normalize-p" class="headerlink" title="获取规范化路径 path.normalize(p)"></a>获取规范化路径 path.normalize(p)<br></h3><pre><code>// 引入 path 模块const path = require(&#39;path&#39;);// 输出 &#39;/foo/bar/baz/asdf&#39;path.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;);</code></pre><p><a href="https://nodejs.org/docs/latest-v9.x/api/path.html" target="_blank" rel="noopener">其他方法请参考 Node Api </a><br></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fs 文件操作</title>
      <link href="/2019/04/01/node/fs/"/>
      <url>/2019/04/01/node/fs/</url>
      
        <content type="html"><![CDATA[<p>在 node 中文件交互是非常重要的，例如文件的打开、读取、写入文件、以及与其交互等等，这其中围绕着异步模式和同步模式读取的话题。下面就 node 的 fs 文件操作模举例说明<br></p><h3 id="fs使用特点"><a href="#fs使用特点" class="headerlink" title="fs使用特点"></a>fs使用特点</h3><p>1、同步的版本将阻塞整个进程，直到它们完成（停止所有连接）<br><br>2、异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回，但是无法保证操作的的正确性和有效的顺序<br></p><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入<br></h3><ol><li>异步文件写入<br></li></ol><pre><code>// 引入 fs 模块const fs = require(&#39;fs&#39;);/** * @description * 异步打开文件操作 fs.open * 异步写入文件操作 fs.writeFile * 异步关闭文件操作 fs.close */fs.open(&#39;file.txt&#39;, &#39;a&#39;, (err, fd)=&gt;{  if (err) throw err;  fs.writeFile(fd, &quot;node是很有意思的语言！&quot;, (err)=&gt;{    if (err) throw err;    console.log(&#39;写入文件成功&#39;)    fs.close(fd, (err)=&gt;{      if (err) throw err;      console.log(&#39;文件以保存并关闭&#39;)    })  })})</code></pre><ol start="2"><li>同步写入方式<br><pre><code>// 引入模块 const fs = require(&#39;fs&#39;);</code></pre></li></ol><p>// 打开文件 同步<br>var fd=fs.openSync(‘file.txt’, ‘w’);</p><p>// 写入内容<br>fs.writeFileSync(fd,”node是很有意思的语言!”); </p><p>// 保存并关闭<br>fs.closeSync(fd);</p><pre><code>### 读写操作&lt;br/&gt;1. 文件读写操作&lt;br/&gt;</code></pre><p>// 引入模块<br>const fs = require(‘fs’);</p><p>/**</p><ul><li>@description</li><li>异步读取文件 fs.readFile</li><li>/<br>fs.readFile(‘source/file.txt’,’utf8’,(err,data)=&gt;{<br>if (err) throw err;<br>console.log(data); //data 默认读取的是二进制 使用toString() 方法转换成<br>})<pre><code></code></pre></li></ul><ol start="2"><li>图片读写操作<br></li></ol><pre><code>// 引入模块const fs = require(&#39;fs&#39;);/** * @description * 异步读取文件 fs.readFile * 异步写入文件 fs.writeFile */fs.readFile(&quot;source/a.jpg&quot;,(err,data) =&gt; {  if (err) throw err;  // 文件写入  fs.writeFile(&#39;b.jpg&#39;, data, (err) =&gt; {    if (err) throw err;    console.log(&#39;写入成功！&#39;)  })});</code></pre><ol start="3"><li>视频读写操作<br></li></ol><pre><code>// 引入模块let fs= require(&#39;fs&#39;);/** * @description * 异步读取文件 fs.readFile * 异步写入文件 fs.writeFile * 创建文件读取流 fs.createReadStream * 创建文件写入流 fs.createWriteStream * 创建管道 fileStream.pipe * fs.readFile() 函数会缓冲整个文件。  * 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。 */// 方式一fs.readFile(&#39;source/a.mp4&#39;, (err, data) =&gt; {  if (err) throw err;  // 文件写入  fs.writeFile(&#39;b.mp4&#39;, data, (err) =&gt; {    if (err) throw err;    console.log(&#39;写入成功！&#39;);  });});// 方式二let rs = fs.createReadStream(&#39;source/a.mp4&#39;);let ws = fs.createWriteStream(&#39;new.mp4&#39;);re.pipe(ws);</code></pre><ol start="4"><li>使用同步文件流写入操作<br><pre><code>// 引入模块let fs= require(&#39;fs&#39;);</code></pre></li></ol><p>// 建立通道<br>let ws = fs.createWriteStream(‘file.txt’)</p><p>// 打开通道<br>ws.once(‘open’, () =&gt; {<br>    console.log(‘通道打开’);<br>})</p><p>ws.once(‘close’, () =&gt; {<br>    console.log(‘通道关闭’);<br>})</p><p>// 写入内容<br>ws.write(‘node开始’);<br>ws.write(‘node1’);<br>ws.write(‘node2’);<br>ws.write(‘node结束’);</p><pre><code>&lt;a href=&quot;https://nodejs.org/docs/latest-v9.x/api/fs.html&quot;&gt;其他方法请参考 Node Api &lt;/a&gt;&lt;br/&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>url</title>
      <link href="/2019/03/28/node/url/"/>
      <url>/2019/03/28/node/url/</url>
      
        <content type="html"><![CDATA[<p>url模块提供用于URL解析和解析的实用程序<br></p><pre><code>const url = require(&#39;url&#39;);</code></pre><p>获取并设置URL的片段部分<strong>url.hash</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org/foo#bar&#39;);console.log(myURL.hash); //#barmyURL.hash = &#39;baz&#39;;console.log(myURL.href); //https://example.org/foo#baz</code></pre><p>获取并设置URL的主机部分<strong>url.host</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org:81/foo&#39;);console.log(myURL.host);  //example.org:81console.log(myURL.hostname) //example.org</code></pre><p>获取并设置序列化url<strong>url.href</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org:81/foo&#39;);console.log(myURL.href);  //https://example.org:81/foo</code></pre><p>获取并设置URL的路径部分<strong>url.pathname</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);console.log(myURL.pathname);  // /foo/abc</code></pre><p>获取并设置URL的端口部分<strong>url.port  0到65535</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);console.log(myURL.port);  // 81</code></pre><p>获取并设置URL的序列化查询部分<strong>url.search</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);console.log(myURL.search);  // name=123</code></pre><p>获取URLSearchParams表示URL的查询参数的对象<strong>url.serchParams</strong><br></p><pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);console.log(myURL.searchParams);  // 123</code></pre><p><a href="https://nodejs.org/api/url.html" target="_blank" rel="noopener">更多方法请参考 Node Api </a><br></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp udp http</title>
      <link href="/2019/03/23/node/http/"/>
      <url>/2019/03/23/node/http/</url>
      
        <content type="html"><![CDATA[<h3 id="构建TCP服务"><a href="#构建TCP服务" class="headerlink" title="构建TCP服务"></a>构建TCP服务<br></h3><p> tcp全名为传输控制协议，在OSI模型中属于传输层协议如下图<br><br> &lt;image src=/images/tcp.png’ width=”300px”&gt;<br></p><p> tcp是面向连接的协议，特点是在传输之前需要3次握手形成会话如下图<br><br> &lt;image src=/images/ack.png’ width=”300px”&gt;<br></p><p>  第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认<br><br>  第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br><br>  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br></p><p>  当然tcp也会有四次挥手，在这里就不具体说明了<br></p><h3 id="创建TCP服务端"><a href="#创建TCP服务端" class="headerlink" title="创建TCP服务端"></a>创建TCP服务端<br></h3><p>1、创建TCP服务端接受网络请求<br><br>1.1服务器事件<br></p><pre><code>var net = require(&#39;net&#39;);var server = net.createServer(function(socket) {  // 开始新连接  socket.on(&#39;data&#39;, function(data) {    socket.write(&#39;hello&#39;);  })  // 断开连接  socket.on(&#39;end&#39;, function() {    console.log(&#39;断开连接&#39;);  }) })server.listen(8124, function() {  console.log(&#39;server start listen port 8124 !&#39;);});</code></pre><p>通过上面代码创建为服务器事件，它是一个<strong>EventEmitter</strong>实例，自定义事件有一下几种<br></p><ul><li>listening 绑定的端口</li><li>connection 连接到服务器时出发此事件</li><li>close 服务器关闭时触发</li><li>error 服务器发生异常时触发<br></li></ul><p>1.2连接事件<br></p><pre><code>var net = require(&#39;net&#39;);var client = net.connect({ port: 8124 }, function () {  console.log(&#39;client connected !&#39;);  client.write(&#39;hello&#39;);})client.on(&#39;data&#39;, function (data) {  conosle.log(data);  client.end();})client.on(&#39;end&#39;, function () {  console.log(&#39;此连接结束&#39;);})</code></pre><p>通过上面代码创建连接事件，服务器可以同时与多个客户端保持连接，对于每个连接其实都是<strong>Stream</strong>对象，它用于服务器端和客户端之间的通讯，自定义事件如下<br></p><ul><li>data 当一端调用write()发送数据时，另一端会触发data，事件传递的数据是write()发送的数据</li><li>end 当连接中的任意一端发送<strong>FIN</strong> 数据时，触发此事件</li><li>drain 当一端调用write()发送数据时，触发此事件</li><li>close 当所有连接完全关闭时触发</li><li>error 服务器发生异常时触发</li><li>timeout 连接超时时触发</li></ul><p><strong>node中 TCP默认开启Nagle算法（优化网络数据包）此算法由于要求缓冲数据达到一定数量或一定时间后才发送，所以可能会造成延迟发送</strong></p><h3 id="构建UDP服务"><a href="#构建UDP服务" class="headerlink" title="构建UDP服务"></a>构建UDP服务<br></h3><p>UDP用户数据包协议，和TCP一样属于网络传输层<br></p><h3 id="创建UDP服务端"><a href="#创建UDP服务端" class="headerlink" title="创建UDP服务端"></a>创建UDP服务端<br></h3><pre><code>var dgram = require(&#39;dgram&#39;);// 创建server对象var server  = dgram.createSocket(&#39;udp4&#39;);// 接到消息时，触发该事件，携带的数据为消息buffer和远程地址信息对象server.on(&#39;message&#39; function (msg, rinfo) {  console.log(msg)  console.log(rinfo)});// 绑定端口之后启动监听时间server.on(&#39;listening&#39;, function () {  var address = server.address();  console.log(address);});// 绑定端口server.bind(41234);</code></pre><h3 id="创建UDP客户端"><a href="#创建UDP客户端" class="headerlink" title="创建UDP客户端"></a>创建UDP客户端<br></h3><pre><code>var dgram = require(&#39;dgram&#39;);var message = new Buffer(&#39;hello&#39;);var client = dgram.createSocket(&#39;udp4&#39;);client.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) {  client.close();})</code></pre><h3 id="构建HTTP服务"><a href="#构建HTTP服务" class="headerlink" title="构建HTTP服务"></a>构建HTTP服务<br></h3><p>HTTP是超文本传输协议，是构建在TCP之上的，属于应用层协议，在HTTP的两端是服务端和浏览器也就是B/S模式<br></p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文<br></h3><p>我们可以在命令行利用curl -v <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 来模拟请求，产生如下报文信息<br></p><p>第一部分其实就是标准的TCP3次握手过程<br></p><pre><code>* About to connect() to localhost (127.0.0.1) port 8080 (#0)*   Trying 127.0.0.1...* TCP_NODELAY set* Connected to localhost (127.0.0.1) port 8080 (#0)</code></pre><p>第二部分在握手完成之后，客户端向服务端发送的请求报文<br></p><pre><code>&gt; GET / HTTP/1.1&gt; Host: 127.0.0.1:8080&gt; User-Agent: curl/7.54.0&gt; Accept: */*&gt;</code></pre><p>第三部分是服务端处理结束后，向客户端发送的响应内容包括响应头和响应体<br></p><pre><code>&lt; HTTP/1.1 200 OK&lt; X-Powered-By: Express&lt; Accept-Ranges: bytes&lt; Content-Type: text/html; charset=UTF-8&lt; Content-Length: 820&lt; ETag: W/&quot;334-dKswJvgc24O5QPXd939SLJD+BhM&quot;&lt; Date: Thu, 11 Apr 2019 10:33:03 GMT&lt; Connection: keep-alive&lt;hello</code></pre><p>第四部分是结束此会话<br></p><pre><code>* Connection #0 to host 127.0.0.1 left intact* Closing connection #0</code></pre><p>通过上面的信息中我们可以看出虽然是基于 TCP，但是本身确实基于请求响应式的，一问一答模式并不是会话模式。<br></p><h3 id="HTTP模块"><a href="#HTTP模块" class="headerlink" title="HTTP模块"></a>HTTP模块<br></h3><p>node http 模块承继 tcp 服务器（ net 模块）它能够与多个客户端保持连接，采用事件驱动，不会为每个连接创建额外的线程或进程。占用内存低，所以能实现高并发，tcp 服务以connection进行服务，http以request进行服务。node http 模块将connection和request进行封装<br><br>&lt;image src=/images/request.png’ width=”400px”&gt;<br></p><p>http模块将所有读写抽象为ServerRequest和ServerResponse对象<br><br>&lt;image src=/images/http.png’ width=”400px”&gt;<br></p><pre><code>function (req, res) {  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});  res.end(&#39;Hello Word&#39;);}</code></pre><h3 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理<br></h3><p>http 提供的 ClientRequest 是基于 tcp 层实现的，在keepalive情况下，一个底层会话能够连接多个请求。<br><br>http 模块包含一个默认的客户端代理对象http.globalAgent<br><br>通过 ClientRequest 对象对用一个服务器发起的 http 最多可以创建5个连接，实际上是一个连接池。如果 http 客户端同时对一个服务器发起超过5个请求，其实也只有5个处于并发状态。<br><br>&lt;image src=/images/http代理.png’ width=”400px”&gt;<br></p><pre><code>// 可以通过http.Agent修改连接数量，但连接数量过大会影响服务器性能var agent = new http.Agent({  maxSockets: 10})var option = {  hostname: &#39;127.0.0.1&#39;,  port: 1334,  path: &#39;/&#39;,  method: &#39;GET&#39;,  agent: agent}</code></pre><h3 id="构建-WebSocket-服务"><a href="#构建-WebSocket-服务" class="headerlink" title="构建 WebSocket 服务"></a>构建 WebSocket 服务<br></h3><p>Websocket 协议解决了服务器与客户端全双工通信的问题,也就是客户端和服务端之间的长连接<br></p><h3 id="WebSocket协议解析"><a href="#WebSocket协议解析" class="headerlink" title="WebSocket协议解析"></a>WebSocket协议解析<br></h3><p>WebSocket协议主要分为两个部分第一部分 http <strong>握手</strong>连接，第二部分协议升级为 WebSocket 进行<strong>数据传输</strong><br><br>&lt;image src=/images/websocket.png’ width=”400px”&gt;<br></p><h3 id="TCP-UDP-HTTP-WebSocket区别"><a href="#TCP-UDP-HTTP-WebSocket区别" class="headerlink" title="TCP UDP HTTP WebSocket区别"></a>TCP UDP HTTP WebSocket区别</h3><ol><li>TCP UDP HTTP WebSocket都是协议，而TCP/IP是不同协议的组合 <br></li><li>Socket的本质是API，只不过是对TCP/IP协议族的抽象或者说封装<br></li><li>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议<br></li></ol><p><strong>1.TCP和UDP</strong><br></p><p>TCP是面向连接的传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至<br><br>UDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至<br></p><p><strong>2.HTTP</strong><br></p><p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。<br>而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作<br></p><p><strong>3.WebSocket</strong><br></p><p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化<br></p><p><strong>4.HTTP、WebSocket与TCP的关系</strong><br></p><p>HTTP通信过程是客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯<br><br>HTTP和WebSocket虽都是基于TCP协议<br></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作数组API方法</title>
      <link href="/2019/03/20/javascript/api/"/>
      <url>/2019/03/20/javascript/api/</url>
      
        <content type="html"><![CDATA[<h3 id="Array对象的作用"><a href="#Array对象的作用" class="headerlink" title="Array对象的作用"></a>Array对象的作用</h3><p>Array 对象用于在单个的变量中存储多个值</p><h3 id="创建Array对象的方法"><a href="#创建Array对象的方法" class="headerlink" title="创建Array对象的方法"></a>创建Array对象的方法</h3><p><code>var arrayObj = new Array()；</code><br><br><code>var arrayObj = []; //本人习惯用这种</code><br><br>返回值：返回新创建并被初始化了的数组。如果调用arrayObj时没有参数或者没有指定 值，那么返回的值为空，数组的length为0。<br></p><h3 id="Array对象的三个属性"><a href="#Array对象的三个属性" class="headerlink" title="Array对象的三个属性"></a>Array对象的三个属性</h3><p><code>constructor</code> //返回数组函数的引用。<br><br><code>length</code> //返回数组元素的长度（最常用）<br><br><code>prototype</code> //可以向数组对象添加属性和方法。<br></p><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>该方法用于连接或者合并数组，并且不会改变原数组，返回一个新数组的副本</p><pre><code>var arrObj = [1,2,3,4];var arrObj1 = [5,6,7,8];arrObj.concat(arrObj1); //[1,2,3,4,5,6,7,8]</code></pre><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>该方法用于把数组中的所有元素用指定的分隔符分割，返回一个字符串</p><pre><code>newArray.join() //&quot;1,2,3,4,5,6,7,8&quot;</code></pre><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p>该方法用于删除并返回数组的最后一个元素,并将原数组的length -1</p><pre><code>arrObj.pop()//4console.log(arrObj); //[1,2,3]</code></pre><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><p>该方法可向数组的末尾添加一个或多个元素，并返回新的长度</p><pre><code>arrObj.push(4);console.log(arrObj); //[1,2,3,4]</code></pre><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><p>该方法用于删除并返回数组的第一个元素,并将原数组的length -1</p><pre><code>arrObj.shift() //1console.log(arrObj) //[2,3,4]</code></pre><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>该方法可向数组的开头添加一个或多个元素，并返回新的长度</p><pre><code>arrObj.unshift(1);console.log(arrObj); //[1,2,3,4]</code></pre><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>该方法可从已有的数组中返回选定的元素,形成一个新的数组</p><pre><code>arrObj.slice(1,2); //[2]console.log(arrObj) //[1,2,3,4]</code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>该法向数组中添加/删除元素，然后返回被删除的元素。该方法会改变原数组</p><pre><code>arrObj.splice(1,2,5); //[2,3]console.log(arrObj); //[1,5,4]</code></pre><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>该方法用于颠倒数组中元素的顺序，并且改变原来的数组，而不会创建新的数组</p><pre><code>arrObj.reverse(); //[4,5,1]</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>该方法用于对数组的元素进行排序</p><p>注意：该方法是按照字符编码顺序进行排序，如果想要实现业务逻辑排序需要自定义比较函数</p><pre><code>var arrObjSort = [1,5,4,2,3];var arrObjSort1 = [1,2,10,3,20,4,30,50,5];arrObjSort.sort(); //[1,2,3,4,5]arrObjSort1.sort(); //[1, 10, 2, 20, 3, 30, 4, 5, 50]</code></pre><p>自定义排序</p><pre><code>function __sortNumber(a,b){   return a-b;}arrObjSort1.sort(__sortNumber); //[1, 2, 3, 4, 5, 10, 20, 30, 50]</code></pre><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>该方法可把数组转换为字符串，并返回结果，与不带参数的join相同</p><pre><code>arrObjSort1.toString(); //&quot;1,2,3,4,5,10,20,30,50&quot;</code></pre><p>toLocaleString-该方法可数组转换为本地字符串。和toString基本相同，但toLocaleString调用的是地区特定的分隔符把生成的字符串连接起来。<br></p><p>如果你开发的脚本在世界范围都有人使用,那么将对象转换成字符串时请使用toString()方法<br></p><p>因为LocaleString()会根据你机器的本地环境来返回字符串,它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化<br></p><p>如果是为了返回时间类型的数据,推荐使用LocaleString().若是在后台处理字符串,请务必使用toString()<br></p><pre><code>var date = new Date();var myArr = [date,&#39;go home&#39;];myArr.toLocaleString(); //&quot;2017/11/7 下午4:35:43,go home&quot;myArr.toString(); //&quot;Tue Nov 07 2017 16:36:25 GMT+0800 (CST),go home&quot;</code></pre><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>该方法可确定某个元素在数组实例中第一次出现的索引位置。如果没找到返回-1,可用索引值进行逻辑判断</p><pre><code>var arr = [1,2,3,4,5];arr.indexOf(2);  //1arr.indexOf(2,1); //1arr.indexOf(2,2); //-1arr.indexOf(6);  //-1</code></pre><p>查找元素出现的位置索引<br></p><pre><code>var indices = [];var arr = [1,2,3,2,5,2,7];var index = arr.indexOf(2);while(index != -1){  indices.push(index);  index = arr.indexOf(2,index + 1);}console.log(indices)</code></pre><p>判断一个元素是否在数组里，不在则向数组中添加元素<br></p><pre><code>var arr = [1,2,3,4,5,6,7];function __upDataCollection(arrCollection,indicesEle){  var matchIndex =  arrCollection.indexOf(indicesEle);  if(matchIndex === -1){     arr.push(indicesEle);          }else{    console.log(&#39;元素中存在相同的值&#39;);  }}__upDataCollection(arr,8); //[1, 2, 3, 4, 5, 6, 7, 8]__upDataCollection(arr,2); //&#39;元素中存在相同的值&#39;</code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>该方法按升序为数组中含有效值的每一项执行一次callback 函数（遍历数组）</p><p><code>forEach()</code> 为每个数组元素执行callback函数；不像<code>map()</code> 或者<code>reduce()</code> ，它总是返回 <code>undefined</code>值，也没有办法终止或跳出正在运行循环的<code>forEach</code>。如果常规的遍历想要检测条件返回bool , 并且可以终止循环，可使用<code>Array.some,Ayyay.every</code>.或者es6新方法<code>Array.find()</code>等等</p><pre><code>var arrayObj = [1,2,3,,5];arrayObj.forEach(function(element, index, array){   console.log(&quot;value[&quot; + index + &quot;] = &quot; + element) },this);//value[0] = 1//value[1] = 2//value[2] = 3//value[4] = 5//可以观察到以上遍历并没有出现undefind</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>该方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组，并且不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）</p><pre><code>//常用的有些业务场景需要重新重组数组对象var arrayObj = [    {name: &#39;zhangsan&#39;, age: 20},     {name: &#39;lisi&#39;, age: 30},     {name: &#39;wangwu&#39;, age: 26}  ];var newArrayObj = arrayObj.map(function(obj, index, array) {    var newObj = {};   newObj[obj.name] = obj.age;   return newObj;});console.log(newArrayObj);//[{&#39;zhangsan&#39;:20},{&#39;lisi&#39;:30},{&#39;wangwu&#39;:26}]</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>该方法创建一个新数组,通过次函数方法会返回相应的过滤后的数据,并且不会改变原数组</p><pre><code>var arrayObj = [3,1,3,2,4,5,6];var newArrayObj = arrayObj.filter(function(value,index,array){   return value &gt; 3});console.log(newArrayObj);//[4, 5, 6]</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素,返回函数累计处理的结果</p><p><code>callback</code>执行数组中每个值的函数，包含四个参数：<br></p><p><code>accumulator</code>累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br></p><p><code>currentValue</code>数组中正在处理的元素。<br></p><p><code>currentIndex</code>数组中正在处理的当前元素的索引。<br></p><p>如果提供了initialValue，则索引号为0，否则为索引为1。array调用reduce的数组initialValue[可选] 用作第一个调用 callback的第一个参数的值。<br></p><p>如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br></p><pre><code>var totalValue = [0, 1, 2, 3].reduce(function(sum, value) {  return sum + value;}, 0); // totalValue  6//将二维数组转化为一维数组var flattened = [[0, 1], [2, 3], [4, 5]].reduce(    function(a, b) {      return a.concat(b);    },[]);  // flattened is [0, 1, 2, 3, 4, 5] </code></pre><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>该方法用于检测数组中的某些元素是否通过callback函数实现的方法。返回bool值</p><pre><code>var arrayObj = [1,2,3,4,5,6];var flag = arrayObj.some(function(element,index,array){  return element &gt; 2;});console.log(flag);//true</code></pre><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>该方法用于检测数组中的所有元素是否通过callback函数实现的方法。返回bool值</p><pre><code>var arrayObj = [1,2,3,4,5,6];var flag = arrayObj.some(function(element,index,array){  return element &gt; 2;});console.log(flag);//false</code></pre><h3 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符(…)"></a>扩展运算符(…)</h3><p>该运算符将一个数组转为用逗号分隔的参数序列</p><p>扩展运算符即可以复制，合并数组，操作分割字符串与结构赋值结合还可以当函数的形参<br></p><pre><code>console.log(...[1,2,3,4,5]);//1 2 3 4 5</code></pre><p>合并数组：<br></p><pre><code>let arrayObj = [1,2,3,4,5,6];let arrayObj1 = [7,8,9];let newArray = [...arrayObj,...arrayObj1];console.log(newArray) //[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>复制数组：<br></p><pre><code>let arrayObj = [1,2,3,4,5];let arrayObjNew = [...arrayObj];console.log(arrayObjNew) //[1,2,3,4,5];</code></pre><p>与结构赋值结合：<br></p><pre><code>const [variable, ...array] = [1, 2, 3, 4, 5];console.log(variable); //1console.log(array); //[2,3,4,5]</code></pre><p>函数形参：</p><pre><code>//例子1:let _arrayObj = [1];let _arrayObj1 = [1,2,3,4,5];var __operationArr = (array,items)=&gt;{    array.push(...items);   console.log(array); //[1,1,2,3,4,5]}__operationArr(_arrayObj,_arrayObj1);//例子2:var __add = (a,b,c,d,e) =&gt;{  return a + b + c +d + e;}__add(..._arrayObj1); //15</code></pre><p>求出数组最大元素：<br></p><pre><code>let arrayObj = [2,3,4,5,3,2,8];Math.max(...arrayObj) //8</code></pre><h3 id="form"><a href="#form" class="headerlink" title="form()"></a>form()</h3><p>该法从一个类似数组或可迭代对象中创建一个新的数组实例，相当于相当于[].slice.call()</p><pre><code>//例子1:let arrayItems = {    &#39;0&#39;: &#39;zhangsan&#39;,    &#39;1&#39;: &#39;lisi&#39;,    &#39;2&#39;: &#39;wangwu&#39;,    length: 3};// ES5的写法var arr1 = [].slice.call(arrayItems); // [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]// ES6的写法let arr2 = Array.from(arrayItems); // [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]例子2:// 常见的DOM NodeList对象let ps = document.querySelectorAll(&#39;p&#39;);let pElementArr = Array.from(ps);pElementArr.forEach((p)=&gt; {  console.log(p);});</code></pre><p>将字符串分割字后变为数组<br></p><pre><code>Array.from(&#39;foo&#39;);//[&#39;f&#39;,&#39;o&#39;,&#39;o&#39;]</code></pre><h3 id="of"><a href="#of" class="headerlink" title="of()"></a>of()</h3><p>该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p><p>Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br></p><pre><code>Array.of(7);       // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7);          // [ , , , , , , ]Array(1, 2, 3);    // [1, 2, 3]</code></pre><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>该方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小</p><p>arr.copyWithin(target)<br></p><p>arr.copyWithin(target, start)<br></p><p>arr.copyWithin(target, start, end)<br></p><p>arr.copyWithin(目标索引, [源开始索引], [结束源索引])<br></p><pre><code>[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4][].copyWithin.call({length: 5, 3: 1}, 0, 3);// {0: 1, 3: 1, length: 5}</code></pre><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>该方法返回数组中满足提供的callback的第一个元素的值。否则返回 undefined</p><p>如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用<code>Array.prototype.indexOf()</code> 或 <code>Array.prototype.includes()</code>。</p><p>如果你需要找到元素的索引，而不是其值<code>Array.prototype.findIndex()</code>;</p><pre><code>let arrayObj = [2,4,5,60,39];let backValue = arrayObj.find((element)=&gt;{return element &gt; 20});console.log(backValue); //60</code></pre><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>该方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素</p><p>语法：<br><br>arr.fill(value) <br><br>arr.fill(value, start) <br><br>arr.fill(value, start, end)<br></p><pre><code>[1, 2, 3].fill(4)            // [4, 4, 4][1, 2, 3].fill(4, 1)         // [1, 4, 4][1, 2, 3].fill(4, 1, 2)      // [1, 4, 3][1, 2, 3].fill(4, 1, 1)      // [1, 2, 3][1, 2, 3].fill(4, -3, -2)    // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN)  // [1, 2, 3]Array(3).fill(4);            // [4, 4, 4][].fill.call({length: 3}, 4) // {0: 4, 1: 4, 2: 4, length: 3}</code></pre><h3 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h3><p>该方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对</p><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();// undefinedconsole.log(iterator);// Array Iterator {}console.log(iterator.next().value); // [0, &quot;a&quot;]console.log(iterator.next().value); // [1, &quot;b&quot;]console.log(iterator.next().value); // [2, &quot;c&quot;]</code></pre><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>该方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false</p><p>语法：<br><br>arr.includes(searchElement)<br><br>arr.includes(searchElement, fromIndex)<br></p><pre><code>[1, 2, 3].includes(2);     // true[1, 2, 3].includes(4);     // false[1, 2, 3].includes(3, 3);  // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象之继承</title>
      <link href="/2019/03/15/javascript/inheritance/"/>
      <url>/2019/03/15/javascript/inheritance/</url>
      
        <content type="html"><![CDATA[<p>原型链虽然很强大，也可以用它来实现继承，但是总会有这样那样的问题。其中最主要的问题是原型链的引用问题。下面借鉴JS高程中的几种方式来学习JS继承,JS继承也是面向对象（oo）编程，但不使用类或者接口，而是使用创建对象的形式。虽然在ES6中实现了Class但其实只是语法糖，原理依然是<strong>proto</strong>。在JS超集中（TypeScript）用类与接口实现继承，会在后续文章中学习记录。</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><pre><code>function Parent () {  this.name = &#39;zhansan&#39;;}Parent.prototype.sayName = function () {    console.log(this.name);}function Child () {}Child.prototype = new Parent();var child = new Child();child.sayName() // zhangsan</code></pre><p>  问题</p><ul><li>引用类型的值的原型属性会被所有实例共享</li><li>在创建子类型的实例时不能向超类型的构造函数传参（没法办在不影响所有对象实例的情况下传参）</li></ul><h3 id="借用构造函数继承（经典继承）"><a href="#借用构造函数继承（经典继承）" class="headerlink" title="借用构造函数继承（经典继承）"></a>借用构造函数继承（经典继承）</h3><p>在子类构造函数内部调用超类型构造函数</p><pre><code>function Parent () {  this.name = [&#39;zhangsan&#39;, &#39;lisi&#39;];}function Child () {  Parent.call(this);}var child = new Child();child.name.push(&#39;wangyu&#39;);child.name() // [&#39;zhangsan&#39;, &#39;lisi&#39; ,&#39;wangyu&#39;]var child1 = new Child();child1.name() //  [&#39;zhangsan&#39;, &#39;lisi&#39;]</code></pre><p>优点：解决了原型链继承的问题</p><p>缺点：方法都在构造函数中定义，函数无法复用，创建实例时方法都会被创建一遍</p><h3 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h3><pre><code>function Parent (name) {  this.name = name;  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];}Parent.prototype.getName = function () {  console.log(this.name)}function Child (name, age) {  Parent.call(this, name);  this.age = age;}Child.prototype = new Parent();Child.prototype.constructor = Child;var child = new Child(&#39;zhangsan&#39;, &#39;20&#39;);child.colors.push(&#39;black&#39;);console.log(child.name); // zhangsanconsole.log(child.age); // 20console.log(child.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child1 = new Child(&#39;lisi&#39;, &#39;28&#39;);console.log(child1.name); // lisiconsole.log(child1.age); // 28console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</code></pre><p>优点：融合原型链继承和构造函数的优</p><p>缺点：调用多次超类构造函数</p><h3 id="原型式继承（道格拉斯）"><a href="#原型式继承（道格拉斯）" class="headerlink" title="原型式继承（道格拉斯）"></a>原型式继承（道格拉斯）</h3><pre><code>function createObj(o) {  function F(){}  F.prototype = o;  return new F();}var person = {  name: &#39;zhansan&#39;,  hobbies: [&#39;swimming&#39;, &#39;reading&#39;]}var person1 = createObj(person);var person2 = createObj(person);person1.name = &#39;person&#39;;console.log(person2.name); // zhangsanperson2.hobbies.push(&#39;running&#39;);console.log(person2.hobbies); // [&quot;swimming&quot;, &quot;reading&quot;, &quot;running&quot;]</code></pre><p>缺点：引用类型的值的原型属性会被所有实例共享</p><h3 id="寄生式继承（道格拉斯升级版）"><a href="#寄生式继承（道格拉斯升级版）" class="headerlink" title="寄生式继承（道格拉斯升级版）"></a>寄生式继承（道格拉斯升级版）</h3><pre><code>function createObj (o) {  var clone = Object.create(o);  clone.sayName = function () {      console.log(&#39;zhangsan&#39;);  }  return clone;}</code></pre><p>缺点：跟借用构造函数模式一样，创建实例时方法都会被创建一遍</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><pre><code>function inheritPrototype(Child, Parent){  var prototype = Object.create(superType.prototype);  prototype.constructor = Child;  Child.prototype = prototype;}function Parent(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}Parent.prototype.sayName = function(){  console.log(this.name);};function Child(name, age){  Parent.call(this, name);  this.age = age;}inheritPrototype(Child, Parent);//实现继承Child.prototype.sayAge = function(){  console.log(this.age);}; </code></pre><p>优点：保证了原型链链路的正确性,没有多余的属性等优点，所以最为理想的ES5继承</p><h3 id="ES6继承"><a href="#ES6继承" class="headerlink" title="ES6继承"></a>ES6继承</h3><pre><code>//class 相当于es5中构造函数//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中//class中定义的所有方法是不可枚举的//class中只能定义方法，不能定义对象，变量等//class和方法内默认都是严格模式//es5中constructor为隐式属性class Parent{  constructor(name=&#39;wang&#39;,age=&#39;27&#39;){    this.name = name;    this.age = age;  }  eat(){    console.log(`${this.name} ${this.age} eat food`)  }}//继承父类class Child extends Parent{   constructor(name = &#39;ren&#39;,age = &#39;27&#39;){     //继承父类属性    super(name, age);   }     eat(){     //继承父类方法      super.eat()     } } let child =new Child(&#39;xiaoxiami&#39;); child.eat();</code></pre><p>优点</p><ul><li>在语法糖下代码量明显减少，和ES6区别ES5继承首先是在子类中创建自己的this指向，最后将方法添加到this中</li></ul><pre><code>Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)</code></pre><ul><li>es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型及原型链</title>
      <link href="/2019/03/10/javascript/prototype/"/>
      <url>/2019/03/10/javascript/prototype/</url>
      
        <content type="html"><![CDATA[<h3 id="普通对象和函数对象"><a href="#普通对象和函数对象" class="headerlink" title="普通对象和函数对象"></a>普通对象和函数对象</h3><pre><code>  // 普通对象  var obj1 = {};   var obj2 = new Object();  var obj3 = new person();  // 函数对象  function person(){};   var person1 = function(){};  var person2 = new Function(&#39;aaa&#39;,&#39;console.warn(aaaa)&#39;);  console.log(typeof Object); //function   console.log(typeof Function); //function   console.log(typeof person); //function   console.log(typeof person1); //function   console.log(typeof person2); //function    console.log(person instanceof Function) // true   console.log(typeof obj1); //object   console.log(typeof obj2); //object   console.log(typeof obj3); //object  console.log(obj3 instanceof Object)  // true</code></pre><p>通过以上实例我们知道 new Function 构建的都是函数对象(关于普通函数与new Function的区别请参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">mozilla开发者</a>), 其余都是普通对象,关于Object与Function的区别会在这章节最后总结</p><h3 id="通过构造函数模式创建对象"><a href="#通过构造函数模式创建对象" class="headerlink" title="通过构造函数模式创建对象"></a>通过构造函数模式创建对象</h3><p>在js高程中我们知道创建对象有很多种模式如下</p><ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合使用构造函数和原型模式</li><li>动态原型模式</li><li>寄生构造函数模式</li><li>稳妥构造函数模式</li></ul><p>当然这几种模式在这里暂时不展开说明，后续继承的时候在分别用讨论，我们这里简单的回忆一下用构造函数创建对象</p><pre><code>  function Person(name, age) {    this.name = name;    this.age = age;  }  Person.prototype.sayName = function () {    console.log(this.name)  }  var person1 = new Person(&#39;zhansan&#39;, 29);  var person2 = new Person(&#39;lisi&#39;, 29);</code></pre><h3 id="proto-prototype-constructor"><a href="#proto-prototype-constructor" class="headerlink" title="proto,prototype,constructor"></a><strong>proto</strong>,prototype,constructor</h3><ul><li><code>__proto__</code>:在JavaScript权威指南中指出每个js对象一定对应一个原型对象，并从原型对象继承属性和方法。</li><li><code>prototype</code>: 当创建函数对象时，js会自动为这个函数添加prototype属性（<strong>这里明确一下只有函数对象才会有此属性</strong>）</li><li>每个原型都有一个 constructor 属性指向关联的构造函数。</li></ul><p>通过上述三点我们针对2中的代码解释为</p><p>当创建<code>Person</code>函数时，js会自动为该函数创建<code>prototype</code>属性，这个属性指向函数的原型对象，函数的原型对象（<code>Person.prototype</code>）会自动获取一个<code>constructor</code>属性指向关联的Person。当我们通过new关键字调用时，js就会创建该构造函数的实例<code>person1</code>或<code>person2</code>，此时我们就可以通过<code>prototype</code>来存储要共享的属性和方法</p><p>下面我们通过图例来说明我们上面的文字</p><p><image src="/images/Person.png"></image></p><p>这里我们注意虽然person1和person2这两个个实例都不包含属性和方法，但是我们可以通过查找对象属性来实现调用person1.sayName()</p><p>此时我们来确定两个实例对象返回的原型指针是否一样(<strong>Object.getPrototypeOf 此方法可以获取对象的原型</strong>)</p><pre><code>Object.getPrototypeOf(person1) === Person.prototype (true)Object.getPrototypeOf(person1) === Person.prototype (true)</code></pre><p>通过如上输出结果得知他们内部都有一个指向Person.prototype的指针也就是</p><pre><code>person1.__proto__ === Person.prototypeperson2.__proto__ === Person.prototype</code></pre><p>经过上面解释这么多我们得出的结果就是如下 </p><pre><code>person1.__proto__ === Person.prototypePerson.prototype.constructor == Person</code></pre><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li>js几乎所有对象都是Object; 典型对象继承属性（包括方法）</li><li>所有引用类型的原型链上必然存在Object的原型</li><li>new Object 出来的实例是普通对象我们前面说过只有函数对象才有prototype</li><li>Object 实际是function Object跟function Function 类似</li><li>Object.prototype是Object构造函数的属性。它也是原型链的终结</li></ul><pre><code>function Object (name,age) {  this.name = name;  this.age = age;}Object.prototype.sayName = function () {  console.log(this.name)}object = new Object(&#39;zhangsan&#39;,20)object.sayName()</code></pre><p>我们通样以图例的形式来说明Object的<strong>proto</strong>,prototype,constructor</p><p><image src="/images/Object.png"></image></p><p>通过以上图例我们得出结论<code>Object.prototype.__proto__ === null</code></p><p>这里面扩展一下null和undefined区别</p><ul><li>null === undefined为false，null == undefined为true 说明只是值相等</li><li>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</li><li>null表示变量未指向任何对象，undefined表示变量被声明但是没有被赋值</li></ul><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul><li>在js中每个函数实际上都是一个Function对象。</li><li>使用Function构造器生成的Function对象是在函数创建时解析的,而其他函数方式是跟其他代码一起解析，所以较为低效</li><li>全局的Function对象没有自己的属性和方法，通过Function.prototype上继承部分属性和方法。</li><li>我们说js中万物皆对象，Function也也是对象，只不过是函数对象所以<code>Function.prototype.__proto__</code>指针指向<code>Object.prototype</code></li><li><code>Object.__proto__</code> 指针指向<code>Function.prototype</code></li></ul><p><strong>Function创建的函数一般在全局作用域中被创建，但并不会像其他函数一样产生闭包，所以只能自己内部和全局的变量</strong></p><pre><code>function Function (name,age){  this.name  = name  this.age = age}Function.prototype.sayName = function () {  console.log(this.name)}f = new Function(&#39;zhangsan&#39;, 20)f.sayName ()</code></pre><p>我们同样以图例的形式来说明Function的<strong>proto</strong>,prototype,constructor</p><p><image src="/images/Function.png"></image></p><p>通过以上图例我们得出结论<code>Object.prototype === Function.prototype.__proto__</code></p><h3 id="将Function，Object，Person链接起来"><a href="#将Function，Object，Person链接起来" class="headerlink" title="将Function，Object，Person链接起来"></a>将Function，Object，Person链接起来</h3><p>此时我们同样通过图例的形式将上面整合起来。来看看整个链路是什么样子</p><p><image src="/images/prototype.png"></image></p><p> 通过以上图例我们可以观察到其实js原型链就是由相互关联的链条组成，查找属性或者方法的过程就是图中红色链条的过程，如果找到则终止否则直到返回null</p><p><code>person1</code> &gt; <code>person1.__proto__</code> &gt; <code>Person.prototype</code> &gt; <code>Person.prototype.__proto__</code> &gt; <code>Object.prototype</code> &gt; <code>Object.prototype.__proto__</code> &gt; <code>null</code></p><p>最后我们来看一下Object和Function的关系，上面已经提到<code>Object.prototype === Function.prototype.__proto__</code></p><ul><li><code>Function.__proto__</code> &gt; <code>Function.prototype</code> &gt; <code>Function.prototype.__proto__</code> &gt; <code>Object.prototype</code> –&gt; <code>Object.prototype.__proto__</code> –&gt; ‘null’;简写为<code>Function.__proto__.__proto__.__proto__</code> &gt; <code>null</code></li><li><code>Object.__proto__</code> &gt; <code>Funtion.prototype</code> &gt; <code>Function.prototype.__proto__</code> &gt; <code>Object.prototype</code> &gt;<code>Object.prototype.__proto__</code> &gt; <code>null</code>;简写为<code>Object.__proto__.__proto__.__proto__</code> &gt; <code>null</code></li></ul><p>通过上面我们可以得出结论</p><ul><li>只有函数对象才有 prototype，但是每个对象（普通对象和函数对象）都拥有<strong>proto</strong>属性</li><li>原型对象都有一个 constructor 属性指向它们的构造函数（也就是自己）</li><li>原生对象既是对象，也是构造函数</li><li>实例对象的隐式原型始终指向构造函数的显式原型（<code>person1.__proto__</code> &gt; <code>Person.prototype</code>）</li><li>原型链的查找过程链接依赖 <strong>proto</strong> 指针逐级向上，并且原型链的尽头始终为null</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2019/03/05/javascript/this/"/>
      <url>/2019/03/05/javascript/this/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>js的关键字，在执行上下文环境时被绑定</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>默认绑定、隐式绑定、apply,call、new绑定。优先级从低到高</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><pre><code>console.log(this); //windowfunction fun() {console.log(this.a) // 非严格模式下1 ，严格模式下undefined}var a = 1;fun(); </code></pre><h3 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h3><p>作为对象方法调用，this 指代上下文对象</p><pre><code>function fun() {   console.log( this.a );}var a = 1;var obj = {   a: 2,  fun: fun };obj.fun(); // 2var c = obj.fun;console.log(c()); // 1</code></pre><h3 id="apply-call"><a href="#apply-call" class="headerlink" title="apply,call"></a>apply,call</h3><p>改变对象的prototype关联对象来改变this,对于null，undefined绑定会失效</p><pre><code>function fun() {   console.log( this.a );}var a = 1;var obj1 = {   a: 2,};var obj2 = {   a: 3,};fun.call( obj1 ); // 2fun.call( obj2 ); // 3fun.call( null ); // 1fun.call( undefined ); // 1</code></pre><h3 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>this 指代new 出的对象<br>使用new来调用函数，会自动执行如下操作：</p><ul><li>创建一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的this。</li><li>如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。<pre><code>function fun(a) {   this.a = a;}var a = 1;var obj = new fun(3);console.log(obj.a); // 3var obj1 = new fun(4);console.log(obj1.a); // 4</code></pre></li></ul><h3 id="es6中箭头函数this指向"><a href="#es6中箭头函数this指向" class="headerlink" title="es6中箭头函数this指向"></a>es6中箭头函数this指向</h3><p>  取决于外层（函数或全局）作用域。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2019/02/25/javascript/closure/"/>
      <url>/2019/02/25/javascript/closure/</url>
      
        <content type="html"><![CDATA[<p>说起闭包那么首先先来了解一下js执行环境（execution context）、作用域以及作用域链（scope chain）</p><h3 id="上下文执行环境"><a href="#上下文执行环境" class="headerlink" title="上下文执行环境"></a>上下文执行环境</h3><p> 执行环境定义了变量或者函数有权访问的其他数据，决定了各自的行为</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol><li>变量对象（varible object）：存放当前执行环境中定义的变量和函数，<strong>如果当前环境是函数则将活动对象（activation object）作为变量对象，但不包括函数表达式</strong></li><li>作用域链：当代码在执行环境中运行时，会创建<strong>变量对象</strong>的一个<strong>作用域链（词法作用域）</strong>，能够保证对执行环境中所有变量和函数有序访问</li><li>this指向：根据调用的规则不同this指向不同产生的执行环境上下文不同</li></ol><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol><li>全局执行环境</li><li>局部执行环境</li></ol><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li>在全局代码执行前, js引擎就会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行环境(window)确定后, 将其push到栈中</li><li>在函数执行环境创建后, 将其push到栈中</li><li>在当前函数执行完后,将栈顶的对象pop</li><li>当所有的代码执行完后, 栈中只剩下window</li></ol><pre><code>  // demo1:  先执行变量提升, 再执行函数提升  function a() {}  var a  console.log(typeof a) // &#39;function&#39;  //demo2:  if (!(b in window)) {    var b = 1  }  console.log(b) // undefined  // demo3:  console.log(a);    // f a() {console.log(10)}  console.log(a());    //  undefined  var a = 1;  function a() {    console.log(&#39;nihao&#39;) //nihao  }  console.log(a)   //1  a = 3;  console.log(a());  //a is not a function;  // demo4:  function fun(){ var a=b=3;}  console.log(b)//B是全局变量 var a是局部变量  b=3;a=undefine</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>概念： 执行上下文中声明的变量和声明的作用范围。</li><li>分类：<ul><li>全局作用域</li><li>函数作用域</li><li>es6块级作用域</li></ul></li><li>作用： 隔离变量，不同作用域下同名变量不会有冲突</li><li>区别：<ul><li>创建时机不同，全局执行上下文是在全局作用域确定后js代码执行前创建而函数执行上下文是在调用函数时, 函数体代码执行之前创建</li><li>作用域是静态的，执行上下文是动态的</li></ul></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul><li>从内到外多个作用域形成的链</li><li>包含父级(<strong>[[scope]]</strong>)变量对象与作用域链和自身的变量对象(<strong>如果是函数则为活动对象AO</strong>)</li></ul><pre><code>var x = 10;function fn () {  console.log(x);}function show (fn) {  var x = 20;  fn();}show(fn) // 10;</code></pre><h3 id="闭包概念"><a href="#闭包概念" class="headerlink" title="闭包概念"></a>闭包概念</h3><p>能够访问其他函数内变量的函数，是一个比较特殊的作用域函数</p><h3 id="闭包作用"><a href="#闭包作用" class="headerlink" title="闭包作用"></a>闭包作用</h3><p>匿名自执行函数,减少内存消耗</p><pre><code>(function ($) {})(jQuery);</code></pre><p>缓存计算结果</p><pre><code>  var fun1 = function(){    var a=1;    return function fun2(){      a++;      alert(a)    }  }  var b = fun1();  b(); // 2         b(); // 3           </code></pre><p>封装,管理私有方法和变量，避免全局变量冲突污染</p><pre><code>  var person = function(){        var name = &quot;renbo&quot;;           return {          getName : function(){            return name;          },          setName : function(newName){            name = newName;          }        }      }() </code></pre><p>实现类和继承等等</p><h3 id="闭包缺点"><a href="#闭包缺点" class="headerlink" title="闭包缺点"></a>闭包缺点</h3><ol><li>由于变量对象一直在内存中引用不被释放，导致内存过高。</li><li>由于多个函数共享一个父级，当父级有变量更改时，所有子函数受影响</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vo Ao</title>
      <link href="/2019/02/20/javascript/voao/"/>
      <url>/2019/02/20/javascript/voao/</url>
      
        <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>js代码虽然是逐行向下执行的，但执行的时候分为两个步骤**</p><ul><li>编译阶段（词法解释/预解释）</li><li>执行</li></ul><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>函数声明和变量声明总是会被解释器(编译阶段)悄悄地被“提升”到最顶部，最后执行</p><h3 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a>解析顺序</h3><ul><li>this和arguments（语言内置）</li><li>函数的形式参数</li><li>函数声明</li><li>变量声明</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>函数的声明比变量的声明的优先级要高</p><h3 id="es6中let关键字及块及作用域"><a href="#es6中let关键字及块及作用域" class="headerlink" title="es6中let关键字及块及作用域"></a>es6中let关键字及块及作用域</h3><p>  demo1</p><pre><code> ``` a = &#39;renbo&#39;; var a; console.log( a ); // renbo // 编译后的代码 var a; a = &#39;renbo&#39;; console.log(a);  ```</code></pre><p>  demo2</p><pre><code>  ```  function demo() {    a = &#39;renbo&#39;;    console.log(a);    console.log(window.a);    var a = &#39;zhangsan&#39;;    console.log(a);  }  demo();   // 编译后的代码  function demo() {    var a;    a = &#39;renbo&#39;;    console.log(a);    console.log(window.a);    a = &#39;zhangsan&#39;;    console.log(a);  }  demo(); // renbo undefined zhangsan  ``` </code></pre><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><pre><code>   // 两种函数的书写方式   var fn = function fn(){} //函数表达式   function fn(){} //函数声明方式 </code></pre><p>   只有声明方式的函数才会有函数提升</p><pre><code>    test();    function test(){      console.log( a );      var a = &#39;renbo&#39;;    }    // 编译后    function test () {      var a; // 在函数作用域内，被提升最前面      console.log(a); // undefined      a = renbo;     }    test();</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2019/02/12/javascript/type/"/>
      <url>/2019/02/12/javascript/type/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>  基本数据类型是按值进行进行访问，变量是放在栈（stack）内存里</p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>  Undefined、Null、Boolean、String、Number、Symbol（es6）</p><p>  基本数据类型的值是不可变的</p><pre><code>```var str = &quot;renbo&quot;;str.toUpperCase(); // RENBOconsole.log(str); // renbo```</code></pre><p>  按值进行比较</p><pre><code>```var a = 1;var b = true;console.log(a == b); // trueconsole.log(a === b); // false```</code></pre><p>  虽然数据类型不相同（true为bool,1为Number)但在比较之前js自动进行了数据类型的隐式转换</p><p>  == 是进行值比较所以为true</p><p>  === 不仅比较值还要比较数据类型所以为false</p><p>  栈内存中保存了变量的标识符和变量的值</p><pre><code>```var a,b;a = 1;b = a;console.log(a); // 1console.log(b); // 1a = 2;console.log(a); // 2console.log(b); // 1```&lt;image src=&#39;/images/javascript-stack.png&#39;&gt;&lt;/image&gt;</code></pre><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>  引用类型的值是保存在堆内存（Heap）中的对象（Object）</p><h3 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a>种类</h3><p>  统称为Object，细分有：Object，Array，Function，Data，RegExp等</p><p>  引用类型的值式可变化的</p><pre><code>```var obj = {name:&#39;renbo&#39;};obj.name = &#39;zhangsan&#39;;obj.age = 28;obj.say = function () {  return &#39;My name is&#39; + this.name + &#39;I‘m&#39; + this.age+ &#39;years old&#39;;}obj.say(); //My name is zhangsan I‘m 28 years old```</code></pre><p>  按引用地址比较</p><pre><code>```var obj = {};var obj1 = {};console.log(obj == obj1); // falseconsole.log(obj === obj1) // false```</code></pre><p>  栈内存中保存了变量标识符和指向堆内存中该对象的指针</p><p>  堆内存中保存了对象的内容</p><pre><code>  var a = {name: &#39;renbo&#39;};  var b = a;  a.name = &#39;zhangsan&#39;;  console.log(b.name); // zhangsan  b.age = 28;  console.log(b.age) // 28  b.say = function () {    return &#39;My name is&#39; + this.name + &#39;I‘m&#39; + this.age+ &#39;years old&#39;;  }  console.log(a.say()); //My name is zhangsan I‘m 28 years old  var c = {    name:&#39;zhangsan&#39;,    age:28  }</code></pre><p>  <image src="/images/javascript-stack1.png"></image></p><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>  经常检查变量是不是基本数据类型</p><pre><code>```var a;a = &quot;hello&quot;;typeof a; // stringa = true;typeof a; // booleana = 1;typeof a; // number a = null;typeof a; // objecttypeof a; // undefineda = Symbol();typeof a; // symbola = function(){}typeof a; // functiona = [];typeof a; // objecta = {};typeof a; // objecta = /renbo/g;typeof a; // object   ```</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>  经常用来判断引用类型的变量具体是某种类型</p><pre><code>```var a;a = function(){}a instanceof Function; // truea = [];a instanceof Array; // truea = {};a instanceof Object; // truea = /renbo/g;a instanceof RegExp ; // true    ```</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在mac中配置多个github账号ssh密钥</title>
      <link href="/2018/08/10/linux/git/"/>
      <url>/2018/08/10/linux/git/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>很多时候我们本地生成的只有一个自己的ssh，但是多个ssh配置的场景也是蛮多的，所以想要commit，push等操作需要配置私钥ssh或者http，才能连接远程git仓库</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>我们假设原来在~/.ssh目录下已经生成了一对密钥,此密钥文件名字是默认生成</p><pre><code>id_rsaid_rsa.pub</code></pre><p>生成第二个ssh key</p><pre><code>ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot;</code></pre><p>这里面不要一路回车，第一步需要我们手动填写保存文件的名字和路径</p><pre><code>Generating public/private rsa key pair.Enter file in which to save the key (/Users/renbo/.ssh/id_rsa): /Users/renbo/.ssh/id_rsa_github&lt;剩下两个直接回车&gt;</code></pre><p>这里我们用id_rsa_github来区别原有密钥对，避免被覆盖。<br>完成之后，我们可以看到~/.ssh目录下多了两个文件，变成：</p><pre><code>id_rsaid_ras.pubid_rsa_githubid_rsa_github.pubknown_hosts</code></pre><p>打开ssh-agent(关于ssh-agent后续介绍)</p><p>这里如果你用的github官方的bash，用：</p><pre><code>ssh-agent -s</code></pre><p>如果是其他的，比如msysgit，用：</p><pre><code>eval $(ssh-agent -s)</code></pre><p>略过这一步的话，下一步会提示这样的错误：Could not open a connection to your authentication agent.</p><h3 id="添加私钥"><a href="#添加私钥" class="headerlink" title="添加私钥"></a>添加私钥</h3><pre><code>ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_github</code></pre><h3 id="创建config文件"><a href="#创建config文件" class="headerlink" title="创建config文件"></a>创建config文件</h3><p>在~/.ssh目录下创建名为config的文件。mkdir config</p><p>打开文件sudo vim config添加一下内容：</p><pre><code># gitlab  Host gitlab.com  HostName gitlab.com  PreferredAuthentications publickey  IdentityFile ~/.ssh/id_rsa_gitlab# github  Host github.com  HostName github.com  PreferredAuthentications publickey  IdentityFile ~/.ssh/id_rsa_github</code></pre><p>其中，Host和HostName填写git服务器的域名。</p><p>IdentityFile指定私钥的路径。</p><p>如果在Linux系统下提示错误：Bad owner or permissions on /home/gary/.ssh/config</p><p>说明config权限过大，chmod命令调整：</p><pre><code>chmod 644 ~/.ssh/config</code></pre><p>然后在github和gitlab上添加公钥即可。githua 在右上角的头像的设置中</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>然后用ssh命令分别测试：</p><pre><code>ssh -T git@github.com</code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>  如果到这里你没有成功的话，别急，教你解决问题的终极办法–debug</p><p>  比如测试github：</p><pre><code>  ssh -vT git@github.com</code></pre><p>  -v 是输出编译信息，然后根据编译信息自己去解决问题吧。</p><h3 id="关于https用户名"><a href="#关于https用户名" class="headerlink" title="关于https用户名"></a>关于https用户名</h3><p>  如果之前有设置全局用户名和邮箱的话，需要unset一下</p><pre><code>  git config --global --unset user.name  git config --global --unset user.email</code></pre><p>  然后在不同的仓库下设置局部的用户名和邮箱</p><p>  比如在公司的repository下</p><pre><code>  git config user.name &quot;yourname&quot;   git config user.email &quot;youremail&quot;</code></pre><p>  在自己的github的仓库在执行刚刚的命令一遍即可。</p><p>  这样就可以在不同的仓库，已不同的账号登录。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux vim使用</title>
      <link href="/2018/07/28/linux/vim/"/>
      <url>/2018/07/28/linux/vim/</url>
      
        <content type="html"><![CDATA[<h3 id="vim三种模式"><a href="#vim三种模式" class="headerlink" title="vim三种模式"></a>vim三种模式</h3><p>命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre><code>:q  退出:q! 强制退出:wq 保存并退出:set number  显示行号:set nonumber  隐藏行号/host  在文档中查找host 按n跳到查找下一个，shift+n查找上一个yyp  复制光标所在行，并粘贴h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件权限</title>
      <link href="/2018/07/25/linux/fileauth/"/>
      <url>/2018/07/25/linux/fileauth/</url>
      
        <content type="html"><![CDATA[<h3 id="三种基本权限"><a href="#三种基本权限" class="headerlink" title="三种基本权限"></a>三种基本权限</h3><pre><code>R  读  数值表示为4W  写  数值表示为2X  可执行  数值表示为1</code></pre><p>1.执行ls -al命令行会出现<br></p><pre><code>drwxr-xr-x  19 renbo  staff   608B Mar 27 11:31 -notes-summarydrwxr-xr-x  41 renbo  staff   1.3K Mar 12 17:05 ant-design-prodrwxr-xr-x   7 renbo  staff   224B May 18  2018 canvasdrwxr-xr-x   8 renbo  staff   256B Sep 11  2017 doT-demodrwxr-xr-x  19 renbo  staff   608B May 24  2018 egg-exampledrwxr-xr-x   4 renbo  staff   128B Nov 21 13:52 expressdrwxr-xr-x   3 renbo  staff    96B Aug 13  2018 flutter</code></pre><p>2.解释：</p><pre><code>d ：第一位表示文件类型，d是目录文件、l是链接文件、-是普通文件、p是管道rwx ：第2-4位表示这个文件的属主拥有的权限。r是读、w是写、x是执行r-x ：第5-7位表示和这个文件属主所在同一个组的用户所具有的权限r-x ：第8-10位表示其他用户所具有的权限r:read就是读权限     --数字4表示w:write就是写权限    --数字2表示x:excute就是执行权限 --数字1表示</code></pre><h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><pre><code>sudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765sudo chmod u+x g+w o+r  filename上面的例子可以用数值表示sudo chmod 765 filename一般超级权限为sudo chmod 777 filename</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户及用户组管理</title>
      <link href="/2018/07/22/linux/user/"/>
      <url>/2018/07/22/linux/user/</url>
      
        <content type="html"><![CDATA[<h3 id="查看存储用户账号"><a href="#查看存储用户账号" class="headerlink" title="查看存储用户账号"></a>查看存储用户账号</h3><pre><code>cat /etc/passwd输出的结构用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre><h3 id="查看存储组账号"><a href="#查看存储组账号" class="headerlink" title="查看存储组账号"></a>查看存储组账号</h3><pre><code>cat /etc/group  </code></pre><h3 id="查看存储用户账号的密码"><a href="#查看存储用户账号的密码" class="headerlink" title="查看存储用户账号的密码"></a>查看存储用户账号的密码</h3><pre><code>cat /etc/shadow   输出结构登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre><h3 id="查看存储用户组账号的密码"><a href="#查看存储用户组账号的密码" class="headerlink" title="查看存储用户组账号的密码"></a>查看存储用户组账号的密码</h3><pre><code>cat /etc/gshadow  </code></pre><h3 id="建立用户帐号"><a href="#建立用户帐号" class="headerlink" title="建立用户帐号"></a>建立用户帐号</h3><pre><code>参数-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。useradd renbo  添加一般用户useradd -g root renbo  为添加用户指定用户组useradd -r renbo  创建系统用户useradd -d /home renbo  为新添加的用户指定home目录useradd caojh -u 544  建立用户且制定ID</code></pre><h3 id="删除用户帐号"><a href="#删除用户帐号" class="headerlink" title="删除用户帐号"></a>删除用户帐号</h3><pre><code>userdel  同建立账号用法相同 </code></pre><h3 id="新建组"><a href="#新建组" class="headerlink" title="新建组"></a>新建组</h3><pre><code>groupadd 组名</code></pre><h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><pre><code>groupdel 组名</code></pre><h3 id="修改账号"><a href="#修改账号" class="headerlink" title="修改账号"></a>修改账号</h3><pre><code>usermod 选项 用户名和useradd用法相同</code></pre><h3 id="指定口令"><a href="#指定口令" class="headerlink" title="指定口令"></a>指定口令</h3><p>用户口令管理给root设置密码(用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令)</p><pre><code>passwd root -l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令。-f 强迫用户下次登录时修改口令。</code></pre><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre><code>su root su - root   切换到root用户改变环境变量su user   切换用户，加载配置文件.bashrcsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile</code></pre><h3 id="系统环境变量文件"><a href="#系统环境变量文件" class="headerlink" title="系统环境变量文件"></a>系统环境变量文件</h3><pre><code>cat /etc/profile 查看vim /etc/profile 编辑</code></pre><h3 id="用户环境变量文件"><a href="#用户环境变量文件" class="headerlink" title="用户环境变量文件"></a>用户环境变量文件</h3><pre><code>cat /etc/bash_profile 查看vim /etc/bash_profile 编辑cat .bashrc</code></pre><h3 id="更改文件的用户及用户组"><a href="#更改文件的用户及用户组" class="headerlink" title="更改文件的用户及用户组"></a>更改文件的用户及用户组</h3><pre><code>sudo chown [-R] owner[:group] {File|Directory}例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop</code></pre><h3 id="切换此文件所属的用户及组"><a href="#切换此文件所属的用户及组" class="headerlink" title="切换此文件所属的用户及组"></a>切换此文件所属的用户及组</h3><pre><code>sudo chown root:root jdk-7u21-linux-i586.tar.gz</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关机重启操作</title>
      <link href="/2018/07/16/linux/shutdown/"/>
      <url>/2018/07/16/linux/shutdown/</url>
      
        <content type="html"><![CDATA[<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><pre><code>shutdown -r  关机重启shutdown -h  关机不重启shutdown now  立刻关机</code></pre><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>关机</p><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>重启</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux备份操作</title>
      <link href="/2018/07/15/linux/backup/"/>
      <url>/2018/07/15/linux/backup/</url>
      
        <content type="html"><![CDATA[<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><pre><code>tar -cvf log.tar log2012.log    仅打包，不压缩！ tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 tar -zxvf /opt/soft/test/log.tar.gz 解压缩</code></pre><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h3><pre><code>dump -0aj -f /tmp/home0.bak /home  制作一个 &#39;/home&#39; 目录的完整备份dump -1aj -f /tmp/home0.bak /home  制作一个 &#39;/home&#39; 目录的交互式备份</code></pre><h3 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h3><pre><code>restore -if /tmp/home0.bak  还原备份</code></pre><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><pre><code>rsync -rogpav --delete /home /tmp  同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp  通过SSH通道rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local  通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public  通过ssh和压缩将本地目录同步到远程目录 </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软件包管理</title>
      <link href="/2018/07/12/linux/package/"/>
      <url>/2018/07/12/linux/package/</url>
      
        <content type="html"><![CDATA[<h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><p>(Debian Package)管理工具，软件包名以.deb后缀</p><pre><code>sudo dpkg -i package.deb 安装/更新 deb 包 sudo dpkg -r package 删除 deb 包 sudo dpkg -l 获取所有已经安装的 deb 包 sudo dpkg -s package 获得已经安装的包的信息</code></pre><h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><p>（Advanced Packaging Tool）</p><pre><code>sudo apt-get install package 安装package包sudo apt-get remove package 卸载package包sudo apt-get upgrade 更新所有package包  sudo apt-get update 更新package包                             </code></pre><h3 id="YUM-软件包升级器"><a href="#YUM-软件包升级器" class="headerlink" title="YUM 软件包升级器"></a>YUM 软件包升级器</h3><pre><code>yum install package 下载并安装rpm包 yum update package 更新rpm包 yum remove package 删除rpm包 yum list 列出当前系统中安装的所有包yum search package 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 </code></pre><h3 id="RPM包"><a href="#RPM包" class="headerlink" title="RPM包"></a>RPM包</h3><pre><code>rpm -ivh package.rpm 安装rpm包 rpm -ivh --nodeeps package.rpm 安装rpm包而忽略依赖关系警告 rpm -U package.rpm 更新rpm包但不改变其配置文件 rpm -F package.rpm 更新确定已经安装的rpm包 rpm -e package.rpm 删除rpm包 rpm -qa 显示系统中所有已经安装的rpm包 </code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>rpm文件是Redhat支持的软件包格式，而.deb是Debian上支持软件包的扩展名</p><p>由于ubuntu是对Debian的扩展，在ubuntu下不能直接使.rpm文件的，需要将.rmp转换成.deb</p><p>解决方法</p><p>1.安装alien，执行<code>sudo apt-get install alien</code></p><p>2.使用alien，执行<code>sudo alien abc.rpm</code></p><p>3.执行完成后，目录下会生成一个abc.deb文件</p><p>4.安装并使用dpkg</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux打包压缩相关指令</title>
      <link href="/2018/07/10/linux/compression/"/>
      <url>/2018/07/10/linux/compression/</url>
      
        <content type="html"><![CDATA[<h3 id="bzip2-选项-参数"><a href="#bzip2-选项-参数" class="headerlink" title="bzip2(选项)(参数)"></a>bzip2(选项)(参数)</h3><p>命令用于创建和管理（包括解压缩）</p><pre><code>  -c或——stdout：将压缩与解压缩的结果送到标准输出；  -d或——decompress：执行解压缩；  -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；  -h或——help：在线帮助；  -k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；  -s或——small：降低程序执行时内存的使用量；  -t或——test：测试.bz2压缩文件的完整性；  -v或——verbose：压缩或解压缩文件时，显示详细的信息；  -z或——compress：强制执行压缩；  -V或——version：显示版本信息；  --repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；  --repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。</code></pre><h3 id="gunzip-选项-参数"><a href="#gunzip-选项-参数" class="headerlink" title="gunzip(选项)(参数)"></a>gunzip(选项)(参数)</h3><p>命令用来解压缩文件</p><pre><code>  -a或——ascii：使用ASCII文字模式；  -c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；  -f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；  -h或——help：在线帮助；  -l或——list：列出压缩文件的相关信息；  -L或——license：显示版本与版权信息；  -n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；  -N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；  -q或——quiet：不显示警告信息；  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；  -S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；  -t或——test：测试压缩文件是否正确无误；  -v或——verbose：显示指令执行过程；  -V或——version：显示版本信息；</code></pre><h3 id="gzip-选项-参数"><a href="#gzip-选项-参数" class="headerlink" title="gzip(选项)(参数)"></a>gzip(选项)(参数)</h3><p>命令用来压缩文件</p><pre><code>  -a或——ascii：使用ASCII文字模式；  -d或--decompress或----uncompress：解开压缩文件；  -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；  -h或——help：在线帮助；  -l或——list：列出压缩文件的相关信息；  -L或——license：显示版本与版权信息；  -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；  -N或——name：压缩文件时，保存原来的文件名称及时间戳记；  -q或——quiet：不显示警告信息；  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；  -S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；  -t或——test：测试压缩文件是否正确无误；  -v或——verbose：显示指令执行过程；  -V或——version：显示版本信息；  -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；  --best：此参数的效果和指定“-9”参数相同；  --fast：此参数的效果和指定“-1”参数相同。</code></pre><h3 id="tar-选项-参数"><a href="#tar-选项-参数" class="headerlink" title="tar(选项)(参数)"></a>tar(选项)(参数)</h3><p>命令用来解压压缩文件</p><pre><code>  -A或--catenate：新增文件到以存在的备份文件；  -B：设置区块大小；  -c或--create：建立新的备份文件；  -C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。  -d：记录文件的差别；  -x或--extract或--get：从备份文件中还原文件；  -t或--list：列出备份文件的内容；  -z或--gzip或--ungzip：通过gzip指令处理备份文件；  -Z或--compress或--uncompress：通过compress指令处理备份文件；  -f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；  -v或--verbose：显示指令执行过程；  -r：添加文件到已经压缩的文件；  -u：添加改变了和现有的文件到已经存在的压缩文件；  -j：支持bzip2解压文件；  -v：显示操作过程；  -l：文件系统边界设置；  -k：保留原有文件不覆盖；  -m：保留文件不被覆盖；  -w：确认压缩文件的正确性；  -p或--same-permissions：用原来的文件权限还原文件；  -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；  -N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；  --exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</code></pre><p>  实例<br></p><pre><code>  tar -cvf log.tar log2012.log    仅打包，不压缩！   tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩   tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 </code></pre><h3 id="zip-选项-参数"><a href="#zip-选项-参数" class="headerlink" title="zip(选项)(参数)"></a>zip(选项)(参数)</h3><p>命令可以用来解压缩文件</p><pre><code>  -A：调整可执行的自动解压缩文件；  -b&lt;工作目录&gt;：指定暂时存放文件的目录；  -c：替每个被压缩的文件加上注释；  -d：从压缩文件内删除指定的文件；  -D：压缩文件内不建立目录名称；  -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；  -F：尝试修复已损坏的压缩文件；  -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；  -h：在线帮助；  -i&lt;范本样式&gt;：只压缩符合条件的文件；  -j：只保存文件名称及其内容，而不存放任何目录名称；  -J：删除压缩文件前面不必要的数据；  -k：使用MS-DOS兼容格式的文件名称；  -l：压缩文件时，把LF字符置换成LF+CR字符；  -ll：压缩文件时，把LF+cp字符置换成LF字符；  -L：显示版权信息；  -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；  -n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件；  -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；  -q：不显示指令执行过程；  -r：递归处理，将指定目录下的所有文件和子目录一并处理；  -S：包含系统和隐藏文件；  -t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期；  -T：检查备份文件内的每个文件是否正确无误；  -u：更换较新的文件到压缩文件内；  -v：显示指令执行过程或显示版本信息；  -V：保存VMS操作系统的文件属性；  -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；  -x&lt;范本样式&gt;：压缩时排除符合条件的文件；  -X：不保存额外的文件属性；  -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；  -z：替压缩文件加上注释；  -$：保存第一个被压缩文件所在磁盘的卷册名称；  -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值。</code></pre><p>  实例<br></p><pre><code>  zip file1.zip file1 创建一个zip格式的压缩包   zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包   unzip file1.zip 解压一个zip格式压缩包 </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统管理指令</title>
      <link href="/2018/07/02/linux/system/"/>
      <url>/2018/07/02/linux/system/</url>
      
        <content type="html"><![CDATA[<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>显示指定文件的详细信息</p><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>显示在线登陆用户</p><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>显示当前操作用户</p><h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><p>显示主机名</p><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p>显示系统信息</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>动态显示当前耗费资源最多进程信息</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看进程状态 </p><pre><code>ps -aux-A ：所有的进程均显示出来，与 -e 具有同样的效用-a ：显示现行终端机下的所有进程，包括其他用户的进程-u ：以用户为主的进程状态x ：通常与 a 这个参数一起使用，可列出较完整信息</code></pre><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>查看目录大小 <code>du -h /home</code>带有单位显示目录信息</p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘大小 <code>df -h</code>带有单位显示磁盘信息</p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看网络情况</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>测试网络连通</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>显示网络状态信息</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>命令帮助文档如：<code>man ls</code></p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>清屏</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>对命令重命名</p><pre><code>alias l=&quot;ls&quot; </code></pre><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用指令</title>
      <link href="/2018/06/23/linux/instructions/"/>
      <url>/2018/06/23/linux/instructions/</url>
      
        <content type="html"><![CDATA[<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示文件或目录</p><pre><code>ls -F  //显示文件或目录ls -l  //列出文件详细信息l(list)ls -a  //列出当前目录下所有文件及目录，包括隐藏的a(all)</code></pre><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><pre><code>mkdir dir  //创建一个dir的目录</code></pre><p>mkdir -p 创建目录，若无父目录，则创建p(parent) <br></p><pre><code>mkdir -p /study/dir1/dir2  //创建一个的目录树</code></pre><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换目录</p><pre><code>cd ..  //返回上级目录cd /home  //进入指定目录cd - //返回上次所在的目录 </code></pre><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</p><pre><code>touch temp  //创建名为temp的空文件touch temp  //如果temp存在则是修改文件的时间属性 可通过ls -l temp 查看文件属性</code></pre><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>命令行输出内容</p><pre><code>echo &#39;zhangsan&#39; &gt;&gt; temp //创建名为temp带有zhangsan内容的文件</code></pre><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看文件内容</p><pre><code>cat temp  //查看temp文件中的内容cat -n temp  //标示文件的行数</code></pre><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>拷贝</p><pre><code>cp temp newtemp  //复制temp文件cp temp/* .  //复制temp目录下的所有文件到当前工作目录 cp -a /temp/dir1 . //复制/temp/dir1目录到当前工作目录 cp -a temp newtemp //复制temp目录 </code></pre><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动或重命名</p><pre><code>mv temp newtemp //重命名/移动一个目录 </code></pre><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除文件</p><pre><code>rm -f file  //删除file文件&#39; rmdir dir1  //删除dir1的目录&#39; rm -rf dir1 //递归删除dir1目录所有的内容rm -rf dir1 dir2 //同时删除两个目录及它们的内容 </code></pre><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在文件系统中查找某文件</p><pre><code>find / -name file1  //从根文件系统查找文件和目录 find / -user renbo  //查找属于用户 &#39;renbo&#39; 的文件和目录 find /home/renbo -name \*.bin  // 查找带home/renbo目录中有.bin结尾的文件 find / -name \*.rpm -exec chmod 755 &#39;{}&#39; \ //查找以.rpm结尾的文件并定义其权限 find / -xdev -name \*.rpm  //查找所有以.rpm结尾的文件</code></pre><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>统计文本中行数、字数、字符数</p><pre><code>wc gitcommit.sh  //3   13  73 gitcommit.sh</code></pre><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>在文本文件中查找某个字符串</p><pre><code>grep Aug /var/log/messages  //在文件 &#39;/var/log/messages&#39;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages  //在文件 &#39;/var/log/messages&#39;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages //选择 &#39;/var/log/messages&#39; 文件中所有包含数字的行 grep Aug -R /var/log/*  //在目录 &#39;/var/log&#39; 及随后的目录中搜索字符串&quot;Aug&quot; </code></pre><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>树形结构显示目录，需要安装tree包</p><pre><code>tree  //显示文件和目录由根目录开始的树形结构 </code></pre><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前目录</p><pre><code>pwd 显示当前路径</code></pre><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>创建链接文件</p><pre><code>ln -s file1 lnk1  //创建一个指向文件或目录的软链接 ln file1 lnk1  //创建一个指向文件或目录的物理链接 </code></pre><h3 id="more、less"><a href="#more、less" class="headerlink" title="more、less"></a>more、less</h3><p>分页显示文本文件内容</p><pre><code>more file1  //查看一个长文件的内容 less file1  //类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 </code></pre><h3 id="head、tail"><a href="#head、tail" class="headerlink" title="head、tail"></a>head、tail</h3><pre><code>head -2 file1 //查看一个文件的前两行 tail -2 file1 //查看一个文件的最后两行 tail -f /var/log/messages //实时查看被添加到一个文件中的内容 </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理器</title>
      <link href="/2017/07/01/css/css-preprocessor/"/>
      <url>/2017/07/01/css/css-preprocessor/</url>
      
        <content type="html"><![CDATA[<p>CSS 预处理器赋予我们很多css强大的功能，能够很清晰地实现代码的分层、复用和依赖管理，提高开发效率</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol><li>Less 的基本语法跟原生的css的风格几乎差不多</li><li>Sass、Stylus 利用缩进、空格和换行来减少需要输入的字符</li></ol><p>Sass</p><pre><code>.header  background-color:red</code></pre><p>Less &amp; SCSS</p><pre><code>.header {  background-color:red;}</code></pre><p>Stylus</p><pre><code>.header  background-color:red</code></pre><h3 id="嵌套语法"><a href="#嵌套语法" class="headerlink" title="嵌套语法"></a>嵌套语法</h3><p>嵌套语法都是一致的,区别是 Sass 和 Stylus 可以不用书写大括号</p><p>less</p><pre><code>.header {  &amp;.title {    color: red;  }}</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>为 CSS 增加了一种有效的复用方式，减少CSS书写重复</p><p>Sass</p><pre><code>$bg: #ccc;.header   background-color:$bg;</code></pre><p>Less</p><pre><code>@bg: #ccc;header {  background-color: @bg;}</code></pre><p>Stylus</p><pre><code>bg = #cccheader  background-color: bg</code></pre><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>Sass 只能使用 url() 表达式引入时进行变量插值</p><pre><code>  $public: public;  @import url(styles.#{$public}.css);</code></pre><p>Less可以在字符串中进行插值：</p><pre><code>  @public: public;  @import &quot;styles.@{public}.css&quot;;</code></pre><p>Stylus 可以利用其字符串拼接的功能实现</p><pre><code>  public = &quot;public&quot;  @import &quot;styles.&quot; + public + &quot;.css&quot;</code></pre><h3 id="混入-Mixins"><a href="#混入-Mixins" class="headerlink" title="混入(Mixins)"></a>混入(Mixins)</h3><p>作用: 样式层面的抽象</p><p>Sass</p><pre><code>  @mixin product-public-text {    font: {      size: 20px;      weight: 600;      family: PingFangSC;    }    color: rgba(72,72,72,1);  }  .product-header-title {    @include product-public-text;    padding: 10px;  }</code></pre><p>Less</p><pre><code>  .product-public-font-weight {    font-weight: 600;  }  .product-public-font(@color: red) {    font-size: 20px;    color: @color;  }  .product-header-title{    .product-public-font-weight;    .product-public-font(red);  }</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Sass</p><pre><code>  .header {    background-color: red;  }  .main.active {    @extend .header;  }</code></pre><p>less</p><pre><code>  .header {    background-color: red;  }  .main {    &amp;:extend(.header);  }</code></pre><p>Stylus,Scss</p><pre><code>  .header    background-color: red;  .main    @extend .header</code></pre><h3 id="高级用法（函数）"><a href="#高级用法（函数）" class="headerlink" title="高级用法（函数）"></a>高级用法（函数）</h3><p>三种预处理器都自带了诸如色彩处理（darken等）、类型判断（if each for while 等）、数值计算等内置函数</p><h3 id="三种预处理器手册"><a href="#三种预处理器手册" class="headerlink" title="三种预处理器手册"></a>三种预处理器手册</h3><ol><li>Sass：<a href="http://sass.bootcss.com/" target="_blank" rel="noopener">http://sass.bootcss.com/</a></li><li>Less： <a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a></li><li>stylus：<a href="https://stylus.bootcss.com/" target="_blank" rel="noopener">https://stylus.bootcss.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css分层理论</title>
      <link href="/2017/06/22/css/css-layered/"/>
      <url>/2017/06/22/css/css-layered/</url>
      
        <content type="html"><![CDATA[<p>css分层理论和命令规则将有助于它的可扩展性，性能的提高和代码的组织管理。</p><h3 id="OOSS"><a href="#OOSS" class="headerlink" title="OOSS"></a>OOSS</h3><ol><li>定义：面向对象css</li><li>设计原则：表现与结构分离，容器与内容分离</li><li>用途：创建可复用的CSS模块以提高性能</li><li>提高团队开发效率，减少耦合</li></ol><h3 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h3><ol><li><p>定义：可扩展的模块化架构的CSS</p></li><li><p>设计原则： 使用一套五个层次来划分CSS</p></li><li><p>用途：创建更结构化的模块以提高性能，增加效率</p><pre><code>Base - 设定HTML elements 的默认值Layout -Page structure 整个网站的「大架构」的外观   Module - Re-usable code bloks 不同页面公共模块 State - Active/Inactive etc 定义元素不同的状态 Theme - Typography and colour schemes 页面上所有「主视觉」的定义 </code></pre><pre><code>.header {}.header-top {}.header-top__title {}.header-top__title--ico {}&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;header-top&quot;&gt;   &lt;div class=&quot;header-top__title&quot;&gt;     &lt;div class=&quot;header-top__title--ico&quot;&gt;&lt;/div&gt;   &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</code></pre></li></ol><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><ol><li><p>定义：block：块，Element：元素，Modifier：修饰符 </p></li><li><p>设计原则：通过给每个元素添加它的父级block模块作为前缀</p></li><li><p>用途：有助于消除页面和body类对嵌套或者附加样式依赖</p><pre><code>.product-details {}.product-details__header {}.product-details__header--ico {}&lt;div class=&quot;product-details&quot;&gt; &lt;div class=&quot;product-details__header&quot;&gt;   &lt;div class=&quot;product-details__header--ico&quot;&gt;&lt;div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre></li></ol><h3 id="SUIT"><a href="#SUIT" class="headerlink" title="SUIT"></a>SUIT</h3><ol><li>定义：SUIT起源于BEM，对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来</li><li>用途：通过抽离组件级别的的样式表，消除潜在的混乱连字符号连接元素名来使得选择器的可读性更强。</li><li>代码示例同BEM 只不过是抽离的组件</li></ol><h3 id="ACSS"><a href="#ACSS" class="headerlink" title="ACSS"></a>ACSS</h3><p>定义： 考虑如何设计一个系统的接口。原子(Atoms)是创建一个区块的最基本的特质，比如说表单按钮。分子(Molecules)是很多个原子(Atoms)的组合，比如说一个表单中包括了一个标签，输入框和按钮。生物(Organisms)是众多分子(Molecules)的组合物，比如一个网站的顶部区域，它包括了网站的标题、导航等。而模板(Templates)又是众多生物(Organisms)的结合体。比如一个网站页面的布局。而最后的页面就是特殊的模板。</p><p><img src="/images/Acss.jpg" alt></p><h3 id="ITCSS"><a href="#ITCSS" class="headerlink" title="ITCSS"></a>ITCSS</h3><p>定义：创造了一系列的层次来管理依赖关系和促进可扩展性。基础的层次包括通用和广泛的选择器。顶部的层次包含了局部模块具体化的选择器。</p><pre><code>.Settings — 全局可用配置，设置开关。$color-ui: #BADA55; $spacing-unit:10px.Tools —通用工具函数。@mixin font-color() {font-color: $color-ui;}.Generic — 通用基础样式。Normalize, resets, box-sizing: border-box;.Base — 未归类的HTML元素。ul {list-style: square outside;}.Objects —设计部分开始使用专用类。.ui-list__item {padding: $spacing-unit;}.Components — 设计符合你们的组件。products-list {@include font-brand();border-top: 1px solid $color-ui;}.Trumps —重写，只影响一块的DOM。(通常带上我们的!important)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 动画</title>
      <link href="/2017/06/20/css/css-animation/"/>
      <url>/2017/06/20/css/css-animation/</url>
      
        <content type="html"><![CDATA[<p>API的简介及简单动画的实现</p><h3 id="3D转换（transform）"><a href="#3D转换（transform）" class="headerlink" title="3D转换（transform）"></a>3D转换（transform）</h3><ol><li><p>定义向元素应用 2D 或 3D 转换，可以对元素进行移动、缩放、转动、拉长或拉伸</p><p>translate(移动) 根据X轴和Y轴位置给定的参数，从当前元素位置移动</p><pre><code>transform: translate(100px,200px);</code></pre><p>rotate（旋转） 给定度数顺时针旋转的元素。负值则为逆时针旋转</p><pre><code>transform: rotate(60deg);</code></pre><p>scale (缩放) 对元素减小或者放大，取决于宽度（X轴）和高度（Y轴）的参数</p><pre><code>transform: scale(2,2);</code></pre><p>skew (倾斜) 根据X轴和Y轴位置给定的角度参数，进行倾斜，负数则为反方向倾斜</p><pre><code>transform: skew(40deg,50deg);</code></pre></li><li><p>transform-origin：允许改变被转换元素的位置</p><pre><code>transform-origin: x-axis y-axis z-axis;</code></pre></li><li><p>transform-style：规定被嵌套元素如何在 3D 空间中显示</p><pre><code>// preserve-3d所有子元素在3D空间中呈现// flat所有子元素在2D平面呈现transform-style: flat|preserve-3d;</code></pre></li><li><p>perspective:设置元素距离视图的距离，以像素计，与 perspective-origin 属性一同使用，能够改变 3D 元素的底部位置</p><pre><code>perspective: number|none;</code></pre></li><li><p>backface-visibility:定义当元素不面向屏幕时是否可见，在旋转元素不希望看到其背面时，该属性很有用</p><pre><code>backface-visibility: visible|hidden;</code></pre></li></ol><h3 id="CSS3过渡（transition）"><a href="#CSS3过渡（transition）" class="headerlink" title="CSS3过渡（transition）"></a>CSS3过渡（transition）</h3><ol><li>某种效果可以从一种样式转变到另一种样式的效果<pre><code>transition: property duration timing-function delay;</code></pre><pre><code>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);</code></pre></li></ol><h3 id="CSS3-动画（animation及-keyframes）"><a href="#CSS3-动画（animation及-keyframes）" class="headerlink" title="CSS3 动画（animation及@keyframes）"></a>CSS3 动画（animation及@keyframes）</h3><ol><li><p>使元素从一种样式逐渐变化为另一种样式的效果</p><ul><li><p>animation</p></li><li><p>@keyframes</p></li><li><p>语法规则及拆解</p><pre><code>animation: animation-name animation-duration animation-timing-function animation-fill-mode animation-delay animation-iteration-count    animation-direction animation-play-state;animation-name(keyframe名字): keyframename|none;animation-duration(动画完成一个周期需要多少秒或毫秒):animation-duration: time | 0;animation-timing-function(动画的速度曲线,使用的数学函数，称为三次贝塞尔曲线，速度曲线): linear    | ease    | ease-in | ease-out    | ease-in-out     | cubic-bezier(n,n,n,n);animation-fill-mode(当动画完成时或又一个延迟未开始播放时的样式): none|forwards|backwards|both|initial|inherit;animation-delay(动画什么时候开始): time;animation-iteration-count(动画被播放的次数):n |infiniteanimation-direction(是否循环交替反向播放动画): normal|reverse|alternate|alternate-reverse|initial|inherit;animation-play-state(动画是否正在运行或暂停):paused|running;</code></pre></li></ul></li></ol><h3 id="css动画库以及动画工具"><a href="#css动画库以及动画工具" class="headerlink" title="css动画库以及动画工具"></a>css动画库以及动画工具</h3><ul><li>matrix3d(<a href="http://ds-overdesign.com/transform/matrix3d.html" target="_blank" rel="noopener">http://ds-overdesign.com/transform/matrix3d.html</a>)</li><li>matrix(<a href="http://meyerweb.com/eric/tools/matrix" target="_blank" rel="noopener">http://meyerweb.com/eric/tools/matrix</a>)</li><li>tools(<a href="http://www.f2e.name/case/css3/tools.html" target="_blank" rel="noopener">http://www.f2e.name/case/css3/tools.html</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基本布局</title>
      <link href="/2017/06/15/css/base-layout/"/>
      <url>/2017/06/15/css/base-layout/</url>
      
        <content type="html"><![CDATA[<h3 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h3><p>利用BFC实现自适应两栏布局</p><pre><code>/****css****/.aside{  float: left;  width: 180px;  height: 500px;  background-color: red;  opacity: 0.5;}.main{  overflow: hidden;  height: 500px;  background-color: green;}&lt;!--html--&gt;&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;aside&quot;&gt;左侧&lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;右侧&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="/images/%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80.gif" alt></p><h3 id="圣杯布局和双飞翼布局"><a href="#圣杯布局和双飞翼布局" class="headerlink" title="圣杯布局和双飞翼布局"></a>圣杯布局和双飞翼布局</h3><ol><li>解决什么问题：两边定宽，中间自适应的三栏布局，中间栏放在文档流前面以优先渲染</li><li>相同点：三栏全float浮动，左右两栏加上负margin让中间栏div并排，形成三栏</li><li>不同点： <ul><li>圣杯布局为了中间内容不被遮挡，将中间div设置左右padding-left和padding-right,将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</li><li>双飞翼布局，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。</li></ul></li><li>圣杯布局代码</li></ol><pre><code>/****css****/.main{  width: 100%;  background: green;}.left{  left: -200px;  width: 200px;  margin-left: -100%;  background: yellowgreen;}.right{  right: -200px;  width: 200px;  margin-left: -200px;  background-color: red;}.main,.left,.right{  position: relative;  float: left;  min-height: 500px;}.container{  padding: 0 200px;  overflow: hidden;  border: 5px solid #ccc;}&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;main&quot;&gt;中间栏目&lt;/div&gt;  &lt;div class=&quot;left&quot;&gt;左侧栏目&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右侧栏目&lt;/div&gt;&lt;/div&gt;</code></pre><ol start="5"><li>双飞翼布局代码</li></ol><pre><code>/****css****/.main,.left,.right{  float: left;  min-height: 500px;}.main{  width:100%;  background-color: red;}.left{  width: 200px;  margin-left: -100%;  background-color: yellow;}.right{  width: 200px;  background-color: green;  margin-left: -200px;}.content{  margin: 0 200px;}&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt; 　　&lt;div class=&quot;main&quot;&gt;    　　&lt;div class=&quot;content&quot;&gt;中间栏目&lt;/div&gt;     &lt;/div&gt;　　&lt;div class=&quot;left&quot;&gt;左侧栏目&lt;/div&gt; 　　&lt;div class=&quot;right&quot;&gt;右侧栏目&lt;/div&gt; &lt;/div&gt;</code></pre><ol start="6"><li>效果图<br><img src="/images/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.gif" alt></li></ol><h3 id="flex弹性盒子布局"><a href="#flex弹性盒子布局" class="headerlink" title="flex弹性盒子布局"></a>flex弹性盒子布局</h3><ol><li><p>定义：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p></li><li><p>优点：相对于传统布局更具有灵活性。</p></li><li><p>缺点：虽然现代浏览器都支持，但是还有少部分浏览器需要单独处理其兼容性</p></li><li><p>问题：</p><ul><li>绝对定位与固定定位的盒子不参与flex布局</li><li>使用Flex布局以后，子元素的float、clear和vertical-align等属性将失效</li><li>具体语法参考阮大大flex布局语法篇和实例篇</li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li></ul></li><li><p>三栏布局示例 </p></li></ol><pre><code>/****css****/.container{  display: flex;  min-height: 500px;}.main{  flex-grow:1;  background-color: red;}.left{  order: -1;  flex-basis: 200px;  background-color: yellow;}.right{  flex-basis: 200px;  background-color: green;}&lt;!--html--&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;main&quot;&gt;中间内容区域&lt;/div&gt;  &lt;div class=&quot;left&quot;&gt;左边栏区域&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右边栏区域&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h3><ol><li>position:absolute绝对定位使元素脱离文档流，因此不占据当前层级的空间</li><li>三栏布局代码示例<pre><code>/****css****/.container{position: relative;}.main,.left,.right{min-height: 500px;top: 0;}.main{background-color: red;margin: 0 200px;}.left{position: absolute;left: 0px;width: 200px;background-color: green;}.right{position:absolute;right: 0px;width: 200px;background: yellow;}</code></pre></li></ol><!--html--><div class="container">  <div class="main">中间内容区域</div>  <div class="left">左边区域</div>  <div class="right">右边区域</div></div>```### media响应式布局<ol><li>定义（Responsive Web Design）：一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li><li>优点<ul><li>跨平台，面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题</li><li>节约成本</li></ul></li><li>缺点<ul><li>兼容性 不兼容低版本浏览器，各种设备工作量大，效率低下</li><li>代码冗余量大，加载时间长</li><li>折中方案，达不到理想的布局效果 </li></ul></li></ol><h3 id="移动端rem布局"><a href="#移动端rem布局" class="headerlink" title="移动端rem布局"></a>移动端rem布局</h3><ol><li>定义（font size of the root element）：相对于根元素的字体大小的单位</li><li>作用：通过js动态计算html font-size 能够使html页面比响应式布局，流式布局，设置最大宽度布局等效果更完善</li><li>需要考虑当前手机的dpr</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础知识概念</title>
      <link href="/2017/06/11/css/base-concepts/"/>
      <url>/2017/06/11/css/base-concepts/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是css"><a href="#什么是css" class="headerlink" title="什么是css"></a>什么是css</h3><p>层叠样式表(英文全称：Cascading Style Sheets),是一种用来表现html或者xml等文件样式的计算机语言。</p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li>在html文档中，每一个渲染在页面中的标签都是一个个盒子模型；</li><li>盒子模型分为w3c标准盒子模型和IE标准盒子模型；当不对Doctype进行定义时，会触发怪异模式。</li><li>盒子模型</li></ul><pre><code>/****css****/.box{  width:100px;  height:100px;  border:10px;  background-color:red;  padding:20px;  margin:20px;}&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><img src="/images/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt></p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><ul><li><p>定义（Block fomatting context）：块级格式化上下文(每一个元素盒子从上向下排列)</p></li><li><p>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p></li><li><p>是一个独立的渲染区域，只有Block-level box参与</p></li><li><p>布局规则</p><ol><li>内部的Box会在垂直方向链接放置</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol></li><li><p>那些元素会生成BFC</p><ol><li>根元素</li><li>float元素不为none</li><li>position为 absolute或者fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ol></li><li><p>BFC作用</p><ol><li>自适应两栏布局</li><li>清除内部浮动</li><li>防止margin重叠</li></ol></li><li><p>例子说明</p></li><li><p>根据以上BFC布局规则第3条、第4条来触发main生成BFC，来实现自适应两栏布局</p><pre><code>  /****css****/  .main{    overflow: hidden;    height: 500px;    background: yellow;  }  .aside{    float: left;    width: 200px;    height: 500px;    background-color: red;  }  &lt;!--html--&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;aside&quot;&gt;侧边栏区域&lt;/div&gt;    &lt;div class=&quot;main&quot;&gt;内容区域&lt;/div&gt;  &lt;/div&gt;</code></pre></li><li><p>根据BFC布局规则第6条，解决float元素使其父元素高度塌陷问题</p><pre><code>  /****css****/  .parent{    border: 1px solid red;    width: 400px;    overflow: hidden;    padding: 10px;  }  .child{    float: left;    height: 300px;    width: 198px;    border: 1px solid green;  }  &lt;!--html--&gt;  &lt;div class=&quot;parent&quot;&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;/div&gt;</code></pre></li><li><p>防止margin重叠,根据生成BFC第4条规则</p><pre><code>  /****css****/  .box{    width: 300px;    height: auto;  }  .content{    width: 300px;    height: 200px;    margin: 100px;    background: red;  }  .warp{    display: inline-block;  }  &lt;!--html--&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;content warp&quot;&gt;&lt;/div&gt;  &lt;/div&gt;</code></pre></li></ul><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><ol><li><p>布局规则</p><ul><li>定义(Inline Formatting Contexts)：内联格式化上下文（每一个元素盒子从左到右排列）</li><li>IFC的line box高度 由其行内元素中 最高的实际高度计算而来（不受到竖直方向的padding/margin影响)</li><li>inline-level box:display 属性为 inline, inline-box，inline-table，table-cell，table-column-group等，会生成 inline-level box。并且参与 inline fomatting context；</li><li>当inline-level box的宽度大于containing block，且达到内容换行条件时，会将inline-level拆散为多个inline-level box并分布到多行中</li><li>inline-level box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短</li><li>IFC中不可能有块级元素，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</li></ul></li><li><p>作用</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li><li>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li></ul></li><li><p>示例</p><ul><li><p>根据布局规则第4条</p><pre><code>/****css****/.break{ border: 1px solid red; background: yellow;}&lt;!--html--&gt;&lt;span class=&quot;break&quot;&gt;这是一个行内盒子这是一个行内盒子这是一个行内盒子&lt;/span&gt;</code></pre><p><img src="/images/css-IFC.jpg" alt></p></li></ul></li><li><p>根据作用第1条,设置span为inline-block,则会在box上产生ifc,在box上设置text-align使span元素水平居中。</p><pre><code> /****css****/ .box{text-align: center;} .content{   display: inline-block;   border: 1px solid red; } &lt;!--html--&gt; &lt;div class=&quot;box&quot;&gt;   &lt;span class=&quot;content&quot;&gt;内容区域&lt;/span&gt; &lt;/div&gt;</code></pre></li><li><p>根据作用第2条，设置盒子2为inline-block，则会在box上产生ifc，设置其vertical-align:middle，盒子1垂直居中。</p><pre><code> /****css****/ .box{   text-align: center;   border: 1px solid red; } .label{   display: inline-block;   height: 100px;   width: 100px;   vertical-align: middle; } &lt;!--html--&gt; &lt;div class=&quot;box&quot;&gt;   &lt;span class=&quot;content&quot;&gt;盒子1&lt;/span&gt;   &lt;span class=&quot;label&quot;&gt;盒子2&lt;/span&gt; &lt;/div&gt;</code></pre></li></ol><h3 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h3><ol><li>定义(Flex Formatting Contexts)：自适应格式化上下文</li><li>display值为flex或者inline-flex的元素将会生成自适应容器（flex container）</li><li>FFC和BFC区别<ul><li>Flexbox 不支持 ::first-line 和 ::first-letter 这两种伪元素</li><li>vertical-align 对 Flexbox 中的子元素失效</li><li>float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流</li><li>多栏布局（column-*） 在 Flexbox 中失效</li><li>Flexbox 下的子元素不会继承父级容器的宽</li></ul></li></ol><h3 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h3><ol><li>定义(GridLayout Formatting Contexts)：网格布局格式化上下文</li><li>display值为grid的元素，获得一个独立的渲染区域，可在网格内定义项目（item）、行（row）、列（columns）</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 系列总结</title>
      <link href="/2017/05/10/html/html/"/>
      <url>/2017/05/10/html/html/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><h3 id="什么是html"><a href="#什么是html" class="headerlink" title="什么是html"></a>什么是html</h3><p>超文本标记语言（HyperText Markup Language），是“网页浏览器中看到展示信息的”设计的一种标记语言。</p><h3 id="Doctype含义"><a href="#Doctype含义" class="headerlink" title="Doctype含义"></a>Doctype含义</h3><ul><li><!DOCTYPE>声明位于位于HTML文档中的第一行，告诉浏览器的解释器用什么文档标准来解析这个文档。</li><li>DOCTYPE书写错误或者不存在会导致文档已兼容模式呈现</li></ul><h3 id="标准模式和混杂模式"><a href="#标准模式和混杂模式" class="headerlink" title="标准模式和混杂模式"></a>标准模式和混杂模式</h3><ul><li>标准模式： html 排版和 js 渲染工作模式都是以该浏览器支持的最高标准运行。</li><li>兼容模式：页面已宽松的向后兼容的方式显示，模拟老浏览器的行为。</li></ul><h3 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;"></a>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code></h3><p>html5不是基于SGML，所以不需要对DTD进行引用，但是它需要对文档类型声明，需要doctype来规范浏览器行为。</p><h3 id="行内元素-块级元素-空元素"><a href="#行内元素-块级元素-空元素" class="headerlink" title="行内元素-块级元素-空元素"></a>行内元素-块级元素-空元素</h3><ul><li>css中规定每个元素都有默认的display属性和值</li><li>该元素的属性的值为‘inline’的则为行内元素（如:<code>span,a img,input</code>等）</li><li>该元素的属性的值为‘block’的则为块级元素（<code>div，ul,li h1...p</code>等）</li><li>空（void）元素 <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code> 等</li></ul><h3 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h3><ol><li>定义：正确的标签做正确的事情</li><li>为什么要做语义化<ul><li>有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。</li><li>在没有CSS的时候能够清晰的看出网页的结构，增强可读性，便于团队开发和维护。</li><li>支持多终端设备的浏览器渲染。</li></ul></li><li>SEO<ul><li>汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</li><li>目的：<br>为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力。</li><li>优化方式： <ul><li>内部优化：<ol><li>META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化。</li><li>内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接。</li><li>网站内容更新：每天保持站内的更新(主要是文章的更新等)。</li></ol></li><li>外部优化：<ol><li>外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性。</li><li>外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。</li><li>外链选择：与一些和你网站相关性比较高，整体质量比较好的网站交换友情链接，巩固稳定关键词排名。</li></ol></li></ul></li></ul></li></ol><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ol><li>概念：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</li><li>目的：保证用户信息安全，防止恶意网站窃取数据，防止cookie共享</li><li>限制范围<ul><li>cookie、localStorage、indexedDB无法读取</li><li>dom 无法获取</li><li>ajax不能发送</li><li>form表单没有限制</li></ul></li><li>如何设置同源策略(host)：document.domain</li><li>不受同源策略限制：<ul><li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</li><li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等。</li></ul></li></ol><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>  受到浏览器同源策略的影响，要操作其他源下面的脚本，就需要跨域。</p><h3 id="Ajax跨域的解决方案"><a href="#Ajax跨域的解决方案" class="headerlink" title="Ajax跨域的解决方案"></a>Ajax跨域的解决方案</h3><p><strong>1.JSONP：</strong></p><p>  网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求jsON数据。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><pre><code>- 缺点只支持get请求- 优点简单方便，易理解，兼容性良好- 如下示例代码```  //动态创建script，用于跨越操作  function creatScriptTag(src) {    var script = document.createElement(&#39;script&#39;);    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);    script.src = src;    document.body.appendChild(script);  }  // 调用creatScriptTag函数  window.onload = function () {    var url = &#39;/index.php?jsoncallback=result&#39;;    creatScriptTag(url);  }  // 定义回调函数  function result (data) {    console.log(data);  } ``````  // index.php   &lt;?php  header(&#39;Content-type: application/json&#39;);  //获取回调函数名  $jsoncallback = htmlspecialchars($_REQUEST [&#39;jsoncallback&#39;]);  //取数据  $data = [    &#39;data&#39;=&gt;&#39;123&#39;,  ];  $json_data = json_encode(array(&#39;code&#39;=&gt;&#39;200&#39;,&#39;msg&#39;=&gt;&#39;请求成功&#39;,&#39;data&#39; =&gt; $data),jsON_UNESCAPED_UNICODE);  //输出jsonp格式的数据  echo $jsoncallback .&quot;(&quot; . $json_data . &quot;)&quot;;  ?&gt;```</code></pre><p><strong>2.WebSocket:</strong></p><p>  是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器设置利用origin字段设置白名单，就可以通过它进行跨源通信。</p><p><strong>3.CORS（Cross-Origin Resource Sharing）</strong></p><ul><li>在请求头信息中增加Origin字段，用来说明此次请求来自那个源（协议+域名+端口），此字段可以设置相应白名单</li><li>必须设置<code>Access-Control-Allow-Origin</code>字段，值要求是<code>Origin</code>字段的值或者是<em>，</em>的意思是接受任意域名的请求</li><li>CORS请求默认不发送cookie和http认证信息，如果要发送，要在服务器端指<code>Access-Control-Allow-Credentials: true</code>,并且ajax请求必须打开withCredentials属性<pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre></li><li>如果选择发送cookie,<code>Access-Control-Allow-Origin</code>字段不能设为*，必须指定明确的，与当前网页一致的域名</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法、变量、数据类型</title>
      <link href="/2017/01/23/php/base/"/>
      <url>/2017/01/23/php/base/</url>
      
        <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ol><li>PHP 脚本以 <code>&lt;?php 开始，以 ?&gt; 结束</code><br></li><li>PHP 文件的默认文件扩展名是 “.php”<br></li><li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码<br></li><li>PHP 中的每个代码行都必须以分号结束，否则输出错误<br><pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; </code></pre></li></ol><?php   echo "Hello World!"; ?><p> </p> ```<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>PHP 变量规则：</strong><br></p><ol><li>变量以 $ 符号开始，后面跟着变量的名称,$a<br></li><li>变量名必须以字母或者下划线字符开始<br></li><li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br></li><li>变量名不能包含空格<br></li><li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）<br></li><li>由于PHP是弱类型语言所以变量不必声明类型和JS类似 <br></li></ol><p><strong>PHP 变量作用域</strong><br></p><p><strong>四种不同的变量作用域</strong><br></p><pre><code>local 局部global 全局static 局部-静态变量parameter 参数</code></pre><p><strong>局部和全局作用域 local global</strong><br></p><pre><code>&lt;?php   $age = 20; //全局作用域  $name = &#39;zhangsan&#39;;  function people () {    $isJob  = &#39;yes&#39;; //局部变量    global $name;   //访问全局作用域    var_dump($name);  // zhangsan   }  people()?&gt;</code></pre><p>解析：<br></p><ol><li>$age 是在函数外部定义的变量，拥有全局作用域，但是这里和 JS 的区别是 $age 在people函数中是不可访问的<br></li><li>$isJob 是在函数内部声明的变量所以是局部变量，只能在函数内部访问<br></li><li>$name global 是在函数内部<strong>调用</strong>函数外部定义的全局变量,正常情况在函数内部访问函数外部的变量则为NULL<br></li></ol><p><strong>Static 作用域</strong><br></p><pre><code>&lt;?php  function test() {    static $a = 0;    // static $a = 1 + 2; // 解析错误 参照解析2    echo $a;    $a++;  }  test (); //0  test (); //1  test (); //2?&gt;</code></pre><p>解析：<br></p><ol><li>静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br></li><li>不能对静态变量用表达式的结果赋值，否则会导致解析错误<br></li><li>static全局变量只初使化一次，下一次依据上一次结果值，上例子中调用三次执行的结果是累加的。<br></li><li>在内存的静态存储区中（静态存储区在整个程序运行期间都存在，其他局部变量存储在栈中。<br></li></ol><p><strong>parameter 参数作用域</strong><br></p><pre><code>  function test($a) {    echo $a;  }  test (1); //1</code></pre><p><strong>小结</strong></p><ol><li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li><li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li><li>函数内访问全局变量需要 global 关键字,如果不使用，则会覆盖全局变量</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>php数据类型</strong></p><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br></p><p>这里由于和 JS 类似所以不多做解释<br></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 面向对象</title>
      <link href="/2017/01/23/php/oop/"/>
      <url>/2017/01/23/php/oop/</url>
      
        <content type="html"><![CDATA[<p><strong>面向对象基础概念</strong><br><br>Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数<br></p><p><strong>对象的主要三个特性</strong><br><br>对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为<br><br>对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型<br><br>对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同<br></p><p>比如 People(人) 是一个抽象类，我们可以具体到男人和女人，男人和女人就是具体的对象，他们有名字属性，可以写，可以学习说话等行为状态。</p><p><strong>面向对象内容</strong><br></p><pre><code>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作对象 − 是类的实例成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性成员函数 − 定义在类的内部，可用于访问对象的数据继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类子类 − 一个类继承其他类称为子类，也可称为派生类多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做&quot;清理善后&quot; 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）</code></pre><h2 id="代码解析上述概念"><a href="#代码解析上述概念" class="headerlink" title="代码解析上述概念"></a>代码解析上述概念</h2><p><strong>PHP中类的定义</strong><br></p><pre><code>  &lt;?php    class People {      // 公有成员属性      public $name = &#39;zhangsan&#39;;      public $age = 28;      // 公有成员函数方法      public function sayName () {        //业务逻辑       }    }  ?&gt;</code></pre><p><strong>PHP中对象的创建</strong><br></p><pre><code>  class People {    // 公有成员属性    public $name = &#39;zhangsan&#39;;    public $age = 28;    // 公有成员函数方法（$this代表自身的对象);    public function sayName () {      echo $this-&gt;name;    }  }  // 通过new操作符创建对象  $body = new People();  // 成员对象的调用  $body-&gt;study();</code></pre><p><strong>PHP中构造函数</strong><br><br>构造函数是一种特殊的方法。主要用来在创建对象时初始化对象和JS中构造函数中的constructor相似<br></p><pre><code>  class People {    // 通过构造方法为成员变量赋初始值    function __construct( $name, $age ) {      $this-&gt;name = $name;      $this-&gt;age = $age;    }    // 公有成员函数方法（$this代表自身的对象);    public function sayName () {      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);      echo &#39;&lt;/br&gt;&#39;;    }  }  // 通过new操作符创建zhangsan对象  $zhangsan = new People(&#39;zhangsan&#39;, 28);  $zhangsan-&gt;sayName();  // 通过new操作符创建lisi对象  $lisi = new People(&#39;lisi&#39;, 26);  $lisi-&gt;sayName();</code></pre><p><strong>PHP中析构函数</strong><br><br>析构函数 (destructor) 与构造函数相反，当对象结束其生命周期时，系统自动执行析构函数，常用场景例如连接数据库在<strong>construct中,处理完数据断开连接在</strong>destruct方法中<br></p><pre><code>  class People {    // 通过构造方法为成员变量赋初始值    function __construct ($name, $age) {      $this-&gt;name = $name;      $this-&gt;age = $age;    }    // 公有成员函数方法（$this代表自身的对象);    public function sayName () {      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);      echo &#39;&lt;/br&gt;&#39;;    }    // 析构函数用于销毁某些变量、对象，操作等    function __destruct () {      $this-&gt;name = &#39;&#39;;      return true;    }  }  // 通过new操作符创建lisi对象  $lisi = new People(&#39;lisi&#39;, 26);  var_dump($lisi);  echo &#39;&lt;br/&gt;&#39;;  if ($lisi-&gt;__destruct()) {    echo &#39;销毁成功 &lt;br/&gt;&#39;;    var_dump($lisi);  }</code></pre><p><strong>PHP中继承实现</strong><br><br>PHP 使用关键字 extends 来继承一个类<br></p><pre><code>  // 父类  class People {    var $name;    var $age;    function __construct ($name, $age) {      $this-&gt;name = $name;      $this-&gt;age = $age;    }    public function sayName () {      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);      echo &#39;&lt;/br&gt;&#39;;    }  }  // 子类  class Boy extends People {    function getParentProperty () {      var_dump($this);    }  }  $lisi = new People(&#39;lisi&#39;, 26);  $boy = new Boy(&#39;wangwu&#39;,28);  $boy-&gt;getParentProperty();  // 子类调用父类方法  $boy-&gt;sayName();</code></pre><p><strong>PHP中方法重写</strong></p><pre><code>  class People {    var $name;    var $age;    function __construct ($name, $age) {      $this-&gt;name = $name;      $this-&gt;age = $age;    }    public function sayName () {      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);      echo &#39;&lt;/br&gt;&#39;;    }  }  // 子类  class Boy extends People {    // 重写父类方法    public function sayName () {      echo (&quot;my name is &amp;nbsp;&quot; .$this-&gt;name);      return $this-&gt;name;    }  }  $lisi = new People(&#39;lisi&#39;, 26);  $boy = new Boy(&#39;wangwu&#39;,28);  // 重写方法  $boy-&gt;sayName();</code></pre><p><strong>PHP中访问的控制</strong><br><br>PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的<br></p><p>public &amp; var（公有）：公有的类成员可以在任何地方被访问<br></p><p>protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问<br></p><p>private（私有）：私有的类成员则只能被其定义所在的类访问<br></p><pre><code>  /**   * 基类   * Define People   */  class People   {    // 声明一个公有的构造函数    public function __construct () {}    // 声明一个共有的方法    public function sayName ()     {      echo &#39;sayname&lt;/br&gt;&#39;;    }    // 声明一个受保护的方法    protected function swim ()     {      echo &#39;swim&lt;/br&gt;&#39;;    }    // 声明一个私有方法    private function study ()     {      echo &#39;study&#39;;    }    // 不加关键字默认公有方法    function getFun () {      $this-&gt;sayName();      $this-&gt;swim();      $this-&gt;study();    }  }  $people = new People();  // 正常运行输出sayname  $people-&gt;sayName();  // 产生错误  $people-&gt;swim();  // 产生错误  $people-&gt;study();  // 公有，受保护，私有都可以执行  $people-&gt;getFun();   /**   * 子类   * Define Boy   */  class Boy extends People  {    function getFun2 ()    {      $this-&gt;sayName();      $this-&gt;swim();      // 这行会产生一个错误      $this-&gt;study();     }  }  $body = new Boy();  // 这行能被正常执行  $body -&gt;sayName();  // 公有的和受保护的都可执行，但私有的不行  $body-&gt;getFun2(); </code></pre><p><strong>PHP中抽象类</strong><br><br>利用关键字abstract声明抽象</p><p>如果类中有一个方法被是声明为抽象，那么这个类也必须声明为抽象<br></p><p>抽象方法只声明了调用方式（参数），不能定义其具体的功能实现（相当于没有函数体），子类通过继承实现抽象方法，且不能被实例化<br></p><p>继承一个抽象类，子类必须定义父类中的所有抽象方法并且必须要和父类的声明访问级别保持一致或者更宽松<br></p><pre><code>  /**   * 定义抽象类People   */  abstract class People   {    abstract protected function eat();    abstract protected function sleep();    abstract protected function study();    public function runing()     {      echo &#39;跑啊跑！&lt;/br&gt;&#39;;    }  }  /**   * 实现抽象类   */  class Zhangsan extends People  {    protected function eat()    {      echo &#39;eat &lt;/br&gt;&#39;;      return &#39;eat&#39;;    }    protected function sleep()    {      echo &#39;sleep &lt;/br&gt;&#39;;      return &#39;sleep&#39;;    }    protected function study()    {      echo &#39;study &lt;/br&gt;&#39;;      return &#39;study&#39;;    }    public function getFunc ()     {      $this-&gt;eat();      $this-&gt;sleep();      $this-&gt;study();    }  }  // 调用子类  $zhangsan = new Zhangsan;  $zhangsan-&gt;runing(); //跑啊跑！  $zhangsan-&gt;getFunc(); // eat sleep study</code></pre><p>场景：在很多类里面很多的方法都是在重复。这里就可以去用抽象类，当然也可以重写一个类，每个公共类实例化实例化一次，调用相同的方法。但是abstract可以省去实例化的步骤，而且可以重载这个方法,这样不是更方便简单嘛<br><br><strong>PHP中接口的使用</strong><br><br>interface主要对类名，类所拥有的方法，以及所传参数起约束和规范作用，和abstract类似。在多人协同开发项目时起重要作用<br></p><pre><code>// 定义接口类interface People  {  public eat () {};}// 实现接口类class Apple implements People{ public function eat () {   echo &#39;我吃的苹果&#39;; }}$apple = new Apple();$apple-&gt;eat(); </code></pre><p>参数约束，如果参数名字不一样会报错<br></p><pre><code>// 定义接口类interface People  {  public function eat($color);}// 实现接口类Appleclass Apple implements People{ public function eat($color) {    echo(&quot;我吃的$color 🍎&lt;br/&gt;&quot;); }}// 实现接口类Grapeclass Grape implements People{  public function eat($color)  {    echo(&quot;我吃的$color 🍇&quot;);  }}$apple = new Apple();$apple-&gt;eat(&#39;红&#39;); $grape = new Grape();$grape-&gt;eat(&#39;紫&#39;); </code></pre><p>接口继承<br></p><pre><code>  // 定义People接口类  interface People    {      public function eat();    }  // 继承People接口类  interface Boy extends People    {      public function drink();    }  // 接口方法实现  class Behavior implements Boy    {      public function eat()      {          echo &quot;吃东西&lt;br&gt;&quot;;      }      public function drink()      {        echo &quot;喝饮料&lt;br&gt;&quot;;      }    }           Behavior::eat();        Behavior::drink();</code></pre><p><strong>总结抽象类和接口</strong><br><br>抽象类就是一个类的服务提供商，拥有众多服务<br></p><p>接口类就是一个类的规范，子类必须完成它指定方法<br></p><p>它们的区别：<br></p><p>抽象类继承用extends,接口继承用implements<br></p><p>抽象类能多重继承,接口多重继承用”,”隔开<br></p><p>抽象类中的方法不必全部重载,接口方法必须声明或者重载<br></p><p>抽象类不必只包含抽象方法,可以定义完整的方法,接口不能包含任何完整定义方法<br></p><p><strong><strong>set,</strong>get,<strong>isset,</strong>unset,<strong>call,</strong>sleep(),__wakeup()等魔术方法</strong></p><ol><li>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用<br></li></ol><p>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作<br></p><p>引入php手册中的例子<br></p><pre><code>  class Connection   {      protected $link;      private $server, $username, $password, $db;      public function __construct($server, $username, $password, $db)      {          $this-&gt;server = $server;          $this-&gt;username = $username;          $this-&gt;password = $password;          $this-&gt;db = $db;          $this-&gt;connect();      }      private function connect()      {          $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password);          mysql_select_db($this-&gt;db, $this-&gt;link);      }      public function __sleep()      {          return array(&#39;server&#39;, &#39;username&#39;, &#39;password&#39;, &#39;db&#39;);      }      public function __wakeup()      {          $this-&gt;connect();      }  }</code></pre><ol start="2"><li>属性重载<strong>set,</strong>get,<strong>isset,</strong>unset<br><pre><code>public __set ( string $name , mixed $value ) : void // 设置私有属性值的时候调用public __get ( string $name ) : mixed  // 获取私有属性值的时候调用public __isset ( string $name ) : bool // 当判断一个私有成员属性是否被设置过时调用public __unset ( string $name ) : void // 当销毁一个私有成员属性的时候调用</code></pre>当实例化一个对象后，调用类中不存在或者没有权限访问的属性的时候，默认调用__get()方法。可以访问内部属性<br></li></ol><ol start="3"><li>方法重载<strong>call和</strong>callStatic<br><pre><code>call 和 callStatic 是类似的方法，前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。正常情况下如果调用一个类不存在的方法 PHP 会抛出致命错误，而使用这两个魔术方法我们可以替换一些更友好的提示或者记录错误调用日志信息、将用户重定向、抛出异常等等，亦或者是如同set 和 get 那样做方法的重命名。</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 常用方法</title>
      <link href="/2017/01/23/php/method/"/>
      <url>/2017/01/23/php/method/</url>
      
        <content type="html"><![CDATA[<p>此篇文章JS数组方法总结一样纯属是为了熟悉API，不得不承认PHP大法好比JS的原生方法多的很。这里只列出个人认为比较常用的。<br></p><p><strong>数组内置函数</strong><br></p><ol><li><p>for、foreach循环输出数组元素<br></p><pre><code>&lt;?php // for循环for ($i = 0; $i &lt;= 100; $i++) { echo &quot;$i &lt;br/&gt;&quot;;} // foreach 只适用于数组$name = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);  // 创建数组foreach ($name as $value) { echo &quot;$value &lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p>count() 获取数组元素的个数 <br></p><pre><code>&lt;?php$nameLength = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);echo count($nameLength); // 3?&gt;</code></pre></li><li><p>输出数组当前的元素的值，如果当前元素为空或者无值则返回FALSE <br></p><pre><code>&lt;?php$name = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);echo current($name); // 返回第一个元素zhangsan echo end($name); // 返回最后一个元素wangwuecho next($name); // 返回指定元素的下一个元素echo prev($name); // 返回指定元素的上一个元素echo reset($name); // 把内部指针移动到数组的首个元素zhangsan</code></pre></li></ol><p>?&gt;</p><pre><code>4. 对当前数组进行排序&lt;br/&gt;</code></pre><p>  $numbers = array(1, 2, 3, 3, 4, 5, 6, 2);</p><p>  // 返回bool<br>  sort($numbers);  //对数组进行升序成功则为true 失败则为false<br>  rsort($numbers); //对数组进行降序成功则为true 失败则为false<br>  array_reverse($array, $preserve); //对原数组按反序排序，返回排序后的数组(2, 6, 5, 4, 3, 3, 2, 1)</p><pre><code>5. 合并数组&lt;br/&gt;</code></pre><p>$arr = array(1, 2, 3, 3, 4, 5, 6, 2);<br>$arr1 = array(10, 20, 30);</p><p>array_merge($arr, $arr1 );</p><pre><code>6. 压栈，出栈&lt;br/&gt;</code></pre><p>$name = ‘wang’;<br>$name1  = array(‘zhang’, ‘li’);</p><p>array_push($name1, $name); // 3 返回新数组的长度</p><p>array_pop($name1); //li 返回被pop的值。栈为空，返回null</p><p>array_shift($name1); //删除第一个元素并返回；</p><p>array_unshift(array，val1，val2,…); //将参数按照顺序加入队列中</p><pre><code>7. 统计数组中值为出现的次数&lt;br/&gt;</code></pre><p>$val = array(1, 2, 3, 3, 4, 3, 3, 1, 1);<br>print_r(array_count_values($val));</p><pre><code>8. 过滤数组的元素&lt;br/&gt;</code></pre><p>function func ($var) {<br>  return($var &amp; 1);<br>}</p><p>$val = array(‘a’, ‘b’, 2, 3, 4);<br>print_r(array_filter($val, ‘func’)); // 3</p><pre><code>9. 检查索引是否在数组中&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’, ‘age’=&gt;’28’);</p><p>if (array_key_exists(‘name’, $people)) {<br>  echo ‘name存在’;<br>}</p><pre><code>10. 检查数组中是否存在指定的值&lt;br/&gt;</code></pre><p>$val = array(‘zhangsan’, ‘lisi’, ‘wangwu’);<br>if (in_array(‘zhangsan’, $val)) {<br>  echo ‘存在’;<br>}</p><pre><code>11. 返回当前元素的Key&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’, ‘age’=&gt;’28’);<br>key($people); //name</p><pre><code>12. 返回当前元素所有的key&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’,’age’=&gt;’28’);<br>print_r(array_keys($people)); // name age</p><pre><code>**时间内置函数**&lt;br/&gt;</code></pre><p>date(format[,timestamp])</p><p>mktime(hour,minute,second,month,day,year) //省略的参数将以本地日期和时间代替</p><p>getdate([timestamp]) </p><pre><code>**URL处理内置函数**&lt;br/&gt;</code></pre><p>urlencode(str) 返回值字符串中所有的非字母和数字字符变成一个百分号(%) 和一个两位的十六进制数，空格被转换成+,-、_和.不做任何转换</p><p>urldecode(str) </p><pre><code>其实还有好多比如字符串的内置函数、文件操作的内置函数、数据库连接的内置函数等等。其实PHP方法还是比JS多用到的时候查看API即可...&lt;br/&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
