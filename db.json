{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/Acss.jpg","path":"images/Acss.jpg","modified":1,"renderable":0},{"_id":"source/images/Function.png","path":"images/Function.png","modified":1,"renderable":0},{"_id":"source/images/Object.png","path":"images/Object.png","modified":1,"renderable":0},{"_id":"source/images/Person.png","path":"images/Person.png","modified":1,"renderable":0},{"_id":"source/images/ack.png","path":"images/ack.png","modified":1,"renderable":0},{"_id":"source/images/arithmetic-concept.png","path":"images/arithmetic-concept.png","modified":1,"renderable":0},{"_id":"source/images/arithmetic_structure_sort.png","path":"images/arithmetic_structure_sort.png","modified":1,"renderable":0},{"_id":"source/images/commonjs.png","path":"images/commonjs.png","modified":1,"renderable":0},{"_id":"source/images/css-IFC.jpg","path":"images/css-IFC.jpg","modified":1,"renderable":0},{"_id":"source/images/css盒子模型.png","path":"images/css盒子模型.png","modified":1,"renderable":0},{"_id":"source/images/http.png","path":"images/http.png","modified":1,"renderable":0},{"_id":"source/images/http代理.png","path":"images/http代理.png","modified":1,"renderable":0},{"_id":"source/images/ipc-create.png","path":"images/ipc-create.png","modified":1,"renderable":0},{"_id":"source/images/ipc.png","path":"images/ipc.png","modified":1,"renderable":0},{"_id":"source/images/javascript-stack.png","path":"images/javascript-stack.png","modified":1,"renderable":0},{"_id":"source/images/javaScript.png","path":"images/javaScript.png","modified":1,"renderable":0},{"_id":"source/images/javascript-stack1.png","path":"images/javascript-stack1.png","modified":1,"renderable":0},{"_id":"source/images/lifecycle.png","path":"images/lifecycle.png","modified":1,"renderable":0},{"_id":"source/images/linux.png","path":"images/linux.png","modified":1,"renderable":0},{"_id":"source/images/master-worker.png","path":"images/master-worker.png","modified":1,"renderable":0},{"_id":"source/images/module-os.png","path":"images/module-os.png","modified":1,"renderable":0},{"_id":"source/images/module-p.png","path":"images/module-p.png","modified":1,"renderable":0},{"_id":"source/images/module.png","path":"images/module.png","modified":1,"renderable":0},{"_id":"source/images/node.png","path":"images/node.png","modified":1,"renderable":0},{"_id":"source/images/php.png","path":"images/php.png","modified":1,"renderable":0},{"_id":"source/images/pointer-yinyong.png","path":"images/pointer-yinyong.png","modified":1,"renderable":0},{"_id":"source/images/process-on.png","path":"images/process-on.png","modified":1,"renderable":0},{"_id":"source/images/process-send.png","path":"images/process-send.png","modified":1,"renderable":0},{"_id":"source/images/prototype.png","path":"images/prototype.png","modified":1,"renderable":0},{"_id":"source/images/react-jsx-children.png","path":"images/react-jsx-children.png","modified":1,"renderable":0},{"_id":"source/images/render-module.jpg","path":"images/render-module.jpg","modified":1,"renderable":0},{"_id":"source/images/request.png","path":"images/request.png","modified":1,"renderable":0},{"_id":"source/images/tcp.png","path":"images/tcp.png","modified":1,"renderable":0},{"_id":"source/images/ts-lang.png","path":"images/ts-lang.png","modified":1,"renderable":0},{"_id":"source/images/typeScript.png","path":"images/typeScript.png","modified":1,"renderable":0},{"_id":"source/images/vue-core-index.png","path":"images/vue-core-index.png","modified":1,"renderable":0},{"_id":"source/images/vue-dep.png","path":"images/vue-dep.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff01.png","path":"images/vue-dom-diff01.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff02.png","path":"images/vue-dom-diff02.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff03.png","path":"images/vue-dom-diff03.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff04.png","path":"images/vue-dom-diff04.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff05.png","path":"images/vue-dom-diff05.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff06.png","path":"images/vue-dom-diff06.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff08.png","path":"images/vue-dom-diff08.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff09.png","path":"images/vue-dom-diff09.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff10.png","path":"images/vue-dom-diff10.png","modified":1,"renderable":0},{"_id":"source/images/vue-folder.png","path":"images/vue-folder.png","modified":1,"renderable":0},{"_id":"source/images/vue-init.png","path":"images/vue-init.png","modified":1,"renderable":0},{"_id":"source/images/vue-observer.png","path":"images/vue-observer.png","modified":1,"renderable":0},{"_id":"source/images/vue-process.png","path":"images/vue-process.png","modified":1,"renderable":0},{"_id":"source/images/vuex.png","path":"images/vuex.png","modified":1,"renderable":0},{"_id":"source/images/websocket.png","path":"images/websocket.png","modified":1,"renderable":0},{"_id":"source/images/cpu.png","path":"images/cpu.png","modified":1,"renderable":0},{"_id":"source/images/event.png","path":"images/event.png","modified":1,"renderable":0},{"_id":"source/images/html.png","path":"images/html.png","modified":1,"renderable":0},{"_id":"source/images/library-react-lifecycle01.png","path":"images/library-react-lifecycle01.png","modified":1,"renderable":0},{"_id":"source/images/library-react-lifecycle02.png","path":"images/library-react-lifecycle02.png","modified":1,"renderable":0},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"source/images/TypeScript 编译原理.png","path":"images/TypeScript 编译原理.png","modified":1,"renderable":0},{"_id":"source/images/event-loop.png","path":"images/event-loop.png","modified":1,"renderable":0},{"_id":"source/images/vue-lifecycle.png","path":"images/vue-lifecycle.png","modified":1,"renderable":0},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"source/images/css-dom-render.jpg","path":"images/css-dom-render.jpg","modified":1,"renderable":0},{"_id":"source/images/dom-render.jpg","path":"images/dom-render.jpg","modified":1,"renderable":0},{"_id":"source/images/pointer.png","path":"images/pointer.png","modified":1,"renderable":0},{"_id":"source/images/render-process.jpg","path":"images/render-process.jpg","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff11.png","path":"images/vue-dom-diff11.png","modified":1,"renderable":0},{"_id":"source/images/vue-dom-diff12.png","path":"images/vue-dom-diff12.png","modified":1,"renderable":0},{"_id":"source/images/render-tree.jpg","path":"images/render-tree.jpg","modified":1,"renderable":0},{"_id":"source/images/timestamp-diagram.svg","path":"images/timestamp-diagram.svg","modified":1,"renderable":0},{"_id":"source/images/vue-vmodel.png","path":"images/vue-vmodel.png","modified":1,"renderable":0},{"_id":"source/images/圣杯布局.gif","path":"images/圣杯布局.gif","modified":1,"renderable":0},{"_id":"source/images/自适应两栏布局.gif","path":"images/自适应两栏布局.gif","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/29.jpg","path":"medias/featureimages/29.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/30.jpg","path":"medias/featureimages/30.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/31.jpg","path":"medias/featureimages/31.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"source/images/library-react-lifecycle03.jpg","path":"images/library-react-lifecycle03.jpg","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"source/images/library-react-lifecycle04.jpg","path":"images/library-react-lifecycle04.jpg","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/zhaolei.jpg","path":"medias/music/avatars/zhaolei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/maliang.jpg","path":"medias/music/avatars/maliang.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/35.jpg","path":"medias/featureimages/35.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/chenhouyu.jpg","path":"medias/music/avatars/chenhouyu.jpg","modified":1,"renderable":1},{"_id":"source/images/CSS.png","path":"images/CSS.png","modified":1,"renderable":0},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/33.jpg","path":"medias/featureimages/33.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/34.jpg","path":"medias/featureimages/34.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/laofan.jpg","path":"medias/music/avatars/laofan.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/32.jpg","path":"medias/featureimages/32.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/wanghouyusheng.mp3","path":"medias/music/wanghouyusheng.mp3","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/lixiangsanxun.mp3","path":"medias/music/lixiangsanxun.mp3","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/hua.mp3","path":"medias/music/hua.mp3","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/yongbaoni.mp3","path":"medias/music/yongbaoni.mp3","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1571102982457},{"_id":"source/CNAME","hash":"181c262cf92b1ff30ea9cdaaaefe2648b4b3f1c0","modified":1571102982457},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1571102982539},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1571102982539},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1571102982539},{"_id":"themes/matery/_config.yml","hash":"abce8e1660d48d549fce95e91411cecdbd3fc09e","modified":1571102982540},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1571102982538},{"_id":"source/_data/musics.json","hash":"8cd9ef3dc7c984f82de962b2366e1ed9853b44c8","modified":1571102982458},{"_id":"source/about/index.md","hash":"4cce428e0a8e97e1075d2f03ea689300c049f81e","modified":1571102982489},{"_id":"source/archives/index.md","hash":"30a0e3a59be650ae34d7bb86ac7da53e21e9cf5b","modified":1571102982489},{"_id":"source/categories/index.md","hash":"67687d3f908737f7c680f096b3e80d9412f23b0e","modified":1571102982490},{"_id":"source/friends/index.md","hash":"08915bb7b924ffb123c64b76d43b93c4bdea9d58","modified":1571102982490},{"_id":"source/tags/index.md","hash":"fe3d7ecc91b81b062a6a60c06859dc24b9d704ac","modified":1571102982538},{"_id":"source/images/Acss.jpg","hash":"24c93cda375ca4bf9d02d7bd56bf47ed22d48594","modified":1571102982491},{"_id":"source/images/Function.png","hash":"7b96f8e301445b0b84fe87dda3171165005499c1","modified":1571102982495},{"_id":"source/images/Object.png","hash":"f9bdf44c968effbe90a1f911581403129569f263","modified":1571102982495},{"_id":"source/images/Person.png","hash":"bd1b0c5ef77f699d05d624eeacb370b92b87e663","modified":1571102982496},{"_id":"source/images/ack.png","hash":"1e9740c51931e3049de55034b09350673588335a","modified":1571102982498},{"_id":"source/images/arithmetic-concept.png","hash":"7c2ec1a1282ed8092b5dec5a76114649f7feaa44","modified":1571196473713},{"_id":"source/images/arithmetic_structure_sort.png","hash":"09aac7ac0b2915f3bdec46f75d5f3e170ce4a6c4","modified":1571207192711},{"_id":"source/images/commonjs.png","hash":"7ff09d53c1ca8d8ad446baa75a6312e6a8c20e4b","modified":1571102982498},{"_id":"source/images/css-IFC.jpg","hash":"c7fb8f083d6e4e0caf37f609add2bcaed350ec94","modified":1571102982499},{"_id":"source/images/css盒子模型.png","hash":"bf2bb7b9d57756a3c17d1e3489d16f13587a68b4","modified":1571102982500},{"_id":"source/images/http.png","hash":"b480d1f688799f35883518ef3f1351bc771095fd","modified":1571102982504},{"_id":"source/images/http代理.png","hash":"1449a4e05af7a7903d47ff550f5bd3b842d0bb03","modified":1571102982504},{"_id":"source/images/ipc-create.png","hash":"ff6ab7e391bfde80348ddb78cf44cba3414c53b0","modified":1571102982504},{"_id":"source/images/ipc.png","hash":"05e57f1b2769c3b824582179c1263c6aecac55da","modified":1571102982505},{"_id":"source/images/javascript-stack.png","hash":"8b16e3377ca35b8a78cb0c9a39b89540e51467f9","modified":1571102982505},{"_id":"source/images/javaScript.png","hash":"0064f030325083e62c7ee86e6b26b5c629d73d8c","modified":1571102982505},{"_id":"source/images/javascript-stack1.png","hash":"ffcf25a0a099b5c10f265c08c52752aaf76a35c0","modified":1571102982506},{"_id":"source/images/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1571102982511},{"_id":"source/images/linux.png","hash":"a2b16695f6f5b517dbbdca8b3fe3f26f1db95250","modified":1571102982511},{"_id":"source/images/master-worker.png","hash":"58bf93ce185d2e91967ae1a90e81f5e89a896d7a","modified":1571102982512},{"_id":"source/images/module-os.png","hash":"d9aa9a85e39cee0bffcd98274fbbcedda20ed146","modified":1571102982512},{"_id":"source/images/module-p.png","hash":"e28e8705eb1357beec46a0557bf51c3d4094a6d9","modified":1571102982512},{"_id":"source/images/module.png","hash":"68164b02e188e29d29344aa687ea6e2e73cd9bc0","modified":1571102982513},{"_id":"source/images/node.png","hash":"a5e96c9b079b38069529417b88ae28a745284c11","modified":1571102982513},{"_id":"source/images/php.png","hash":"b9c9e7c9042be1daa66fec971ff89774c7962579","modified":1571102982513},{"_id":"source/images/pointer-yinyong.png","hash":"dc47cfb50b6e9527fdf42459cdb8c198d891dc79","modified":1571129666631},{"_id":"source/images/process-on.png","hash":"d630c0f4b09b6a677b956376dc23bfc4f69e0149","modified":1571102982514},{"_id":"source/images/process-send.png","hash":"d79dbf894fe5c388a69fac3666c9f63920400e87","modified":1571102982514},{"_id":"source/images/prototype.png","hash":"5586538f0d2d9cfd12d173be694ba1a3803a304b","modified":1571102982515},{"_id":"source/images/react-jsx-children.png","hash":"01c61717d5321b236b64300412d37d88de653143","modified":1571102982515},{"_id":"source/images/render-module.jpg","hash":"64975e4502e09146eb8fa6decdf1cb9a18e2c442","modified":1571102982516},{"_id":"source/images/request.png","hash":"fd9be1b20518eadc3297f2de098a318a21e13a0f","modified":1571102982518},{"_id":"source/images/tcp.png","hash":"6a280c4905ee8656c6c76193b9595d822caacb08","modified":1571102982519},{"_id":"source/images/ts-lang.png","hash":"d74e4262805a053fb4a087295609153c26099d28","modified":1571102982520},{"_id":"source/images/typeScript.png","hash":"9500854a5014949a859627aeab4031ce04c17a54","modified":1571102982521},{"_id":"source/images/vue-core-index.png","hash":"23fcb56dd70c950fa00aeee266b500d0a7c725c4","modified":1571102982521},{"_id":"source/images/vue-dep.png","hash":"df84ba493c60d0e9c67acb6a1c464b5e2faec8ef","modified":1571102982522},{"_id":"source/images/vue-dom-diff01.png","hash":"e312c23ef9f74c9ae0fd075b5bd27b5b745de069","modified":1571102982522},{"_id":"source/images/vue-dom-diff02.png","hash":"8687ba820764127b63c8afa60ab70b7e5548add7","modified":1571102982523},{"_id":"source/images/vue-dom-diff03.png","hash":"a01a09d8a55e51dd0808b0ce1b70899222503d58","modified":1571102982523},{"_id":"source/images/vue-dom-diff04.png","hash":"856027eae0146dc5e9a59057dd473daf0623cc07","modified":1571102982524},{"_id":"source/images/vue-dom-diff05.png","hash":"f9b57a6cb9905e5cb7fdb1e8ec3d660e87742d93","modified":1571102982525},{"_id":"source/images/vue-dom-diff06.png","hash":"42f3f6d744fe350789dee667620e23f22a973c94","modified":1571102982525},{"_id":"source/images/vue-dom-diff08.png","hash":"284f9cc2fffc1816e6fb6a800ae7251888805015","modified":1571102982526},{"_id":"source/images/vue-dom-diff09.png","hash":"4b039f1ba6f09f7aee13ea416b10e9115d794457","modified":1571102982526},{"_id":"source/images/vue-dom-diff10.png","hash":"11dd275692f7242dd706f85ef537f9c3f558323c","modified":1571102982527},{"_id":"source/images/vue-folder.png","hash":"b25f5c35bfc74494791c5165e2b6a04a94455b3f","modified":1571102982530},{"_id":"source/images/vue-init.png","hash":"20917d3b1221f8189d8afe9c33ea5a2718e236c7","modified":1571102982531},{"_id":"source/images/vue-observer.png","hash":"9559c83aade65703cdf443ef88666f5227b5880b","modified":1571102982532},{"_id":"source/images/vue-process.png","hash":"b8b645b04e854b2fa1435a32d3fab55e8d42fdc8","modified":1571102982533},{"_id":"source/images/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1571102982534},{"_id":"source/images/websocket.png","hash":"dcb8ac2f57b208bdba0f23824f7a3ee275761d0d","modified":1571102982535},{"_id":"themes/matery/languages/default.yml","hash":"4be4158d800a5b1260b40c4d536d9fcf93faf82c","modified":1571102982540},{"_id":"themes/matery/languages/zh-CN.yml","hash":"8faa81effe45aea572a23dbaa39ba6cf6853845f","modified":1571102982541},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1571102982541},{"_id":"themes/matery/layout/archive.ejs","hash":"3cb5125e8243e82e96f8ca2fc30d3ec30390447f","modified":1571102982554},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1571102982554},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1571102982554},{"_id":"themes/matery/layout/category.ejs","hash":"41af886df5f0c3251e6ba810f43b9abbc900894b","modified":1571102982555},{"_id":"themes/matery/layout/friends.ejs","hash":"b9b75ff45324da5b4ddbb6e16ea1ecd239dbc310","modified":1571102982555},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1571102982555},{"_id":"themes/matery/layout/index.ejs","hash":"e920e19d370b6c218f89c86dc5baad4ff5b6f413","modified":1571102982555},{"_id":"themes/matery/layout/layout.ejs","hash":"f99d28f7c3382caf4321641f2d79582aac0b0c90","modified":1571102982556},{"_id":"themes/matery/layout/post.ejs","hash":"9ecae79690293cacdccc172118f1fe481705b1f2","modified":1571102982556},{"_id":"themes/matery/layout/tag.ejs","hash":"780e6b678ab9b81b5e1eee4193dd81101b52c545","modified":1571102982556},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1571102982556},{"_id":"source/images/cpu.png","hash":"ba4d72cd4b5c6acb9224fdc4b8d7d04cea8edebd","modified":1571123143264},{"_id":"source/images/event.png","hash":"f7bf62133be3c66694837bf62616b0474880f7eb","modified":1571102982503},{"_id":"source/images/html.png","hash":"95e9503f721a28aa6a1ab8496fea624ae180ac30","modified":1571102982503},{"_id":"source/images/library-react-lifecycle01.png","hash":"eedffc921f0c7d78a65065aa81e87d061ace9cb7","modified":1571102982507},{"_id":"source/images/library-react-lifecycle02.png","hash":"967b896a8ade58b47a3df231ae3aa14ea552eeea","modified":1571102982508},{"_id":"themes/matery/source/favicon.png","hash":"b20bab8ce1f2f7426a6960a7f0fd7cc06a923381","modified":1571102982558},{"_id":"source/images/TypeScript 编译原理.png","hash":"adf3c184f3d9fae5b155e642fa636eca451200a0","modified":1571102982497},{"_id":"source/images/event-loop.png","hash":"69b4d7bdbdbb112b8cf0deac2d16e8de25e2e3e0","modified":1571102982502},{"_id":"source/images/vue-lifecycle.png","hash":"02c466c84bc89bcaad6eb11b3dfd4c5b7917e3ec","modified":1571102982532},{"_id":"source/_posts/arithmetic/README.md","hash":"6d36f1d1da85937c2299d38533a99f2cd008c0cc","modified":1571192832612},{"_id":"source/_posts/arithmetic/TwoSum.md","hash":"9d3d8bd29d0c300a803459ee8eb451f3b8ea11ec","modified":1571109535196},{"_id":"source/_posts/arithmetic/data_structure.md","hash":"4ab24bdb0f64abf3cd9f9e60b868af6cb67b6d40","modified":1571207231770},{"_id":"source/_posts/arithmetic/pointer.md","hash":"c5db14b6abfdc567439103ffa7d7cea3467c7630","modified":1571195603227},{"_id":"source/_posts/html/html.md","hash":"f7e43a827786f82cd91e9b6bcdea26380886098a","modified":1571102982461},{"_id":"source/_posts/css/base-layout.md","hash":"0df6f8a3d30c9fcbcc3893489fe5ef7250c9d841","modified":1571102982459},{"_id":"source/_posts/css/base-concepts.md","hash":"81dea5c4a9f0ee60f42094b1ad23777905c961be","modified":1571102982459},{"_id":"source/_posts/css/css-animation.md","hash":"4bef0c715a8816dfd4b31c95aaba1bfb9b3fd284","modified":1571102982459},{"_id":"source/_posts/css/css-layered.md","hash":"513c10d6ee245dc8c5425d118561a3ec611ea4d8","modified":1571102982460},{"_id":"source/_posts/css/css-preprocessor.md","hash":"890fb7cf34a2486b856758fe38f16b35de456d5b","modified":1571102982460},{"_id":"source/_posts/javascript/Generator-Async.md","hash":"f4cacca4191dfef5223ffe94d17499fdf755d7d4","modified":1571102982461},{"_id":"source/_posts/javascript/bind.md","hash":"6c6f536f707e60de4ca5904f017dca9afc510231","modified":1571102982462},{"_id":"source/_posts/javascript/call.md","hash":"939213bf731761bdd249fd22c8ace4ad38d9dcc8","modified":1571102982462},{"_id":"source/_posts/javascript/closure.md","hash":"dc6732d2f6168a69bc4c210ecd81ab4b5bf15753","modified":1571102982463},{"_id":"source/_posts/javascript/debounce.md","hash":"51ed9b02072a7a5ae7786dcaa714c64e0b8b5bc1","modified":1571102982463},{"_id":"source/_posts/javascript/functionCurrying.md","hash":"8bd20a2db7e61ff024d63a113efed95ccbbbbac5","modified":1571102982464},{"_id":"source/_posts/javascript/drag.md","hash":"7aa37dba3cd1416a5310e0371b8c9e57c2cfaf68","modified":1571102982464},{"_id":"source/_posts/javascript/functionalCombination.md","hash":"8d738f49a902029a9b10145f935b09ebaa325dc9","modified":1571102982465},{"_id":"source/_posts/javascript/functionalBase.md","hash":"847d61ecb14253426d49c551ddcd124b6ca1d453","modified":1571102982464},{"_id":"source/_posts/javascript/functionalPoint.md","hash":"93cde5622e6643b7520a6bead0fb386751cbf89a","modified":1571102982465},{"_id":"source/_posts/javascript/functionalPurity.md","hash":"9e8a880afae0758e8b098552c96222cdfe4648b5","modified":1571102982465},{"_id":"source/_posts/javascript/inheritance.md","hash":"1ae119e725b37891feded4ea8726bbb071c45388","modified":1571102982465},{"_id":"source/_posts/javascript/json.md","hash":"31060d5d61332d1329ce8dd2cc8bcc534badf567","modified":1571102982466},{"_id":"source/_posts/javascript/new.md","hash":"43a6069dd358b35ff6b3cc58e0734436247e4246","modified":1571102982466},{"_id":"source/_posts/javascript/promise.md","hash":"5d5dcae4471f7f30bbe99886661ad73519fdb5b6","modified":1571102982466},{"_id":"source/_posts/javascript/prototype.md","hash":"19c2d0a1f6197113b79cae3610cb3ad1367ff5d4","modified":1571102982467},{"_id":"source/_posts/javascript/type.md","hash":"2c2b67b362fa449fa78736f597fcf083b44e09db","modified":1571102982467},{"_id":"source/_posts/javascript/this.md","hash":"ea2414770044a62dbae8cbd05ceeecd873f2df93","modified":1571102982467},{"_id":"source/_posts/javascript/voao.md","hash":"caabc65bda07740ac06550ffdb314d64d2e4b73d","modified":1571102982468},{"_id":"source/_posts/linux/fileauth.md","hash":"799b96fd32e6109657cda66d27df939cb59a5af2","modified":1571102982469},{"_id":"source/_posts/linux/compression.md","hash":"f3cc54c27b5493556836e76967e095f899cc30a3","modified":1571102982469},{"_id":"source/_posts/linux/backup.md","hash":"06f0ac257e7502fc6bcedec6b59fb9fca54fddf0","modified":1571102982468},{"_id":"source/_posts/linux/git.md","hash":"bfb52785c7a6caf607659bcaeaec062173874622","modified":1571102982469},{"_id":"source/_posts/linux/instructions.md","hash":"fc306daab0e626ac5cbcadec501df1d37db11281","modified":1571102982470},{"_id":"source/_posts/linux/package.md","hash":"1fcebe4cba2c9636831f7e3ba0e9dfb7e29fbee0","modified":1571102982470},{"_id":"source/_posts/linux/shutdown.md","hash":"b6ae585b56d36b6a0bfc39c301871d5ba5f66876","modified":1571102982470},{"_id":"source/_posts/linux/system.md","hash":"211b6255a5a888413f1ed3799b4f60e0235d36b4","modified":1571102982470},{"_id":"source/_posts/linux/user.md","hash":"2e46eeb0031b159537effa645b4f8ff07c0f175a","modified":1571102982471},{"_id":"source/_posts/linux/vim.md","hash":"c25e8e4b39956995b8d8275c25c08b48cb58f1aa","modified":1571102982471},{"_id":"source/_posts/node/crypto.md","hash":"3599783d88c1c7d12a3b5129f2e4c4a1d44f411d","modified":1571102982472},{"_id":"source/_posts/node/event.md","hash":"8fb9901a4d7e7624f8afbbb903b9044c7b340161","modified":1571102982473},{"_id":"source/_posts/node/error.md","hash":"72ee57b64f6802e90bba606d0170b8f5d31f18f9","modified":1571102982472},{"_id":"source/_posts/node/fs.md","hash":"b6d74199da872723f1042d448178f876786ce91a","modified":1571102982473},{"_id":"source/_posts/node/http.md","hash":"29b70c3439999d593441ae1629b524c53287c204","modified":1571102982473},{"_id":"source/_posts/node/module.md","hash":"38f6eaca70b74802d0398249fc6e056e9f61927d","modified":1571102982474},{"_id":"source/_posts/node/path.md","hash":"899a6df406186331bb87631ffbb90e4b78659e3a","modified":1571102982474},{"_id":"source/_posts/node/process.md","hash":"89d56631bb4da4df40dcf483c6a299c579d922c5","modified":1571102982474},{"_id":"source/_posts/node/querystring.md","hash":"51311203a4b15b673b5af7b3d1df1057b72663be","modified":1571102982475},{"_id":"source/_posts/node/url.md","hash":"7cdd471f9c77de1654c79e758888dafba37a38bb","modified":1571102982475},{"_id":"source/_posts/php/method.md","hash":"e60bfa2187729ec65d4eb725aaeb67361e834b40","modified":1571102982476},{"_id":"source/_posts/php/base.md","hash":"e5bf1d5c7101a3ddc9be350865493e0f6861815c","modified":1571102982476},{"_id":"source/_posts/php/oop.md","hash":"9a5974d5c6e4980a8f071cc024a9c5bb81e9b799","modified":1571102982476},{"_id":"source/_posts/react/library-react-jsx.md","hash":"57c67131745f536a0badd8073e801652c01d162b","modified":1571102982477},{"_id":"source/_posts/react/library-react-lifecycle.md","hash":"4983b204a8890879814ba38e38de0490a4a2adeb","modified":1571102982477},{"_id":"source/_posts/typescript/baseDataType.md","hash":"5cec52173c513ff939f93c6a477cede62cb66980","modified":1571102982478},{"_id":"source/_posts/typescript/class.md","hash":"dd4ce81c75021fbde265aeee64b7d633b3e98e4f","modified":1571102982478},{"_id":"source/_posts/typescript/compilationPrinciple.md","hash":"179fc36e0feb53e77b1284e36745d74a8c4125d7","modified":1571102982478},{"_id":"source/_posts/typescript/declareFile.md","hash":"c1b26749a927e24d77af3d1ad91afb92ab5346d6","modified":1571102982479},{"_id":"source/_posts/typescript/decorators.md","hash":"71e7a488875ee0cbc4a5c2a16ac4eb581880088b","modified":1571102982479},{"_id":"source/_posts/typescript/envConfig.md","hash":"2fe14965da03b3398ce5e4a2e7c5b71d5935ae18","modified":1571102982479},{"_id":"source/_posts/typescript/function.md","hash":"cdd4ff062ef213d50b664cb81dd9b5811d43e3e8","modified":1571102982480},{"_id":"source/_posts/typescript/generics.md","hash":"e4bba58970170d579d44d656a8775617a5011ea8","modified":1571102982480},{"_id":"source/_posts/typescript/global.d.ts.md","hash":"705b1c0e9b2aef345ef99496d7834c027dd70e2f","modified":1571102982480},{"_id":"source/_posts/typescript/interfaces.md","hash":"dc9ddcd37f1fc715a980d9e8e9c5f05aaf82a1d8","modified":1571102982481},{"_id":"source/_posts/typescript/mixinx.md","hash":"2e7e458e77a00f81fd2f21722bfac4da54dad318","modified":1571102982481},{"_id":"source/_posts/typescript/module-class.d.ts.md","hash":"bd2be8f45dd6f0766788725005cc7bad995e2181","modified":1571102982481},{"_id":"source/_posts/typescript/module-function.d.ts.md","hash":"ba61e1fd51512185351a46116d050ebe35e7ca88","modified":1571102982482},{"_id":"source/_posts/typescript/module.d.ts.md","hash":"8725c9b53e147663474e375aee6d18483118d8b0","modified":1571102982482},{"_id":"source/_posts/typescript/module.md","hash":"8e7f11754fcc1e5fce4cebf566ea3ca534e10bfe","modified":1571102982482},{"_id":"source/_posts/typescript/test.ts","hash":"871bca543429e15201ad8d0de580cf51619a4125","modified":1571102982483},{"_id":"source/_posts/typescript/tsConfig.md","hash":"4e69b050fbf5ef5d3a86257810b6a86ae19afd44","modified":1571102982483},{"_id":"source/_posts/vue/vueAsync-component.md","hash":"0b568ed60bac47db109547ebb09c0f86b0765320","modified":1571102982484},{"_id":"source/_posts/vue/vueComUpdate.md","hash":"cd23d442ad817a8775034eff8c6cb2f1918eec89","modified":1571102982484},{"_id":"source/_posts/vue/vueCompile.md","hash":"ab043778a1645beac371df79c4471aae2162aafa","modified":1571102982485},{"_id":"source/_posts/vue/vueComponentRegister.md","hash":"5c086716d97b8f48973f071db98a550d7b5424c1","modified":1571102982485},{"_id":"source/_posts/vue/vueComponents.md","hash":"dc39b379a3c16a545ebb700c14605bca5e152b9c","modified":1571102982485},{"_id":"source/_posts/vue/vueComputedWatcher.md","hash":"2061eeef0968822d7e21e157cb4ab8d25098c174","modified":1571102982486},{"_id":"source/_posts/vue/vueKeepAlive.md","hash":"18343cc3e6ff81554a1af766256475a5b7077218","modified":1571102982486},{"_id":"source/_posts/vue/vueLifecycle.md","hash":"45f5f2a8f087b8fb5e84f3f23976fe3d192e19e6","modified":1571102982486},{"_id":"source/_posts/vue/vueObserve.md","hash":"531e77ff2ff8ee5ad8860c316015b73691de4ee4","modified":1571102982487},{"_id":"source/_posts/vue/vuePrinciple.md","hash":"751a203bea74296ea9605290b9422368d145af9c","modified":1571102982487},{"_id":"source/_posts/vue/vueRouter.md","hash":"7418097e9f8b72c14d49081e060573900ffedfd1","modified":1571102982488},{"_id":"source/_posts/vue/vueVModel.md","hash":"7684a099f154a11df999ed790bc2f20f02cf0e52","modified":1571102982488},{"_id":"source/_posts/vue/vuex.md","hash":"0a3a3837af5c412380f1853ec4cdfd2e79a556d6","modified":1571102982488},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1571102982542},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1571102982542},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"6bf708dbd705b486bc464e9be8e8834bbd692850","modified":1571102982542},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1571102982543},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"ef827b2e35d49139292e3c17c0a935c4577c88b5","modified":1571102982543},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"2391e40c2a12abb976f7c0974c81261657635325","modified":1571102982544},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1571102982544},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1571102982544},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1571102982545},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"8de86229bb38d857b6f6c01c5095329a23e5bcc2","modified":1571102982545},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1571102982545},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"b3c7663d46f13ec997e314004995c2caa8db442e","modified":1571102982545},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"8e4f8158a65843f7b4e5cde81c634ed181ee0667","modified":1571102982546},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1571102982546},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"33c882dc2575739df042297f0ffa80d89ac10cd0","modified":1571102982546},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1571102982547},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"ae8a8db3f0d630e92cf70cfcb3a9afb026b1395a","modified":1571102982547},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1571102982547},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1571102982548},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1571102982548},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e6476c86ce108794b6fce57e69e3cd29f7d4f26","modified":1571102982548},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1571102982548},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1571102982549},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1571102982549},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1571102982549},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"531e7f7972f820793415ee12f8a726cd7f86912e","modified":1571102982550},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"8671cff27aef7298b2518dd57fe0671959f21701","modified":1571102982550},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1571102982550},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1571102982550},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"2af85ddef6e61a44cbe10e8f6272a8324681ee3f","modified":1571102982551},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1571102982551},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1571102982551},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1571102982551},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1571102982552},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1571102982552},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1571102982553},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1571102982553},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"62df3af8007302a4173031a6656f6147fa2ee5da","modified":1571102982553},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1571102982553},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1571102982554},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1571102982556},{"_id":"themes/matery/source/css/matery.css","hash":"0ed1cdf1da51419eb684e622fe5a5d0c5c0991f2","modified":1571102982557},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1571102982557},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1571102982557},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1571102982558},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1571102982559},{"_id":"themes/matery/source/medias/logo.png","hash":"1569d7d0d096feece4a0b2fa627ac4ce7acb7fd7","modified":1571102982616},{"_id":"source/images/css-dom-render.jpg","hash":"154deb251505d145c93b2a0dd6cf44e8ba3c3678","modified":1571102982500},{"_id":"source/images/dom-render.jpg","hash":"7eeed9bff9d46f498fe95cfd698e8e60710647ea","modified":1571102982501},{"_id":"source/images/pointer.png","hash":"0684d698c49bb4a12f0f941ec3e165626c5d5edc","modified":1571128516534},{"_id":"source/images/render-process.jpg","hash":"d9bde85e73c48b1c7289a601e24f52f3a25f1d43","modified":1571102982517},{"_id":"source/images/vue-dom-diff11.png","hash":"71832563c37aadeb61be4602bfde2d1596b94930","modified":1571102982529},{"_id":"source/images/vue-dom-diff12.png","hash":"86ff43f1ee3510f3d2a011da957fe1d206ce1f16","modified":1571102982530},{"_id":"source/_posts/javascript/api.md","hash":"553cc88656842d805ca5d9df6d1698d1a4b86b41","modified":1571102982462},{"_id":"source/images/render-tree.jpg","hash":"3326b141b427915d4fef9476d1ae3139df589113","modified":1571102982518},{"_id":"source/images/timestamp-diagram.svg","hash":"59228be9d502f05e0a5601b1f1ee71a5570d4902","modified":1571102982520},{"_id":"source/images/vue-vmodel.png","hash":"9adb23e04bdb3a6bfc6943b477fc82685e2133a0","modified":1571102982534},{"_id":"source/images/圣杯布局.gif","hash":"137d4f2207b255d31a2517bf52473f06f281a885","modified":1571102982536},{"_id":"source/images/自适应两栏布局.gif","hash":"8f2f6aa4cf40724b9d27e6f49ff1d66d7b076b42","modified":1571102982537},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1571102982559},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1571102982560},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1571102982560},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1571102982561},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1571102982569},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1571102982570},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1571102982572},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1571102982573},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1571102982574},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1571102982574},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1571102982580},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1571102982581},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1571102982582},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1571102982582},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1571102982586},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1571102982586},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"edfd4164885baf5d7bb5c8de6ced3a5d0e10b93b","modified":1571102982588},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"4225465807e1fc33c4819d79d9a48eb0257d857d","modified":1571102982590},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"986ae5b11ce9d157150eb2793fcb9243920768fc","modified":1571102982595},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"78250e8418cbc7d89272ccb3b97e4ca196514095","modified":1571102982596},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"48b6bca92dac83f9447a34d9f53698f7c3b8c548","modified":1571102982596},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"0d97dc07a380b54190910e82088177ae0f987b2d","modified":1571102982596},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"5150977f5755b57c47d5e6ff8d6460a29484b254","modified":1571102982597},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"5b9d68323520c1a029c4bdb3ce551c3dd82266fd","modified":1571102982597},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"d135f58dabe1e3896783313b65f1ba0cd77209d7","modified":1571102982598},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"19cca40728c936aafb41f94358a8aae7682ff8b2","modified":1571102982598},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"7d9ca7886fc340a20120c79d79554fca966a0173","modified":1571102982599},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"19e379a9384532667ca1fde405400955b86d7989","modified":1571102982599},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"427a9a8068bb1301393c84d332c080c9ddfbc445","modified":1571102982599},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"398b1e824baa404e1da212712baeef951b391096","modified":1571102982600},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"b0db8f7e05c0b3e8d379a32cddcf5a31506b48fe","modified":1571102982600},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"5debdaf99b1b304aaa3a5b8bfaf1c15913961625","modified":1571102982601},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"83a5f0346d5d09cb6ee40c61f5ae0b7084084cb9","modified":1571102982601},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"e2b55d8c0105ab833ef1b17de212b4bf3b23f977","modified":1571102982601},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"58d0d034b1352a41ff5f257ffab0b4a5ed6cf008","modified":1571102982602},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"b6de14f0421aef87b08215e161621d4ac20306b1","modified":1571102982602},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"1e68849e3d90b313f3c1f3817a7e2f348f4d941c","modified":1571102982602},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"833ddda3c5db3f3d1752633f0dba8e94d242b105","modified":1571102982603},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"62784ad9f69d49a0c90b531aff4e8a9e8b945e9d","modified":1571102982603},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"d386afb274d345e628251c557002558bc50a641c","modified":1571102982604},{"_id":"themes/matery/source/medias/featureimages/29.jpg","hash":"5d3e4ac5a43cea177ce0802b2506cc26a946f0f2","modified":1571102982604},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"943b167a9ecab3bf7309b233831269e939cfab93","modified":1571102982604},{"_id":"themes/matery/source/medias/featureimages/30.jpg","hash":"3384b49f86da5e71c4a341f93b75569c5aefcc6f","modified":1571102982605},{"_id":"themes/matery/source/medias/featureimages/31.jpg","hash":"758361a87a3ea1b5cdaf39b82c58cd5c9879e972","modified":1571102982605},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"7c7d6d366851025796fef8edaa17ed9276aa1f60","modified":1571102982614},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"fc23dd41463142543467e8da280e32f4f030115b","modified":1571102982614},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"7e497f9b7cd6ecc1af517a2bd54363afc297f677","modified":1571102982614},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"f0f370e6fdea794a60175cf36b8914815448bd37","modified":1571102982615},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"f9666a41d2d442e61d20199c5cad4543696a8bce","modified":1571102982615},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"319dcdaca9b33e7d6b161825ba936ec7f9d3b232","modified":1571102982616},{"_id":"source/images/library-react-lifecycle03.jpg","hash":"8b2dccba7fe18bf7c034a65b3c8bb348b46a9c4c","modified":1571102982509},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1571102982561},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1571102982570},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1571102982575},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"6979c760beb550b681a06a8f11688f2d1591a70e","modified":1571102982587},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"7273c89d119ed9e73e3212972670d7ea40cef071","modified":1571102982799},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"e4b6c7007108bc3631372cf2b028803c4cc8e671","modified":1571102982800},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1571102982562},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"9d5dd7e092c8eaf6266e2498cff72e6c98790a05","modified":1571102982572},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1571102982573},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1571102982576},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1571102982576},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1571102982576},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1571102982577},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1571102982578},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1571102982578},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1571102982578},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1571102982578},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1571102982580},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"80ae4aa0dba3634dd9bf59586d541d2dd8d8191c","modified":1571102982581},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1571102982583},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1571102982583},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1571102982583},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1571102982584},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1571102982584},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1571102982585},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1571102982586},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1571102982587},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"778f287dfea4b4b707e75add4dfcb4be96f94a66","modified":1571102982590},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"d550bf0803c2ec347b5047a209cde47a5e3e7478","modified":1571102982591},{"_id":"source/images/library-react-lifecycle04.jpg","hash":"54d5358c4882c79380aff712f049a01ae030d169","modified":1571102982510},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1571102982577},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1571102982581},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"90074183570e58bf4cc5a19a21ce0c8456970e8a","modified":1571102982592},{"_id":"themes/matery/source/medias/music/avatars/zhaolei.jpg","hash":"3fd850b1b14c3065da53f52adba606c9b94d6f91","modified":1571102982620},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1571102982569},{"_id":"themes/matery/source/medias/music/avatars/maliang.jpg","hash":"99bbcdb66a9c5313d4fe4b92eeaead42c2515fa1","modified":1571102982619},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1571102982568},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1571102982563},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1571102982564},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"18788ca08a0ca8a0dca90baed8bc59f38e43cc9e","modified":1571102982589},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"89c2be390083e9a6ca417728a9cc89d740c37bb4","modified":1571102982594},{"_id":"themes/matery/source/medias/featureimages/35.jpg","hash":"677436212d24cd0092e720051d90f73d0e57e8f2","modified":1571102982613},{"_id":"themes/matery/source/medias/music/avatars/chenhouyu.jpg","hash":"ce5a90ff7c84b8a5e3e56236783fa6806e1f1498","modified":1571102982617},{"_id":"source/images/CSS.png","hash":"b84ac2e337ebbbeaf01b62d9876cc83fbd09aee0","modified":1571102982494},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1571102982567},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"880581d92a6e9aff2b7e3f0bc537eda760565e5f","modified":1571102982593},{"_id":"themes/matery/source/medias/featureimages/33.jpg","hash":"ba0282364c03af5c37e8b2d4a984e5f7c2ff81d4","modified":1571102982610},{"_id":"themes/matery/source/medias/featureimages/34.jpg","hash":"7b4cd1b5b2be38865a2c407b728a2ab12b167cd7","modified":1571102982612},{"_id":"themes/matery/source/medias/music/avatars/laofan.jpg","hash":"5117ed92c8175825b9116716bb4005cf7d5c09c6","modified":1571102982618},{"_id":"themes/matery/source/medias/featureimages/32.jpg","hash":"15a3a72b8e12093a83babba11ba21b8660291f68","modified":1571102982608},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1571102982566},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1571102982571},{"_id":"themes/matery/source/medias/music/wanghouyusheng.mp3","hash":"c6a9203f13c4021c34d012fa8f2e3d3a713603b4","modified":1571102982738},{"_id":"themes/matery/source/medias/music/lixiangsanxun.mp3","hash":"3830afc5553bf36e04cadcd5c0d060e1a838fbbc","modified":1571102982702},{"_id":"themes/matery/source/medias/music/hua.mp3","hash":"6ed72d5b959a236deeaf9cbee66bd29f74cffb14","modified":1571102982663},{"_id":"themes/matery/source/medias/music/yongbaoni.mp3","hash":"4422fc80bafc7ae3e5f03af1ec38cb0f6f15bf7e","modified":1571102982798},{"_id":"public/baidu_urls.txt","hash":"4d4d128c8d035e5cc2ada28a6808f1a62a900262","modified":1571207273450},{"_id":"public/atom.xml","hash":"452e3e604015656a1f63573de173ccae87a86bf2","modified":1571207273456},{"_id":"public/baidusitemap.xml","hash":"74e958a0621398e350701b81f585c7dfe59eda6e","modified":1571207278787},{"_id":"public/search.xml","hash":"38413e2e0fccc71fca487521a52e04adf42939c6","modified":1571207279144},{"_id":"public/sitemap.xml","hash":"f23c5e66bd95567de3e2fc4933cf9d7e18da3739","modified":1571207279147},{"_id":"public/404.html","hash":"ed12a79d7b106107832f980f44bdc0d028303dd1","modified":1571207279229},{"_id":"public/about/index.html","hash":"639a3a7cc644eff8642f4da541a921c7a21405cf","modified":1571207279229},{"_id":"public/categories/index.html","hash":"88b6242f46b3ddd480fa3861edbec3809468ac96","modified":1571207279230},{"_id":"public/tags/index.html","hash":"0d0d338f25d4046eb247deabc85efdd69320bc50","modified":1571207279230},{"_id":"public/friends/index.html","hash":"6daa1f645ce556aacb2f4b4146135c2c30d83ccc","modified":1571207279230},{"_id":"public/archives/index.html","hash":"c95cf05570cec919a1dc481272cfa5404cd153ed","modified":1571207279230},{"_id":"public/2019/10/16/arithmetic/data-structure/index.html","hash":"d5361fcfa73ae406571a89f801309fe9e29ac467","modified":1571207279230},{"_id":"public/2019/10/15/arithmetic/pointer/index.html","hash":"4cd94cd5bfcaf7c96db2ada213542be8799a504b","modified":1571207279230},{"_id":"public/2019/10/15/arithmetic/twosum/index.html","hash":"d0661692f63e096f2bd61b941bffd3f77f90185b","modified":1571207279230},{"_id":"public/2019/10/15/arithmetic/readme/index.html","hash":"49c6c66c6649ed54ebf3293573df5533a386aed7","modified":1571207279230},{"_id":"public/2019/10/02/react/library-react-lifecycle/index.html","hash":"2ca6be1b75bb0a30b09e566f645947604e6c7a3d","modified":1571207279230},{"_id":"public/2019/10/01/react/library-react-jsx/index.html","hash":"7310a2067ee675b9dfb921981a010ff18f08d6d7","modified":1571207279230},{"_id":"public/2019/09/22/vue/vuekeepalive/index.html","hash":"258ca29664e783c05a08e1c8c1f2d2ded8b1ece9","modified":1571207279230},{"_id":"public/2019/09/21/vue/vuelifecycle/index.html","hash":"7e845669b951b9e68f10186604badb3cef1309a8","modified":1571207279230},{"_id":"public/2019/09/21/vue/vuecomponents/index.html","hash":"99af80c8a296d806029dbe6d7a5f474fa95d6e22","modified":1571207279230},{"_id":"public/2019/09/19/vue/vuecompile/index.html","hash":"dcd150d5b2708dd2a4203646dd4afdf965f618e1","modified":1571207279230},{"_id":"public/2019/09/18/vue/vuecomupdate/index.html","hash":"522177e94d25b05cac5497f2a57a499c4001a0ab","modified":1571207279231},{"_id":"public/2019/09/12/vue/vuevmodel/index.html","hash":"e2a3fa2076406fcb0fe4ceaec134a674f606c61b","modified":1571207279231},{"_id":"public/2019/09/10/vue/vueasync-component/index.html","hash":"6b27ab1abfd2fe9ce6da996a187a252c03f527c9","modified":1571207279231},{"_id":"public/2019/09/08/vue/vuecomponentregister/index.html","hash":"342b0bab371b24681ba26036078018aceca0d737","modified":1571207279231},{"_id":"public/2019/09/07/vue/vuecomputedwatcher/index.html","hash":"7dade43b70d97ccc7b6fdd54af26c1bc9bdcf89d","modified":1571207279231},{"_id":"public/2019/09/05/vue/vueobserve/index.html","hash":"56be0000615cda3dafd3e338355d20d87f33a3bd","modified":1571207279231},{"_id":"public/2019/08/27/vue/vueprinciple/index.html","hash":"ef354620d2242258632f9d3e8425d43df329bb61","modified":1571207279232},{"_id":"public/2019/08/26/javascript/generator-async/index.html","hash":"ec9ea639da868f433299c5ca761e3cd12911eef2","modified":1571207279232},{"_id":"public/2019/08/15/typescript/module-function.d.ts/index.html","hash":"968ac1af844a3f830aa2285baf005b456c05ea19","modified":1571207279232},{"_id":"public/2019/08/15/typescript/global.d.ts/index.html","hash":"ec57285f6c02752e7e860a36af885af4f2e34a33","modified":1571207279232},{"_id":"public/2019/08/15/typescript/module-class.d.ts/index.html","hash":"e0782bd461ce7ae59b55bc0489e7809f2f23153f","modified":1571207279232},{"_id":"public/2019/08/15/typescript/module.d.ts/index.html","hash":"a2f261a3e775d53e24ed9b38703f2b8bfe6b2909","modified":1571207279232},{"_id":"public/2019/08/05/typescript/compilationprinciple/index.html","hash":"fa492fa75009cb635d1a6b7dadc2aea408078f9a","modified":1571207279232},{"_id":"public/2019/07/25/javascript/functionalpoint/index.html","hash":"63290203369e0cb516e848afa03280601fa008ab","modified":1571207279232},{"_id":"public/2019/07/22/javascript/functionalcombination/index.html","hash":"87afe7d6938ca1e917b1b3991d0604ae40def00f","modified":1571207279232},{"_id":"public/2019/07/18/typescript/decorators/index.html","hash":"6f84685d58f506e73287ca2f60e01a7032a3764d","modified":1571207279232},{"_id":"public/2019/07/17/javascript/functioncurrying/index.html","hash":"cc5c5f215c17492e2f05c7aef216bd5e2d307cf9","modified":1571207279232},{"_id":"public/2019/07/15/typescript/tsconfig/index.html","hash":"1c1f9635af63083a51935593c2905e82272e45f7","modified":1571207279232},{"_id":"public/2019/07/15/javascript/functionalpurity/index.html","hash":"cc6734a71928ac9e968f3c881cc748a8602195c3","modified":1571207279232},{"_id":"public/2019/07/12/javascript/functionalbase/index.html","hash":"7ec01c620fd51c6c16ba8720379297002cd7a91a","modified":1571207279232},{"_id":"public/2019/07/02/typescript/mixinx/index.html","hash":"05ad2afbc8e4040a666c5746cee32b9ca346a572","modified":1571207279232},{"_id":"public/2019/06/20/typescript/declarefile/index.html","hash":"38ef93e770cd61a87475a8a4f660547bf1207ae6","modified":1571207279233},{"_id":"public/2019/06/15/typescript/module/index.html","hash":"9c880b06995944c501a69944095fa3cd279b61a0","modified":1571207279233},{"_id":"public/2019/06/11/javascript/promise/index.html","hash":"bb8a2357728e2595ae440f13e548f4d2681d96aa","modified":1571207279233},{"_id":"public/2019/05/23/typescript/basedatatype/index.html","hash":"1ed8a5f13a16ba88ccf06b1f10b9ed17603b8763","modified":1571207279233},{"_id":"public/2019/05/22/typescript/generics/index.html","hash":"ec05e3edf29144773b0bd081a98ebd2fe41a8cbd","modified":1571207279233},{"_id":"public/2019/05/18/typescript/interfaces/index.html","hash":"1ebcab7ad1fd48bec577c3dc0a2147e562fe3fd0","modified":1571207279233},{"_id":"public/2019/05/17/typescript/class/index.html","hash":"e210fe1cfbfd154b1f0764e1fad2d35dfbc63691","modified":1571207279233},{"_id":"public/2019/05/16/typescript/function/index.html","hash":"b7ba032067faaf97c38e9a2f119833c0693be843","modified":1571207279233},{"_id":"public/2019/05/15/typescript/envconfig/index.html","hash":"f9a87b51e92fd3eaa519685bdede6f35e36a35a3","modified":1571207279233},{"_id":"public/2019/05/15/javascript/debounce/index.html","hash":"6cb007b1e29e44c777c946074d46f1d030f11dab","modified":1571207279233},{"_id":"public/2019/05/11/javascript/json/index.html","hash":"c5157e5fa69bdbf89b45aeb62fa504cc053f6958","modified":1571207279233},{"_id":"public/2019/04/27/javascript/new/index.html","hash":"ad368471e52e8dcd103461f100a0db5c6ba2b2fa","modified":1571207279233},{"_id":"public/2019/04/22/javascript/call/index.html","hash":"87fb801d05f939c2d19c4c2d4ffa21fd95d35e09","modified":1571207279233},{"_id":"public/2019/04/21/javascript/bind/index.html","hash":"e0590257d78db735dbc681c973fa6e6273d5530f","modified":1571207279234},{"_id":"public/2019/04/14/node/error/index.html","hash":"58986933ad1de92103b8d15b806523dd1d44c6af","modified":1571207279234},{"_id":"public/2019/04/12/node/process/index.html","hash":"cee51e238229db33871c3bc3b30fae24a9db9cd2","modified":1571207279234},{"_id":"public/2019/04/10/node/event/index.html","hash":"e00aaaabe92751108330dd7a69a528cd7e09575c","modified":1571207279234},{"_id":"public/2019/04/09/javascript/drag/index.html","hash":"24527cb3c09900e0ab8bf7185233af837867dc72","modified":1571207279234},{"_id":"public/2019/04/08/node/crypto/index.html","hash":"3df6b170c1a15d6cfeb738c22df681ebacaa93a9","modified":1571207279234},{"_id":"public/2019/04/05/node/module/index.html","hash":"534d28b86a73ea713fcd65da41fae9474e2e3c27","modified":1571207279234},{"_id":"public/2019/04/04/node/querystring/index.html","hash":"3a87a9ee09b709bc86251984b88479323ac5cd50","modified":1571207279234},{"_id":"public/2019/04/02/node/path/index.html","hash":"24218604957cefe63d9a290ed56dbd1ba55b2670","modified":1571207279234},{"_id":"public/2019/04/01/node/fs/index.html","hash":"a851d46126442e8d143011494558f10d60b5fd32","modified":1571207279234},{"_id":"public/2019/03/23/node/http/index.html","hash":"8de0c896fde501cfe1c5be7ae65c1b06fc127939","modified":1571207279235},{"_id":"public/2019/03/28/node/url/index.html","hash":"809716a0c4e78a2b2acbaa4912872aaa9e3ac0a1","modified":1571207279235},{"_id":"public/2019/03/20/javascript/api/index.html","hash":"924765f928926280788b403026bafd4a0cc17ec1","modified":1571207279235},{"_id":"public/2019/03/15/javascript/inheritance/index.html","hash":"dc4e4509678c004e9127b2f32ab301d685c8233d","modified":1571207279235},{"_id":"public/2019/03/10/javascript/prototype/index.html","hash":"67172d7b018aea63257114c098e3dcf13992b9db","modified":1571207279235},{"_id":"public/2019/03/05/javascript/this/index.html","hash":"f60c06aa9174b35599473b4cda6a5dbe19025f8c","modified":1571207279235},{"_id":"public/2019/02/25/javascript/closure/index.html","hash":"6fd5ab68a0f01001bcc255b2b9f155b87fb5032c","modified":1571207279235},{"_id":"public/2019/02/20/javascript/voao/index.html","hash":"c9120d40301840fb2834ba69b9e7a8dda637c235","modified":1571207279235},{"_id":"public/2019/02/12/javascript/type/index.html","hash":"82c7760a163af35c9280c07e3ce90170fe34dc4e","modified":1571207279235},{"_id":"public/2018/08/10/linux/git/index.html","hash":"d3a49b023dcd0bb769beba15b96a984c53818624","modified":1571207279235},{"_id":"public/2018/09/10/vue/vuex/index.html","hash":"f5d20421e5334fcc04db82927677e9b73a20b705","modified":1571207279235},{"_id":"public/2018/07/28/linux/vim/index.html","hash":"780477166566f336dcde7ac7e2e21c541c7fd80e","modified":1571207279235},{"_id":"public/2018/08/10/vue/vuerouter/index.html","hash":"c417f916af258888e2a380c80fe130896285d88e","modified":1571207279235},{"_id":"public/2018/07/25/linux/fileauth/index.html","hash":"a8ae7da477bfca7add0f910733a75b7fc142cca1","modified":1571207279236},{"_id":"public/2018/07/22/linux/user/index.html","hash":"e8dc10ed9f2f61a58578617721e75f60f46338a9","modified":1571207279236},{"_id":"public/2018/07/16/linux/shutdown/index.html","hash":"b4e4497f793763d6f6ec98aeb577515cd828ee45","modified":1571207279236},{"_id":"public/2018/07/15/linux/backup/index.html","hash":"5ab47fa56d9d146694c3507835c5a01a270f66c2","modified":1571207279236},{"_id":"public/2018/07/12/linux/package/index.html","hash":"d60fdfb6da5e80d8127446a921a4a3cada04c6c4","modified":1571207279236},{"_id":"public/2018/07/10/linux/compression/index.html","hash":"c66e7418b5d719b4f20340d83ad692cbd17d62c0","modified":1571207279236},{"_id":"public/2018/07/02/linux/system/index.html","hash":"16c1d6cd408189ee9a269783b2683f4e9b75ae1e","modified":1571207279236},{"_id":"public/2018/06/23/linux/instructions/index.html","hash":"dceb6e6906a762ac0238a4166c86506cb4264f76","modified":1571207279236},{"_id":"public/2017/07/01/css/css-preprocessor/index.html","hash":"9841973ab23f64d3c392b4b5f88a3c6136f49a8b","modified":1571207279236},{"_id":"public/2017/06/22/css/css-layered/index.html","hash":"44861c4d6d09f9ded8f27fcc7eaacdc359c7c0a5","modified":1571207279236},{"_id":"public/2017/06/20/css/css-animation/index.html","hash":"26830979cefd998a30f69ed6464d3105e6cd37c3","modified":1571207279236},{"_id":"public/2017/06/15/css/base-layout/index.html","hash":"01263a4654b187ad679659b92eb86c93f423c826","modified":1571207279236},{"_id":"public/2017/06/11/css/base-concepts/index.html","hash":"387409e934c814fe7ea0911a752bbf40e3673c6d","modified":1571207279236},{"_id":"public/2017/05/10/html/html/index.html","hash":"87053f197b223852646bc32501f80e82db6f429a","modified":1571207279236},{"_id":"public/2017/01/23/php/oop/index.html","hash":"5ac6cb357f0642353b7eb00c1991bda524977b26","modified":1571207279236},{"_id":"public/2017/01/23/php/base/index.html","hash":"f2b1e93f7b238ef8c5ab1f6309d96a54a2b2be06","modified":1571207279237},{"_id":"public/2017/01/23/php/method/index.html","hash":"ba067ee8958a6eb9f157432411dde3cb9abac3ef","modified":1571207279237},{"_id":"public/archives/page/2/index.html","hash":"26f591d4535c91385ce8c550bb3c3d91aba18bb9","modified":1571207279237},{"_id":"public/archives/page/3/index.html","hash":"e422b905658645dd9dbe595ca5f841bf3b9c9fd1","modified":1571207279237},{"_id":"public/archives/page/4/index.html","hash":"7da3eef2be0b6546de608f98bac0966031e69004","modified":1571207279237},{"_id":"public/archives/page/5/index.html","hash":"9d3a7075b9fb1b95976768fbf02e9ea86bec4b0f","modified":1571207279237},{"_id":"public/archives/page/6/index.html","hash":"597f9fb2c0361db7bb2e6df78e392efc9aad9ec3","modified":1571207279237},{"_id":"public/archives/page/7/index.html","hash":"7c6ff78beaf082cb85b56bf9c9005f517c18c5ba","modified":1571207279237},{"_id":"public/archives/2017/index.html","hash":"4afea54237c2a52865c332ea212f990f69e6f9f5","modified":1571207279237},{"_id":"public/archives/2017/01/index.html","hash":"19496d113596e4f44f16d9ef3b60bbdd9e36fbeb","modified":1571207279237},{"_id":"public/archives/2017/05/index.html","hash":"89949559e6e34459e3bd55daadbbb4cf10289df5","modified":1571207279237},{"_id":"public/archives/2017/06/index.html","hash":"f5f95cde7de309301c4212d4256d79a0e1c448be","modified":1571207279237},{"_id":"public/archives/2017/07/index.html","hash":"8adfed4a7be78528e5b49bd7f8f5cedc69e9a44d","modified":1571207279237},{"_id":"public/archives/2018/index.html","hash":"b961e79d3da7a1d60238c1fc89a33570ccd05230","modified":1571207279237},{"_id":"public/archives/2018/06/index.html","hash":"aedce94ced57b577f872bf13fe968b94092a0289","modified":1571207279237},{"_id":"public/archives/2018/07/index.html","hash":"d67a7c82cf348c70163fe51109e49904e42696c3","modified":1571207279237},{"_id":"public/archives/2018/08/index.html","hash":"535b602e08e52776b066f2a7b1de615e7920e820","modified":1571207279238},{"_id":"public/archives/2018/09/index.html","hash":"dff4ab5ce8684725729e558f6cb9ae32d480e83d","modified":1571207279238},{"_id":"public/archives/2019/index.html","hash":"38415deb08147db17c05e318b1d6ce9ee44c7b64","modified":1571207279238},{"_id":"public/archives/2019/page/2/index.html","hash":"c4babf1ca0279affd7ab23204be069c0def7f21b","modified":1571207279238},{"_id":"public/archives/2019/page/3/index.html","hash":"831c5577b8f653d59d5acadb7009836c6662525b","modified":1571207279238},{"_id":"public/archives/2019/page/4/index.html","hash":"ad670a2de84e280f17fdf51c9d7a408deba7acac","modified":1571207279238},{"_id":"public/archives/2019/page/5/index.html","hash":"57649775173523c301336476dee5209c4fa1349d","modified":1571207279238},{"_id":"public/archives/2019/page/6/index.html","hash":"dddaccbcc378ae23a4789f367d9b9be72b1e8508","modified":1571207279238},{"_id":"public/archives/2019/02/index.html","hash":"7cebefde55fec1426431390e76e8484dbb26691e","modified":1571207279238},{"_id":"public/archives/2019/03/index.html","hash":"535e94c7ed746e0a7ca589f27f85e8de5bdcdaf0","modified":1571207279238},{"_id":"public/archives/2019/04/index.html","hash":"f911d59f3b90788c32584ab8cb45f20393c03756","modified":1571207279238},{"_id":"public/archives/2019/05/index.html","hash":"c2fc4c8af606117702acd875c1d7132fd8c28fd8","modified":1571207279238},{"_id":"public/archives/2019/06/index.html","hash":"228ef5b4425cc9971931dc93fdccbb20bd044849","modified":1571207279238},{"_id":"public/archives/2019/07/index.html","hash":"06976d1d6aaf87c914a72ca01eccdc067540257e","modified":1571207279238},{"_id":"public/archives/2019/08/index.html","hash":"1ab2ee2d9d22c94c3fc567a29795048f49cd99d6","modified":1571207279238},{"_id":"public/archives/2019/09/index.html","hash":"5d68eab9cb9959828f135cdd117fb3a2e20f1ddb","modified":1571207279238},{"_id":"public/archives/2019/10/index.html","hash":"7b82ae5af1be6e19b9b97128cb4b78af5fd2e5a0","modified":1571207279238},{"_id":"public/categories/HTML/index.html","hash":"f672f2abdf36b00a7b8c654d30f595c207ecf833","modified":1571207279238},{"_id":"public/categories/CSS/index.html","hash":"3d2cf0cd859f26ebf5c2fb3e97c9465d90d5aa1f","modified":1571207279238},{"_id":"public/categories/JavaScript/index.html","hash":"5b54c87bf6d13eedab00fa4c337554c1d9601790","modified":1571207279238},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"f4e37b5939f37462d1320dc9b744110bdb593826","modified":1571207279239},{"_id":"public/categories/函数式编程/index.html","hash":"a12b294331145b801c285e28e2158f33a272d6b2","modified":1571207279239},{"_id":"public/categories/Linux/index.html","hash":"6ae2b4b0b692ceb64f8a5d7edb428f60b6e5c3af","modified":1571207279239},{"_id":"public/categories/Node/index.html","hash":"7e80ef7b7bf33d614c279f90aea3f23cd9f1d82d","modified":1571207279239},{"_id":"public/categories/PHP/index.html","hash":"5a3659ef9cbadf538065597c283de61ed67231fc","modified":1571207279239},{"_id":"public/categories/TypeScript/index.html","hash":"cabcc09e464892388713c703eadd3d6ca612fa90","modified":1571207279239},{"_id":"public/categories/TypeScript/page/2/index.html","hash":"e07e4f8d98bb4fc0b2370737d87dda2fcb80129d","modified":1571207279239},{"_id":"public/categories/vue/index.html","hash":"b9604af3175c7af63af986a08b1ddc927005d642","modified":1571207279239},{"_id":"public/categories/vue/page/2/index.html","hash":"f3a2ec2fc1859eb229b6d0bacb27d15ccfc32d08","modified":1571207279239},{"_id":"public/index.html","hash":"a3ccd14dc5906c31928ac6d3f37ad46d37b432bc","modified":1571207279239},{"_id":"public/page/2/index.html","hash":"10d7c0ab73add09a3b3371e3d75e1742753084fc","modified":1571207279239},{"_id":"public/categories/react/index.html","hash":"600cf160bf50e71ebf7f642ac09716bcb1c6ea3a","modified":1571207279239},{"_id":"public/page/3/index.html","hash":"e2bb83be3c220ad2b3b7d37cf5419843d098e380","modified":1571207279239},{"_id":"public/page/5/index.html","hash":"56c9a4940e6188cb908914a8f1660de697a2ae5b","modified":1571207279239},{"_id":"public/page/6/index.html","hash":"4b31e7fc1cc80ea776def318c9e4d13e1a7c5a1e","modified":1571207279239},{"_id":"public/page/4/index.html","hash":"e754c79592b41a6b435404caf03df4bbcc3b5185","modified":1571207279239},{"_id":"public/page/7/index.html","hash":"c72f2118e55c4c0bac8d1e216bafd344391e0c17","modified":1571207279239},{"_id":"public/tags/HTML/index.html","hash":"e1a512d508c131287399589a9d0105331f791674","modified":1571207279239},{"_id":"public/tags/CSS/index.html","hash":"40e898633a1f2f80aed1e0c1014f38bbb228297b","modified":1571207279239},{"_id":"public/tags/JavaScript/index.html","hash":"473c03508a451cd5f1e0217760dae830d45db494","modified":1571207279239},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"1a3672bf27fe7e60ff38405986ba8c4365f329d0","modified":1571207279239},{"_id":"public/tags/函数式编程/index.html","hash":"e7b2dca3d06410f2c3822b9bb714c09a3f501996","modified":1571207279240},{"_id":"public/tags/Node/index.html","hash":"e8b293c9cb6678dc02e1840a344a0da93a9fe429","modified":1571207279240},{"_id":"public/tags/PHP/index.html","hash":"b58593efef3402be8b1dc3622dbd54a86302616f","modified":1571207279240},{"_id":"public/tags/TypeScript/index.html","hash":"c2a3e08c7fa89728f8e381ce18882df341f8afed","modified":1571207279240},{"_id":"public/tags/TypeScript/page/2/index.html","hash":"7cafed407ab0eeef7d726def2962955e97e3bdd0","modified":1571207279240},{"_id":"public/tags/vue/index.html","hash":"c5ce6ed48321fbf3149044954a8a61e8c283f40d","modified":1571207279240},{"_id":"public/tags/vue/page/2/index.html","hash":"31f58a918ee99e4d049e64832c87870b7dd8eddb","modified":1571207279240},{"_id":"public/tags/Linux/index.html","hash":"41fbc143ebb217da00f9236a61341f91ecf92d44","modified":1571207279240},{"_id":"public/tags/react/index.html","hash":"bb9735e2758071812b44a52fd09eeaf1fcd3b48e","modified":1571207279240},{"_id":"public/CNAME","hash":"181c262cf92b1ff30ea9cdaaaefe2648b4b3f1c0","modified":1571207279311},{"_id":"public/images/Acss.jpg","hash":"24c93cda375ca4bf9d02d7bd56bf47ed22d48594","modified":1571207279311},{"_id":"public/images/Function.png","hash":"7b96f8e301445b0b84fe87dda3171165005499c1","modified":1571207279311},{"_id":"public/images/Object.png","hash":"f9bdf44c968effbe90a1f911581403129569f263","modified":1571207279311},{"_id":"public/images/Person.png","hash":"bd1b0c5ef77f699d05d624eeacb370b92b87e663","modified":1571207279311},{"_id":"public/images/ack.png","hash":"1e9740c51931e3049de55034b09350673588335a","modified":1571207279311},{"_id":"public/images/arithmetic-concept.png","hash":"7c2ec1a1282ed8092b5dec5a76114649f7feaa44","modified":1571207279311},{"_id":"public/images/arithmetic_structure_sort.png","hash":"09aac7ac0b2915f3bdec46f75d5f3e170ce4a6c4","modified":1571207279311},{"_id":"public/images/commonjs.png","hash":"7ff09d53c1ca8d8ad446baa75a6312e6a8c20e4b","modified":1571207279311},{"_id":"public/images/http代理.png","hash":"1449a4e05af7a7903d47ff550f5bd3b842d0bb03","modified":1571207279311},{"_id":"public/images/css-IFC.jpg","hash":"c7fb8f083d6e4e0caf37f609add2bcaed350ec94","modified":1571207279311},{"_id":"public/images/css盒子模型.png","hash":"bf2bb7b9d57756a3c17d1e3489d16f13587a68b4","modified":1571207279311},{"_id":"public/images/ipc-create.png","hash":"ff6ab7e391bfde80348ddb78cf44cba3414c53b0","modified":1571207279311},{"_id":"public/images/http.png","hash":"b480d1f688799f35883518ef3f1351bc771095fd","modified":1571207279311},{"_id":"public/images/ipc.png","hash":"05e57f1b2769c3b824582179c1263c6aecac55da","modified":1571207279312},{"_id":"public/images/javascript-stack.png","hash":"8b16e3377ca35b8a78cb0c9a39b89540e51467f9","modified":1571207279312},{"_id":"public/images/javaScript.png","hash":"0064f030325083e62c7ee86e6b26b5c629d73d8c","modified":1571207279312},{"_id":"public/images/javascript-stack1.png","hash":"ffcf25a0a099b5c10f265c08c52752aaf76a35c0","modified":1571207279312},{"_id":"public/images/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1571207279312},{"_id":"public/images/master-worker.png","hash":"58bf93ce185d2e91967ae1a90e81f5e89a896d7a","modified":1571207279312},{"_id":"public/images/linux.png","hash":"a2b16695f6f5b517dbbdca8b3fe3f26f1db95250","modified":1571207279312},{"_id":"public/images/module-os.png","hash":"d9aa9a85e39cee0bffcd98274fbbcedda20ed146","modified":1571207279312},{"_id":"public/images/module-p.png","hash":"e28e8705eb1357beec46a0557bf51c3d4094a6d9","modified":1571207279312},{"_id":"public/images/node.png","hash":"a5e96c9b079b38069529417b88ae28a745284c11","modified":1571207279312},{"_id":"public/images/module.png","hash":"68164b02e188e29d29344aa687ea6e2e73cd9bc0","modified":1571207279312},{"_id":"public/images/pointer-yinyong.png","hash":"dc47cfb50b6e9527fdf42459cdb8c198d891dc79","modified":1571207279312},{"_id":"public/images/process-on.png","hash":"d630c0f4b09b6a677b956376dc23bfc4f69e0149","modified":1571207279312},{"_id":"public/images/php.png","hash":"b9c9e7c9042be1daa66fec971ff89774c7962579","modified":1571207279312},{"_id":"public/images/process-send.png","hash":"d79dbf894fe5c388a69fac3666c9f63920400e87","modified":1571207279312},{"_id":"public/images/prototype.png","hash":"5586538f0d2d9cfd12d173be694ba1a3803a304b","modified":1571207279312},{"_id":"public/images/react-jsx-children.png","hash":"01c61717d5321b236b64300412d37d88de653143","modified":1571207279312},{"_id":"public/images/render-module.jpg","hash":"64975e4502e09146eb8fa6decdf1cb9a18e2c442","modified":1571207279312},{"_id":"public/images/request.png","hash":"fd9be1b20518eadc3297f2de098a318a21e13a0f","modified":1571207279312},{"_id":"public/images/tcp.png","hash":"6a280c4905ee8656c6c76193b9595d822caacb08","modified":1571207279312},{"_id":"public/images/ts-lang.png","hash":"d74e4262805a053fb4a087295609153c26099d28","modified":1571207279312},{"_id":"public/images/typeScript.png","hash":"9500854a5014949a859627aeab4031ce04c17a54","modified":1571207279313},{"_id":"public/images/vue-core-index.png","hash":"23fcb56dd70c950fa00aeee266b500d0a7c725c4","modified":1571207279313},{"_id":"public/images/vue-dep.png","hash":"df84ba493c60d0e9c67acb6a1c464b5e2faec8ef","modified":1571207279313},{"_id":"public/images/vue-dom-diff01.png","hash":"e312c23ef9f74c9ae0fd075b5bd27b5b745de069","modified":1571207279313},{"_id":"public/images/vue-dom-diff02.png","hash":"8687ba820764127b63c8afa60ab70b7e5548add7","modified":1571207279313},{"_id":"public/images/vue-dom-diff03.png","hash":"a01a09d8a55e51dd0808b0ce1b70899222503d58","modified":1571207279313},{"_id":"public/images/vue-dom-diff04.png","hash":"856027eae0146dc5e9a59057dd473daf0623cc07","modified":1571207279313},{"_id":"public/images/vue-dom-diff05.png","hash":"f9b57a6cb9905e5cb7fdb1e8ec3d660e87742d93","modified":1571207279313},{"_id":"public/images/vue-dom-diff06.png","hash":"42f3f6d744fe350789dee667620e23f22a973c94","modified":1571207279313},{"_id":"public/images/vue-dom-diff08.png","hash":"284f9cc2fffc1816e6fb6a800ae7251888805015","modified":1571207279313},{"_id":"public/images/vue-dom-diff09.png","hash":"4b039f1ba6f09f7aee13ea416b10e9115d794457","modified":1571207279313},{"_id":"public/images/vue-dom-diff10.png","hash":"11dd275692f7242dd706f85ef537f9c3f558323c","modified":1571207279313},{"_id":"public/images/vue-folder.png","hash":"b25f5c35bfc74494791c5165e2b6a04a94455b3f","modified":1571207279313},{"_id":"public/images/vue-init.png","hash":"20917d3b1221f8189d8afe9c33ea5a2718e236c7","modified":1571207279313},{"_id":"public/images/vue-observer.png","hash":"9559c83aade65703cdf443ef88666f5227b5880b","modified":1571207279313},{"_id":"public/images/vue-process.png","hash":"b8b645b04e854b2fa1435a32d3fab55e8d42fdc8","modified":1571207279313},{"_id":"public/images/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1571207279314},{"_id":"public/images/websocket.png","hash":"dcb8ac2f57b208bdba0f23824f7a3ee275761d0d","modified":1571207279314},{"_id":"public/medias/logo.png","hash":"1569d7d0d096feece4a0b2fa627ac4ce7acb7fd7","modified":1571207279314},{"_id":"public/medias/avatars/avatar.jpg","hash":"edfd4164885baf5d7bb5c8de6ced3a5d0e10b93b","modified":1571207279322},{"_id":"public/medias/banner/2.jpg","hash":"4225465807e1fc33c4819d79d9a48eb0257d857d","modified":1571207279322},{"_id":"public/medias/featureimages/0.jpg","hash":"986ae5b11ce9d157150eb2793fcb9243920768fc","modified":1571207279322},{"_id":"public/medias/featureimages/1.jpg","hash":"78250e8418cbc7d89272ccb3b97e4ca196514095","modified":1571207279322},{"_id":"public/medias/featureimages/10.jpg","hash":"48b6bca92dac83f9447a34d9f53698f7c3b8c548","modified":1571207279323},{"_id":"public/medias/featureimages/11.jpg","hash":"0d97dc07a380b54190910e82088177ae0f987b2d","modified":1571207279323},{"_id":"public/medias/featureimages/12.jpg","hash":"5150977f5755b57c47d5e6ff8d6460a29484b254","modified":1571207279323},{"_id":"public/medias/featureimages/13.jpg","hash":"5b9d68323520c1a029c4bdb3ce551c3dd82266fd","modified":1571207279323},{"_id":"public/medias/featureimages/14.jpg","hash":"d135f58dabe1e3896783313b65f1ba0cd77209d7","modified":1571207279323},{"_id":"public/medias/featureimages/15.jpg","hash":"19cca40728c936aafb41f94358a8aae7682ff8b2","modified":1571207279323},{"_id":"public/medias/featureimages/16.jpg","hash":"7d9ca7886fc340a20120c79d79554fca966a0173","modified":1571207279323},{"_id":"public/medias/featureimages/17.jpg","hash":"19e379a9384532667ca1fde405400955b86d7989","modified":1571207279323},{"_id":"public/medias/featureimages/18.jpg","hash":"427a9a8068bb1301393c84d332c080c9ddfbc445","modified":1571207279323},{"_id":"public/medias/featureimages/19.jpg","hash":"398b1e824baa404e1da212712baeef951b391096","modified":1571207279323},{"_id":"public/medias/featureimages/2.jpg","hash":"b0db8f7e05c0b3e8d379a32cddcf5a31506b48fe","modified":1571207279324},{"_id":"public/medias/featureimages/20.jpg","hash":"5debdaf99b1b304aaa3a5b8bfaf1c15913961625","modified":1571207279324},{"_id":"public/medias/featureimages/21.jpg","hash":"83a5f0346d5d09cb6ee40c61f5ae0b7084084cb9","modified":1571207279324},{"_id":"public/medias/featureimages/22.jpg","hash":"e2b55d8c0105ab833ef1b17de212b4bf3b23f977","modified":1571207279324},{"_id":"public/medias/featureimages/23.jpg","hash":"58d0d034b1352a41ff5f257ffab0b4a5ed6cf008","modified":1571207279324},{"_id":"public/medias/featureimages/24.jpg","hash":"b6de14f0421aef87b08215e161621d4ac20306b1","modified":1571207279324},{"_id":"public/medias/featureimages/25.jpg","hash":"1e68849e3d90b313f3c1f3817a7e2f348f4d941c","modified":1571207279324},{"_id":"public/medias/featureimages/26.jpg","hash":"833ddda3c5db3f3d1752633f0dba8e94d242b105","modified":1571207279324},{"_id":"public/medias/featureimages/27.jpg","hash":"62784ad9f69d49a0c90b531aff4e8a9e8b945e9d","modified":1571207279324},{"_id":"public/medias/featureimages/28.jpg","hash":"d386afb274d345e628251c557002558bc50a641c","modified":1571207279324},{"_id":"public/medias/featureimages/29.jpg","hash":"5d3e4ac5a43cea177ce0802b2506cc26a946f0f2","modified":1571207279324},{"_id":"public/medias/featureimages/3.jpg","hash":"943b167a9ecab3bf7309b233831269e939cfab93","modified":1571207279324},{"_id":"public/medias/featureimages/30.jpg","hash":"3384b49f86da5e71c4a341f93b75569c5aefcc6f","modified":1571207279324},{"_id":"public/medias/featureimages/31.jpg","hash":"758361a87a3ea1b5cdaf39b82c58cd5c9879e972","modified":1571207279324},{"_id":"public/medias/featureimages/4.jpg","hash":"7c7d6d366851025796fef8edaa17ed9276aa1f60","modified":1571207279324},{"_id":"public/medias/featureimages/5.jpg","hash":"fc23dd41463142543467e8da280e32f4f030115b","modified":1571207279324},{"_id":"public/medias/featureimages/6.jpg","hash":"7e497f9b7cd6ecc1af517a2bd54363afc297f677","modified":1571207279324},{"_id":"public/medias/featureimages/7.jpg","hash":"f0f370e6fdea794a60175cf36b8914815448bd37","modified":1571207279324},{"_id":"public/medias/featureimages/8.jpg","hash":"f9666a41d2d442e61d20199c5cad4543696a8bce","modified":1571207279324},{"_id":"public/medias/featureimages/9.jpg","hash":"319dcdaca9b33e7d6b161825ba936ec7f9d3b232","modified":1571207279324},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1571207279324},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1571207279324},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1571207279324},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1571207279324},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1571207279324},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1571207279324},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1571207279324},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1571207279324},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1571207279324},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1571207279324},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1571207279324},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1571207279324},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1571207279324},{"_id":"public/css/prism-line-numbers.css","hash":"e0db113a99e4a09d2161a539b1652d96e4a22fac","modified":1571207279325},{"_id":"public/images/cpu.png","hash":"ba4d72cd4b5c6acb9224fdc4b8d7d04cea8edebd","modified":1571207279338},{"_id":"public/images/event.png","hash":"f7bf62133be3c66694837bf62616b0474880f7eb","modified":1571207279338},{"_id":"public/images/html.png","hash":"95e9503f721a28aa6a1ab8496fea624ae180ac30","modified":1571207279339},{"_id":"public/images/library-react-lifecycle01.png","hash":"eedffc921f0c7d78a65065aa81e87d061ace9cb7","modified":1571207279339},{"_id":"public/images/library-react-lifecycle02.png","hash":"967b896a8ade58b47a3df231ae3aa14ea552eeea","modified":1571207279339},{"_id":"public/favicon.png","hash":"b20bab8ce1f2f7426a6960a7f0fd7cc06a923381","modified":1571207279339},{"_id":"public/medias/reward/alipay.jpg","hash":"7273c89d119ed9e73e3212972670d7ea40cef071","modified":1571207279339},{"_id":"public/medias/reward/wechat.png","hash":"e4b6c7007108bc3631372cf2b028803c4cc8e671","modified":1571207279339},{"_id":"public/medias/music/avatars/zhaolei.jpg","hash":"3fd850b1b14c3065da53f52adba606c9b94d6f91","modified":1571207279339},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1571207279339},{"_id":"public/medias/music/avatars/maliang.jpg","hash":"99bbcdb66a9c5313d4fe4b92eeaead42c2515fa1","modified":1571207279339},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1571207279339},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1571207279352},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1571207279352},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1571207279352},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1571207279352},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1571207279352},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1571207279352},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1571207279352},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1571207279352},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1571207279353},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1571207279353},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1571207279353},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1571207279353},{"_id":"public/images/TypeScript 编译原理.png","hash":"adf3c184f3d9fae5b155e642fa636eca451200a0","modified":1571207279353},{"_id":"public/images/event-loop.png","hash":"69b4d7bdbdbb112b8cf0deac2d16e8de25e2e3e0","modified":1571207279353},{"_id":"public/images/vue-lifecycle.png","hash":"02c466c84bc89bcaad6eb11b3dfd4c5b7917e3ec","modified":1571207279353},{"_id":"public/images/render-process.jpg","hash":"d9bde85e73c48b1c7289a601e24f52f3a25f1d43","modified":1571207279353},{"_id":"public/images/vue-dom-diff12.png","hash":"86ff43f1ee3510f3d2a011da957fe1d206ce1f16","modified":1571207279353},{"_id":"public/medias/banner/1.jpg","hash":"778f287dfea4b4b707e75add4dfcb4be96f94a66","modified":1571207279354},{"_id":"public/medias/banner/3.jpg","hash":"d550bf0803c2ec347b5047a209cde47a5e3e7478","modified":1571207279354},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1571207279354},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1571207279354},{"_id":"public/medias/music/avatars/chenhouyu.jpg","hash":"ce5a90ff7c84b8a5e3e56236783fa6806e1f1498","modified":1571207279354},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1571207279354},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1571207279361},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1571207279361},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1571207279362},{"_id":"public/images/css-dom-render.jpg","hash":"154deb251505d145c93b2a0dd6cf44e8ba3c3678","modified":1571207279362},{"_id":"public/images/dom-render.jpg","hash":"7eeed9bff9d46f498fe95cfd698e8e60710647ea","modified":1571207279362},{"_id":"public/images/pointer.png","hash":"0684d698c49bb4a12f0f941ec3e165626c5d5edc","modified":1571207279362},{"_id":"public/medias/banner/4.jpg","hash":"90074183570e58bf4cc5a19a21ce0c8456970e8a","modified":1571207279362},{"_id":"public/css/matery.css","hash":"4a20a2d46bfb84b3de85c8d9c8aaffd4b5c441ae","modified":1571207279364},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1571207279364},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1571207279364},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1571207279364},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1571207279364},{"_id":"public/images/vue-dom-diff11.png","hash":"71832563c37aadeb61be4602bfde2d1596b94930","modified":1571207279376},{"_id":"public/images/vue-vmodel.png","hash":"9adb23e04bdb3a6bfc6943b477fc82685e2133a0","modified":1571207279376},{"_id":"public/medias/banner/6.jpg","hash":"89c2be390083e9a6ca417728a9cc89d740c37bb4","modified":1571207279377},{"_id":"public/medias/featureimages/35.jpg","hash":"677436212d24cd0092e720051d90f73d0e57e8f2","modified":1571207279377},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1571207279379},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1571207279379},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1571207279379},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1571207279379},{"_id":"public/medias/banner/0.jpg","hash":"18788ca08a0ca8a0dca90baed8bc59f38e43cc9e","modified":1571207279401},{"_id":"public/images/自适应两栏布局.gif","hash":"8f2f6aa4cf40724b9d27e6f49ff1d66d7b076b42","modified":1571207279415},{"_id":"public/images/library-react-lifecycle03.jpg","hash":"8b2dccba7fe18bf7c034a65b3c8bb348b46a9c4c","modified":1571207279415},{"_id":"public/images/library-react-lifecycle04.jpg","hash":"54d5358c4882c79380aff712f049a01ae030d169","modified":1571207279416},{"_id":"public/medias/music/avatars/laofan.jpg","hash":"5117ed92c8175825b9116716bb4005cf7d5c09c6","modified":1571207279416},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1571207279421},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1571207279421},{"_id":"public/images/render-tree.jpg","hash":"3326b141b427915d4fef9476d1ae3139df589113","modified":1571207279439},{"_id":"public/medias/featureimages/33.jpg","hash":"ba0282364c03af5c37e8b2d4a984e5f7c2ff81d4","modified":1571207279439},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1571207279447},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1571207279447},{"_id":"public/images/timestamp-diagram.svg","hash":"59228be9d502f05e0a5601b1f1ee71a5570d4902","modified":1571207279455},{"_id":"public/images/圣杯布局.gif","hash":"137d4f2207b255d31a2517bf52473f06f281a885","modified":1571207279455},{"_id":"public/medias/featureimages/34.jpg","hash":"7b4cd1b5b2be38865a2c407b728a2ab12b167cd7","modified":1571207279455},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1571207279456},{"_id":"public/medias/banner/5.jpg","hash":"880581d92a6e9aff2b7e3f0bc537eda760565e5f","modified":1571207279503},{"_id":"public/libs/valine/Valine.min.js","hash":"031c1a5640d64ab3b829395ad5a7596b9fb122e6","modified":1571207279505},{"_id":"public/medias/featureimages/32.jpg","hash":"15a3a72b8e12093a83babba11ba21b8660291f68","modified":1571207279521},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1571207279522},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1571207279524},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1571207279547},{"_id":"public/images/CSS.png","hash":"b84ac2e337ebbbeaf01b62d9876cc83fbd09aee0","modified":1571207279577},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1571207279583},{"_id":"public/libs/materialize/materialize.min.css","hash":"580459a012f556fba86438953062013a94b201af","modified":1571207279587},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1571207279587},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1571207279589},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1571207279593},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1571207279644},{"_id":"public/medias/music/wanghouyusheng.mp3","hash":"c6a9203f13c4021c34d012fa8f2e3d3a713603b4","modified":1571207279660},{"_id":"public/medias/music/lixiangsanxun.mp3","hash":"3830afc5553bf36e04cadcd5c0d060e1a838fbbc","modified":1571207279668},{"_id":"public/medias/music/hua.mp3","hash":"6ed72d5b959a236deeaf9cbee66bd29f74cffb14","modified":1571207279675},{"_id":"public/medias/music/yongbaoni.mp3","hash":"4422fc80bafc7ae3e5f03af1ec38cb0f6f15bf7e","modified":1571207279707}],"Category":[{"name":"HTML","_id":"ck1sw8oqd000cb0u6dodaqxk3"},{"name":"CSS","_id":"ck1sw8oqm000hb0u683dyw1ok"},{"name":"JavaScript","_id":"ck1sw8or80016b0u6x7f8rcq4"},{"name":"函数式编程","_id":"ck1sw8orm001qb0u65qjvy206"},{"name":"Linux","_id":"ck1sw8osf0032b0u6yxprhui1"},{"name":"Node","_id":"ck1sw8ots004rb0u69u8bynhk"},{"name":"PHP","_id":"ck1sw8ous0061b0u6ficyswcn"},{"name":"TypeScript","_id":"ck1sw8ouv0069b0u620t9e9zs"},{"name":"vue","_id":"ck1sw8ovk007xb0u65wftd6te"},{"name":"react","_id":"ck1sw8owg008wb0u6gtg9ritb"}],"Data":[{"_id":"musics","data":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2019-10-15T01:29:42.457Z","path":"404.html","comments":1,"_id":"ck1sw8okd0000b0u63a9efd6c","content":"","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","type":"about","layout":"about","_content":"\n**北京阳光帕拉网络科技有限公司 2018.2-至今**\n*前端负责人*\n\n1.负责公司线上产品前端架构及框架搭建\n\n2.负责公司线上产品性能优化 \n\n3.负责小程序、app、管理后台业务开发 \n\n4.负责对团队人员的培养及技术指导 \n\n5.负责对前端工作工期把控、及分配等 \n\n6.负责把前端项目和产品，后端沟通后落地实施\n\n\n\n**北京璧合科技股份有限公司 2016.7-2018.2**\n*前端组长*\n\n1.负责公司级组件库的编写\n\n2.负责公司sass系统的开发、迭代和维护 \n\n3.负责公司运营页面的开发 \n\n4.负责培养初级前端开发\n\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-07-19 16:41:10\ntype: \"about\"\nlayout: \"about\"\n---\n\n**北京阳光帕拉网络科技有限公司 2018.2-至今**\n*前端负责人*\n\n1.负责公司线上产品前端架构及框架搭建\n\n2.负责公司线上产品性能优化 \n\n3.负责小程序、app、管理后台业务开发 \n\n4.负责对团队人员的培养及技术指导 \n\n5.负责对前端工作工期把控、及分配等 \n\n6.负责把前端项目和产品，后端沟通后落地实施\n\n\n\n**北京璧合科技股份有限公司 2016.7-2018.2**\n*前端组长*\n\n1.负责公司级组件库的编写\n\n2.负责公司sass系统的开发、迭代和维护 \n\n3.负责公司运营页面的开发 \n\n4.负责培养初级前端开发\n\n\n","updated":"2019-10-15T01:29:42.489Z","path":"about/index.html","comments":1,"_id":"ck1sw8onq0001b0u6s9s31pc3","content":"<p><strong>北京阳光帕拉网络科技有限公司 2018.2-至今</strong><br><em>前端负责人</em></p>\n<p>1.负责公司线上产品前端架构及框架搭建</p>\n<p>2.负责公司线上产品性能优化 </p>\n<p>3.负责小程序、app、管理后台业务开发 </p>\n<p>4.负责对团队人员的培养及技术指导 </p>\n<p>5.负责对前端工作工期把控、及分配等 </p>\n<p>6.负责把前端项目和产品，后端沟通后落地实施</p>\n<p><strong>北京璧合科技股份有限公司 2016.7-2018.2</strong><br><em>前端组长</em></p>\n<p>1.负责公司级组件库的编写</p>\n<p>2.负责公司sass系统的开发、迭代和维护 </p>\n<p>3.负责公司运营页面的开发 </p>\n<p>4.负责培养初级前端开发</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p><strong>北京阳光帕拉网络科技有限公司 2018.2-至今</strong><br><em>前端负责人</em></p>\n<p>1.负责公司线上产品前端架构及框架搭建</p>\n<p>2.负责公司线上产品性能优化 </p>\n<p>3.负责小程序、app、管理后台业务开发 </p>\n<p>4.负责对团队人员的培养及技术指导 </p>\n<p>5.负责对前端工作工期把控、及分配等 </p>\n<p>6.负责把前端项目和产品，后端沟通后落地实施</p>\n<p><strong>北京璧合科技股份有限公司 2016.7-2018.2</strong><br><em>前端组长</em></p>\n<p>1.负责公司级组件库的编写</p>\n<p>2.负责公司sass系统的开发、迭代和维护 </p>\n<p>3.负责公司运营页面的开发 </p>\n<p>4.负责培养初级前端开发</p>\n"},{"title":"categories","date":"2019-07-19T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-07-19 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2019-10-15T01:29:42.490Z","path":"categories/index.html","comments":1,"_id":"ck1sw8onr0002b0u6ouxbr45t","content":"","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-07-19 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2019-10-15T01:29:42.538Z","path":"tags/index.html","comments":1,"_id":"ck1sw8ont0003b0u6pidi89hc","content":"","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":""},{"title":"friends","date":"2019-07-19T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n**感谢所有支持和帮助过我的人，希望今后也能和大家一起学习进步。**\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2019-07-19 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n**感谢所有支持和帮助过我的人，希望今后也能和大家一起学习进步。**\n","updated":"2019-10-15T01:29:42.490Z","path":"friends/index.html","comments":1,"_id":"ck1sw8onu0004b0u6p8n65qxv","content":"<p><strong>感谢所有支持和帮助过我的人，希望今后也能和大家一起学习进步。</strong></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p><strong>感谢所有支持和帮助过我的人，希望今后也能和大家一起学习进步。</strong></p>\n"},{"title":"archives","date":"2019-07-19T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2019-07-19 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2019-10-15T01:29:42.489Z","path":"archives/index.html","comments":1,"_id":"ck1sw8onv0005b0u63r40oe2g","content":"","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":""}],"Post":[{"_content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例：\n```\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n   \n   \n};\n\n```","source":"_posts/arithmetic/TwoSum.md","raw":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例：\n```\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n   \n   \n};\n\n```","slug":"arithmetic/TwoSum","published":1,"date":"2019-10-15T03:13:36.140Z","updated":"2019-10-15T03:18:55.196Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8opq0006b0u6lq02bus8","content":"<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>示例：</p>\n<pre><code>给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]</code></pre><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">\n<span class=\"token comment\" spellcheck=\"true\">/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */</span>\n<span class=\"token keyword\">var</span> twoSum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>示例：</p>\n<pre><code>给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]</code></pre><pre><code class=\"javascript\">\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n\n\n};\n</code></pre>\n"},{"_content":"# 算法目录\n算法知识梳理、总结的地方。欢迎 star 共同进步😊😊😊\n\n\n## 算法基础理论\n[指针]: ./pointer.md \"pointer\"\n\n算法的根本在理解数据结构和指针，希望大家在首先理解指针之后，再认真学习下基础的数据结构，最后再理解算法。各种算法归咎根本也不过是在各种数据结构中畅游。而所有的数据结构都是由基本数据结构的变种而来。\n\n一法通则万法通，让我们从基础学起。\n\n- [指针]\n\n\n\n## 算法\n[两数之和]: ./TwoSum.md \"两数之和\"\n\n- [两数之和]\n\n\n## 贡献\n该目录内容除[MarsPen](https://github.com/MarsPen \"任博\")外由以下成员贡献：\n\n- [xiaoranzife](https://github.com/FontEndArt \"前端小然子\")\n","source":"_posts/arithmetic/README.md","raw":"# 算法目录\n算法知识梳理、总结的地方。欢迎 star 共同进步😊😊😊\n\n\n## 算法基础理论\n[指针]: ./pointer.md \"pointer\"\n\n算法的根本在理解数据结构和指针，希望大家在首先理解指针之后，再认真学习下基础的数据结构，最后再理解算法。各种算法归咎根本也不过是在各种数据结构中畅游。而所有的数据结构都是由基本数据结构的变种而来。\n\n一法通则万法通，让我们从基础学起。\n\n- [指针]\n\n\n\n## 算法\n[两数之和]: ./TwoSum.md \"两数之和\"\n\n- [两数之和]\n\n\n## 贡献\n该目录内容除[MarsPen](https://github.com/MarsPen \"任博\")外由以下成员贡献：\n\n- [xiaoranzife](https://github.com/FontEndArt \"前端小然子\")\n","slug":"arithmetic/README","published":1,"date":"2019-10-15T02:13:16.470Z","updated":"2019-10-16T02:27:12.612Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oq30007b0u60m8gewz1","content":"<h1 id=\"算法目录\"><a href=\"#算法目录\" class=\"headerlink\" title=\"算法目录\"></a>算法目录</h1><p>算法知识梳理、总结的地方。欢迎 star 共同进步😊😊😊</p>\n<h2 id=\"算法基础理论\"><a href=\"#算法基础理论\" class=\"headerlink\" title=\"算法基础理论\"></a>算法基础理论</h2><p>算法的根本在理解数据结构和指针，希望大家在首先理解指针之后，再认真学习下基础的数据结构，最后再理解算法。各种算法归咎根本也不过是在各种数据结构中畅游。而所有的数据结构都是由基本数据结构的变种而来。</p>\n<p>一法通则万法通，让我们从基础学起。</p>\n<ul>\n<li><a href=\"./pointer.md\" title=\"pointer\">指针</a></li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ul>\n<li><a href=\"./TwoSum.md\" title=\"两数之和\">两数之和</a></li>\n</ul>\n<h2 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h2><p>该目录内容除<a href=\"https://github.com/MarsPen\" title=\"任博\" target=\"_blank\" rel=\"noopener\">MarsPen</a>外由以下成员贡献：</p>\n<ul>\n<li><a href=\"https://github.com/FontEndArt\" title=\"前端小然子\" target=\"_blank\" rel=\"noopener\">xiaoranzife</a></li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h1 id=\"算法目录\"><a href=\"#算法目录\" class=\"headerlink\" title=\"算法目录\"></a>算法目录</h1><p>算法知识梳理、总结的地方。欢迎 star 共同进步😊😊😊</p>\n<h2 id=\"算法基础理论\"><a href=\"#算法基础理论\" class=\"headerlink\" title=\"算法基础理论\"></a>算法基础理论</h2><p>算法的根本在理解数据结构和指针，希望大家在首先理解指针之后，再认真学习下基础的数据结构，最后再理解算法。各种算法归咎根本也不过是在各种数据结构中畅游。而所有的数据结构都是由基本数据结构的变种而来。</p>\n<p>一法通则万法通，让我们从基础学起。</p>\n<ul>\n<li><a href=\"./pointer.md\" title=\"pointer\">指针</a></li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ul>\n<li><a href=\"./TwoSum.md\" title=\"两数之和\">两数之和</a></li>\n</ul>\n<h2 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h2><p>该目录内容除<a href=\"https://github.com/MarsPen\" title=\"任博\" target=\"_blank\" rel=\"noopener\">MarsPen</a>外由以下成员贡献：</p>\n<ul>\n<li><a href=\"https://github.com/FontEndArt\" title=\"前端小然子\" target=\"_blank\" rel=\"noopener\">xiaoranzife</a></li>\n</ul>\n"},{"title":"基本的数据结构","author":"前端小然子","_content":"\n# 基本的数据结构\n\n## 认识数据结构\n\n### 数据结构的说明\n---\n\n数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结构不是使我们学会编码，而是为我们提供一种编程的思想，具有更好的思路。\n\n关于数据结构有两种说法，如下：\n\n- 广义的说法：数据结构 = 数据存储 + 算法\n- 狭义的说法：数据结构 = 数据的存储；\n\n### 数据结构和算法的关系\n---\n\n数据结构与算法是相互依托的关系。计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据模型的算法：\n\n- 数据结构 ==> 建筑工程中的建筑设计图\n- 算法 ==> 工程中的施工流程图\n\n### 用数据结构可以做什么\n---\n\n- 程序员的内功心法之一\n- 有效管理数据对象\n- 解决处理性能问题\n- 面试加分项（现在一些简单的数据结构和算法已经是必备项了）\n\n\n## 基本数据结构及衍生结构\n\n### 几个算法中的基本概念\n---\n\n- 数据\n- 数据元素\n- 数据项\n- 数据对象\n- 数据结构\n\n它们之间的关系就像下图一样：\n\n![算法的几个基本概念](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic-concept.png?raw=true)\n\n### 浅析数据结构\n---\n\n数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的。\n\n- 逻辑结构：反映数据元素之间的逻辑关系。\n- 存储结构：数据结构在计算机中的表示。\n- 算法：对数据的操作\n\n![数据结构分类](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic_structure_sort.png?raw=true)\n\n\n## 封装与数据结构的原则\n\n## 前端中的数据结构应用\n\n\n\n## 致谢\n感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。\n\n[前端小然子的博客](https://xiaoranzife.com \"前端小然子\")\n","source":"_posts/arithmetic/data_structure.md","raw":"---\ntitle: 基本的数据结构\nauthor: 前端小然子\n---\n\n# 基本的数据结构\n\n## 认识数据结构\n\n### 数据结构的说明\n---\n\n数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结构不是使我们学会编码，而是为我们提供一种编程的思想，具有更好的思路。\n\n关于数据结构有两种说法，如下：\n\n- 广义的说法：数据结构 = 数据存储 + 算法\n- 狭义的说法：数据结构 = 数据的存储；\n\n### 数据结构和算法的关系\n---\n\n数据结构与算法是相互依托的关系。计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据模型的算法：\n\n- 数据结构 ==> 建筑工程中的建筑设计图\n- 算法 ==> 工程中的施工流程图\n\n### 用数据结构可以做什么\n---\n\n- 程序员的内功心法之一\n- 有效管理数据对象\n- 解决处理性能问题\n- 面试加分项（现在一些简单的数据结构和算法已经是必备项了）\n\n\n## 基本数据结构及衍生结构\n\n### 几个算法中的基本概念\n---\n\n- 数据\n- 数据元素\n- 数据项\n- 数据对象\n- 数据结构\n\n它们之间的关系就像下图一样：\n\n![算法的几个基本概念](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic-concept.png?raw=true)\n\n### 浅析数据结构\n---\n\n数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的。\n\n- 逻辑结构：反映数据元素之间的逻辑关系。\n- 存储结构：数据结构在计算机中的表示。\n- 算法：对数据的操作\n\n![数据结构分类](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic_structure_sort.png?raw=true)\n\n\n## 封装与数据结构的原则\n\n## 前端中的数据结构应用\n\n\n\n## 致谢\n感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。\n\n[前端小然子的博客](https://xiaoranzife.com \"前端小然子\")\n","slug":"arithmetic/data_structure","published":1,"date":"2019-10-16T03:12:48.040Z","updated":"2019-10-16T06:27:11.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oq70008b0u6zyzrg0tf","content":"<h1 id=\"基本的数据结构\"><a href=\"#基本的数据结构\" class=\"headerlink\" title=\"基本的数据结构\"></a>基本的数据结构</h1><h2 id=\"认识数据结构\"><a href=\"#认识数据结构\" class=\"headerlink\" title=\"认识数据结构\"></a>认识数据结构</h2><h3 id=\"数据结构的说明\"><a href=\"#数据结构的说明\" class=\"headerlink\" title=\"数据结构的说明\"></a>数据结构的说明</h3><hr>\n<p>数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结构不是使我们学会编码，而是为我们提供一种编程的思想，具有更好的思路。</p>\n<p>关于数据结构有两种说法，如下：</p>\n<ul>\n<li>广义的说法：数据结构 = 数据存储 + 算法</li>\n<li>狭义的说法：数据结构 = 数据的存储；</li>\n</ul>\n<h3 id=\"数据结构和算法的关系\"><a href=\"#数据结构和算法的关系\" class=\"headerlink\" title=\"数据结构和算法的关系\"></a>数据结构和算法的关系</h3><hr>\n<p>数据结构与算法是相互依托的关系。计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据模型的算法：</p>\n<ul>\n<li>数据结构 ==&gt; 建筑工程中的建筑设计图</li>\n<li>算法 ==&gt; 工程中的施工流程图</li>\n</ul>\n<h3 id=\"用数据结构可以做什么\"><a href=\"#用数据结构可以做什么\" class=\"headerlink\" title=\"用数据结构可以做什么\"></a>用数据结构可以做什么</h3><hr>\n<ul>\n<li>程序员的内功心法之一</li>\n<li>有效管理数据对象</li>\n<li>解决处理性能问题</li>\n<li>面试加分项（现在一些简单的数据结构和算法已经是必备项了）</li>\n</ul>\n<h2 id=\"基本数据结构及衍生结构\"><a href=\"#基本数据结构及衍生结构\" class=\"headerlink\" title=\"基本数据结构及衍生结构\"></a>基本数据结构及衍生结构</h2><h3 id=\"几个算法中的基本概念\"><a href=\"#几个算法中的基本概念\" class=\"headerlink\" title=\"几个算法中的基本概念\"></a>几个算法中的基本概念</h3><hr>\n<ul>\n<li>数据</li>\n<li>数据元素</li>\n<li>数据项</li>\n<li>数据对象</li>\n<li>数据结构</li>\n</ul>\n<p>它们之间的关系就像下图一样：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic-concept.png?raw=true\" alt=\"算法的几个基本概念\"></p>\n<h3 id=\"浅析数据结构\"><a href=\"#浅析数据结构\" class=\"headerlink\" title=\"浅析数据结构\"></a>浅析数据结构</h3><hr>\n<p>数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的。</p>\n<ul>\n<li>逻辑结构：反映数据元素之间的逻辑关系。</li>\n<li>存储结构：数据结构在计算机中的表示。</li>\n<li>算法：对数据的操作</li>\n</ul>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic_structure_sort.png?raw=true\" alt=\"数据结构分类\"></p>\n<h2 id=\"封装与数据结构的原则\"><a href=\"#封装与数据结构的原则\" class=\"headerlink\" title=\"封装与数据结构的原则\"></a>封装与数据结构的原则</h2><h2 id=\"前端中的数据结构应用\"><a href=\"#前端中的数据结构应用\" class=\"headerlink\" title=\"前端中的数据结构应用\"></a>前端中的数据结构应用</h2><h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。</p>\n<p><a href=\"https://xiaoranzife.com\" title=\"前端小然子\" target=\"_blank\" rel=\"noopener\">前端小然子的博客</a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h1 id=\"基本的数据结构\"><a href=\"#基本的数据结构\" class=\"headerlink\" title=\"基本的数据结构\"></a>基本的数据结构</h1><h2 id=\"认识数据结构\"><a href=\"#认识数据结构\" class=\"headerlink\" title=\"认识数据结构\"></a>认识数据结构</h2><h3 id=\"数据结构的说明\"><a href=\"#数据结构的说明\" class=\"headerlink\" title=\"数据结构的说明\"></a>数据结构的说明</h3><hr>\n<p>数据结构起源于程序设计，是用计算机来存储、组织数据的方式。数据结构不是使我们学会编码，而是为我们提供一种编程的思想，具有更好的思路。</p>\n<p>关于数据结构有两种说法，如下：</p>\n<ul>\n<li>广义的说法：数据结构 = 数据存储 + 算法</li>\n<li>狭义的说法：数据结构 = 数据的存储；</li>\n</ul>\n<h3 id=\"数据结构和算法的关系\"><a href=\"#数据结构和算法的关系\" class=\"headerlink\" title=\"数据结构和算法的关系\"></a>数据结构和算法的关系</h3><hr>\n<p>数据结构与算法是相互依托的关系。计算机解决问题，应该是先从具体问题中抽象出一个适当的数据模型，设计出一个解此数据模型的算法：</p>\n<ul>\n<li>数据结构 ==&gt; 建筑工程中的建筑设计图</li>\n<li>算法 ==&gt; 工程中的施工流程图</li>\n</ul>\n<h3 id=\"用数据结构可以做什么\"><a href=\"#用数据结构可以做什么\" class=\"headerlink\" title=\"用数据结构可以做什么\"></a>用数据结构可以做什么</h3><hr>\n<ul>\n<li>程序员的内功心法之一</li>\n<li>有效管理数据对象</li>\n<li>解决处理性能问题</li>\n<li>面试加分项（现在一些简单的数据结构和算法已经是必备项了）</li>\n</ul>\n<h2 id=\"基本数据结构及衍生结构\"><a href=\"#基本数据结构及衍生结构\" class=\"headerlink\" title=\"基本数据结构及衍生结构\"></a>基本数据结构及衍生结构</h2><h3 id=\"几个算法中的基本概念\"><a href=\"#几个算法中的基本概念\" class=\"headerlink\" title=\"几个算法中的基本概念\"></a>几个算法中的基本概念</h3><hr>\n<ul>\n<li>数据</li>\n<li>数据元素</li>\n<li>数据项</li>\n<li>数据对象</li>\n<li>数据结构</li>\n</ul>\n<p>它们之间的关系就像下图一样：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic-concept.png?raw=true\" alt=\"算法的几个基本概念\"></p>\n<h3 id=\"浅析数据结构\"><a href=\"#浅析数据结构\" class=\"headerlink\" title=\"浅析数据结构\"></a>浅析数据结构</h3><hr>\n<p>数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的。</p>\n<ul>\n<li>逻辑结构：反映数据元素之间的逻辑关系。</li>\n<li>存储结构：数据结构在计算机中的表示。</li>\n<li>算法：对数据的操作</li>\n</ul>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/arithmetic_structure_sort.png?raw=true\" alt=\"数据结构分类\"></p>\n<h2 id=\"封装与数据结构的原则\"><a href=\"#封装与数据结构的原则\" class=\"headerlink\" title=\"封装与数据结构的原则\"></a>封装与数据结构的原则</h2><h2 id=\"前端中的数据结构应用\"><a href=\"#前端中的数据结构应用\" class=\"headerlink\" title=\"前端中的数据结构应用\"></a>前端中的数据结构应用</h2><h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。</p>\n<p><a href=\"https://xiaoranzife.com\" title=\"前端小然子\" target=\"_blank\" rel=\"noopener\">前端小然子的博客</a></p>\n"},{"title":"理解内存与指针","author":"前端小然子","_content":"\n# 理解内存与指针\n\n## 内存与内存地址\n\n### 什么是内存\n---\n\n内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。\n\n内存也被称为 内储存器 和 主存储器，其作用是用于暂时存放CPU中的运算数据，以及和硬盘等外部存储器交换的数据。下面是CPU的组成和工作原理：\n\n![图一](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/cpu.png?raw=true)\n\n<!-- <img src=\"/images/cpu.png\"> -->\n\n在计算机的组成结构中，有一个很重要的部分是储存器。\n\n存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存）。\n\n内存就是暂时存储程序以及数据的地方，相对于外存（硬盘是外存的一种）而言，我们在电脑上输入文字、字符的时候，它就会被存入内存中，只有当你选择保存文件的时候，内存中的数据才会被存入硬盘。\n\n内存是CPU能够直接寻址的存储空间，特点是存取速率特别快，临时存放数据，不能永久保存数据。\n\n外存是计算机的存储器的一种，主要用来存放暂时不用的程序和数据。特定是容量大、价格低，但是存取速度慢。外存和内存之间尝尝频繁的交换信息。\n\n### 什么是内存地址\n---\n\n内存地址是用于软硬件等不同层级中的数据概念，用来访问内存中的数据。\n\n可以通过WiKi或者百度百科进行更加深入的了解。\n\n## 指针、地址与引用\n\n### 引用\n---\n\n引用是一个变量的别名，为什么引入别名？是因为我们想定义一个变量，由这个变量来共享另一个变量的内存空间，所以使用别名是一个很好的选择。\n\n变量是什么？ 是一个内存空间的名字，如果我们给这个内存空间再另外起一个名字，就是能共享这个内存了，引用（别名）由此而来。\n\n比如：\n```javascript\nvar obj = { a: 1, b: 2 };\nvar obj1 = obj;\n```\n\n这里我们就可以说变量obj1是变量obj的一个引用；（因为在javascript中，object类型的赋值，是引用地址赋值）\n\n### 指针\n---\n\n指针，指向另一个内存空间的变量，我们可以用个它来索引另一个内存空间中的内容，而指针本身有自己的内存空间。\n\n如下图所示：\n\n![图二](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer.png?raw=true)\n\n### 两者区别\n---\n\n引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。\n\n引用在开始的时候就绑定到了一个内存空间(开始必须赋初值), 所以它只能是这个内存空间的名字, 而不能改成其他的, 当然, 我们可以改变这个内存空间的值。\n\neg:\n```javascript\nvar obj = { a: 1, b: 2 };\nvar obj1 = obj;\n\nobj.b = 3;\n// {a: 1, b: 3 }\n\nobj1.a = 4;\n// {a: 4, b: 3 }\n\nobj1 = { a:1, c:2 };\nconsole.log(obj1);\n// { a:1, c:2 };\nconsole.log(obj);\n// {a: 4, b: 3 }\n```\n这段代码的过程如下：\n\n![图三](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer-yinyong.png?raw=true)\n\n## 指向变量的指针\n\n一个变量的地址指出了变量的存储单元在内存中的具体位置，能对变量进行存取操作。那这个变量就是指向变量的指针。\n\n可以参考上面的 ***“图二”*** 可以很好的理解指向变量的指针。\n\n## 指向指针的指针\n\n如果一个指针变量存放的又是另一个指针变量的地址，则称这个变量为指向指针的指针变量或指向指针的指针。\n\n```c\n#include <stdio.h>\n\n// 入口主函数\nvoid main () {\n    int a = 5;\n    // 这里&a就是变量a的内存地址\n    int *p = &a;\n    // 这里是打印输出变量a的值\n    printf(\"%d\\n\", *p);\n}\n```\n\n## 指向函数的指针\n\n指向函数的指针变量被称为函数指针。本身是指针变量，只不过该指针变量指向函数。\n\n有了函数指针之后，就可以用该指针变量来调用函数。\n\n函数指针有两个用途：\n\n- 调用函数\n\n- 做函数的参数\n\n```javascript\n\n// 调用函数\nfunction max (x, y) {\n    return x > y ? x : y;\n}\n\nmax(1, 2);\n\n\n// 做函数的参数\nconst a = [1,5,3,4,78,96,54,1,2,3,4];\n\nfunction sum(total, num) {\n    return total + Math.round(num);\n}\n\na.reduce(sum);\n\n```\n\n以上例子中 **max** 和 **sum** 都是指向函数的指针变量。\n\n## 多级指针\n\n多级指针，是指 “指向地址的指针”;\n\n### 一级指针\n---\n\n```c\n#include <stdio.h>\n\n// 入口主函数\nvoid main () {\n    int i = 10;\n    // 这里&a就是变量a的内存地址\n    int *p1 = &a;\n    // 这里是打印输出变量a的值\n    printf(\"%d\\n\", *p1);\n}\n```\n在这里的 *p1 就是一级指针\n\n这里同样参考 ***“图二”*** 来理解\n\n指针变量p可以通过 *p1 来获取到变量i的值，也可以进行修改操作，总之 *p1 可以操作变量i的内存空间，所以 * 是一个操作内存空间的一个符号。\n\n*p也就被称为一级指针。\n\n### 二级指针\n---\n\n同上面讲的一级指针原理一致。\n\n```c\n#include <stdio.h>\n\n// 入口主函数\nvoid main () {\n    int i = 10;\n    // 这里&a就是变量a的内存地址\n    int *p1 = &a;\n    int **p2 = &p1;\n}\n```\n\n**p2 即为二级指针。\n\n---\n\n其余多级指针依旧同理：\n```c\nint ***p3 = &p2;\nint ****p4 = &p3;\n```\n\n## 动态内存分配\n\n|内存|描述|特性|\n|-|-|-|\n|栈区|是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow|自动分配 ， 自动释放|\n|堆区|用于动态内存分配|手动分配和释放 ， 可占用80%内存|\n|全局区或静态区|在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）|只初始化一次|\n|程序代码区|代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。|代码区的指令中包括操作码和要操作的对象（或对象地址引用）|\n\n---\n\n理解指针的操作，更加有助于我们更快的理解数据结构和算法。\n\n## 致谢\n感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。\n\n[前端小然子的博客](https://xiaoranzife.com \"前端小然子\")\n","source":"_posts/arithmetic/pointer.md","raw":"---\ntitle: 理解内存与指针\nauthor: 前端小然子\n---\n\n# 理解内存与指针\n\n## 内存与内存地址\n\n### 什么是内存\n---\n\n内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。\n\n内存也被称为 内储存器 和 主存储器，其作用是用于暂时存放CPU中的运算数据，以及和硬盘等外部存储器交换的数据。下面是CPU的组成和工作原理：\n\n![图一](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/cpu.png?raw=true)\n\n<!-- <img src=\"/images/cpu.png\"> -->\n\n在计算机的组成结构中，有一个很重要的部分是储存器。\n\n存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存）。\n\n内存就是暂时存储程序以及数据的地方，相对于外存（硬盘是外存的一种）而言，我们在电脑上输入文字、字符的时候，它就会被存入内存中，只有当你选择保存文件的时候，内存中的数据才会被存入硬盘。\n\n内存是CPU能够直接寻址的存储空间，特点是存取速率特别快，临时存放数据，不能永久保存数据。\n\n外存是计算机的存储器的一种，主要用来存放暂时不用的程序和数据。特定是容量大、价格低，但是存取速度慢。外存和内存之间尝尝频繁的交换信息。\n\n### 什么是内存地址\n---\n\n内存地址是用于软硬件等不同层级中的数据概念，用来访问内存中的数据。\n\n可以通过WiKi或者百度百科进行更加深入的了解。\n\n## 指针、地址与引用\n\n### 引用\n---\n\n引用是一个变量的别名，为什么引入别名？是因为我们想定义一个变量，由这个变量来共享另一个变量的内存空间，所以使用别名是一个很好的选择。\n\n变量是什么？ 是一个内存空间的名字，如果我们给这个内存空间再另外起一个名字，就是能共享这个内存了，引用（别名）由此而来。\n\n比如：\n```javascript\nvar obj = { a: 1, b: 2 };\nvar obj1 = obj;\n```\n\n这里我们就可以说变量obj1是变量obj的一个引用；（因为在javascript中，object类型的赋值，是引用地址赋值）\n\n### 指针\n---\n\n指针，指向另一个内存空间的变量，我们可以用个它来索引另一个内存空间中的内容，而指针本身有自己的内存空间。\n\n如下图所示：\n\n![图二](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer.png?raw=true)\n\n### 两者区别\n---\n\n引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。\n\n引用在开始的时候就绑定到了一个内存空间(开始必须赋初值), 所以它只能是这个内存空间的名字, 而不能改成其他的, 当然, 我们可以改变这个内存空间的值。\n\neg:\n```javascript\nvar obj = { a: 1, b: 2 };\nvar obj1 = obj;\n\nobj.b = 3;\n// {a: 1, b: 3 }\n\nobj1.a = 4;\n// {a: 4, b: 3 }\n\nobj1 = { a:1, c:2 };\nconsole.log(obj1);\n// { a:1, c:2 };\nconsole.log(obj);\n// {a: 4, b: 3 }\n```\n这段代码的过程如下：\n\n![图三](https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer-yinyong.png?raw=true)\n\n## 指向变量的指针\n\n一个变量的地址指出了变量的存储单元在内存中的具体位置，能对变量进行存取操作。那这个变量就是指向变量的指针。\n\n可以参考上面的 ***“图二”*** 可以很好的理解指向变量的指针。\n\n## 指向指针的指针\n\n如果一个指针变量存放的又是另一个指针变量的地址，则称这个变量为指向指针的指针变量或指向指针的指针。\n\n```c\n#include <stdio.h>\n\n// 入口主函数\nvoid main () {\n    int a = 5;\n    // 这里&a就是变量a的内存地址\n    int *p = &a;\n    // 这里是打印输出变量a的值\n    printf(\"%d\\n\", *p);\n}\n```\n\n## 指向函数的指针\n\n指向函数的指针变量被称为函数指针。本身是指针变量，只不过该指针变量指向函数。\n\n有了函数指针之后，就可以用该指针变量来调用函数。\n\n函数指针有两个用途：\n\n- 调用函数\n\n- 做函数的参数\n\n```javascript\n\n// 调用函数\nfunction max (x, y) {\n    return x > y ? x : y;\n}\n\nmax(1, 2);\n\n\n// 做函数的参数\nconst a = [1,5,3,4,78,96,54,1,2,3,4];\n\nfunction sum(total, num) {\n    return total + Math.round(num);\n}\n\na.reduce(sum);\n\n```\n\n以上例子中 **max** 和 **sum** 都是指向函数的指针变量。\n\n## 多级指针\n\n多级指针，是指 “指向地址的指针”;\n\n### 一级指针\n---\n\n```c\n#include <stdio.h>\n\n// 入口主函数\nvoid main () {\n    int i = 10;\n    // 这里&a就是变量a的内存地址\n    int *p1 = &a;\n    // 这里是打印输出变量a的值\n    printf(\"%d\\n\", *p1);\n}\n```\n在这里的 *p1 就是一级指针\n\n这里同样参考 ***“图二”*** 来理解\n\n指针变量p可以通过 *p1 来获取到变量i的值，也可以进行修改操作，总之 *p1 可以操作变量i的内存空间，所以 * 是一个操作内存空间的一个符号。\n\n*p也就被称为一级指针。\n\n### 二级指针\n---\n\n同上面讲的一级指针原理一致。\n\n```c\n#include <stdio.h>\n\n// 入口主函数\nvoid main () {\n    int i = 10;\n    // 这里&a就是变量a的内存地址\n    int *p1 = &a;\n    int **p2 = &p1;\n}\n```\n\n**p2 即为二级指针。\n\n---\n\n其余多级指针依旧同理：\n```c\nint ***p3 = &p2;\nint ****p4 = &p3;\n```\n\n## 动态内存分配\n\n|内存|描述|特性|\n|-|-|-|\n|栈区|是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow|自动分配 ， 自动释放|\n|堆区|用于动态内存分配|手动分配和释放 ， 可占用80%内存|\n|全局区或静态区|在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）|只初始化一次|\n|程序代码区|代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。|代码区的指令中包括操作码和要操作的对象（或对象地址引用）|\n\n---\n\n理解指针的操作，更加有助于我们更快的理解数据结构和算法。\n\n## 致谢\n感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。\n\n[前端小然子的博客](https://xiaoranzife.com \"前端小然子\")\n","slug":"arithmetic/pointer","published":1,"date":"2019-10-15T03:15:26.025Z","updated":"2019-10-16T03:13:23.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oq90009b0u6a5yjthm8","content":"<h1 id=\"理解内存与指针\"><a href=\"#理解内存与指针\" class=\"headerlink\" title=\"理解内存与指针\"></a>理解内存与指针</h1><h2 id=\"内存与内存地址\"><a href=\"#内存与内存地址\" class=\"headerlink\" title=\"内存与内存地址\"></a>内存与内存地址</h2><h3 id=\"什么是内存\"><a href=\"#什么是内存\" class=\"headerlink\" title=\"什么是内存\"></a>什么是内存</h3><hr>\n<p>内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p>\n<p>内存也被称为 内储存器 和 主存储器，其作用是用于暂时存放CPU中的运算数据，以及和硬盘等外部存储器交换的数据。下面是CPU的组成和工作原理：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/cpu.png?raw=true\" alt=\"图一\"></p>\n<!-- <img src=\"/images/cpu.png\"> -->\n\n<p>在计算机的组成结构中，有一个很重要的部分是储存器。</p>\n<p>存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存）。</p>\n<p>内存就是暂时存储程序以及数据的地方，相对于外存（硬盘是外存的一种）而言，我们在电脑上输入文字、字符的时候，它就会被存入内存中，只有当你选择保存文件的时候，内存中的数据才会被存入硬盘。</p>\n<p>内存是CPU能够直接寻址的存储空间，特点是存取速率特别快，临时存放数据，不能永久保存数据。</p>\n<p>外存是计算机的存储器的一种，主要用来存放暂时不用的程序和数据。特定是容量大、价格低，但是存取速度慢。外存和内存之间尝尝频繁的交换信息。</p>\n<h3 id=\"什么是内存地址\"><a href=\"#什么是内存地址\" class=\"headerlink\" title=\"什么是内存地址\"></a>什么是内存地址</h3><hr>\n<p>内存地址是用于软硬件等不同层级中的数据概念，用来访问内存中的数据。</p>\n<p>可以通过WiKi或者百度百科进行更加深入的了解。</p>\n<h2 id=\"指针、地址与引用\"><a href=\"#指针、地址与引用\" class=\"headerlink\" title=\"指针、地址与引用\"></a>指针、地址与引用</h2><h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><hr>\n<p>引用是一个变量的别名，为什么引入别名？是因为我们想定义一个变量，由这个变量来共享另一个变量的内存空间，所以使用别名是一个很好的选择。</p>\n<p>变量是什么？ 是一个内存空间的名字，如果我们给这个内存空间再另外起一个名字，就是能共享这个内存了，引用（别名）由此而来。</p>\n<p>比如：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这里我们就可以说变量obj1是变量obj的一个引用；（因为在javascript中，object类型的赋值，是引用地址赋值）</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><hr>\n<p>指针，指向另一个内存空间的变量，我们可以用个它来索引另一个内存空间中的内容，而指针本身有自己的内存空间。</p>\n<p>如下图所示：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer.png?raw=true\" alt=\"图二\"></p>\n<h3 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h3><hr>\n<p>引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。</p>\n<p>引用在开始的时候就绑定到了一个内存空间(开始必须赋初值), 所以它只能是这个内存空间的名字, 而不能改成其他的, 当然, 我们可以改变这个内存空间的值。</p>\n<p>eg:</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">;</span>\n\nobj<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// {a: 1, b: 3 }</span>\n\nobj1<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// {a: 4, b: 3 }</span>\n\nobj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">:</span><span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// { a:1, c:2 };</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// {a: 4, b: 3 }</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这段代码的过程如下：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer-yinyong.png?raw=true\" alt=\"图三\"></p>\n<h2 id=\"指向变量的指针\"><a href=\"#指向变量的指针\" class=\"headerlink\" title=\"指向变量的指针\"></a>指向变量的指针</h2><p>一个变量的地址指出了变量的存储单元在内存中的具体位置，能对变量进行存取操作。那这个变量就是指向变量的指针。</p>\n<p>可以参考上面的 <strong><em>“图二”</em></strong> 可以很好的理解指向变量的指针。</p>\n<h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个变量为指向指针的指针变量或指向指针的指针。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 入口主函数</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里&amp;a就是变量a的内存地址</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里是打印输出变量a的值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"指向函数的指针\"><a href=\"#指向函数的指针\" class=\"headerlink\" title=\"指向函数的指针\"></a>指向函数的指针</h2><p>指向函数的指针变量被称为函数指针。本身是指针变量，只不过该指针变量指向函数。</p>\n<p>有了函数指针之后，就可以用该指针变量来调用函数。</p>\n<p>函数指针有两个用途：</p>\n<ul>\n<li><p>调用函数</p>\n</li>\n<li><p>做函数的参数</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">\n<span class=\"token comment\" spellcheck=\"true\">// 调用函数</span>\n<span class=\"token keyword\">function</span> max <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">></span> y <span class=\"token operator\">?</span> x <span class=\"token punctuation\">:</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 做函数的参数</span>\n<span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">78</span><span class=\"token punctuation\">,</span><span class=\"token number\">96</span><span class=\"token punctuation\">,</span><span class=\"token number\">54</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>total<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> total <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>以上例子中 <strong>max</strong> 和 <strong>sum</strong> 都是指向函数的指针变量。</p>\n<h2 id=\"多级指针\"><a href=\"#多级指针\" class=\"headerlink\" title=\"多级指针\"></a>多级指针</h2><p>多级指针，是指 “指向地址的指针”;</p>\n<h3 id=\"一级指针\"><a href=\"#一级指针\" class=\"headerlink\" title=\"一级指针\"></a>一级指针</h3><hr>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 入口主函数</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里&amp;a就是变量a的内存地址</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里是打印输出变量a的值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在这里的 *p1 就是一级指针</p>\n<p>这里同样参考 <strong><em>“图二”</em></strong> 来理解</p>\n<p>指针变量p可以通过 *p1 来获取到变量i的值，也可以进行修改操作，总之 *p1 可以操作变量i的内存空间，所以 * 是一个操作内存空间的一个符号。</p>\n<p>*p也就被称为一级指针。</p>\n<h3 id=\"二级指针\"><a href=\"#二级指针\" class=\"headerlink\" title=\"二级指针\"></a>二级指针</h3><hr>\n<p>同上面讲的一级指针原理一致。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 入口主函数</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里&amp;a就是变量a的内存地址</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>p2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>**p2 即为二级指针。</p>\n<hr>\n<p>其余多级指针依旧同理：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>p3 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p2<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>p4 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p3<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"动态内存分配\"><a href=\"#动态内存分配\" class=\"headerlink\" title=\"动态内存分配\"></a>动态内存分配</h2><table>\n<thead>\n<tr>\n<th>内存</th>\n<th>描述</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>栈区</td>\n<td>是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow</td>\n<td>自动分配 ， 自动释放</td>\n</tr>\n<tr>\n<td>堆区</td>\n<td>用于动态内存分配</td>\n<td>手动分配和释放 ， 可占用80%内存</td>\n</tr>\n<tr>\n<td>全局区或静态区</td>\n<td>在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）</td>\n<td>只初始化一次</td>\n</tr>\n<tr>\n<td>程序代码区</td>\n<td>代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</td>\n<td>代码区的指令中包括操作码和要操作的对象（或对象地址引用）</td>\n</tr>\n</tbody></table>\n<hr>\n<p>理解指针的操作，更加有助于我们更快的理解数据结构和算法。</p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。</p>\n<p><a href=\"https://xiaoranzife.com\" title=\"前端小然子\" target=\"_blank\" rel=\"noopener\">前端小然子的博客</a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h1 id=\"理解内存与指针\"><a href=\"#理解内存与指针\" class=\"headerlink\" title=\"理解内存与指针\"></a>理解内存与指针</h1><h2 id=\"内存与内存地址\"><a href=\"#内存与内存地址\" class=\"headerlink\" title=\"内存与内存地址\"></a>内存与内存地址</h2><h3 id=\"什么是内存\"><a href=\"#什么是内存\" class=\"headerlink\" title=\"什么是内存\"></a>什么是内存</h3><hr>\n<p>内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p>\n<p>内存也被称为 内储存器 和 主存储器，其作用是用于暂时存放CPU中的运算数据，以及和硬盘等外部存储器交换的数据。下面是CPU的组成和工作原理：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/cpu.png?raw=true\" alt=\"图一\"></p>\n<!-- <img src=\"/images/cpu.png\"> -->\n\n<p>在计算机的组成结构中，有一个很重要的部分是储存器。</p>\n<p>存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存）。</p>\n<p>内存就是暂时存储程序以及数据的地方，相对于外存（硬盘是外存的一种）而言，我们在电脑上输入文字、字符的时候，它就会被存入内存中，只有当你选择保存文件的时候，内存中的数据才会被存入硬盘。</p>\n<p>内存是CPU能够直接寻址的存储空间，特点是存取速率特别快，临时存放数据，不能永久保存数据。</p>\n<p>外存是计算机的存储器的一种，主要用来存放暂时不用的程序和数据。特定是容量大、价格低，但是存取速度慢。外存和内存之间尝尝频繁的交换信息。</p>\n<h3 id=\"什么是内存地址\"><a href=\"#什么是内存地址\" class=\"headerlink\" title=\"什么是内存地址\"></a>什么是内存地址</h3><hr>\n<p>内存地址是用于软硬件等不同层级中的数据概念，用来访问内存中的数据。</p>\n<p>可以通过WiKi或者百度百科进行更加深入的了解。</p>\n<h2 id=\"指针、地址与引用\"><a href=\"#指针、地址与引用\" class=\"headerlink\" title=\"指针、地址与引用\"></a>指针、地址与引用</h2><h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><hr>\n<p>引用是一个变量的别名，为什么引入别名？是因为我们想定义一个变量，由这个变量来共享另一个变量的内存空间，所以使用别名是一个很好的选择。</p>\n<p>变量是什么？ 是一个内存空间的名字，如果我们给这个内存空间再另外起一个名字，就是能共享这个内存了，引用（别名）由此而来。</p>\n<p>比如：</p>\n<pre><code class=\"javascript\">var obj = { a: 1, b: 2 };\nvar obj1 = obj;</code></pre>\n<p>这里我们就可以说变量obj1是变量obj的一个引用；（因为在javascript中，object类型的赋值，是引用地址赋值）</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><hr>\n<p>指针，指向另一个内存空间的变量，我们可以用个它来索引另一个内存空间中的内容，而指针本身有自己的内存空间。</p>\n<p>如下图所示：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer.png?raw=true\" alt=\"图二\"></p>\n<h3 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h3><hr>\n<p>引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。</p>\n<p>引用在开始的时候就绑定到了一个内存空间(开始必须赋初值), 所以它只能是这个内存空间的名字, 而不能改成其他的, 当然, 我们可以改变这个内存空间的值。</p>\n<p>eg:</p>\n<pre><code class=\"javascript\">var obj = { a: 1, b: 2 };\nvar obj1 = obj;\n\nobj.b = 3;\n// {a: 1, b: 3 }\n\nobj1.a = 4;\n// {a: 4, b: 3 }\n\nobj1 = { a:1, c:2 };\nconsole.log(obj1);\n// { a:1, c:2 };\nconsole.log(obj);\n// {a: 4, b: 3 }</code></pre>\n<p>这段代码的过程如下：</p>\n<p><img src=\"https://github.com/MarsPen/-notes-summary/blob/xiaoranzife/source/images/pointer-yinyong.png?raw=true\" alt=\"图三\"></p>\n<h2 id=\"指向变量的指针\"><a href=\"#指向变量的指针\" class=\"headerlink\" title=\"指向变量的指针\"></a>指向变量的指针</h2><p>一个变量的地址指出了变量的存储单元在内存中的具体位置，能对变量进行存取操作。那这个变量就是指向变量的指针。</p>\n<p>可以参考上面的 <strong><em>“图二”</em></strong> 可以很好的理解指向变量的指针。</p>\n<h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个变量为指向指针的指针变量或指向指针的指针。</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\n// 入口主函数\nvoid main () {\n    int a = 5;\n    // 这里&amp;a就是变量a的内存地址\n    int *p = &amp;a;\n    // 这里是打印输出变量a的值\n    printf(&quot;%d\\n&quot;, *p);\n}</code></pre>\n<h2 id=\"指向函数的指针\"><a href=\"#指向函数的指针\" class=\"headerlink\" title=\"指向函数的指针\"></a>指向函数的指针</h2><p>指向函数的指针变量被称为函数指针。本身是指针变量，只不过该指针变量指向函数。</p>\n<p>有了函数指针之后，就可以用该指针变量来调用函数。</p>\n<p>函数指针有两个用途：</p>\n<ul>\n<li><p>调用函数</p>\n</li>\n<li><p>做函数的参数</p>\n</li>\n</ul>\n<pre><code class=\"javascript\">\n// 调用函数\nfunction max (x, y) {\n    return x &gt; y ? x : y;\n}\n\nmax(1, 2);\n\n\n// 做函数的参数\nconst a = [1,5,3,4,78,96,54,1,2,3,4];\n\nfunction sum(total, num) {\n    return total + Math.round(num);\n}\n\na.reduce(sum);\n</code></pre>\n<p>以上例子中 <strong>max</strong> 和 <strong>sum</strong> 都是指向函数的指针变量。</p>\n<h2 id=\"多级指针\"><a href=\"#多级指针\" class=\"headerlink\" title=\"多级指针\"></a>多级指针</h2><p>多级指针，是指 “指向地址的指针”;</p>\n<h3 id=\"一级指针\"><a href=\"#一级指针\" class=\"headerlink\" title=\"一级指针\"></a>一级指针</h3><hr>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\n// 入口主函数\nvoid main () {\n    int i = 10;\n    // 这里&amp;a就是变量a的内存地址\n    int *p1 = &amp;a;\n    // 这里是打印输出变量a的值\n    printf(&quot;%d\\n&quot;, *p1);\n}</code></pre>\n<p>在这里的 *p1 就是一级指针</p>\n<p>这里同样参考 <strong><em>“图二”</em></strong> 来理解</p>\n<p>指针变量p可以通过 *p1 来获取到变量i的值，也可以进行修改操作，总之 *p1 可以操作变量i的内存空间，所以 * 是一个操作内存空间的一个符号。</p>\n<p>*p也就被称为一级指针。</p>\n<h3 id=\"二级指针\"><a href=\"#二级指针\" class=\"headerlink\" title=\"二级指针\"></a>二级指针</h3><hr>\n<p>同上面讲的一级指针原理一致。</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\n// 入口主函数\nvoid main () {\n    int i = 10;\n    // 这里&amp;a就是变量a的内存地址\n    int *p1 = &amp;a;\n    int **p2 = &amp;p1;\n}</code></pre>\n<p>**p2 即为二级指针。</p>\n<hr>\n<p>其余多级指针依旧同理：</p>\n<pre><code class=\"c\">int ***p3 = &amp;p2;\nint ****p4 = &amp;p3;</code></pre>\n<h2 id=\"动态内存分配\"><a href=\"#动态内存分配\" class=\"headerlink\" title=\"动态内存分配\"></a>动态内存分配</h2><table>\n<thead>\n<tr>\n<th>内存</th>\n<th>描述</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>栈区</td>\n<td>是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow</td>\n<td>自动分配 ， 自动释放</td>\n</tr>\n<tr>\n<td>堆区</td>\n<td>用于动态内存分配</td>\n<td>手动分配和释放 ， 可占用80%内存</td>\n</tr>\n<tr>\n<td>全局区或静态区</td>\n<td>在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）</td>\n<td>只初始化一次</td>\n</tr>\n<tr>\n<td>程序代码区</td>\n<td>代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</td>\n<td>代码区的指令中包括操作码和要操作的对象（或对象地址引用）</td>\n</tr>\n</tbody></table>\n<hr>\n<p>理解指针的操作，更加有助于我们更快的理解数据结构和算法。</p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客。</p>\n<p><a href=\"https://xiaoranzife.com\" title=\"前端小然子\" target=\"_blank\" rel=\"noopener\">前端小然子的博客</a></p>\n"},{"title":"HTML 系列总结","date":"2017-05-10T14:00:00.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"包含 html 的基本概念，标准模式和混杂模式，html语义化，同源策略，跨域等基础知识。","_content":"\n<div align=\"middle\"><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66\"></iframe></div>\n\n\n### 什么是html\n超文本标记语言（HyperText Markup Language），是“网页浏览器中看到展示信息的”设计的一种标记语言。\n\n### Doctype含义\n\n- <!DOCTYPE>声明位于位于HTML文档中的第一行，告诉浏览器的解释器用什么文档标准来解析这个文档。\n- DOCTYPE书写错误或者不存在会导致文档已兼容模式呈现\n\n### 标准模式和混杂模式\n- 标准模式： html 排版和 js 渲染工作模式都是以该浏览器支持的最高标准运行。\n- 兼容模式：页面已宽松的向后兼容的方式显示，模拟老浏览器的行为。\n\n### HTML5 为什么只需要写 `<!DOCTYPE HTML>`\n\nhtml5不是基于SGML，所以不需要对DTD进行引用，但是它需要对文档类型声明，需要doctype来规范浏览器行为。\n\n### 行内元素-块级元素-空元素\n-  css中规定每个元素都有默认的display属性和值\n-  该元素的属性的值为‘inline’的则为行内元素（如:`span,a img,input`等）\n-  该元素的属性的值为‘block’的则为块级元素（`div，ul,li h1...p`等）\n-  空（void）元素 `<br> <hr> <img> <input> <link> <meta>` 等\n\n### html语义化\n1. 定义：正确的标签做正确的事情\n2. 为什么要做语义化\n  -  有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。\n  -  在没有CSS的时候能够清晰的看出网页的结构，增强可读性，便于团队开发和维护。\n  -  支持多终端设备的浏览器渲染。\n3. SEO\n  - 汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。\n  - 目的：\n    为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力。\n  - 优化方式： \n    - 内部优化：\n      1. META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化。\n      2. 内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接。\n      3. 网站内容更新：每天保持站内的更新(主要是文章的更新等)。\n    - 外部优化：\n      1. 外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性。\n      2. 外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。\n      3. 外链选择：与一些和你网站相关性比较高，整体质量比较好的网站交换友情链接，巩固稳定关键词排名。\n\n### 同源策略\n1. 概念：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。\n2. 目的：保证用户信息安全，防止恶意网站窃取数据，防止cookie共享\n3. 限制范围\n  - cookie、localStorage、indexedDB无法读取\n  - dom 无法获取\n  - ajax不能发送\n  - form表单没有限制\n4. 如何设置同源策略(host)：document.domain\n5. 不受同源策略限制：\n  - 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。\n  - 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等。\n\n### 跨域\n  受到浏览器同源策略的影响，要操作其他源下面的脚本，就需要跨域。\n\n### Ajax跨域的解决方案\n**1.JSONP：**\n\n  网页添加一个`<script>`元素，向服务器请求jsON数据。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n\n    - 缺点只支持get请求\n    - 优点简单方便，易理解，兼容性良好\n    - 如下示例代码\n    ```\n      //动态创建script，用于跨越操作\n      function creatScriptTag(src) {\n        var script = document.createElement('script');\n        script.setAttribute(\"type\",\"text/javascript\");\n        script.src = src;\n        document.body.appendChild(script);\n      }\n      // 调用creatScriptTag函数\n      window.onload = function () {\n        var url = '/index.php?jsoncallback=result';\n        creatScriptTag(url);\n      }\n      // 定义回调函数\n      function result (data) {\n        console.log(data);\n      } \n    ```\n\n    ```\n      // index.php \n      <?php\n      header('Content-type: application/json');\n      //获取回调函数名\n      $jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);\n      //取数据\n      $data = [\n        'data'=>'123',\n      ];\n      $json_data = json_encode(array('code'=>'200','msg'=>'请求成功','data' => $data),jsON_UNESCAPED_UNICODE);\n      //输出jsonp格式的数据\n      echo $jsoncallback .\"(\" . $json_data . \")\";\n      ?>\n    ```\n    \n**2.WebSocket:**\n\n  是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器设置利用origin字段设置白名单，就可以通过它进行跨源通信。\n\n**3.CORS（Cross-Origin Resource Sharing）**\n   - 在请求头信息中增加Origin字段，用来说明此次请求来自那个源（协议+域名+端口），此字段可以设置相应白名单\n   - 必须设置`Access-Control-Allow-Origin`字段，值要求是`Origin`字段的值或者是*，*的意思是接受任意域名的请求\n   - CORS请求默认不发送cookie和http认证信息，如果要发送，要在服务器端指`Access-Control-Allow-Credentials: true`,并且ajax请求必须打开withCredentials属性\n   ```\n   var xhr = new XMLHttpRequest();\n   xhr.withCredentials = true;\n   ```\n   - 如果选择发送cookie,`Access-Control-Allow-Origin`字段不能设为*，必须指定明确的，与当前网页一致的域名\n\n\n\n\n","source":"_posts/html/html.md","raw":"---\ntitle: HTML 系列总结\ndate: 2017-05-10 22:00:00\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: 包含 html 的基本概念，标准模式和混杂模式，html语义化，同源策略，跨域等基础知识。\ntags:\n- HTML\ncategories:\n- HTML\n---\n\n<div align=\"middle\"><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66\"></iframe></div>\n\n\n### 什么是html\n超文本标记语言（HyperText Markup Language），是“网页浏览器中看到展示信息的”设计的一种标记语言。\n\n### Doctype含义\n\n- <!DOCTYPE>声明位于位于HTML文档中的第一行，告诉浏览器的解释器用什么文档标准来解析这个文档。\n- DOCTYPE书写错误或者不存在会导致文档已兼容模式呈现\n\n### 标准模式和混杂模式\n- 标准模式： html 排版和 js 渲染工作模式都是以该浏览器支持的最高标准运行。\n- 兼容模式：页面已宽松的向后兼容的方式显示，模拟老浏览器的行为。\n\n### HTML5 为什么只需要写 `<!DOCTYPE HTML>`\n\nhtml5不是基于SGML，所以不需要对DTD进行引用，但是它需要对文档类型声明，需要doctype来规范浏览器行为。\n\n### 行内元素-块级元素-空元素\n-  css中规定每个元素都有默认的display属性和值\n-  该元素的属性的值为‘inline’的则为行内元素（如:`span,a img,input`等）\n-  该元素的属性的值为‘block’的则为块级元素（`div，ul,li h1...p`等）\n-  空（void）元素 `<br> <hr> <img> <input> <link> <meta>` 等\n\n### html语义化\n1. 定义：正确的标签做正确的事情\n2. 为什么要做语义化\n  -  有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。\n  -  在没有CSS的时候能够清晰的看出网页的结构，增强可读性，便于团队开发和维护。\n  -  支持多终端设备的浏览器渲染。\n3. SEO\n  - 汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。\n  - 目的：\n    为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力。\n  - 优化方式： \n    - 内部优化：\n      1. META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化。\n      2. 内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接。\n      3. 网站内容更新：每天保持站内的更新(主要是文章的更新等)。\n    - 外部优化：\n      1. 外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性。\n      2. 外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。\n      3. 外链选择：与一些和你网站相关性比较高，整体质量比较好的网站交换友情链接，巩固稳定关键词排名。\n\n### 同源策略\n1. 概念：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。\n2. 目的：保证用户信息安全，防止恶意网站窃取数据，防止cookie共享\n3. 限制范围\n  - cookie、localStorage、indexedDB无法读取\n  - dom 无法获取\n  - ajax不能发送\n  - form表单没有限制\n4. 如何设置同源策略(host)：document.domain\n5. 不受同源策略限制：\n  - 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。\n  - 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等。\n\n### 跨域\n  受到浏览器同源策略的影响，要操作其他源下面的脚本，就需要跨域。\n\n### Ajax跨域的解决方案\n**1.JSONP：**\n\n  网页添加一个`<script>`元素，向服务器请求jsON数据。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n\n    - 缺点只支持get请求\n    - 优点简单方便，易理解，兼容性良好\n    - 如下示例代码\n    ```\n      //动态创建script，用于跨越操作\n      function creatScriptTag(src) {\n        var script = document.createElement('script');\n        script.setAttribute(\"type\",\"text/javascript\");\n        script.src = src;\n        document.body.appendChild(script);\n      }\n      // 调用creatScriptTag函数\n      window.onload = function () {\n        var url = '/index.php?jsoncallback=result';\n        creatScriptTag(url);\n      }\n      // 定义回调函数\n      function result (data) {\n        console.log(data);\n      } \n    ```\n\n    ```\n      // index.php \n      <?php\n      header('Content-type: application/json');\n      //获取回调函数名\n      $jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);\n      //取数据\n      $data = [\n        'data'=>'123',\n      ];\n      $json_data = json_encode(array('code'=>'200','msg'=>'请求成功','data' => $data),jsON_UNESCAPED_UNICODE);\n      //输出jsonp格式的数据\n      echo $jsoncallback .\"(\" . $json_data . \")\";\n      ?>\n    ```\n    \n**2.WebSocket:**\n\n  是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器设置利用origin字段设置白名单，就可以通过它进行跨源通信。\n\n**3.CORS（Cross-Origin Resource Sharing）**\n   - 在请求头信息中增加Origin字段，用来说明此次请求来自那个源（协议+域名+端口），此字段可以设置相应白名单\n   - 必须设置`Access-Control-Allow-Origin`字段，值要求是`Origin`字段的值或者是*，*的意思是接受任意域名的请求\n   - CORS请求默认不发送cookie和http认证信息，如果要发送，要在服务器端指`Access-Control-Allow-Credentials: true`,并且ajax请求必须打开withCredentials属性\n   ```\n   var xhr = new XMLHttpRequest();\n   xhr.withCredentials = true;\n   ```\n   - 如果选择发送cookie,`Access-Control-Allow-Origin`字段不能设为*，必须指定明确的，与当前网页一致的域名\n\n\n\n\n","slug":"html/html","published":1,"updated":"2019-10-15T01:29:42.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqa000ab0u6l7vpb3jz","content":"<div align=\"middle\"><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66\"></iframe></div>\n\n\n<h3 id=\"什么是html\"><a href=\"#什么是html\" class=\"headerlink\" title=\"什么是html\"></a>什么是html</h3><p>超文本标记语言（HyperText Markup Language），是“网页浏览器中看到展示信息的”设计的一种标记语言。</p>\n<h3 id=\"Doctype含义\"><a href=\"#Doctype含义\" class=\"headerlink\" title=\"Doctype含义\"></a>Doctype含义</h3><ul>\n<li><!DOCTYPE>声明位于位于HTML文档中的第一行，告诉浏览器的解释器用什么文档标准来解析这个文档。</li>\n<li>DOCTYPE书写错误或者不存在会导致文档已兼容模式呈现</li>\n</ul>\n<h3 id=\"标准模式和混杂模式\"><a href=\"#标准模式和混杂模式\" class=\"headerlink\" title=\"标准模式和混杂模式\"></a>标准模式和混杂模式</h3><ul>\n<li>标准模式： html 排版和 js 渲染工作模式都是以该浏览器支持的最高标准运行。</li>\n<li>兼容模式：页面已宽松的向后兼容的方式显示，模拟老浏览器的行为。</li>\n</ul>\n<h3 id=\"HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt\"><a href=\"#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt\" class=\"headerlink\" title=\"HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;\"></a>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code></h3><p>html5不是基于SGML，所以不需要对DTD进行引用，但是它需要对文档类型声明，需要doctype来规范浏览器行为。</p>\n<h3 id=\"行内元素-块级元素-空元素\"><a href=\"#行内元素-块级元素-空元素\" class=\"headerlink\" title=\"行内元素-块级元素-空元素\"></a>行内元素-块级元素-空元素</h3><ul>\n<li>css中规定每个元素都有默认的display属性和值</li>\n<li>该元素的属性的值为‘inline’的则为行内元素（如:<code>span,a img,input</code>等）</li>\n<li>该元素的属性的值为‘block’的则为块级元素（<code>div，ul,li h1...p</code>等）</li>\n<li>空（void）元素 <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code> 等</li>\n</ul>\n<h3 id=\"html语义化\"><a href=\"#html语义化\" class=\"headerlink\" title=\"html语义化\"></a>html语义化</h3><ol>\n<li>定义：正确的标签做正确的事情</li>\n<li>为什么要做语义化<ul>\n<li>有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。</li>\n<li>在没有CSS的时候能够清晰的看出网页的结构，增强可读性，便于团队开发和维护。</li>\n<li>支持多终端设备的浏览器渲染。</li>\n</ul>\n</li>\n<li>SEO<ul>\n<li>汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</li>\n<li>目的：<br>为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力。</li>\n<li>优化方式： <ul>\n<li>内部优化：<ol>\n<li>META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化。</li>\n<li>内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接。</li>\n<li>网站内容更新：每天保持站内的更新(主要是文章的更新等)。</li>\n</ol>\n</li>\n<li>外部优化：<ol>\n<li>外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性。</li>\n<li>外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。</li>\n<li>外链选择：与一些和你网站相关性比较高，整体质量比较好的网站交换友情链接，巩固稳定关键词排名。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ol>\n<li>概念：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</li>\n<li>目的：保证用户信息安全，防止恶意网站窃取数据，防止cookie共享</li>\n<li>限制范围<ul>\n<li>cookie、localStorage、indexedDB无法读取</li>\n<li>dom 无法获取</li>\n<li>ajax不能发送</li>\n<li>form表单没有限制</li>\n</ul>\n</li>\n<li>如何设置同源策略(host)：document.domain</li>\n<li>不受同源策略限制：<ul>\n<li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</li>\n<li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>  受到浏览器同源策略的影响，要操作其他源下面的脚本，就需要跨域。</p>\n<h3 id=\"Ajax跨域的解决方案\"><a href=\"#Ajax跨域的解决方案\" class=\"headerlink\" title=\"Ajax跨域的解决方案\"></a>Ajax跨域的解决方案</h3><p><strong>1.JSONP：</strong></p>\n<p>  网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求jsON数据。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>\n<pre><code>- 缺点只支持get请求\n- 优点简单方便，易理解，兼容性良好\n- 如下示例代码\n```\n  //动态创建script，用于跨越操作\n  function creatScriptTag(src) {\n    var script = document.createElement(&#39;script&#39;);\n    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);\n    script.src = src;\n    document.body.appendChild(script);\n  }\n  // 调用creatScriptTag函数\n  window.onload = function () {\n    var url = &#39;/index.php?jsoncallback=result&#39;;\n    creatScriptTag(url);\n  }\n  // 定义回调函数\n  function result (data) {\n    console.log(data);\n  } \n```\n\n```\n  // index.php \n  &lt;?php\n  header(&#39;Content-type: application/json&#39;);\n  //获取回调函数名\n  $jsoncallback = htmlspecialchars($_REQUEST [&#39;jsoncallback&#39;]);\n  //取数据\n  $data = [\n    &#39;data&#39;=&gt;&#39;123&#39;,\n  ];\n  $json_data = json_encode(array(&#39;code&#39;=&gt;&#39;200&#39;,&#39;msg&#39;=&gt;&#39;请求成功&#39;,&#39;data&#39; =&gt; $data),jsON_UNESCAPED_UNICODE);\n  //输出jsonp格式的数据\n  echo $jsoncallback .&quot;(&quot; . $json_data . &quot;)&quot;;\n  ?&gt;\n```</code></pre><p><strong>2.WebSocket:</strong></p>\n<p>  是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器设置利用origin字段设置白名单，就可以通过它进行跨源通信。</p>\n<p><strong>3.CORS（Cross-Origin Resource Sharing）</strong></p>\n<ul>\n<li>在请求头信息中增加Origin字段，用来说明此次请求来自那个源（协议+域名+端口），此字段可以设置相应白名单</li>\n<li>必须设置<code>Access-Control-Allow-Origin</code>字段，值要求是<code>Origin</code>字段的值或者是<em>，</em>的意思是接受任意域名的请求</li>\n<li>CORS请求默认不发送cookie和http认证信息，如果要发送，要在服务器端指<code>Access-Control-Allow-Credentials: true</code>,并且ajax请求必须打开withCredentials属性<pre><code>var xhr = new XMLHttpRequest();\nxhr.withCredentials = true;</code></pre></li>\n<li>如果选择发送cookie,<code>Access-Control-Allow-Origin</code>字段不能设为*，必须指定明确的，与当前网页一致的域名</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<div align=\"middle\"><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66\"></iframe></div>\n\n\n<h3 id=\"什么是html\"><a href=\"#什么是html\" class=\"headerlink\" title=\"什么是html\"></a>什么是html</h3><p>超文本标记语言（HyperText Markup Language），是“网页浏览器中看到展示信息的”设计的一种标记语言。</p>\n<h3 id=\"Doctype含义\"><a href=\"#Doctype含义\" class=\"headerlink\" title=\"Doctype含义\"></a>Doctype含义</h3><ul>\n<li><!DOCTYPE>声明位于位于HTML文档中的第一行，告诉浏览器的解释器用什么文档标准来解析这个文档。</li>\n<li>DOCTYPE书写错误或者不存在会导致文档已兼容模式呈现</li>\n</ul>\n<h3 id=\"标准模式和混杂模式\"><a href=\"#标准模式和混杂模式\" class=\"headerlink\" title=\"标准模式和混杂模式\"></a>标准模式和混杂模式</h3><ul>\n<li>标准模式： html 排版和 js 渲染工作模式都是以该浏览器支持的最高标准运行。</li>\n<li>兼容模式：页面已宽松的向后兼容的方式显示，模拟老浏览器的行为。</li>\n</ul>\n<h3 id=\"HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt\"><a href=\"#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt\" class=\"headerlink\" title=\"HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;\"></a>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code></h3><p>html5不是基于SGML，所以不需要对DTD进行引用，但是它需要对文档类型声明，需要doctype来规范浏览器行为。</p>\n<h3 id=\"行内元素-块级元素-空元素\"><a href=\"#行内元素-块级元素-空元素\" class=\"headerlink\" title=\"行内元素-块级元素-空元素\"></a>行内元素-块级元素-空元素</h3><ul>\n<li>css中规定每个元素都有默认的display属性和值</li>\n<li>该元素的属性的值为‘inline’的则为行内元素（如:<code>span,a img,input</code>等）</li>\n<li>该元素的属性的值为‘block’的则为块级元素（<code>div，ul,li h1...p</code>等）</li>\n<li>空（void）元素 <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code> 等</li>\n</ul>\n<h3 id=\"html语义化\"><a href=\"#html语义化\" class=\"headerlink\" title=\"html语义化\"></a>html语义化</h3><ol>\n<li>定义：正确的标签做正确的事情</li>\n<li>为什么要做语义化<ul>\n<li>有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。</li>\n<li>在没有CSS的时候能够清晰的看出网页的结构，增强可读性，便于团队开发和维护。</li>\n<li>支持多终端设备的浏览器渲染。</li>\n</ul>\n</li>\n<li>SEO<ul>\n<li>汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</li>\n<li>目的：<br>为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益；SEO包含站外SEO和站内SEO两方面；为了从搜索引擎中获得更多的免费流量，从网站结构、内容建设方案、用户互动传播、页面等角度进行合理规划，还会使搜索引擎中显示的网站相关信息对用户来说更具有吸引力。</li>\n<li>优化方式： <ul>\n<li>内部优化：<ol>\n<li>META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化。</li>\n<li>内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接。</li>\n<li>网站内容更新：每天保持站内的更新(主要是文章的更新等)。</li>\n</ol>\n</li>\n<li>外部优化：<ol>\n<li>外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性。</li>\n<li>外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。</li>\n<li>外链选择：与一些和你网站相关性比较高，整体质量比较好的网站交换友情链接，巩固稳定关键词排名。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><ol>\n<li>概念：如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</li>\n<li>目的：保证用户信息安全，防止恶意网站窃取数据，防止cookie共享</li>\n<li>限制范围<ul>\n<li>cookie、localStorage、indexedDB无法读取</li>\n<li>dom 无法获取</li>\n<li>ajax不能发送</li>\n<li>form表单没有限制</li>\n</ul>\n</li>\n<li>如何设置同源策略(host)：document.domain</li>\n<li>不受同源策略限制：<ul>\n<li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</li>\n<li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>  受到浏览器同源策略的影响，要操作其他源下面的脚本，就需要跨域。</p>\n<h3 id=\"Ajax跨域的解决方案\"><a href=\"#Ajax跨域的解决方案\" class=\"headerlink\" title=\"Ajax跨域的解决方案\"></a>Ajax跨域的解决方案</h3><p><strong>1.JSONP：</strong></p>\n<p>  网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求jsON数据。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>\n<pre><code>- 缺点只支持get请求\n- 优点简单方便，易理解，兼容性良好\n- 如下示例代码\n```\n  //动态创建script，用于跨越操作\n  function creatScriptTag(src) {\n    var script = document.createElement(&#39;script&#39;);\n    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);\n    script.src = src;\n    document.body.appendChild(script);\n  }\n  // 调用creatScriptTag函数\n  window.onload = function () {\n    var url = &#39;/index.php?jsoncallback=result&#39;;\n    creatScriptTag(url);\n  }\n  // 定义回调函数\n  function result (data) {\n    console.log(data);\n  } \n```\n\n```\n  // index.php \n  &lt;?php\n  header(&#39;Content-type: application/json&#39;);\n  //获取回调函数名\n  $jsoncallback = htmlspecialchars($_REQUEST [&#39;jsoncallback&#39;]);\n  //取数据\n  $data = [\n    &#39;data&#39;=&gt;&#39;123&#39;,\n  ];\n  $json_data = json_encode(array(&#39;code&#39;=&gt;&#39;200&#39;,&#39;msg&#39;=&gt;&#39;请求成功&#39;,&#39;data&#39; =&gt; $data),jsON_UNESCAPED_UNICODE);\n  //输出jsonp格式的数据\n  echo $jsoncallback .&quot;(&quot; . $json_data . &quot;)&quot;;\n  ?&gt;\n```</code></pre><p><strong>2.WebSocket:</strong></p>\n<p>  是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器设置利用origin字段设置白名单，就可以通过它进行跨源通信。</p>\n<p><strong>3.CORS（Cross-Origin Resource Sharing）</strong></p>\n<ul>\n<li>在请求头信息中增加Origin字段，用来说明此次请求来自那个源（协议+域名+端口），此字段可以设置相应白名单</li>\n<li>必须设置<code>Access-Control-Allow-Origin</code>字段，值要求是<code>Origin</code>字段的值或者是<em>，</em>的意思是接受任意域名的请求</li>\n<li>CORS请求默认不发送cookie和http认证信息，如果要发送，要在服务器端指<code>Access-Control-Allow-Credentials: true</code>,并且ajax请求必须打开withCredentials属性<pre><code>var xhr = new XMLHttpRequest();\nxhr.withCredentials = true;</code></pre></li>\n<li>如果选择发送cookie,<code>Access-Control-Allow-Origin</code>字段不能设为*，必须指定明确的，与当前网页一致的域名</li>\n</ul>\n"},{"title":"CSS 基本布局","date":"2017-06-15T12:02:06.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识","_content":"\n### 自适应两栏布局\n\n利用BFC实现自适应两栏布局\n```\n/****css****/\n.aside{\n  float: left;\n  width: 180px;\n  height: 500px;\n  background-color: red;\n  opacity: 0.5;\n}\n.main{\n  overflow: hidden;\n  height: 500px;\n  background-color: green;\n}\n\n<!--html-->\n<div class=\"box\">\n  <div class=\"aside\">左侧</div>\n  <div class=\"main\">右侧</div>\n</div>\n```\n![](/images/自适应两栏布局.gif)\n\n\n### 圣杯布局和双飞翼布局\n\n1. 解决什么问题：两边定宽，中间自适应的三栏布局，中间栏放在文档流前面以优先渲染\n2. 相同点：三栏全float浮动，左右两栏加上负margin让中间栏div并排，形成三栏\n3. 不同点： \n  - 圣杯布局为了中间内容不被遮挡，将中间div设置左右padding-left和padding-right,将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。\n  - 双飞翼布局，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。\n4. 圣杯布局代码\n\n```\n/****css****/\n.main{\n  width: 100%;\n  background: green;\n}\n.left{\n  left: -200px;\n  width: 200px;\n  margin-left: -100%;\n  background: yellowgreen;\n}\n.right{\n  right: -200px;\n  width: 200px;\n  margin-left: -200px;\n  background-color: red;\n}\n.main,.left,.right{\n  position: relative;\n  float: left;\n  min-height: 500px;\n}\n.container{\n  padding: 0 200px;\n  overflow: hidden;\n  border: 5px solid #ccc;\n}\n\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间栏目</div>\n  <div class=\"left\">左侧栏目</div>\n  <div class=\"right\">右侧栏目</div>\n</div>\n```\n\n5. 双飞翼布局代码\n\n```\n/****css****/\n.main,.left,.right{\n  float: left;\n  min-height: 500px;\n}\n.main{\n  width:100%;\n  background-color: red;\n}\n.left{\n  width: 200px;\n  margin-left: -100%;\n  background-color: yellow;\n}\n.right{\n  width: 200px;\n  background-color: green;\n  margin-left: -200px;\n}\n.content{\n  margin: 0 200px;\n}\n\n<!--html-->\n<div class=\"container\"> \n　　<div class=\"main\">\n    　　<div class=\"content\">中间栏目</div> \n    </div>\n　　<div class=\"left\">左侧栏目</div> \n　　<div class=\"right\">右侧栏目</div> \n</div>\n```\n\n6. 效果图\n![](/images/圣杯布局.gif)\n\n### flex弹性盒子布局\n1. 定义：Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n2. 优点：相对于传统布局更具有灵活性。\n3. 缺点：虽然现代浏览器都支持，但是还有少部分浏览器需要单独处理其兼容性\n4. 问题：\n  - 绝对定位与固定定位的盒子不参与flex布局\n  - 使用Flex布局以后，子元素的float、clear和vertical-align等属性将失效\n  - 具体语法参考阮大大flex布局语法篇和实例篇\n  - http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n  - http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n\n5. 三栏布局示例 \n\n```\n/****css****/\n.container{\n  display: flex;\n  min-height: 500px;\n}\n.main{\n  flex-grow:1;\n  background-color: red;\n}\n.left{\n  order: -1;\n  flex-basis: 200px;\n  background-color: yellow;\n}\n.right{\n  flex-basis: 200px;\n  background-color: green;\n}\n\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间内容区域</div>\n  <div class=\"left\">左边栏区域</div>\n  <div class=\"right\">右边栏区域</div>\n</div>\n```\n\n### 绝对定位布局\n\n1. position:absolute绝对定位使元素脱离文档流，因此不占据当前层级的空间\n2. 三栏布局代码示例\n```\n/****css****/\n.container{\n  position: relative;\n}\n.main,.left,.right{\n  min-height: 500px;\n  top: 0;\n}\n.main{\n  background-color: red;\n  margin: 0 200px;\n}\n.left{\n  position: absolute;\n  left: 0px;\n  width: 200px;\n  background-color: green;\n}\n.right{\n  position:absolute;\n  right: 0px;\n  width: 200px;\n  background: yellow;\n}\n\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间内容区域</div>\n  <div class=\"left\">左边区域</div>\n  <div class=\"right\">右边区域</div>\n</div>\n```\n### media响应式布局\n\n1. 定义（Responsive Web Design）：一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本\n2. 优点\n  - 跨平台，面对不同分辨率设备灵活性强\n  - 能够快捷解决多设备显示适应问题\n  - 节约成本\n3. 缺点\n  - 兼容性 不兼容低版本浏览器，\b各种设备工作量大，效率低下\n  - 代码冗余量大，加载时间长\n  - 折中方案，达不到理想的布局效果 \n\n### 移动端rem布局\n\n1. 定义（font size of the root element）：相对于根元素的字体大小的单位\n2. 作用：通过js动态计算html font-size 能够使html页面比响应式布局，流式布局，设置最大宽度布局等效果更完善\n3. 需要考虑当前手机的dpr","source":"_posts/css/base-layout.md","raw":"---\ntitle: CSS 基本布局\ndate: 2017-6-15 20:02:06\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识\ntags:\n- CSS\ncategories:\n- CSS\n---\n\n### 自适应两栏布局\n\n利用BFC实现自适应两栏布局\n```\n/****css****/\n.aside{\n  float: left;\n  width: 180px;\n  height: 500px;\n  background-color: red;\n  opacity: 0.5;\n}\n.main{\n  overflow: hidden;\n  height: 500px;\n  background-color: green;\n}\n\n<!--html-->\n<div class=\"box\">\n  <div class=\"aside\">左侧</div>\n  <div class=\"main\">右侧</div>\n</div>\n```\n![](/images/自适应两栏布局.gif)\n\n\n### 圣杯布局和双飞翼布局\n\n1. 解决什么问题：两边定宽，中间自适应的三栏布局，中间栏放在文档流前面以优先渲染\n2. 相同点：三栏全float浮动，左右两栏加上负margin让中间栏div并排，形成三栏\n3. 不同点： \n  - 圣杯布局为了中间内容不被遮挡，将中间div设置左右padding-left和padding-right,将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。\n  - 双飞翼布局，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。\n4. 圣杯布局代码\n\n```\n/****css****/\n.main{\n  width: 100%;\n  background: green;\n}\n.left{\n  left: -200px;\n  width: 200px;\n  margin-left: -100%;\n  background: yellowgreen;\n}\n.right{\n  right: -200px;\n  width: 200px;\n  margin-left: -200px;\n  background-color: red;\n}\n.main,.left,.right{\n  position: relative;\n  float: left;\n  min-height: 500px;\n}\n.container{\n  padding: 0 200px;\n  overflow: hidden;\n  border: 5px solid #ccc;\n}\n\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间栏目</div>\n  <div class=\"left\">左侧栏目</div>\n  <div class=\"right\">右侧栏目</div>\n</div>\n```\n\n5. 双飞翼布局代码\n\n```\n/****css****/\n.main,.left,.right{\n  float: left;\n  min-height: 500px;\n}\n.main{\n  width:100%;\n  background-color: red;\n}\n.left{\n  width: 200px;\n  margin-left: -100%;\n  background-color: yellow;\n}\n.right{\n  width: 200px;\n  background-color: green;\n  margin-left: -200px;\n}\n.content{\n  margin: 0 200px;\n}\n\n<!--html-->\n<div class=\"container\"> \n　　<div class=\"main\">\n    　　<div class=\"content\">中间栏目</div> \n    </div>\n　　<div class=\"left\">左侧栏目</div> \n　　<div class=\"right\">右侧栏目</div> \n</div>\n```\n\n6. 效果图\n![](/images/圣杯布局.gif)\n\n### flex弹性盒子布局\n1. 定义：Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n2. 优点：相对于传统布局更具有灵活性。\n3. 缺点：虽然现代浏览器都支持，但是还有少部分浏览器需要单独处理其兼容性\n4. 问题：\n  - 绝对定位与固定定位的盒子不参与flex布局\n  - 使用Flex布局以后，子元素的float、clear和vertical-align等属性将失效\n  - 具体语法参考阮大大flex布局语法篇和实例篇\n  - http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n  - http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n\n5. 三栏布局示例 \n\n```\n/****css****/\n.container{\n  display: flex;\n  min-height: 500px;\n}\n.main{\n  flex-grow:1;\n  background-color: red;\n}\n.left{\n  order: -1;\n  flex-basis: 200px;\n  background-color: yellow;\n}\n.right{\n  flex-basis: 200px;\n  background-color: green;\n}\n\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间内容区域</div>\n  <div class=\"left\">左边栏区域</div>\n  <div class=\"right\">右边栏区域</div>\n</div>\n```\n\n### 绝对定位布局\n\n1. position:absolute绝对定位使元素脱离文档流，因此不占据当前层级的空间\n2. 三栏布局代码示例\n```\n/****css****/\n.container{\n  position: relative;\n}\n.main,.left,.right{\n  min-height: 500px;\n  top: 0;\n}\n.main{\n  background-color: red;\n  margin: 0 200px;\n}\n.left{\n  position: absolute;\n  left: 0px;\n  width: 200px;\n  background-color: green;\n}\n.right{\n  position:absolute;\n  right: 0px;\n  width: 200px;\n  background: yellow;\n}\n\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间内容区域</div>\n  <div class=\"left\">左边区域</div>\n  <div class=\"right\">右边区域</div>\n</div>\n```\n### media响应式布局\n\n1. 定义（Responsive Web Design）：一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本\n2. 优点\n  - 跨平台，面对不同分辨率设备灵活性强\n  - 能够快捷解决多设备显示适应问题\n  - 节约成本\n3. 缺点\n  - 兼容性 不兼容低版本浏览器，\b各种设备工作量大，效率低下\n  - 代码冗余量大，加载时间长\n  - 折中方案，达不到理想的布局效果 \n\n### 移动端rem布局\n\n1. 定义（font size of the root element）：相对于根元素的字体大小的单位\n2. 作用：通过js动态计算html font-size 能够使html页面比响应式布局，流式布局，设置最大宽度布局等效果更完善\n3. 需要考虑当前手机的dpr","slug":"css/base-layout","published":1,"updated":"2019-10-15T01:29:42.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqb000bb0u6kjtobw4s","content":"<h3 id=\"自适应两栏布局\"><a href=\"#自适应两栏布局\" class=\"headerlink\" title=\"自适应两栏布局\"></a>自适应两栏布局</h3><p>利用BFC实现自适应两栏布局</p>\n<pre><code>/****css****/\n.aside{\n  float: left;\n  width: 180px;\n  height: 500px;\n  background-color: red;\n  opacity: 0.5;\n}\n.main{\n  overflow: hidden;\n  height: 500px;\n  background-color: green;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;box&quot;&gt;\n  &lt;div class=&quot;aside&quot;&gt;左侧&lt;/div&gt;\n  &lt;div class=&quot;main&quot;&gt;右侧&lt;/div&gt;\n&lt;/div&gt;</code></pre><p><img src=\"/images/%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80.gif\" alt></p>\n<h3 id=\"圣杯布局和双飞翼布局\"><a href=\"#圣杯布局和双飞翼布局\" class=\"headerlink\" title=\"圣杯布局和双飞翼布局\"></a>圣杯布局和双飞翼布局</h3><ol>\n<li>解决什么问题：两边定宽，中间自适应的三栏布局，中间栏放在文档流前面以优先渲染</li>\n<li>相同点：三栏全float浮动，左右两栏加上负margin让中间栏div并排，形成三栏</li>\n<li>不同点： <ul>\n<li>圣杯布局为了中间内容不被遮挡，将中间div设置左右padding-left和padding-right,将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</li>\n<li>双飞翼布局，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。</li>\n</ul>\n</li>\n<li>圣杯布局代码</li>\n</ol>\n<pre><code>/****css****/\n.main{\n  width: 100%;\n  background: green;\n}\n.left{\n  left: -200px;\n  width: 200px;\n  margin-left: -100%;\n  background: yellowgreen;\n}\n.right{\n  right: -200px;\n  width: 200px;\n  margin-left: -200px;\n  background-color: red;\n}\n.main,.left,.right{\n  position: relative;\n  float: left;\n  min-height: 500px;\n}\n.container{\n  padding: 0 200px;\n  overflow: hidden;\n  border: 5px solid #ccc;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;container&quot;&gt;\n  &lt;div class=&quot;main&quot;&gt;中间栏目&lt;/div&gt;\n  &lt;div class=&quot;left&quot;&gt;左侧栏目&lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;右侧栏目&lt;/div&gt;\n&lt;/div&gt;</code></pre><ol start=\"5\">\n<li>双飞翼布局代码</li>\n</ol>\n<pre><code>/****css****/\n.main,.left,.right{\n  float: left;\n  min-height: 500px;\n}\n.main{\n  width:100%;\n  background-color: red;\n}\n.left{\n  width: 200px;\n  margin-left: -100%;\n  background-color: yellow;\n}\n.right{\n  width: 200px;\n  background-color: green;\n  margin-left: -200px;\n}\n.content{\n  margin: 0 200px;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;container&quot;&gt; \n　　&lt;div class=&quot;main&quot;&gt;\n    　　&lt;div class=&quot;content&quot;&gt;中间栏目&lt;/div&gt; \n    &lt;/div&gt;\n　　&lt;div class=&quot;left&quot;&gt;左侧栏目&lt;/div&gt; \n　　&lt;div class=&quot;right&quot;&gt;右侧栏目&lt;/div&gt; \n&lt;/div&gt;</code></pre><ol start=\"6\">\n<li>效果图<br><img src=\"/images/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.gif\" alt></li>\n</ol>\n<h3 id=\"flex弹性盒子布局\"><a href=\"#flex弹性盒子布局\" class=\"headerlink\" title=\"flex弹性盒子布局\"></a>flex弹性盒子布局</h3><ol>\n<li><p>定义：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n</li>\n<li><p>优点：相对于传统布局更具有灵活性。</p>\n</li>\n<li><p>缺点：虽然现代浏览器都支持，但是还有少部分浏览器需要单独处理其兼容性</p>\n</li>\n<li><p>问题：</p>\n<ul>\n<li>绝对定位与固定定位的盒子不参与flex布局</li>\n<li>使用Flex布局以后，子元素的float、clear和vertical-align等属性将失效</li>\n<li>具体语法参考阮大大flex布局语法篇和实例篇</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li>\n</ul>\n</li>\n<li><p>三栏布局示例 </p>\n</li>\n</ol>\n<pre><code>/****css****/\n.container{\n  display: flex;\n  min-height: 500px;\n}\n.main{\n  flex-grow:1;\n  background-color: red;\n}\n.left{\n  order: -1;\n  flex-basis: 200px;\n  background-color: yellow;\n}\n.right{\n  flex-basis: 200px;\n  background-color: green;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;container&quot;&gt;\n  &lt;div class=&quot;main&quot;&gt;中间内容区域&lt;/div&gt;\n  &lt;div class=&quot;left&quot;&gt;左边栏区域&lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;右边栏区域&lt;/div&gt;\n&lt;/div&gt;</code></pre><h3 id=\"绝对定位布局\"><a href=\"#绝对定位布局\" class=\"headerlink\" title=\"绝对定位布局\"></a>绝对定位布局</h3><ol>\n<li>position:absolute绝对定位使元素脱离文档流，因此不占据当前层级的空间</li>\n<li>三栏布局代码示例<pre><code>/****css****/\n.container{\nposition: relative;\n}\n.main,.left,.right{\nmin-height: 500px;\ntop: 0;\n}\n.main{\nbackground-color: red;\nmargin: 0 200px;\n}\n.left{\nposition: absolute;\nleft: 0px;\nwidth: 200px;\nbackground-color: green;\n}\n.right{\nposition:absolute;\nright: 0px;\nwidth: 200px;\nbackground: yellow;\n}\n</code></pre></li>\n</ol>\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间内容区域</div>\n  <div class=\"left\">左边区域</div>\n  <div class=\"right\">右边区域</div>\n</div>\n```\n### media响应式布局\n\n<ol>\n<li>定义（Responsive Web Design）：一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li>\n<li>优点<ul>\n<li>跨平台，面对不同分辨率设备灵活性强</li>\n<li>能够快捷解决多设备显示适应问题</li>\n<li>节约成本</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>兼容性 不兼容低版本浏览器，\b各种设备工作量大，效率低下</li>\n<li>代码冗余量大，加载时间长</li>\n<li>折中方案，达不到理想的布局效果 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"移动端rem布局\"><a href=\"#移动端rem布局\" class=\"headerlink\" title=\"移动端rem布局\"></a>移动端rem布局</h3><ol>\n<li>定义（font size of the root element）：相对于根元素的字体大小的单位</li>\n<li>作用：通过js动态计算html font-size 能够使html页面比响应式布局，流式布局，设置最大宽度布局等效果更完善</li>\n<li>需要考虑当前手机的dpr</li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"自适应两栏布局\"><a href=\"#自适应两栏布局\" class=\"headerlink\" title=\"自适应两栏布局\"></a>自适应两栏布局</h3><p>利用BFC实现自适应两栏布局</p>\n<pre><code>/****css****/\n.aside{\n  float: left;\n  width: 180px;\n  height: 500px;\n  background-color: red;\n  opacity: 0.5;\n}\n.main{\n  overflow: hidden;\n  height: 500px;\n  background-color: green;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;box&quot;&gt;\n  &lt;div class=&quot;aside&quot;&gt;左侧&lt;/div&gt;\n  &lt;div class=&quot;main&quot;&gt;右侧&lt;/div&gt;\n&lt;/div&gt;</code></pre><p><img src=\"/images/%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80.gif\" alt></p>\n<h3 id=\"圣杯布局和双飞翼布局\"><a href=\"#圣杯布局和双飞翼布局\" class=\"headerlink\" title=\"圣杯布局和双飞翼布局\"></a>圣杯布局和双飞翼布局</h3><ol>\n<li>解决什么问题：两边定宽，中间自适应的三栏布局，中间栏放在文档流前面以优先渲染</li>\n<li>相同点：三栏全float浮动，左右两栏加上负margin让中间栏div并排，形成三栏</li>\n<li>不同点： <ul>\n<li>圣杯布局为了中间内容不被遮挡，将中间div设置左右padding-left和padding-right,将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</li>\n<li>双飞翼布局，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。</li>\n</ul>\n</li>\n<li>圣杯布局代码</li>\n</ol>\n<pre><code>/****css****/\n.main{\n  width: 100%;\n  background: green;\n}\n.left{\n  left: -200px;\n  width: 200px;\n  margin-left: -100%;\n  background: yellowgreen;\n}\n.right{\n  right: -200px;\n  width: 200px;\n  margin-left: -200px;\n  background-color: red;\n}\n.main,.left,.right{\n  position: relative;\n  float: left;\n  min-height: 500px;\n}\n.container{\n  padding: 0 200px;\n  overflow: hidden;\n  border: 5px solid #ccc;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;container&quot;&gt;\n  &lt;div class=&quot;main&quot;&gt;中间栏目&lt;/div&gt;\n  &lt;div class=&quot;left&quot;&gt;左侧栏目&lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;右侧栏目&lt;/div&gt;\n&lt;/div&gt;</code></pre><ol start=\"5\">\n<li>双飞翼布局代码</li>\n</ol>\n<pre><code>/****css****/\n.main,.left,.right{\n  float: left;\n  min-height: 500px;\n}\n.main{\n  width:100%;\n  background-color: red;\n}\n.left{\n  width: 200px;\n  margin-left: -100%;\n  background-color: yellow;\n}\n.right{\n  width: 200px;\n  background-color: green;\n  margin-left: -200px;\n}\n.content{\n  margin: 0 200px;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;container&quot;&gt; \n　　&lt;div class=&quot;main&quot;&gt;\n    　　&lt;div class=&quot;content&quot;&gt;中间栏目&lt;/div&gt; \n    &lt;/div&gt;\n　　&lt;div class=&quot;left&quot;&gt;左侧栏目&lt;/div&gt; \n　　&lt;div class=&quot;right&quot;&gt;右侧栏目&lt;/div&gt; \n&lt;/div&gt;</code></pre><ol start=\"6\">\n<li>效果图<br><img src=\"/images/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.gif\" alt></li>\n</ol>\n<h3 id=\"flex弹性盒子布局\"><a href=\"#flex弹性盒子布局\" class=\"headerlink\" title=\"flex弹性盒子布局\"></a>flex弹性盒子布局</h3><ol>\n<li><p>定义：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n</li>\n<li><p>优点：相对于传统布局更具有灵活性。</p>\n</li>\n<li><p>缺点：虽然现代浏览器都支持，但是还有少部分浏览器需要单独处理其兼容性</p>\n</li>\n<li><p>问题：</p>\n<ul>\n<li>绝对定位与固定定位的盒子不参与flex布局</li>\n<li>使用Flex布局以后，子元素的float、clear和vertical-align等属性将失效</li>\n<li>具体语法参考阮大大flex布局语法篇和实例篇</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li>\n</ul>\n</li>\n<li><p>三栏布局示例 </p>\n</li>\n</ol>\n<pre><code>/****css****/\n.container{\n  display: flex;\n  min-height: 500px;\n}\n.main{\n  flex-grow:1;\n  background-color: red;\n}\n.left{\n  order: -1;\n  flex-basis: 200px;\n  background-color: yellow;\n}\n.right{\n  flex-basis: 200px;\n  background-color: green;\n}\n\n&lt;!--html--&gt;\n&lt;div class=&quot;container&quot;&gt;\n  &lt;div class=&quot;main&quot;&gt;中间内容区域&lt;/div&gt;\n  &lt;div class=&quot;left&quot;&gt;左边栏区域&lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;右边栏区域&lt;/div&gt;\n&lt;/div&gt;</code></pre><h3 id=\"绝对定位布局\"><a href=\"#绝对定位布局\" class=\"headerlink\" title=\"绝对定位布局\"></a>绝对定位布局</h3><ol>\n<li>position:absolute绝对定位使元素脱离文档流，因此不占据当前层级的空间</li>\n<li>三栏布局代码示例<pre><code>/****css****/\n.container{\nposition: relative;\n}\n.main,.left,.right{\nmin-height: 500px;\ntop: 0;\n}\n.main{\nbackground-color: red;\nmargin: 0 200px;\n}\n.left{\nposition: absolute;\nleft: 0px;\nwidth: 200px;\nbackground-color: green;\n}\n.right{\nposition:absolute;\nright: 0px;\nwidth: 200px;\nbackground: yellow;\n}\n</code></pre></li>\n</ol>\n<!--html-->\n<div class=\"container\">\n  <div class=\"main\">中间内容区域</div>\n  <div class=\"left\">左边区域</div>\n  <div class=\"right\">右边区域</div>\n</div>\n```\n### media响应式布局\n\n<ol>\n<li>定义（Responsive Web Design）：一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li>\n<li>优点<ul>\n<li>跨平台，面对不同分辨率设备灵活性强</li>\n<li>能够快捷解决多设备显示适应问题</li>\n<li>节约成本</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>兼容性 不兼容低版本浏览器，\b各种设备工作量大，效率低下</li>\n<li>代码冗余量大，加载时间长</li>\n<li>折中方案，达不到理想的布局效果 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"移动端rem布局\"><a href=\"#移动端rem布局\" class=\"headerlink\" title=\"移动端rem布局\"></a>移动端rem布局</h3><ol>\n<li>定义（font size of the root element）：相对于根元素的字体大小的单位</li>\n<li>作用：通过js动态计算html font-size 能够使html页面比响应式布局，流式布局，设置最大宽度布局等效果更完善</li>\n<li>需要考虑当前手机的dpr</li>\n</ol>\n"},{"title":"CSS 基础知识概念","date":"2017-06-11T12:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识","_content":"\n### 什么是css\n层叠样式表(英文全称：Cascading Style Sheets),是一种用来表现html或者xml等文件样式的计算机语言。\n\n### 盒子模型\n- 在html文档中，每一个渲染在页面中的标签都是一个个盒子模型；\n- 盒子模型分为w3c标准盒子模型和IE标准盒子模型；当不对Doctype进行定义时，会触发怪异模式。\n- 盒子模型\n\n```\n/****css****/\n.box{\n  width:100px;\n  height:100px;\n  border:10px;\n  background-color:red;\n  padding:20px;\n  margin:20px;\n}\n\n<div class=\"box\"></div>\n```\n\n![](/images/css盒子模型.png)\n\n### BFC\n\n  - 定义（Block fomatting context）：块级格式化上下文(每一个元素盒子从上向下排列)\n  - block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；\n  - 是一个独立的渲染区域，只有Block-level box参与\n  - 布局规则\n    1. 内部的Box会在垂直方向链接放置\n    2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n    3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n    4. BFC的区域不会与float box重叠\n    5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n    6. 计算BFC的高度时，浮动元素也参与计算\n  - 那些元素会生成BFC\n    1. 根元素\n    2. float元素不为none\n    3. position为 absolute或者fixed\n    4. display为inline-block, table-cell, table-caption, flex, inline-flex\n    5. overflow不为visible\n  - BFC作用\n    1. 自适应两栏布局\n    2. 清除内部浮动\n    3. 防止margin重叠\n\n  - 例子说明\n  - 根据以上BFC布局规则第3条、第4条来触发main生成BFC，来实现自适应两栏布局\n      ```\n      /****css****/\n      .main{\n        overflow: hidden;\n        height: 500px;\n        background: yellow;\n      }\n      .aside{\n        float: left;\n        width: 200px;\n        height: 500px;\n        background-color: red;\n      }\n      \n      <!--html-->\n      <div class=\"box\">\n        <div class=\"aside\">侧边栏区域</div>\n        <div class=\"main\">内容区域</div>\n      </div>\n      ```\n  - 根据BFC布局规则第6条，解决float元素使其父元素高度塌陷问题\n    ```\n      /****css****/\n      .parent{\n        border: 1px solid red;\n        width: 400px;\n        overflow: hidden;\n        padding: 10px;\n      }\n      .child{\n        float: left;\n        height: 300px;\n        width: 198px;\n        border: 1px solid green;\n      }\n      \n      <!--html-->\n      <div class=\"parent\">\n        <div class=\"child\"></div>\n        <div class=\"child\"></div>\n      </div>\n    ```\n  - 防止margin重叠,根据生成BFC第4条规则\n    ```\n      /****css****/\n      .box{\n        width: 300px;\n        height: auto;\n      }\n      .content{\n        width: 300px;\n        height: 200px;\n        margin: 100px;\n        background: red;\n      }\n      .warp{\n        display: inline-block;\n      }\n\n      <!--html-->\n      <div class=\"box\">\n        <div class=\"content\"></div>\n        <div class=\"content warp\"></div>\n      </div>\n    ```\n\n### IFC\n\n  1. 布局规则\n    - 定义(Inline Formatting Contexts)：内联格式化上下文（每一个元素盒子从左到右排列）\n    - IFC的line box高度 由其行内元素中 最高的实际高度计算而来（不受到竖直方向的padding/margin影响)\n    - inline-level box:display 属性为 inline, inline-box，inline-table，table-cell，table-column-group等，会生成 inline-level box。并且参与 inline fomatting context；\n    - 当inline-level box的宽度大于containing block，且达到内容换行条件时，会将inline-level拆散为多个inline-level box并分布到多行中\n    - inline-level box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短\n    - IFC中不可能有块级元素，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。\n  2. 作用\n    - 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。\n    - 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。\n\n  3. 示例\n   - 根据布局规则第4条\n    ```\n      /****css****/\n      .break{\n        border: 1px solid red;\n        background: yellow;\n      }\n      \n      <!--html-->\n      <span class=\"break\">这是一个行内盒子这是一个行内盒子这是一个行内盒子</span>\n    ```\n    ![](/images/css-IFC.jpg)\n  4. 根据作用第1条,设置span为inline-block,则会在box上产生ifc,在box上设置text-align使span元素水平居中。\n    ```\n      /****css****/\n      .box{text-align: center;}\n      .content{\n        display: inline-block;\n        border: 1px solid red;\n      }\n      \n      <!--html-->\n      <div class=\"box\">\n        <span class=\"content\">内容区域</span>\n      </div>\n    ```\n  5. 根据作用第2条，设置盒子2为inline-block，则会在box上产生ifc，设置其vertical-align:middle，盒子1垂直居中。\n    ```\n      /****css****/\n      .box{\n        text-align: center;\n        border: 1px solid red;\n      }\n      .label{\n        display: inline-block;\n        height: 100px;\n        width: 100px;\n        vertical-align: middle;\n      }\n      \n      <!--html-->\n      <div class=\"box\">\n        <span class=\"content\">盒子1</span>\n        <span class=\"label\">盒子2</span>\n      </div>\n    ```\n\n### FFC\n\n  1. 定义(Flex Formatting Contexts)：自适应格式化上下文\n  2. display值为flex或者inline-flex的元素将会生成自适应容器（flex container）\n  3. FFC和BFC区别\n    - Flexbox 不支持 ::first-line 和 ::first-letter 这两种伪元素\n    - vertical-align 对 Flexbox 中的子元素失效\n    - float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流\n    - 多栏布局（column-*） 在 Flexbox 中失效\n    - Flexbox 下的子元素不会继承父级容器的宽\n\n### GFC\n\n  1. 定义(GridLayout Formatting Contexts)：网格布局格式化上下文\n  2. display值为grid的元素，获得一个独立的渲染区域，可在网格内定义项目（item）、行（row）、列（columns）\n\n\n\n","source":"_posts/css/base-concepts.md","raw":"---\ntitle: CSS 基础知识概念\ndate: 2017-6-11 20:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识\ntags:\n- CSS\ncategories:\n- CSS\n---\n\n### 什么是css\n层叠样式表(英文全称：Cascading Style Sheets),是一种用来表现html或者xml等文件样式的计算机语言。\n\n### 盒子模型\n- 在html文档中，每一个渲染在页面中的标签都是一个个盒子模型；\n- 盒子模型分为w3c标准盒子模型和IE标准盒子模型；当不对Doctype进行定义时，会触发怪异模式。\n- 盒子模型\n\n```\n/****css****/\n.box{\n  width:100px;\n  height:100px;\n  border:10px;\n  background-color:red;\n  padding:20px;\n  margin:20px;\n}\n\n<div class=\"box\"></div>\n```\n\n![](/images/css盒子模型.png)\n\n### BFC\n\n  - 定义（Block fomatting context）：块级格式化上下文(每一个元素盒子从上向下排列)\n  - block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；\n  - 是一个独立的渲染区域，只有Block-level box参与\n  - 布局规则\n    1. 内部的Box会在垂直方向链接放置\n    2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n    3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n    4. BFC的区域不会与float box重叠\n    5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n    6. 计算BFC的高度时，浮动元素也参与计算\n  - 那些元素会生成BFC\n    1. 根元素\n    2. float元素不为none\n    3. position为 absolute或者fixed\n    4. display为inline-block, table-cell, table-caption, flex, inline-flex\n    5. overflow不为visible\n  - BFC作用\n    1. 自适应两栏布局\n    2. 清除内部浮动\n    3. 防止margin重叠\n\n  - 例子说明\n  - 根据以上BFC布局规则第3条、第4条来触发main生成BFC，来实现自适应两栏布局\n      ```\n      /****css****/\n      .main{\n        overflow: hidden;\n        height: 500px;\n        background: yellow;\n      }\n      .aside{\n        float: left;\n        width: 200px;\n        height: 500px;\n        background-color: red;\n      }\n      \n      <!--html-->\n      <div class=\"box\">\n        <div class=\"aside\">侧边栏区域</div>\n        <div class=\"main\">内容区域</div>\n      </div>\n      ```\n  - 根据BFC布局规则第6条，解决float元素使其父元素高度塌陷问题\n    ```\n      /****css****/\n      .parent{\n        border: 1px solid red;\n        width: 400px;\n        overflow: hidden;\n        padding: 10px;\n      }\n      .child{\n        float: left;\n        height: 300px;\n        width: 198px;\n        border: 1px solid green;\n      }\n      \n      <!--html-->\n      <div class=\"parent\">\n        <div class=\"child\"></div>\n        <div class=\"child\"></div>\n      </div>\n    ```\n  - 防止margin重叠,根据生成BFC第4条规则\n    ```\n      /****css****/\n      .box{\n        width: 300px;\n        height: auto;\n      }\n      .content{\n        width: 300px;\n        height: 200px;\n        margin: 100px;\n        background: red;\n      }\n      .warp{\n        display: inline-block;\n      }\n\n      <!--html-->\n      <div class=\"box\">\n        <div class=\"content\"></div>\n        <div class=\"content warp\"></div>\n      </div>\n    ```\n\n### IFC\n\n  1. 布局规则\n    - 定义(Inline Formatting Contexts)：内联格式化上下文（每一个元素盒子从左到右排列）\n    - IFC的line box高度 由其行内元素中 最高的实际高度计算而来（不受到竖直方向的padding/margin影响)\n    - inline-level box:display 属性为 inline, inline-box，inline-table，table-cell，table-column-group等，会生成 inline-level box。并且参与 inline fomatting context；\n    - 当inline-level box的宽度大于containing block，且达到内容换行条件时，会将inline-level拆散为多个inline-level box并分布到多行中\n    - inline-level box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短\n    - IFC中不可能有块级元素，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。\n  2. 作用\n    - 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。\n    - 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。\n\n  3. 示例\n   - 根据布局规则第4条\n    ```\n      /****css****/\n      .break{\n        border: 1px solid red;\n        background: yellow;\n      }\n      \n      <!--html-->\n      <span class=\"break\">这是一个行内盒子这是一个行内盒子这是一个行内盒子</span>\n    ```\n    ![](/images/css-IFC.jpg)\n  4. 根据作用第1条,设置span为inline-block,则会在box上产生ifc,在box上设置text-align使span元素水平居中。\n    ```\n      /****css****/\n      .box{text-align: center;}\n      .content{\n        display: inline-block;\n        border: 1px solid red;\n      }\n      \n      <!--html-->\n      <div class=\"box\">\n        <span class=\"content\">内容区域</span>\n      </div>\n    ```\n  5. 根据作用第2条，设置盒子2为inline-block，则会在box上产生ifc，设置其vertical-align:middle，盒子1垂直居中。\n    ```\n      /****css****/\n      .box{\n        text-align: center;\n        border: 1px solid red;\n      }\n      .label{\n        display: inline-block;\n        height: 100px;\n        width: 100px;\n        vertical-align: middle;\n      }\n      \n      <!--html-->\n      <div class=\"box\">\n        <span class=\"content\">盒子1</span>\n        <span class=\"label\">盒子2</span>\n      </div>\n    ```\n\n### FFC\n\n  1. 定义(Flex Formatting Contexts)：自适应格式化上下文\n  2. display值为flex或者inline-flex的元素将会生成自适应容器（flex container）\n  3. FFC和BFC区别\n    - Flexbox 不支持 ::first-line 和 ::first-letter 这两种伪元素\n    - vertical-align 对 Flexbox 中的子元素失效\n    - float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流\n    - 多栏布局（column-*） 在 Flexbox 中失效\n    - Flexbox 下的子元素不会继承父级容器的宽\n\n### GFC\n\n  1. 定义(GridLayout Formatting Contexts)：网格布局格式化上下文\n  2. display值为grid的元素，获得一个独立的渲染区域，可在网格内定义项目（item）、行（row）、列（columns）\n\n\n\n","slug":"css/base-concepts","published":1,"updated":"2019-10-15T01:29:42.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqi000eb0u6fe826zpm","content":"<h3 id=\"什么是css\"><a href=\"#什么是css\" class=\"headerlink\" title=\"什么是css\"></a>什么是css</h3><p>层叠样式表(英文全称：Cascading Style Sheets),是一种用来表现html或者xml等文件样式的计算机语言。</p>\n<h3 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h3><ul>\n<li>在html文档中，每一个渲染在页面中的标签都是一个个盒子模型；</li>\n<li>盒子模型分为w3c标准盒子模型和IE标准盒子模型；当不对Doctype进行定义时，会触发怪异模式。</li>\n<li>盒子模型</li>\n</ul>\n<pre><code>/****css****/\n.box{\n  width:100px;\n  height:100px;\n  border:10px;\n  background-color:red;\n  padding:20px;\n  margin:20px;\n}\n\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><img src=\"/images/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png\" alt></p>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><ul>\n<li><p>定义（Block fomatting context）：块级格式化上下文(每一个元素盒子从上向下排列)</p>\n</li>\n<li><p>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p>\n</li>\n<li><p>是一个独立的渲染区域，只有Block-level box参与</p>\n</li>\n<li><p>布局规则</p>\n<ol>\n<li>内部的Box会在垂直方向链接放置</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC的区域不会与float box重叠</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n</li>\n<li><p>那些元素会生成BFC</p>\n<ol>\n<li>根元素</li>\n<li>float元素不为none</li>\n<li>position为 absolute或者fixed</li>\n<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow不为visible</li>\n</ol>\n</li>\n<li><p>BFC作用</p>\n<ol>\n<li>自适应两栏布局</li>\n<li>清除内部浮动</li>\n<li>防止margin重叠</li>\n</ol>\n</li>\n<li><p>例子说明</p>\n</li>\n<li><p>根据以上BFC布局规则第3条、第4条来触发main生成BFC，来实现自适应两栏布局</p>\n<pre><code>  /****css****/\n  .main{\n    overflow: hidden;\n    height: 500px;\n    background: yellow;\n  }\n  .aside{\n    float: left;\n    width: 200px;\n    height: 500px;\n    background-color: red;\n  }\n\n  &lt;!--html--&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    &lt;div class=&quot;aside&quot;&gt;侧边栏区域&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;内容区域&lt;/div&gt;\n  &lt;/div&gt;</code></pre></li>\n<li><p>根据BFC布局规则第6条，解决float元素使其父元素高度塌陷问题</p>\n<pre><code>  /****css****/\n  .parent{\n    border: 1px solid red;\n    width: 400px;\n    overflow: hidden;\n    padding: 10px;\n  }\n  .child{\n    float: left;\n    height: 300px;\n    width: 198px;\n    border: 1px solid green;\n  }\n\n  &lt;!--html--&gt;\n  &lt;div class=&quot;parent&quot;&gt;\n    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;</code></pre></li>\n<li><p>防止margin重叠,根据生成BFC第4条规则</p>\n<pre><code>  /****css****/\n  .box{\n    width: 300px;\n    height: auto;\n  }\n  .content{\n    width: 300px;\n    height: 200px;\n    margin: 100px;\n    background: red;\n  }\n  .warp{\n    display: inline-block;\n  }\n\n  &lt;!--html--&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;content warp&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;</code></pre></li>\n</ul>\n<h3 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h3><ol>\n<li><p>布局规则</p>\n<ul>\n<li>定义(Inline Formatting Contexts)：内联格式化上下文（每一个元素盒子从左到右排列）</li>\n<li>IFC的line box高度 由其行内元素中 最高的实际高度计算而来（不受到竖直方向的padding/margin影响)</li>\n<li>inline-level box:display 属性为 inline, inline-box，inline-table，table-cell，table-column-group等，会生成 inline-level box。并且参与 inline fomatting context；</li>\n<li>当inline-level box的宽度大于containing block，且达到内容换行条件时，会将inline-level拆散为多个inline-level box并分布到多行中</li>\n<li>inline-level box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短</li>\n<li>IFC中不可能有块级元素，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li>\n<li>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n</li>\n<li><p>示例</p>\n<ul>\n<li><p>根据布局规则第4条</p>\n<pre><code>/****css****/\n.break{\n border: 1px solid red;\n background: yellow;\n}\n\n&lt;!--html--&gt;\n&lt;span class=&quot;break&quot;&gt;这是一个行内盒子这是一个行内盒子这是一个行内盒子&lt;/span&gt;</code></pre><p><img src=\"/images/css-IFC.jpg\" alt></p>\n</li>\n</ul>\n</li>\n<li><p>根据作用第1条,设置span为inline-block,则会在box上产生ifc,在box上设置text-align使span元素水平居中。</p>\n<pre><code> /****css****/\n .box{text-align: center;}\n .content{\n   display: inline-block;\n   border: 1px solid red;\n }\n\n &lt;!--html--&gt;\n &lt;div class=&quot;box&quot;&gt;\n   &lt;span class=&quot;content&quot;&gt;内容区域&lt;/span&gt;\n &lt;/div&gt;</code></pre></li>\n<li><p>根据作用第2条，设置盒子2为inline-block，则会在box上产生ifc，设置其vertical-align:middle，盒子1垂直居中。</p>\n<pre><code> /****css****/\n .box{\n   text-align: center;\n   border: 1px solid red;\n }\n .label{\n   display: inline-block;\n   height: 100px;\n   width: 100px;\n   vertical-align: middle;\n }\n\n &lt;!--html--&gt;\n &lt;div class=&quot;box&quot;&gt;\n   &lt;span class=&quot;content&quot;&gt;盒子1&lt;/span&gt;\n   &lt;span class=&quot;label&quot;&gt;盒子2&lt;/span&gt;\n &lt;/div&gt;</code></pre></li>\n</ol>\n<h3 id=\"FFC\"><a href=\"#FFC\" class=\"headerlink\" title=\"FFC\"></a>FFC</h3><ol>\n<li>定义(Flex Formatting Contexts)：自适应格式化上下文</li>\n<li>display值为flex或者inline-flex的元素将会生成自适应容器（flex container）</li>\n<li>FFC和BFC区别<ul>\n<li>Flexbox 不支持 ::first-line 和 ::first-letter 这两种伪元素</li>\n<li>vertical-align 对 Flexbox 中的子元素失效</li>\n<li>float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流</li>\n<li>多栏布局（column-*） 在 Flexbox 中失效</li>\n<li>Flexbox 下的子元素不会继承父级容器的宽</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"GFC\"><a href=\"#GFC\" class=\"headerlink\" title=\"GFC\"></a>GFC</h3><ol>\n<li>定义(GridLayout Formatting Contexts)：网格布局格式化上下文</li>\n<li>display值为grid的元素，获得一个独立的渲染区域，可在网格内定义项目（item）、行（row）、列（columns）</li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"什么是css\"><a href=\"#什么是css\" class=\"headerlink\" title=\"什么是css\"></a>什么是css</h3><p>层叠样式表(英文全称：Cascading Style Sheets),是一种用来表现html或者xml等文件样式的计算机语言。</p>\n<h3 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h3><ul>\n<li>在html文档中，每一个渲染在页面中的标签都是一个个盒子模型；</li>\n<li>盒子模型分为w3c标准盒子模型和IE标准盒子模型；当不对Doctype进行定义时，会触发怪异模式。</li>\n<li>盒子模型</li>\n</ul>\n<pre><code>/****css****/\n.box{\n  width:100px;\n  height:100px;\n  border:10px;\n  background-color:red;\n  padding:20px;\n  margin:20px;\n}\n\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><img src=\"/images/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png\" alt></p>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><ul>\n<li><p>定义（Block fomatting context）：块级格式化上下文(每一个元素盒子从上向下排列)</p>\n</li>\n<li><p>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</p>\n</li>\n<li><p>是一个独立的渲染区域，只有Block-level box参与</p>\n</li>\n<li><p>布局规则</p>\n<ol>\n<li>内部的Box会在垂直方向链接放置</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC的区域不会与float box重叠</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n</li>\n<li><p>那些元素会生成BFC</p>\n<ol>\n<li>根元素</li>\n<li>float元素不为none</li>\n<li>position为 absolute或者fixed</li>\n<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow不为visible</li>\n</ol>\n</li>\n<li><p>BFC作用</p>\n<ol>\n<li>自适应两栏布局</li>\n<li>清除内部浮动</li>\n<li>防止margin重叠</li>\n</ol>\n</li>\n<li><p>例子说明</p>\n</li>\n<li><p>根据以上BFC布局规则第3条、第4条来触发main生成BFC，来实现自适应两栏布局</p>\n<pre><code>  /****css****/\n  .main{\n    overflow: hidden;\n    height: 500px;\n    background: yellow;\n  }\n  .aside{\n    float: left;\n    width: 200px;\n    height: 500px;\n    background-color: red;\n  }\n\n  &lt;!--html--&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    &lt;div class=&quot;aside&quot;&gt;侧边栏区域&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;内容区域&lt;/div&gt;\n  &lt;/div&gt;</code></pre></li>\n<li><p>根据BFC布局规则第6条，解决float元素使其父元素高度塌陷问题</p>\n<pre><code>  /****css****/\n  .parent{\n    border: 1px solid red;\n    width: 400px;\n    overflow: hidden;\n    padding: 10px;\n  }\n  .child{\n    float: left;\n    height: 300px;\n    width: 198px;\n    border: 1px solid green;\n  }\n\n  &lt;!--html--&gt;\n  &lt;div class=&quot;parent&quot;&gt;\n    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;</code></pre></li>\n<li><p>防止margin重叠,根据生成BFC第4条规则</p>\n<pre><code>  /****css****/\n  .box{\n    width: 300px;\n    height: auto;\n  }\n  .content{\n    width: 300px;\n    height: 200px;\n    margin: 100px;\n    background: red;\n  }\n  .warp{\n    display: inline-block;\n  }\n\n  &lt;!--html--&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;content warp&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;</code></pre></li>\n</ul>\n<h3 id=\"IFC\"><a href=\"#IFC\" class=\"headerlink\" title=\"IFC\"></a>IFC</h3><ol>\n<li><p>布局规则</p>\n<ul>\n<li>定义(Inline Formatting Contexts)：内联格式化上下文（每一个元素盒子从左到右排列）</li>\n<li>IFC的line box高度 由其行内元素中 最高的实际高度计算而来（不受到竖直方向的padding/margin影响)</li>\n<li>inline-level box:display 属性为 inline, inline-box，inline-table，table-cell，table-column-group等，会生成 inline-level box。并且参与 inline fomatting context；</li>\n<li>当inline-level box的宽度大于containing block，且达到内容换行条件时，会将inline-level拆散为多个inline-level box并分布到多行中</li>\n<li>inline-level box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短</li>\n<li>IFC中不可能有块级元素，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li>\n<li>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>\n</ul>\n</li>\n<li><p>示例</p>\n<ul>\n<li><p>根据布局规则第4条</p>\n<pre><code>/****css****/\n.break{\n border: 1px solid red;\n background: yellow;\n}\n\n&lt;!--html--&gt;\n&lt;span class=&quot;break&quot;&gt;这是一个行内盒子这是一个行内盒子这是一个行内盒子&lt;/span&gt;</code></pre><p><img src=\"/images/css-IFC.jpg\" alt></p>\n</li>\n</ul>\n</li>\n<li><p>根据作用第1条,设置span为inline-block,则会在box上产生ifc,在box上设置text-align使span元素水平居中。</p>\n<pre><code> /****css****/\n .box{text-align: center;}\n .content{\n   display: inline-block;\n   border: 1px solid red;\n }\n\n &lt;!--html--&gt;\n &lt;div class=&quot;box&quot;&gt;\n   &lt;span class=&quot;content&quot;&gt;内容区域&lt;/span&gt;\n &lt;/div&gt;</code></pre></li>\n<li><p>根据作用第2条，设置盒子2为inline-block，则会在box上产生ifc，设置其vertical-align:middle，盒子1垂直居中。</p>\n<pre><code> /****css****/\n .box{\n   text-align: center;\n   border: 1px solid red;\n }\n .label{\n   display: inline-block;\n   height: 100px;\n   width: 100px;\n   vertical-align: middle;\n }\n\n &lt;!--html--&gt;\n &lt;div class=&quot;box&quot;&gt;\n   &lt;span class=&quot;content&quot;&gt;盒子1&lt;/span&gt;\n   &lt;span class=&quot;label&quot;&gt;盒子2&lt;/span&gt;\n &lt;/div&gt;</code></pre></li>\n</ol>\n<h3 id=\"FFC\"><a href=\"#FFC\" class=\"headerlink\" title=\"FFC\"></a>FFC</h3><ol>\n<li>定义(Flex Formatting Contexts)：自适应格式化上下文</li>\n<li>display值为flex或者inline-flex的元素将会生成自适应容器（flex container）</li>\n<li>FFC和BFC区别<ul>\n<li>Flexbox 不支持 ::first-line 和 ::first-letter 这两种伪元素</li>\n<li>vertical-align 对 Flexbox 中的子元素失效</li>\n<li>float 和 clear 属性对 Flexbox 中的子元素是没有效果的，也不会使子元素脱离文档流</li>\n<li>多栏布局（column-*） 在 Flexbox 中失效</li>\n<li>Flexbox 下的子元素不会继承父级容器的宽</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"GFC\"><a href=\"#GFC\" class=\"headerlink\" title=\"GFC\"></a>GFC</h3><ol>\n<li>定义(GridLayout Formatting Contexts)：网格布局格式化上下文</li>\n<li>display值为grid的元素，获得一个独立的渲染区域，可在网格内定义项目（item）、行（row）、列（columns）</li>\n</ol>\n"},{"title":"CSS 动画","date":"2017-06-20T13:06:05.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识","_content":"\n\nAPI的简介及简单动画的实现\n\n### 3D转换（transform）\n\n1. 定义向元素应用 2D 或 3D 转换，可以对元素进行移动、缩放、转动、拉长或拉伸\n\n  translate(移动) 根据X轴和Y轴位置给定的参数，从当前元素位置移动\n  ```\n  transform: translate(100px,200px);\n  ```\n\n  rotate（旋转） 给定度数顺时针旋转的元素。负值则为逆时针旋转\n  ```\n  transform: rotate(60deg);\n  ```\n\n  scale (缩放) 对元素减小或者放大，取决于宽度（X轴）和高度（Y轴）的参数\n  ```\n  transform: scale(2,2);\n  ```\n\n  skew (倾斜) 根据X轴和Y轴位置给定的角度参数，进行倾斜，负数则为反方向倾斜\n  ```\n  transform: skew(40deg,50deg);\n  ```\n\n2. transform-origin：允许改变被转换元素的位置\n  ```\n  transform-origin: x-axis y-axis z-axis;\n  ```\n\n3. transform-style：规定被嵌套元素如何在 3D 空间中显示\n  ```\n  // preserve-3d所有子元素在3D空间中呈现\n  // flat所有子元素在2D平面呈现\n  transform-style: flat|preserve-3d;\n  ```\n\n4. perspective:设置元素距离视图的距离，以像素计，与 perspective-origin 属性一同使用，能够改变 3D 元素的底部位置\n  ```\n  perspective: number|none;\n  ``` \n\n5. backface-visibility:定义当元素不面向屏幕时是否可见，在旋转元素不希望看到其背面时，该属性很有用\n  ```\n  backface-visibility: visible|hidden;\n  ```\n\n### CSS3过渡（transition）\n1. 某种效果可以从一种样式转变到另一种样式的效果\n   ```\n   transition: property duration timing-function delay;\n   ```\n   ```\n   transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);\n   ```\n\n### CSS3 动画（animation及@keyframes）\n\n1. 使元素从一种样式逐渐变化为另一种样式的效果\n   - animation\n   - @keyframes\n   - 语法规则及拆解\n   ```\n    animation: animation-name animation-duration animation-timing-function animation-fill-mode animation-delay animation-iteration-count\tanimation-direction animation-play-state;\n\n    animation-name(keyframe名字): keyframename|none;\n\n    animation-duration(动画完成一个周期需要多少秒或毫秒):animation-duration: time | 0;\n\n    animation-timing-function(动画的速度曲线,使用的数学函数，称为三次贝塞尔曲线，速度曲线): linear\t| ease\t| ease-in | ease-out\t| ease-in-out\t | cubic-bezier(n,n,n,n);\n\n    animation-fill-mode(当动画完成时或又一个延迟未开始播放时的样式): none|forwards|backwards|both|initial|inherit;\n\n    animation-delay(动画什么时候开始): time;\n\n    animation-iteration-count(动画被播放的次数):n |infinite\n\n    animation-direction(是否循环交替反向播放动画): normal|reverse|alternate|alternate-reverse|initial|inherit;\n    \n    animation-play-state(动画是否正在运行或暂停):paused|running;\n   ```\n \n### css动画库以及动画工具\n   - matrix3d(http://ds-overdesign.com/transform/matrix3d.html)\n   - matrix(http://meyerweb.com/eric/tools/matrix)\n   - tools(http://www.f2e.name/case/css3/tools.html)\n\n  ","source":"_posts/css/css-animation.md","raw":"---\ntitle: CSS 动画\ndate: 2017-6-20 21:06:05\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识\ntags:\n- CSS\ncategories:\n- CSS\n---\n\n\nAPI的简介及简单动画的实现\n\n### 3D转换（transform）\n\n1. 定义向元素应用 2D 或 3D 转换，可以对元素进行移动、缩放、转动、拉长或拉伸\n\n  translate(移动) 根据X轴和Y轴位置给定的参数，从当前元素位置移动\n  ```\n  transform: translate(100px,200px);\n  ```\n\n  rotate（旋转） 给定度数顺时针旋转的元素。负值则为逆时针旋转\n  ```\n  transform: rotate(60deg);\n  ```\n\n  scale (缩放) 对元素减小或者放大，取决于宽度（X轴）和高度（Y轴）的参数\n  ```\n  transform: scale(2,2);\n  ```\n\n  skew (倾斜) 根据X轴和Y轴位置给定的角度参数，进行倾斜，负数则为反方向倾斜\n  ```\n  transform: skew(40deg,50deg);\n  ```\n\n2. transform-origin：允许改变被转换元素的位置\n  ```\n  transform-origin: x-axis y-axis z-axis;\n  ```\n\n3. transform-style：规定被嵌套元素如何在 3D 空间中显示\n  ```\n  // preserve-3d所有子元素在3D空间中呈现\n  // flat所有子元素在2D平面呈现\n  transform-style: flat|preserve-3d;\n  ```\n\n4. perspective:设置元素距离视图的距离，以像素计，与 perspective-origin 属性一同使用，能够改变 3D 元素的底部位置\n  ```\n  perspective: number|none;\n  ``` \n\n5. backface-visibility:定义当元素不面向屏幕时是否可见，在旋转元素不希望看到其背面时，该属性很有用\n  ```\n  backface-visibility: visible|hidden;\n  ```\n\n### CSS3过渡（transition）\n1. 某种效果可以从一种样式转变到另一种样式的效果\n   ```\n   transition: property duration timing-function delay;\n   ```\n   ```\n   transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);\n   ```\n\n### CSS3 动画（animation及@keyframes）\n\n1. 使元素从一种样式逐渐变化为另一种样式的效果\n   - animation\n   - @keyframes\n   - 语法规则及拆解\n   ```\n    animation: animation-name animation-duration animation-timing-function animation-fill-mode animation-delay animation-iteration-count\tanimation-direction animation-play-state;\n\n    animation-name(keyframe名字): keyframename|none;\n\n    animation-duration(动画完成一个周期需要多少秒或毫秒):animation-duration: time | 0;\n\n    animation-timing-function(动画的速度曲线,使用的数学函数，称为三次贝塞尔曲线，速度曲线): linear\t| ease\t| ease-in | ease-out\t| ease-in-out\t | cubic-bezier(n,n,n,n);\n\n    animation-fill-mode(当动画完成时或又一个延迟未开始播放时的样式): none|forwards|backwards|both|initial|inherit;\n\n    animation-delay(动画什么时候开始): time;\n\n    animation-iteration-count(动画被播放的次数):n |infinite\n\n    animation-direction(是否循环交替反向播放动画): normal|reverse|alternate|alternate-reverse|initial|inherit;\n    \n    animation-play-state(动画是否正在运行或暂停):paused|running;\n   ```\n \n### css动画库以及动画工具\n   - matrix3d(http://ds-overdesign.com/transform/matrix3d.html)\n   - matrix(http://meyerweb.com/eric/tools/matrix)\n   - tools(http://www.f2e.name/case/css3/tools.html)\n\n  ","slug":"css/css-animation","published":1,"updated":"2019-10-15T01:29:42.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqk000fb0u6srakrzub","content":"<p>API的简介及简单动画的实现</p>\n<h3 id=\"3D转换（transform）\"><a href=\"#3D转换（transform）\" class=\"headerlink\" title=\"3D转换（transform）\"></a>3D转换（transform）</h3><ol>\n<li><p>定义向元素应用 2D 或 3D 转换，可以对元素进行移动、缩放、转动、拉长或拉伸</p>\n<p>translate(移动) 根据X轴和Y轴位置给定的参数，从当前元素位置移动</p>\n<pre><code>transform: translate(100px,200px);</code></pre><p>rotate（旋转） 给定度数顺时针旋转的元素。负值则为逆时针旋转</p>\n<pre><code>transform: rotate(60deg);</code></pre><p>scale (缩放) 对元素减小或者放大，取决于宽度（X轴）和高度（Y轴）的参数</p>\n<pre><code>transform: scale(2,2);</code></pre><p>skew (倾斜) 根据X轴和Y轴位置给定的角度参数，进行倾斜，负数则为反方向倾斜</p>\n<pre><code>transform: skew(40deg,50deg);</code></pre></li>\n<li><p>transform-origin：允许改变被转换元素的位置</p>\n<pre><code>transform-origin: x-axis y-axis z-axis;</code></pre></li>\n<li><p>transform-style：规定被嵌套元素如何在 3D 空间中显示</p>\n<pre><code>// preserve-3d所有子元素在3D空间中呈现\n// flat所有子元素在2D平面呈现\ntransform-style: flat|preserve-3d;</code></pre></li>\n<li><p>perspective:设置元素距离视图的距离，以像素计，与 perspective-origin 属性一同使用，能够改变 3D 元素的底部位置</p>\n<pre><code>perspective: number|none;</code></pre></li>\n<li><p>backface-visibility:定义当元素不面向屏幕时是否可见，在旋转元素不希望看到其背面时，该属性很有用</p>\n<pre><code>backface-visibility: visible|hidden;</code></pre></li>\n</ol>\n<h3 id=\"CSS3过渡（transition）\"><a href=\"#CSS3过渡（transition）\" class=\"headerlink\" title=\"CSS3过渡（transition）\"></a>CSS3过渡（transition）</h3><ol>\n<li>某种效果可以从一种样式转变到另一种样式的效果<pre><code>transition: property duration timing-function delay;</code></pre><pre><code>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);</code></pre></li>\n</ol>\n<h3 id=\"CSS3-动画（animation及-keyframes）\"><a href=\"#CSS3-动画（animation及-keyframes）\" class=\"headerlink\" title=\"CSS3 动画（animation及@keyframes）\"></a>CSS3 动画（animation及@keyframes）</h3><ol>\n<li><p>使元素从一种样式逐渐变化为另一种样式的效果</p>\n<ul>\n<li><p>animation</p>\n</li>\n<li><p>@keyframes</p>\n</li>\n<li><p>语法规则及拆解</p>\n<pre><code>animation: animation-name animation-duration animation-timing-function animation-fill-mode animation-delay animation-iteration-count    animation-direction animation-play-state;\n\nanimation-name(keyframe名字): keyframename|none;\n\nanimation-duration(动画完成一个周期需要多少秒或毫秒):animation-duration: time | 0;\n\nanimation-timing-function(动画的速度曲线,使用的数学函数，称为三次贝塞尔曲线，速度曲线): linear    | ease    | ease-in | ease-out    | ease-in-out     | cubic-bezier(n,n,n,n);\n\nanimation-fill-mode(当动画完成时或又一个延迟未开始播放时的样式): none|forwards|backwards|both|initial|inherit;\n\nanimation-delay(动画什么时候开始): time;\n\nanimation-iteration-count(动画被播放的次数):n |infinite\n\nanimation-direction(是否循环交替反向播放动画): normal|reverse|alternate|alternate-reverse|initial|inherit;\n\nanimation-play-state(动画是否正在运行或暂停):paused|running;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"css动画库以及动画工具\"><a href=\"#css动画库以及动画工具\" class=\"headerlink\" title=\"css动画库以及动画工具\"></a>css动画库以及动画工具</h3><ul>\n<li>matrix3d(<a href=\"http://ds-overdesign.com/transform/matrix3d.html\" target=\"_blank\" rel=\"noopener\">http://ds-overdesign.com/transform/matrix3d.html</a>)</li>\n<li>matrix(<a href=\"http://meyerweb.com/eric/tools/matrix\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/matrix</a>)</li>\n<li>tools(<a href=\"http://www.f2e.name/case/css3/tools.html\" target=\"_blank\" rel=\"noopener\">http://www.f2e.name/case/css3/tools.html</a>)</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>API的简介及简单动画的实现</p>\n<h3 id=\"3D转换（transform）\"><a href=\"#3D转换（transform）\" class=\"headerlink\" title=\"3D转换（transform）\"></a>3D转换（transform）</h3><ol>\n<li><p>定义向元素应用 2D 或 3D 转换，可以对元素进行移动、缩放、转动、拉长或拉伸</p>\n<p>translate(移动) 根据X轴和Y轴位置给定的参数，从当前元素位置移动</p>\n<pre><code>transform: translate(100px,200px);</code></pre><p>rotate（旋转） 给定度数顺时针旋转的元素。负值则为逆时针旋转</p>\n<pre><code>transform: rotate(60deg);</code></pre><p>scale (缩放) 对元素减小或者放大，取决于宽度（X轴）和高度（Y轴）的参数</p>\n<pre><code>transform: scale(2,2);</code></pre><p>skew (倾斜) 根据X轴和Y轴位置给定的角度参数，进行倾斜，负数则为反方向倾斜</p>\n<pre><code>transform: skew(40deg,50deg);</code></pre></li>\n<li><p>transform-origin：允许改变被转换元素的位置</p>\n<pre><code>transform-origin: x-axis y-axis z-axis;</code></pre></li>\n<li><p>transform-style：规定被嵌套元素如何在 3D 空间中显示</p>\n<pre><code>// preserve-3d所有子元素在3D空间中呈现\n// flat所有子元素在2D平面呈现\ntransform-style: flat|preserve-3d;</code></pre></li>\n<li><p>perspective:设置元素距离视图的距离，以像素计，与 perspective-origin 属性一同使用，能够改变 3D 元素的底部位置</p>\n<pre><code>perspective: number|none;</code></pre></li>\n<li><p>backface-visibility:定义当元素不面向屏幕时是否可见，在旋转元素不希望看到其背面时，该属性很有用</p>\n<pre><code>backface-visibility: visible|hidden;</code></pre></li>\n</ol>\n<h3 id=\"CSS3过渡（transition）\"><a href=\"#CSS3过渡（transition）\" class=\"headerlink\" title=\"CSS3过渡（transition）\"></a>CSS3过渡（transition）</h3><ol>\n<li>某种效果可以从一种样式转变到另一种样式的效果<pre><code>transition: property duration timing-function delay;</code></pre><pre><code>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);</code></pre></li>\n</ol>\n<h3 id=\"CSS3-动画（animation及-keyframes）\"><a href=\"#CSS3-动画（animation及-keyframes）\" class=\"headerlink\" title=\"CSS3 动画（animation及@keyframes）\"></a>CSS3 动画（animation及@keyframes）</h3><ol>\n<li><p>使元素从一种样式逐渐变化为另一种样式的效果</p>\n<ul>\n<li><p>animation</p>\n</li>\n<li><p>@keyframes</p>\n</li>\n<li><p>语法规则及拆解</p>\n<pre><code>animation: animation-name animation-duration animation-timing-function animation-fill-mode animation-delay animation-iteration-count    animation-direction animation-play-state;\n\nanimation-name(keyframe名字): keyframename|none;\n\nanimation-duration(动画完成一个周期需要多少秒或毫秒):animation-duration: time | 0;\n\nanimation-timing-function(动画的速度曲线,使用的数学函数，称为三次贝塞尔曲线，速度曲线): linear    | ease    | ease-in | ease-out    | ease-in-out     | cubic-bezier(n,n,n,n);\n\nanimation-fill-mode(当动画完成时或又一个延迟未开始播放时的样式): none|forwards|backwards|both|initial|inherit;\n\nanimation-delay(动画什么时候开始): time;\n\nanimation-iteration-count(动画被播放的次数):n |infinite\n\nanimation-direction(是否循环交替反向播放动画): normal|reverse|alternate|alternate-reverse|initial|inherit;\n\nanimation-play-state(动画是否正在运行或暂停):paused|running;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"css动画库以及动画工具\"><a href=\"#css动画库以及动画工具\" class=\"headerlink\" title=\"css动画库以及动画工具\"></a>css动画库以及动画工具</h3><ul>\n<li>matrix3d(<a href=\"http://ds-overdesign.com/transform/matrix3d.html\" target=\"_blank\" rel=\"noopener\">http://ds-overdesign.com/transform/matrix3d.html</a>)</li>\n<li>matrix(<a href=\"http://meyerweb.com/eric/tools/matrix\" target=\"_blank\" rel=\"noopener\">http://meyerweb.com/eric/tools/matrix</a>)</li>\n<li>tools(<a href=\"http://www.f2e.name/case/css3/tools.html\" target=\"_blank\" rel=\"noopener\">http://www.f2e.name/case/css3/tools.html</a>)</li>\n</ul>\n"},{"title":"css分层理论","date":"2017-06-22T10:02:25.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识","_content":"\ncss分层理论和命令规则将有助于它的可扩展性，性能的提高和代码的组织管理。\n\n### OOSS\n1. 定义：面向对象css\n2. 设计原则：表现与结构分离，容器与内容分离\n3. 用途：创建可复用的CSS模块以提高性能\n4. 提高团队开发效率，减少耦合\n\n### SMACSS\n1. 定义：可扩展的模块化架构的CSS\n2. 设计原则： 使用一套五个层次来划分CSS\n3. 用途：创建更结构化的模块以提高性能，增加效率\n  ```\n  Base - 设定HTML elements 的默认值\n  Layout -Page structure 整个网站的「大架构」的外观   \n  Module - Re-usable code bloks 不同页面公共模块 \n  State - Active/Inactive etc 定义元素不同的状态 \n  Theme - Typography and colour schemes 页面上所有「主视觉」的定义 \n  ```\n    \n  ```\n  .header {}\n  .header-top {}\n  .header-top__title {}\n  .header-top__title--ico {}\n\n  <div class=\"header\">\n    <div class=\"header-top\">\n      <div class=\"header-top__title\">\n        <div class=\"header-top__title--ico\"></div>\n      </div>\n    </div>\n  </div>\n  ```\n\n### BEM\n1. 定义：block：块，Element：元素，Modifier：修饰符 \n2. 设计原则：通过给每个元素添加它的父级block模块作为前缀\n3. 用途：有助于消除页面和body类对嵌套或者附加样式依赖\n  ```\n  .product-details {}\n  .product-details__header {}\n  .product-details__header--ico {}\n\n  <div class=\"product-details\">\n    <div class=\"product-details__header\">\n      <div class=\"product-details__header--ico\"><div> \n    </div>\n  </div>\n  ```\n\n### SUIT\n1. 定义：SUIT起源于BEM，对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来\n2. 用途：通过抽离组件级别的的样式表，消除潜在的混乱连字符号连接元素名来使得选择器的可读性更强。\n3. 代码示例同BEM 只不过是抽离的组件\n\n### ACSS\n\n定义： 考虑如何设计一个系统的接口。原子(Atoms)是创建一个区块的最基本的特质，比如说表单按钮。分子(Molecules)是很多个原子(Atoms)的组合，比如说一个表单中包括了一个标签，输入框和按钮。生物(Organisms)是众多分子(Molecules)的组合物，比如一个网站的顶部区域，它包括了网站的标题、导航等。而模板(Templates)又是众多生物(Organisms)的结合体。比如一个网站页面的布局。而最后的页面就是特殊的模板。\n\n![](/images/Acss.jpg)\n\n### ITCSS\n\n定义：创造了一系列的层次来管理依赖关系和促进可扩展性。基础的层次包括通用和广泛的选择器。顶部的层次包含了局部模块具体化的选择器。\n\n```\n.Settings — 全局可用配置，设置开关。$color-ui: #BADA55; $spacing-unit:10px\n.Tools —通用工具函数。@mixin font-color() {font-color: $color-ui;}\n.Generic — 通用基础样式。Normalize, resets, box-sizing: border-box;\n.Base — 未归类的HTML元素。ul {list-style: square outside;}\n.Objects —设计部分开始使用专用类。.ui-list__item {padding: $spacing-unit;}\n.Components — 设计符合你们的组件。products-list {@include font-brand();border-top: 1px solid $color-ui;}\n.Trumps —重写，只影响一块的DOM。(通常带上我们的!important)\n\n```\n","source":"_posts/css/css-layered.md","raw":"---\ntitle: css分层理论\ndate: 2017-6-22 18:02:25\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识\ntags:\n- CSS\ncategories:\n- CSS\n---\n\ncss分层理论和命令规则将有助于它的可扩展性，性能的提高和代码的组织管理。\n\n### OOSS\n1. 定义：面向对象css\n2. 设计原则：表现与结构分离，容器与内容分离\n3. 用途：创建可复用的CSS模块以提高性能\n4. 提高团队开发效率，减少耦合\n\n### SMACSS\n1. 定义：可扩展的模块化架构的CSS\n2. 设计原则： 使用一套五个层次来划分CSS\n3. 用途：创建更结构化的模块以提高性能，增加效率\n  ```\n  Base - 设定HTML elements 的默认值\n  Layout -Page structure 整个网站的「大架构」的外观   \n  Module - Re-usable code bloks 不同页面公共模块 \n  State - Active/Inactive etc 定义元素不同的状态 \n  Theme - Typography and colour schemes 页面上所有「主视觉」的定义 \n  ```\n    \n  ```\n  .header {}\n  .header-top {}\n  .header-top__title {}\n  .header-top__title--ico {}\n\n  <div class=\"header\">\n    <div class=\"header-top\">\n      <div class=\"header-top__title\">\n        <div class=\"header-top__title--ico\"></div>\n      </div>\n    </div>\n  </div>\n  ```\n\n### BEM\n1. 定义：block：块，Element：元素，Modifier：修饰符 \n2. 设计原则：通过给每个元素添加它的父级block模块作为前缀\n3. 用途：有助于消除页面和body类对嵌套或者附加样式依赖\n  ```\n  .product-details {}\n  .product-details__header {}\n  .product-details__header--ico {}\n\n  <div class=\"product-details\">\n    <div class=\"product-details__header\">\n      <div class=\"product-details__header--ico\"><div> \n    </div>\n  </div>\n  ```\n\n### SUIT\n1. 定义：SUIT起源于BEM，对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来\n2. 用途：通过抽离组件级别的的样式表，消除潜在的混乱连字符号连接元素名来使得选择器的可读性更强。\n3. 代码示例同BEM 只不过是抽离的组件\n\n### ACSS\n\n定义： 考虑如何设计一个系统的接口。原子(Atoms)是创建一个区块的最基本的特质，比如说表单按钮。分子(Molecules)是很多个原子(Atoms)的组合，比如说一个表单中包括了一个标签，输入框和按钮。生物(Organisms)是众多分子(Molecules)的组合物，比如一个网站的顶部区域，它包括了网站的标题、导航等。而模板(Templates)又是众多生物(Organisms)的结合体。比如一个网站页面的布局。而最后的页面就是特殊的模板。\n\n![](/images/Acss.jpg)\n\n### ITCSS\n\n定义：创造了一系列的层次来管理依赖关系和促进可扩展性。基础的层次包括通用和广泛的选择器。顶部的层次包含了局部模块具体化的选择器。\n\n```\n.Settings — 全局可用配置，设置开关。$color-ui: #BADA55; $spacing-unit:10px\n.Tools —通用工具函数。@mixin font-color() {font-color: $color-ui;}\n.Generic — 通用基础样式。Normalize, resets, box-sizing: border-box;\n.Base — 未归类的HTML元素。ul {list-style: square outside;}\n.Objects —设计部分开始使用专用类。.ui-list__item {padding: $spacing-unit;}\n.Components — 设计符合你们的组件。products-list {@include font-brand();border-top: 1px solid $color-ui;}\n.Trumps —重写，只影响一块的DOM。(通常带上我们的!important)\n\n```\n","slug":"css/css-layered","published":1,"updated":"2019-10-15T01:29:42.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oql000gb0u62o3iq9vh","content":"<p>css分层理论和命令规则将有助于它的可扩展性，性能的提高和代码的组织管理。</p>\n<h3 id=\"OOSS\"><a href=\"#OOSS\" class=\"headerlink\" title=\"OOSS\"></a>OOSS</h3><ol>\n<li>定义：面向对象css</li>\n<li>设计原则：表现与结构分离，容器与内容分离</li>\n<li>用途：创建可复用的CSS模块以提高性能</li>\n<li>提高团队开发效率，减少耦合</li>\n</ol>\n<h3 id=\"SMACSS\"><a href=\"#SMACSS\" class=\"headerlink\" title=\"SMACSS\"></a>SMACSS</h3><ol>\n<li><p>定义：可扩展的模块化架构的CSS</p>\n</li>\n<li><p>设计原则： 使用一套五个层次来划分CSS</p>\n</li>\n<li><p>用途：创建更结构化的模块以提高性能，增加效率</p>\n<pre><code>Base - 设定HTML elements 的默认值\nLayout -Page structure 整个网站的「大架构」的外观   \nModule - Re-usable code bloks 不同页面公共模块 \nState - Active/Inactive etc 定义元素不同的状态 \nTheme - Typography and colour schemes 页面上所有「主视觉」的定义 </code></pre><pre><code>.header {}\n.header-top {}\n.header-top__title {}\n.header-top__title--ico {}\n\n&lt;div class=&quot;header&quot;&gt;\n &lt;div class=&quot;header-top&quot;&gt;\n   &lt;div class=&quot;header-top__title&quot;&gt;\n     &lt;div class=&quot;header-top__title--ico&quot;&gt;&lt;/div&gt;\n   &lt;/div&gt;\n &lt;/div&gt;\n&lt;/div&gt;</code></pre></li>\n</ol>\n<h3 id=\"BEM\"><a href=\"#BEM\" class=\"headerlink\" title=\"BEM\"></a>BEM</h3><ol>\n<li><p>定义：block：块，Element：元素，Modifier：修饰符 </p>\n</li>\n<li><p>设计原则：通过给每个元素添加它的父级block模块作为前缀</p>\n</li>\n<li><p>用途：有助于消除页面和body类对嵌套或者附加样式依赖</p>\n<pre><code>.product-details {}\n.product-details__header {}\n.product-details__header--ico {}\n\n&lt;div class=&quot;product-details&quot;&gt;\n &lt;div class=&quot;product-details__header&quot;&gt;\n   &lt;div class=&quot;product-details__header--ico&quot;&gt;&lt;div&gt; \n &lt;/div&gt;\n&lt;/div&gt;</code></pre></li>\n</ol>\n<h3 id=\"SUIT\"><a href=\"#SUIT\" class=\"headerlink\" title=\"SUIT\"></a>SUIT</h3><ol>\n<li>定义：SUIT起源于BEM，对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来</li>\n<li>用途：通过抽离组件级别的的样式表，消除潜在的混乱连字符号连接元素名来使得选择器的可读性更强。</li>\n<li>代码示例同BEM 只不过是抽离的组件</li>\n</ol>\n<h3 id=\"ACSS\"><a href=\"#ACSS\" class=\"headerlink\" title=\"ACSS\"></a>ACSS</h3><p>定义： 考虑如何设计一个系统的接口。原子(Atoms)是创建一个区块的最基本的特质，比如说表单按钮。分子(Molecules)是很多个原子(Atoms)的组合，比如说一个表单中包括了一个标签，输入框和按钮。生物(Organisms)是众多分子(Molecules)的组合物，比如一个网站的顶部区域，它包括了网站的标题、导航等。而模板(Templates)又是众多生物(Organisms)的结合体。比如一个网站页面的布局。而最后的页面就是特殊的模板。</p>\n<p><img src=\"/images/Acss.jpg\" alt></p>\n<h3 id=\"ITCSS\"><a href=\"#ITCSS\" class=\"headerlink\" title=\"ITCSS\"></a>ITCSS</h3><p>定义：创造了一系列的层次来管理依赖关系和促进可扩展性。基础的层次包括通用和广泛的选择器。顶部的层次包含了局部模块具体化的选择器。</p>\n<pre><code>.Settings — 全局可用配置，设置开关。$color-ui: #BADA55; $spacing-unit:10px\n.Tools —通用工具函数。@mixin font-color() {font-color: $color-ui;}\n.Generic — 通用基础样式。Normalize, resets, box-sizing: border-box;\n.Base — 未归类的HTML元素。ul {list-style: square outside;}\n.Objects —设计部分开始使用专用类。.ui-list__item {padding: $spacing-unit;}\n.Components — 设计符合你们的组件。products-list {@include font-brand();border-top: 1px solid $color-ui;}\n.Trumps —重写，只影响一块的DOM。(通常带上我们的!important)\n</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>css分层理论和命令规则将有助于它的可扩展性，性能的提高和代码的组织管理。</p>\n<h3 id=\"OOSS\"><a href=\"#OOSS\" class=\"headerlink\" title=\"OOSS\"></a>OOSS</h3><ol>\n<li>定义：面向对象css</li>\n<li>设计原则：表现与结构分离，容器与内容分离</li>\n<li>用途：创建可复用的CSS模块以提高性能</li>\n<li>提高团队开发效率，减少耦合</li>\n</ol>\n<h3 id=\"SMACSS\"><a href=\"#SMACSS\" class=\"headerlink\" title=\"SMACSS\"></a>SMACSS</h3><ol>\n<li><p>定义：可扩展的模块化架构的CSS</p>\n</li>\n<li><p>设计原则： 使用一套五个层次来划分CSS</p>\n</li>\n<li><p>用途：创建更结构化的模块以提高性能，增加效率</p>\n<pre><code>Base - 设定HTML elements 的默认值\nLayout -Page structure 整个网站的「大架构」的外观   \nModule - Re-usable code bloks 不同页面公共模块 \nState - Active/Inactive etc 定义元素不同的状态 \nTheme - Typography and colour schemes 页面上所有「主视觉」的定义 </code></pre><pre><code>.header {}\n.header-top {}\n.header-top__title {}\n.header-top__title--ico {}\n\n&lt;div class=&quot;header&quot;&gt;\n &lt;div class=&quot;header-top&quot;&gt;\n   &lt;div class=&quot;header-top__title&quot;&gt;\n     &lt;div class=&quot;header-top__title--ico&quot;&gt;&lt;/div&gt;\n   &lt;/div&gt;\n &lt;/div&gt;\n&lt;/div&gt;</code></pre></li>\n</ol>\n<h3 id=\"BEM\"><a href=\"#BEM\" class=\"headerlink\" title=\"BEM\"></a>BEM</h3><ol>\n<li><p>定义：block：块，Element：元素，Modifier：修饰符 </p>\n</li>\n<li><p>设计原则：通过给每个元素添加它的父级block模块作为前缀</p>\n</li>\n<li><p>用途：有助于消除页面和body类对嵌套或者附加样式依赖</p>\n<pre><code>.product-details {}\n.product-details__header {}\n.product-details__header--ico {}\n\n&lt;div class=&quot;product-details&quot;&gt;\n &lt;div class=&quot;product-details__header&quot;&gt;\n   &lt;div class=&quot;product-details__header--ico&quot;&gt;&lt;div&gt; \n &lt;/div&gt;\n&lt;/div&gt;</code></pre></li>\n</ol>\n<h3 id=\"SUIT\"><a href=\"#SUIT\" class=\"headerlink\" title=\"SUIT\"></a>SUIT</h3><ol>\n<li>定义：SUIT起源于BEM，对组件名使用驼峰式和连字号把组件从他们的修饰和子孙后代中区分出来</li>\n<li>用途：通过抽离组件级别的的样式表，消除潜在的混乱连字符号连接元素名来使得选择器的可读性更强。</li>\n<li>代码示例同BEM 只不过是抽离的组件</li>\n</ol>\n<h3 id=\"ACSS\"><a href=\"#ACSS\" class=\"headerlink\" title=\"ACSS\"></a>ACSS</h3><p>定义： 考虑如何设计一个系统的接口。原子(Atoms)是创建一个区块的最基本的特质，比如说表单按钮。分子(Molecules)是很多个原子(Atoms)的组合，比如说一个表单中包括了一个标签，输入框和按钮。生物(Organisms)是众多分子(Molecules)的组合物，比如一个网站的顶部区域，它包括了网站的标题、导航等。而模板(Templates)又是众多生物(Organisms)的结合体。比如一个网站页面的布局。而最后的页面就是特殊的模板。</p>\n<p><img src=\"/images/Acss.jpg\" alt></p>\n<h3 id=\"ITCSS\"><a href=\"#ITCSS\" class=\"headerlink\" title=\"ITCSS\"></a>ITCSS</h3><p>定义：创造了一系列的层次来管理依赖关系和促进可扩展性。基础的层次包括通用和广泛的选择器。顶部的层次包含了局部模块具体化的选择器。</p>\n<pre><code>.Settings — 全局可用配置，设置开关。$color-ui: #BADA55; $spacing-unit:10px\n.Tools —通用工具函数。@mixin font-color() {font-color: $color-ui;}\n.Generic — 通用基础样式。Normalize, resets, box-sizing: border-box;\n.Base — 未归类的HTML元素。ul {list-style: square outside;}\n.Objects —设计部分开始使用专用类。.ui-list__item {padding: $spacing-unit;}\n.Components — 设计符合你们的组件。products-list {@include font-brand();border-top: 1px solid $color-ui;}\n.Trumps —重写，只影响一块的DOM。(通常带上我们的!important)\n</code></pre>"},{"title":"CSS预处理器","date":"2017-07-01T14:25:01.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识","_content":"\nCSS 预处理器赋予我们很多css强大的功能，能够很清晰地实现代码的分层、复用和依赖管理，提高开发效率\n\n### 基本语法\n\n1. Less 的基本语法跟原生的css的风格几乎差不多\n2. Sass、Stylus 利用缩进、空格和换行来减少需要输入的字符\n\nSass\n\n```\n.header\n  background-color:red\n```\n\nLess & SCSS\n\n```\n.header {\n  background-color:red;\n}\n```\n\nStylus\n\n```\n.header\n  background-color:red\n```\n\n### 嵌套语法\n\n嵌套语法都是一致的,区别是 Sass 和 Stylus 可以不用书写大括号\n\nless\n\n```\n.header {\n  &.title {\n    color: red;\n  }\n}\n```\n\n### 变量\n\n为 CSS 增加了一种有效的复用方式，减少CSS书写重复\n\nSass\n\n```\n$bg: #ccc;\n\n.header \n  background-color:$bg;\n```\n\nLess\n```\n@bg: #ccc;\n\nheader {\n  background-color: @bg;\n}\n```\n\nStylus\n\n```\nbg = #ccc\n\nheader\n  background-color: bg\n```\n\n### @import\n\nSass 只能使用 url() 表达式引入时进行变量插值\n  ```\n  $public: public;\n\n  @import url(styles.#{$public}.css);\n  ```\n\nLess可以在字符串中进行插值：\n  ```\n  @public: public;\n\n  @import \"styles.@{public}.css\";\n  ```\n\nStylus 可以利用其字符串拼接的功能实现\n  ```\n  public = \"public\"\n\n  @import \"styles.\" + public + \".css\"\n  ```\n\n\n### 混入(Mixins)\n\n作用: 样式层面的抽象\n\nSass\n  ```\n  @mixin product-public-text {\n    font: {\n      size: 20px;\n      weight: 600;\n      family: PingFangSC;\n    }\n    color: rgba(72,72,72,1);\n  }\n  .product-header-title {\n    @include product-public-text;\n    padding: 10px;\n  }\n  ```\n\nLess\n  ```\n  .product-public-font-weight {\n    font-weight: 600;\n  }\n\n  .product-public-font(@color: red) {\n    font-size: 20px;\n    color: @color;\n  }\n\n  .product-header-title{\n    .product-public-font-weight;\n    .product-public-font(red);\n  }\n  ```\n\n### 继承\n\nSass\n  ```\n  .header {\n    background-color: red;\n  }\n  .main.active {\n    @extend .header;\n  }\n  ```\n\nless\n  ```\n  .header {\n    background-color: red;\n  }\n  .main {\n    &:extend(.header);\n  }\n  ```\n\nStylus,Scss\n  ```\n  .header\n    background-color: red;\n\n  .main\n    @extend .header\n  ```\n\n### 高级用法（函数）\n\n三种预处理器都自带了诸如色彩处理（darken等）、类型判断（if each for while 等）、数值计算等内置函数\n\n### 三种预处理器手册\n\n1. Sass：http://sass.bootcss.com/\n2. Less： https://less.bootcss.com/\n3. stylus：https://stylus.bootcss.com/\n","source":"_posts/css/css-preprocessor.md","raw":"---\ntitle: CSS预处理器\ndate: 2017-7-01 22:25:01\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: css 基础系列文章，包含基础概念、常用基本基本布局、css分层与面向对象理论、css动画与3D、css与处理器等基础知识\ntags:\n- CSS\ncategories:\n- CSS\n---\n\nCSS 预处理器赋予我们很多css强大的功能，能够很清晰地实现代码的分层、复用和依赖管理，提高开发效率\n\n### 基本语法\n\n1. Less 的基本语法跟原生的css的风格几乎差不多\n2. Sass、Stylus 利用缩进、空格和换行来减少需要输入的字符\n\nSass\n\n```\n.header\n  background-color:red\n```\n\nLess & SCSS\n\n```\n.header {\n  background-color:red;\n}\n```\n\nStylus\n\n```\n.header\n  background-color:red\n```\n\n### 嵌套语法\n\n嵌套语法都是一致的,区别是 Sass 和 Stylus 可以不用书写大括号\n\nless\n\n```\n.header {\n  &.title {\n    color: red;\n  }\n}\n```\n\n### 变量\n\n为 CSS 增加了一种有效的复用方式，减少CSS书写重复\n\nSass\n\n```\n$bg: #ccc;\n\n.header \n  background-color:$bg;\n```\n\nLess\n```\n@bg: #ccc;\n\nheader {\n  background-color: @bg;\n}\n```\n\nStylus\n\n```\nbg = #ccc\n\nheader\n  background-color: bg\n```\n\n### @import\n\nSass 只能使用 url() 表达式引入时进行变量插值\n  ```\n  $public: public;\n\n  @import url(styles.#{$public}.css);\n  ```\n\nLess可以在字符串中进行插值：\n  ```\n  @public: public;\n\n  @import \"styles.@{public}.css\";\n  ```\n\nStylus 可以利用其字符串拼接的功能实现\n  ```\n  public = \"public\"\n\n  @import \"styles.\" + public + \".css\"\n  ```\n\n\n### 混入(Mixins)\n\n作用: 样式层面的抽象\n\nSass\n  ```\n  @mixin product-public-text {\n    font: {\n      size: 20px;\n      weight: 600;\n      family: PingFangSC;\n    }\n    color: rgba(72,72,72,1);\n  }\n  .product-header-title {\n    @include product-public-text;\n    padding: 10px;\n  }\n  ```\n\nLess\n  ```\n  .product-public-font-weight {\n    font-weight: 600;\n  }\n\n  .product-public-font(@color: red) {\n    font-size: 20px;\n    color: @color;\n  }\n\n  .product-header-title{\n    .product-public-font-weight;\n    .product-public-font(red);\n  }\n  ```\n\n### 继承\n\nSass\n  ```\n  .header {\n    background-color: red;\n  }\n  .main.active {\n    @extend .header;\n  }\n  ```\n\nless\n  ```\n  .header {\n    background-color: red;\n  }\n  .main {\n    &:extend(.header);\n  }\n  ```\n\nStylus,Scss\n  ```\n  .header\n    background-color: red;\n\n  .main\n    @extend .header\n  ```\n\n### 高级用法（函数）\n\n三种预处理器都自带了诸如色彩处理（darken等）、类型判断（if each for while 等）、数值计算等内置函数\n\n### 三种预处理器手册\n\n1. Sass：http://sass.bootcss.com/\n2. Less： https://less.bootcss.com/\n3. stylus：https://stylus.bootcss.com/\n","slug":"css/css-preprocessor","published":1,"updated":"2019-10-15T01:29:42.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqn000kb0u6cft7pcd2","content":"<p>CSS 预处理器赋予我们很多css强大的功能，能够很清晰地实现代码的分层、复用和依赖管理，提高开发效率</p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><ol>\n<li>Less 的基本语法跟原生的css的风格几乎差不多</li>\n<li>Sass、Stylus 利用缩进、空格和换行来减少需要输入的字符</li>\n</ol>\n<p>Sass</p>\n<pre><code>.header\n  background-color:red</code></pre><p>Less &amp; SCSS</p>\n<pre><code>.header {\n  background-color:red;\n}</code></pre><p>Stylus</p>\n<pre><code>.header\n  background-color:red</code></pre><h3 id=\"嵌套语法\"><a href=\"#嵌套语法\" class=\"headerlink\" title=\"嵌套语法\"></a>嵌套语法</h3><p>嵌套语法都是一致的,区别是 Sass 和 Stylus 可以不用书写大括号</p>\n<p>less</p>\n<pre><code>.header {\n  &amp;.title {\n    color: red;\n  }\n}</code></pre><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>为 CSS 增加了一种有效的复用方式，减少CSS书写重复</p>\n<p>Sass</p>\n<pre><code>$bg: #ccc;\n\n.header \n  background-color:$bg;</code></pre><p>Less</p>\n<pre><code>@bg: #ccc;\n\nheader {\n  background-color: @bg;\n}</code></pre><p>Stylus</p>\n<pre><code>bg = #ccc\n\nheader\n  background-color: bg</code></pre><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"@import\"></a>@import</h3><p>Sass 只能使用 url() 表达式引入时进行变量插值</p>\n<pre><code>  $public: public;\n\n  @import url(styles.#{$public}.css);</code></pre><p>Less可以在字符串中进行插值：</p>\n<pre><code>  @public: public;\n\n  @import &quot;styles.@{public}.css&quot;;</code></pre><p>Stylus 可以利用其字符串拼接的功能实现</p>\n<pre><code>  public = &quot;public&quot;\n\n  @import &quot;styles.&quot; + public + &quot;.css&quot;</code></pre><h3 id=\"混入-Mixins\"><a href=\"#混入-Mixins\" class=\"headerlink\" title=\"混入(Mixins)\"></a>混入(Mixins)</h3><p>作用: 样式层面的抽象</p>\n<p>Sass</p>\n<pre><code>  @mixin product-public-text {\n    font: {\n      size: 20px;\n      weight: 600;\n      family: PingFangSC;\n    }\n    color: rgba(72,72,72,1);\n  }\n  .product-header-title {\n    @include product-public-text;\n    padding: 10px;\n  }</code></pre><p>Less</p>\n<pre><code>  .product-public-font-weight {\n    font-weight: 600;\n  }\n\n  .product-public-font(@color: red) {\n    font-size: 20px;\n    color: @color;\n  }\n\n  .product-header-title{\n    .product-public-font-weight;\n    .product-public-font(red);\n  }</code></pre><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>Sass</p>\n<pre><code>  .header {\n    background-color: red;\n  }\n  .main.active {\n    @extend .header;\n  }</code></pre><p>less</p>\n<pre><code>  .header {\n    background-color: red;\n  }\n  .main {\n    &amp;:extend(.header);\n  }</code></pre><p>Stylus,Scss</p>\n<pre><code>  .header\n    background-color: red;\n\n  .main\n    @extend .header</code></pre><h3 id=\"高级用法（函数）\"><a href=\"#高级用法（函数）\" class=\"headerlink\" title=\"高级用法（函数）\"></a>高级用法（函数）</h3><p>三种预处理器都自带了诸如色彩处理（darken等）、类型判断（if each for while 等）、数值计算等内置函数</p>\n<h3 id=\"三种预处理器手册\"><a href=\"#三种预处理器手册\" class=\"headerlink\" title=\"三种预处理器手册\"></a>三种预处理器手册</h3><ol>\n<li>Sass：<a href=\"http://sass.bootcss.com/\" target=\"_blank\" rel=\"noopener\">http://sass.bootcss.com/</a></li>\n<li>Less： <a href=\"https://less.bootcss.com/\" target=\"_blank\" rel=\"noopener\">https://less.bootcss.com/</a></li>\n<li>stylus：<a href=\"https://stylus.bootcss.com/\" target=\"_blank\" rel=\"noopener\">https://stylus.bootcss.com/</a></li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>CSS 预处理器赋予我们很多css强大的功能，能够很清晰地实现代码的分层、复用和依赖管理，提高开发效率</p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><ol>\n<li>Less 的基本语法跟原生的css的风格几乎差不多</li>\n<li>Sass、Stylus 利用缩进、空格和换行来减少需要输入的字符</li>\n</ol>\n<p>Sass</p>\n<pre><code>.header\n  background-color:red</code></pre><p>Less &amp; SCSS</p>\n<pre><code>.header {\n  background-color:red;\n}</code></pre><p>Stylus</p>\n<pre><code>.header\n  background-color:red</code></pre><h3 id=\"嵌套语法\"><a href=\"#嵌套语法\" class=\"headerlink\" title=\"嵌套语法\"></a>嵌套语法</h3><p>嵌套语法都是一致的,区别是 Sass 和 Stylus 可以不用书写大括号</p>\n<p>less</p>\n<pre><code>.header {\n  &amp;.title {\n    color: red;\n  }\n}</code></pre><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>为 CSS 增加了一种有效的复用方式，减少CSS书写重复</p>\n<p>Sass</p>\n<pre><code>$bg: #ccc;\n\n.header \n  background-color:$bg;</code></pre><p>Less</p>\n<pre><code>@bg: #ccc;\n\nheader {\n  background-color: @bg;\n}</code></pre><p>Stylus</p>\n<pre><code>bg = #ccc\n\nheader\n  background-color: bg</code></pre><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"@import\"></a>@import</h3><p>Sass 只能使用 url() 表达式引入时进行变量插值</p>\n<pre><code>  $public: public;\n\n  @import url(styles.#{$public}.css);</code></pre><p>Less可以在字符串中进行插值：</p>\n<pre><code>  @public: public;\n\n  @import &quot;styles.@{public}.css&quot;;</code></pre><p>Stylus 可以利用其字符串拼接的功能实现</p>\n<pre><code>  public = &quot;public&quot;\n\n  @import &quot;styles.&quot; + public + &quot;.css&quot;</code></pre><h3 id=\"混入-Mixins\"><a href=\"#混入-Mixins\" class=\"headerlink\" title=\"混入(Mixins)\"></a>混入(Mixins)</h3><p>作用: 样式层面的抽象</p>\n<p>Sass</p>\n<pre><code>  @mixin product-public-text {\n    font: {\n      size: 20px;\n      weight: 600;\n      family: PingFangSC;\n    }\n    color: rgba(72,72,72,1);\n  }\n  .product-header-title {\n    @include product-public-text;\n    padding: 10px;\n  }</code></pre><p>Less</p>\n<pre><code>  .product-public-font-weight {\n    font-weight: 600;\n  }\n\n  .product-public-font(@color: red) {\n    font-size: 20px;\n    color: @color;\n  }\n\n  .product-header-title{\n    .product-public-font-weight;\n    .product-public-font(red);\n  }</code></pre><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>Sass</p>\n<pre><code>  .header {\n    background-color: red;\n  }\n  .main.active {\n    @extend .header;\n  }</code></pre><p>less</p>\n<pre><code>  .header {\n    background-color: red;\n  }\n  .main {\n    &amp;:extend(.header);\n  }</code></pre><p>Stylus,Scss</p>\n<pre><code>  .header\n    background-color: red;\n\n  .main\n    @extend .header</code></pre><h3 id=\"高级用法（函数）\"><a href=\"#高级用法（函数）\" class=\"headerlink\" title=\"高级用法（函数）\"></a>高级用法（函数）</h3><p>三种预处理器都自带了诸如色彩处理（darken等）、类型判断（if each for while 等）、数值计算等内置函数</p>\n<h3 id=\"三种预处理器手册\"><a href=\"#三种预处理器手册\" class=\"headerlink\" title=\"三种预处理器手册\"></a>三种预处理器手册</h3><ol>\n<li>Sass：<a href=\"http://sass.bootcss.com/\" target=\"_blank\" rel=\"noopener\">http://sass.bootcss.com/</a></li>\n<li>Less： <a href=\"https://less.bootcss.com/\" target=\"_blank\" rel=\"noopener\">https://less.bootcss.com/</a></li>\n<li>stylus：<a href=\"https://stylus.bootcss.com/\" target=\"_blank\" rel=\"noopener\">https://stylus.bootcss.com/</a></li>\n</ol>\n"},{"title":"bind 函数","date":"2019-04-21T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\nbind 方法其实和 call apply 功能上差不多，只不过 bind() 方法会绑定一个新的函数，通过这个新的函数我们可以当作构造函数、偏函数等等去使用\n\n\n### 作为绑定函数使用\n\ndemo1\n\n```js\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return this.value;\n  }\n}\n\n// 直接调用 this 指向 obj\nobj.getValue()  // 29\n\n// obj.getValue 是一个函数体，在全局作用域中调用，所以 this 指向 window\nlet valFun = obj.getValue;\nvalFun(); // 20\n\n// 使用 bind 将当前的 this 指针指向 obj 对象上\nlet boundGetValue = valFun.bind(obj);\nboundGetValue(); // 29\n```\n\ndemo2\n\n```js\n/**\n * obj.getValue() 返回的是一个匿名函数\n * obj.getValue()() 立即执行函数\n * 匿名函数上下文执行环境具有全局性，所以 this 通常指向 window\n */\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return function () {\n      return this.value\n    }.bind(this);\n  }\n}\n\nobj.getValue()() // 20\n\n\n\n// 利用bind我们可以使匿名函数的 this 指针指向当前对象（当然还有很多方法比如在匿名函数内增加变量 _this = this）\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return function () {\n      return this.value\n    }.bind(this);\n  }\n}\n\nobj.getValue()() // 29\n\n\n// 当然要是改变上述 this 指针不只用 bind 可以如下方法(还有很多方法 比如 apply call)\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    let _this = this;\n    return function () {\n      return _this.value\n    }\n  }\n}\n\nobj.getValue()() // 29\n\n```\n\n### 作为偏函数使用\n\n使一个函数拥有预设的初始参数，这就是偏函数。比如函数A已经拥有参数或者变量，此时我们通过调用函数A，产生函数B，我们就说B为偏函数\n\n在这里我们不展开说明偏函数，柯里化一些函数式编程的概念，在 **JS 高级系列** 函数式编程中会有详细介绍\n\n\n```js\n/**\n * 插入到目标函数的参数列表的开始位置\n * 传递给绑定函数的参数会跟在它们后面\n */\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\n// 偏函数\nlet listArr = list.bind(null, 28);\n\nconsole.log(listArr()); // [28]\n\nconsole.log(listArr(1, 2, 3)); // [28, 1, 2, 3]\n\n\n/**\n * 多次 bind 无效 只能执行一次\n * bind 内部 使用call apply 实现\n */\n\nfunction bar () {\n  console.log(this.value);\n}\n\nlet foo = {\n  value: 1\n}\n\nlet foo1 = {\n  value: 2\n}\n\nlet func = bar.bind(foo).bind(foo1);\nconsole.log(func()); // 1\n\n```\n\n### 模拟第一步\n\n通过上面的应用我们实现 bind 有几个条件\n\n- bind 会返回一个新的函数\n- 可以传递任意参数\n- 绑定 bind 的函数可以有返回值\n\n```js\nFunction.prototype.newBind = function (context) {\n  var _this = this;\n  // 获取 bind 的参数，如上面偏函数的例子\n  var _args = Array.prototype.slice.call(arguments, 1);\n  // 返回新函数\n  return function () {\n    // bind 返回函数传入的参数\n    var _bindArgs = Array.prototype.slice.call(arguments);\n    // 合并参数返回\n    return self.apply(context, _args.concat(_bindArgs));\n  }\n}\n\n```\n\n### 模拟第二步\n\n通过第一步其实我们已经模拟了 bind 的大部分功能，但是在 JS 中也可以把函数当成构造函数来用 可以使用 new 关键字， 这个时候 bind 绑定的函数的 this 就会失效，因为在构造函数中 this 永远指向的是它的实例，关于 new 会在下篇文章中作出解释<br/>\n\n- 通过修改返回的函数的原型，来改变 this 指向问题\n- 调用 bind 一定是函数，否则提示错误\n\n```js\nFunction.prototype.newBind  = function (context) {\n\n  // 提示错误信息\n  if (typeof this != 'function') {\n    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n  }\n\n  var _this = this;\n  \n  // 获取参数\n  var _args = Array.prototype.slice.call(arguments, 1);\n\n  // 利用空函数来防止修改绑定函数的原型，关于 prototype 请查看 prototype 章节\n  var _fNOP = function () {};\n\n  // bind 返回的新函数\n  var _fBound = function () {\n    var _bindArgs = Array.prototype.slice.call(arguments);\n    // 如果返回的 _fBound 被当做 new 的构造函数调用\n    return _this.apply(this instanceof _fBound ? this : context, args.concat(_bindArgs));\n  }\n\n  // 让 _fBound 构造的实例继承绑定函数原型中的值，否则会修改绑定函数的原型的值\n  _fNOP.prototype = this.prototype;\n  _fBound.prototype = new _fNOP();\n\n  return _fBound;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/bind.md","raw":"---\ntitle: bind 函数\ndate: 2019-4-21 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\nbind 方法其实和 call apply 功能上差不多，只不过 bind() 方法会绑定一个新的函数，通过这个新的函数我们可以当作构造函数、偏函数等等去使用\n\n\n### 作为绑定函数使用\n\ndemo1\n\n```js\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return this.value;\n  }\n}\n\n// 直接调用 this 指向 obj\nobj.getValue()  // 29\n\n// obj.getValue 是一个函数体，在全局作用域中调用，所以 this 指向 window\nlet valFun = obj.getValue;\nvalFun(); // 20\n\n// 使用 bind 将当前的 this 指针指向 obj 对象上\nlet boundGetValue = valFun.bind(obj);\nboundGetValue(); // 29\n```\n\ndemo2\n\n```js\n/**\n * obj.getValue() 返回的是一个匿名函数\n * obj.getValue()() 立即执行函数\n * 匿名函数上下文执行环境具有全局性，所以 this 通常指向 window\n */\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return function () {\n      return this.value\n    }.bind(this);\n  }\n}\n\nobj.getValue()() // 20\n\n\n\n// 利用bind我们可以使匿名函数的 this 指针指向当前对象（当然还有很多方法比如在匿名函数内增加变量 _this = this）\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return function () {\n      return this.value\n    }.bind(this);\n  }\n}\n\nobj.getValue()() // 29\n\n\n// 当然要是改变上述 this 指针不只用 bind 可以如下方法(还有很多方法 比如 apply call)\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    let _this = this;\n    return function () {\n      return _this.value\n    }\n  }\n}\n\nobj.getValue()() // 29\n\n```\n\n### 作为偏函数使用\n\n使一个函数拥有预设的初始参数，这就是偏函数。比如函数A已经拥有参数或者变量，此时我们通过调用函数A，产生函数B，我们就说B为偏函数\n\n在这里我们不展开说明偏函数，柯里化一些函数式编程的概念，在 **JS 高级系列** 函数式编程中会有详细介绍\n\n\n```js\n/**\n * 插入到目标函数的参数列表的开始位置\n * 传递给绑定函数的参数会跟在它们后面\n */\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\n// 偏函数\nlet listArr = list.bind(null, 28);\n\nconsole.log(listArr()); // [28]\n\nconsole.log(listArr(1, 2, 3)); // [28, 1, 2, 3]\n\n\n/**\n * 多次 bind 无效 只能执行一次\n * bind 内部 使用call apply 实现\n */\n\nfunction bar () {\n  console.log(this.value);\n}\n\nlet foo = {\n  value: 1\n}\n\nlet foo1 = {\n  value: 2\n}\n\nlet func = bar.bind(foo).bind(foo1);\nconsole.log(func()); // 1\n\n```\n\n### 模拟第一步\n\n通过上面的应用我们实现 bind 有几个条件\n\n- bind 会返回一个新的函数\n- 可以传递任意参数\n- 绑定 bind 的函数可以有返回值\n\n```js\nFunction.prototype.newBind = function (context) {\n  var _this = this;\n  // 获取 bind 的参数，如上面偏函数的例子\n  var _args = Array.prototype.slice.call(arguments, 1);\n  // 返回新函数\n  return function () {\n    // bind 返回函数传入的参数\n    var _bindArgs = Array.prototype.slice.call(arguments);\n    // 合并参数返回\n    return self.apply(context, _args.concat(_bindArgs));\n  }\n}\n\n```\n\n### 模拟第二步\n\n通过第一步其实我们已经模拟了 bind 的大部分功能，但是在 JS 中也可以把函数当成构造函数来用 可以使用 new 关键字， 这个时候 bind 绑定的函数的 this 就会失效，因为在构造函数中 this 永远指向的是它的实例，关于 new 会在下篇文章中作出解释<br/>\n\n- 通过修改返回的函数的原型，来改变 this 指向问题\n- 调用 bind 一定是函数，否则提示错误\n\n```js\nFunction.prototype.newBind  = function (context) {\n\n  // 提示错误信息\n  if (typeof this != 'function') {\n    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n  }\n\n  var _this = this;\n  \n  // 获取参数\n  var _args = Array.prototype.slice.call(arguments, 1);\n\n  // 利用空函数来防止修改绑定函数的原型，关于 prototype 请查看 prototype 章节\n  var _fNOP = function () {};\n\n  // bind 返回的新函数\n  var _fBound = function () {\n    var _bindArgs = Array.prototype.slice.call(arguments);\n    // 如果返回的 _fBound 被当做 new 的构造函数调用\n    return _this.apply(this instanceof _fBound ? this : context, args.concat(_bindArgs));\n  }\n\n  // 让 _fBound 构造的实例继承绑定函数原型中的值，否则会修改绑定函数的原型的值\n  _fNOP.prototype = this.prototype;\n  _fBound.prototype = new _fNOP();\n\n  return _fBound;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/bind","published":1,"updated":"2019-10-15T01:29:42.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqp000lb0u6ephvtx5u","content":"<p>bind 方法其实和 call apply 功能上差不多，只不过 bind() 方法会绑定一个新的函数，通过这个新的函数我们可以当作构造函数、偏函数等等去使用</p>\n<h3 id=\"作为绑定函数使用\"><a href=\"#作为绑定函数使用\" class=\"headerlink\" title=\"作为绑定函数使用\"></a>作为绑定函数使用</h3><p>demo1</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  getValue<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 直接调用 this 指向 obj</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 29</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// obj.getValue 是一个函数体，在全局作用域中调用，所以 this 指向 window</span>\n<span class=\"token keyword\">let</span> valFun <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>getValue<span class=\"token punctuation\">;</span>\n<span class=\"token function\">valFun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 20</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使用 bind 将当前的 this 指针指向 obj 对象上</span>\n<span class=\"token keyword\">let</span> boundGetValue <span class=\"token operator\">=</span> valFun<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">boundGetValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 29</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>demo2</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * obj.getValue() 返回的是一个匿名函数\n * obj.getValue()() 立即执行函数\n * 匿名函数上下文执行环境具有全局性，所以 this 通常指向 window\n */</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  getValue<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 20</span>\n\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 利用bind我们可以使匿名函数的 this 指针指向当前对象（当然还有很多方法比如在匿名函数内增加变量 _this = this）</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  getValue<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 29</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 当然要是改变上述 this 指针不只用 bind 可以如下方法(还有很多方法 比如 apply call)</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  getValue<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> _this<span class=\"token punctuation\">.</span>value\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 29</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"作为偏函数使用\"><a href=\"#作为偏函数使用\" class=\"headerlink\" title=\"作为偏函数使用\"></a>作为偏函数使用</h3><p>使一个函数拥有预设的初始参数，这就是偏函数。比如函数A已经拥有参数或者变量，此时我们通过调用函数A，产生函数B，我们就说B为偏函数</p>\n<p>在这里我们不展开说明偏函数，柯里化一些函数式编程的概念，在 <strong>JS 高级系列</strong> 函数式编程中会有详细介绍</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 插入到目标函数的参数列表的开始位置\n * 传递给绑定函数的参数会跟在它们后面\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 偏函数</span>\n<span class=\"token keyword\">let</span> listArr <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">listArr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [28]</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">listArr</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [28, 1, 2, 3]</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 多次 bind 无效 只能执行一次\n * bind 内部 使用call apply 实现\n */</span>\n\n<span class=\"token keyword\">function</span> bar <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> foo1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> func <span class=\"token operator\">=</span> bar<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>foo1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"模拟第一步\"><a href=\"#模拟第一步\" class=\"headerlink\" title=\"模拟第一步\"></a>模拟第一步</h3><p>通过上面的应用我们实现 bind 有几个条件</p>\n<ul>\n<li>bind 会返回一个新的函数</li>\n<li>可以传递任意参数</li>\n<li>绑定 bind 的函数可以有返回值</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>newBind <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 获取 bind 的参数，如上面偏函数的例子</span>\n  <span class=\"token keyword\">var</span> _args <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 返回新函数</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// bind 返回函数传入的参数</span>\n    <span class=\"token keyword\">var</span> _bindArgs <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 合并参数返回</span>\n    <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> _args<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>_bindArgs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"模拟第二步\"><a href=\"#模拟第二步\" class=\"headerlink\" title=\"模拟第二步\"></a>模拟第二步</h3><p>通过第一步其实我们已经模拟了 bind 的大部分功能，但是在 JS 中也可以把函数当成构造函数来用 可以使用 new 关键字， 这个时候 bind 绑定的函数的 this 就会失效，因为在构造函数中 this 永远指向的是它的实例，关于 new 会在下篇文章中作出解释<br></p>\n<ul>\n<li>通过修改返回的函数的原型，来改变 this 指向问题</li>\n<li>调用 bind 一定是函数，否则提示错误</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>newBind  <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 提示错误信息</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token keyword\">this</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Function.prototype.bind - what is trying to be bound is not callable'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 获取参数</span>\n  <span class=\"token keyword\">var</span> _args <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 利用空函数来防止修改绑定函数的原型，关于 prototype 请查看 prototype 章节</span>\n  <span class=\"token keyword\">var</span> _fNOP <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// bind 返回的新函数</span>\n  <span class=\"token keyword\">var</span> _fBound <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> _bindArgs <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果返回的 _fBound 被当做 new 的构造函数调用</span>\n    <span class=\"token keyword\">return</span> _this<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">_fBound</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">:</span> context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>_bindArgs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 让 _fBound 构造的实例继承绑定函数原型中的值，否则会修改绑定函数的原型的值</span>\n  _fNOP<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n  _fBound<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">_fNOP</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> _fBound<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>bind 方法其实和 call apply 功能上差不多，只不过 bind() 方法会绑定一个新的函数，通过这个新的函数我们可以当作构造函数、偏函数等等去使用</p>\n<h3 id=\"作为绑定函数使用\"><a href=\"#作为绑定函数使用\" class=\"headerlink\" title=\"作为绑定函数使用\"></a>作为绑定函数使用</h3><p>demo1</p>\n<pre><code class=\"js\">this.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return this.value;\n  }\n}\n\n// 直接调用 this 指向 obj\nobj.getValue()  // 29\n\n// obj.getValue 是一个函数体，在全局作用域中调用，所以 this 指向 window\nlet valFun = obj.getValue;\nvalFun(); // 20\n\n// 使用 bind 将当前的 this 指针指向 obj 对象上\nlet boundGetValue = valFun.bind(obj);\nboundGetValue(); // 29</code></pre>\n<p>demo2</p>\n<pre><code class=\"js\">/**\n * obj.getValue() 返回的是一个匿名函数\n * obj.getValue()() 立即执行函数\n * 匿名函数上下文执行环境具有全局性，所以 this 通常指向 window\n */\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return function () {\n      return this.value\n    }.bind(this);\n  }\n}\n\nobj.getValue()() // 20\n\n\n\n// 利用bind我们可以使匿名函数的 this 指针指向当前对象（当然还有很多方法比如在匿名函数内增加变量 _this = this）\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    return function () {\n      return this.value\n    }.bind(this);\n  }\n}\n\nobj.getValue()() // 29\n\n\n// 当然要是改变上述 this 指针不只用 bind 可以如下方法(还有很多方法 比如 apply call)\nthis.value = 20;\n\nlet obj = {\n  value: 29,\n  getValue:function () {\n    let _this = this;\n    return function () {\n      return _this.value\n    }\n  }\n}\n\nobj.getValue()() // 29\n</code></pre>\n<h3 id=\"作为偏函数使用\"><a href=\"#作为偏函数使用\" class=\"headerlink\" title=\"作为偏函数使用\"></a>作为偏函数使用</h3><p>使一个函数拥有预设的初始参数，这就是偏函数。比如函数A已经拥有参数或者变量，此时我们通过调用函数A，产生函数B，我们就说B为偏函数</p>\n<p>在这里我们不展开说明偏函数，柯里化一些函数式编程的概念，在 <strong>JS 高级系列</strong> 函数式编程中会有详细介绍</p>\n<pre><code class=\"js\">/**\n * 插入到目标函数的参数列表的开始位置\n * 传递给绑定函数的参数会跟在它们后面\n */\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\n// 偏函数\nlet listArr = list.bind(null, 28);\n\nconsole.log(listArr()); // [28]\n\nconsole.log(listArr(1, 2, 3)); // [28, 1, 2, 3]\n\n\n/**\n * 多次 bind 无效 只能执行一次\n * bind 内部 使用call apply 实现\n */\n\nfunction bar () {\n  console.log(this.value);\n}\n\nlet foo = {\n  value: 1\n}\n\nlet foo1 = {\n  value: 2\n}\n\nlet func = bar.bind(foo).bind(foo1);\nconsole.log(func()); // 1\n</code></pre>\n<h3 id=\"模拟第一步\"><a href=\"#模拟第一步\" class=\"headerlink\" title=\"模拟第一步\"></a>模拟第一步</h3><p>通过上面的应用我们实现 bind 有几个条件</p>\n<ul>\n<li>bind 会返回一个新的函数</li>\n<li>可以传递任意参数</li>\n<li>绑定 bind 的函数可以有返回值</li>\n</ul>\n<pre><code class=\"js\">Function.prototype.newBind = function (context) {\n  var _this = this;\n  // 获取 bind 的参数，如上面偏函数的例子\n  var _args = Array.prototype.slice.call(arguments, 1);\n  // 返回新函数\n  return function () {\n    // bind 返回函数传入的参数\n    var _bindArgs = Array.prototype.slice.call(arguments);\n    // 合并参数返回\n    return self.apply(context, _args.concat(_bindArgs));\n  }\n}\n</code></pre>\n<h3 id=\"模拟第二步\"><a href=\"#模拟第二步\" class=\"headerlink\" title=\"模拟第二步\"></a>模拟第二步</h3><p>通过第一步其实我们已经模拟了 bind 的大部分功能，但是在 JS 中也可以把函数当成构造函数来用 可以使用 new 关键字， 这个时候 bind 绑定的函数的 this 就会失效，因为在构造函数中 this 永远指向的是它的实例，关于 new 会在下篇文章中作出解释<br></p>\n<ul>\n<li>通过修改返回的函数的原型，来改变 this 指向问题</li>\n<li>调用 bind 一定是函数，否则提示错误</li>\n</ul>\n<pre><code class=\"js\">Function.prototype.newBind  = function (context) {\n\n  // 提示错误信息\n  if (typeof this != &#39;function&#39;) {\n    throw new TypeError(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;);\n  }\n\n  var _this = this;\n\n  // 获取参数\n  var _args = Array.prototype.slice.call(arguments, 1);\n\n  // 利用空函数来防止修改绑定函数的原型，关于 prototype 请查看 prototype 章节\n  var _fNOP = function () {};\n\n  // bind 返回的新函数\n  var _fBound = function () {\n    var _bindArgs = Array.prototype.slice.call(arguments);\n    // 如果返回的 _fBound 被当做 new 的构造函数调用\n    return _this.apply(this instanceof _fBound ? this : context, args.concat(_bindArgs));\n  }\n\n  // 让 _fBound 构造的实例继承绑定函数原型中的值，否则会修改绑定函数的原型的值\n  _fNOP.prototype = this.prototype;\n  _fBound.prototype = new _fNOP();\n\n  return _fBound;\n}\n</code></pre>\n"},{"title":"call 和 apply","date":"2019-04-22T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n谈起 call 和 apply 这两个 Function.prototype 上的方法可能很熟悉了，它在继承，改变this指针上有很多的应用场景。接下来我们简单的来重新回忆一下 call 和 apply 这两个函数的功能 <br/>\n\n### 例子一\n\n```js\nlet obj = {\n  value : 20\n}\n\nfunction fun () {\n  console.log(this.value)\n}\n\nfun.call(obj) //20\n\n```\n\n### 例子二\n\n```js\ndocument.getElementById( 'element' ).onclick = function(){\n  let func = function(){ \n      console.log ( this ); // 指向element元素\n  } \n  func.call(this);\n}; \n```\n\n\n### 例子三\n\n```js\nfunction FunA (val) {\n  this.value = val;\n}\n\nfunction FunB () {\n  FunA.apply(this, arguments);\n}\n\nFunB.prototype.getValue = function () {\n  return this.value\n}\n\nlet funb = new FunB(20);\nconsole.log(funb.getValue()) //20\n```\n经过上面的例子我们可以直观的知道call apply 的作用大部分都是用作改变this的指针。那么接下来我们来模拟 call apply 实现简单的一下这两个函数<br/>\n\n### 模拟实现第一步\n\n实现思路<br/>\n1、将函数设为对象的属性用来改变 this 指向<br/>\n2、调用对应函数<br/>\n3、删除对象的函数<br/>\n\n接下来我们改造一下例子一的函数<br/>\n```js\nlet obj = {\n  value: 20,\n  fun: function () {\n    this.value\n  }\n}\n\nobj.fun() // 20\ndelete obj.fun\n\nconsole.log(obj) // {value: 20}\n```\n\n接下来简单的把上面的函数封装一下<br/>\n```js\nFunction.prototype.newCall = function (context) {\n  context.fn = this;\n  context.fn();\n  delete context.fn;\n}\n\n// 通过例子一测试\nlet obj = {\n  value : 20\n}\n\nfunction fun () {\n  console.log(this.value)\n}\n\nfun.newCall(obj) // 20\n```\n\n### 模拟实现第二步\n第一步的我们只实现了基础。没有考虑参数的情况。call，apply 的基本区别就是在参数上 call 参数数量不确定，apply 只接受两个参数。接下来我们继续优化上面的例子\n\n1、将函数设为对象的属性用来改变 this 指向<br/>\n2、调用对应函数<br/>\n3、删除对象的函数<br/>\n4、取出不定长的参数放到执行的函数里面<br/>\n\n```js\nFunction.prototype.newCall = function (context, ...args) {\n\n  // 如果传入参数 this 为 null，则默认为当前宿主环境\n  let ec = typeof window === 'object' ? window : global;\n\n  // 防止方法冲突覆盖\n  let fn = Symbol();\n  context = context || ec;\n\n  // 改变 this\n  context[fn] = this;\n\n  // 将参数放入函数内\n  let result = context[fn](...args);\n\n  // 删除对象中的函数\n  delete context[fn];\n\n  return result;\n}\n\n// 测试一下\nlet obj = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(name);\n  console.log(age);\n  console.log(this.value);\n}\n\nbar.newCall(obj, 'renbo', 27); \n```\n\n通过以上 call 的实现我们对apply的实现应该说也清楚了， 上述说过call 和 apply 的区别就在与参数上面，通过ES6实现的方法实际上 call, apply 一样<br/>\n\n### 模拟实现 apply\n```js\nFunction.prototype.newApply = function (context, args) {\n  // 如果传入参数 this 为 null，则默认为当前宿主环境\n  let ec = typeof window === 'object' ? window : global;\n\n  // 防止方法冲突覆盖\n  let fn = Symbol();\n  context = context || ec;\n\n  // 改变 this\n  context[fn] = this;\n\n  // 将参数放入函数内\n  let result = context[fn](...args);\n\n  // 删除对象中的函数\n  delete context[fn];\n\n  return result;\n}\n\n// 测试一下\nlet obj = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(name);\n  console.log(age);\n  console.log(this.value);\n}\n\nbar.newApply(obj, ['renbo', 27]); \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/call.md","raw":"---\ntitle: call 和 apply\ndate: 2019-4-22 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n谈起 call 和 apply 这两个 Function.prototype 上的方法可能很熟悉了，它在继承，改变this指针上有很多的应用场景。接下来我们简单的来重新回忆一下 call 和 apply 这两个函数的功能 <br/>\n\n### 例子一\n\n```js\nlet obj = {\n  value : 20\n}\n\nfunction fun () {\n  console.log(this.value)\n}\n\nfun.call(obj) //20\n\n```\n\n### 例子二\n\n```js\ndocument.getElementById( 'element' ).onclick = function(){\n  let func = function(){ \n      console.log ( this ); // 指向element元素\n  } \n  func.call(this);\n}; \n```\n\n\n### 例子三\n\n```js\nfunction FunA (val) {\n  this.value = val;\n}\n\nfunction FunB () {\n  FunA.apply(this, arguments);\n}\n\nFunB.prototype.getValue = function () {\n  return this.value\n}\n\nlet funb = new FunB(20);\nconsole.log(funb.getValue()) //20\n```\n经过上面的例子我们可以直观的知道call apply 的作用大部分都是用作改变this的指针。那么接下来我们来模拟 call apply 实现简单的一下这两个函数<br/>\n\n### 模拟实现第一步\n\n实现思路<br/>\n1、将函数设为对象的属性用来改变 this 指向<br/>\n2、调用对应函数<br/>\n3、删除对象的函数<br/>\n\n接下来我们改造一下例子一的函数<br/>\n```js\nlet obj = {\n  value: 20,\n  fun: function () {\n    this.value\n  }\n}\n\nobj.fun() // 20\ndelete obj.fun\n\nconsole.log(obj) // {value: 20}\n```\n\n接下来简单的把上面的函数封装一下<br/>\n```js\nFunction.prototype.newCall = function (context) {\n  context.fn = this;\n  context.fn();\n  delete context.fn;\n}\n\n// 通过例子一测试\nlet obj = {\n  value : 20\n}\n\nfunction fun () {\n  console.log(this.value)\n}\n\nfun.newCall(obj) // 20\n```\n\n### 模拟实现第二步\n第一步的我们只实现了基础。没有考虑参数的情况。call，apply 的基本区别就是在参数上 call 参数数量不确定，apply 只接受两个参数。接下来我们继续优化上面的例子\n\n1、将函数设为对象的属性用来改变 this 指向<br/>\n2、调用对应函数<br/>\n3、删除对象的函数<br/>\n4、取出不定长的参数放到执行的函数里面<br/>\n\n```js\nFunction.prototype.newCall = function (context, ...args) {\n\n  // 如果传入参数 this 为 null，则默认为当前宿主环境\n  let ec = typeof window === 'object' ? window : global;\n\n  // 防止方法冲突覆盖\n  let fn = Symbol();\n  context = context || ec;\n\n  // 改变 this\n  context[fn] = this;\n\n  // 将参数放入函数内\n  let result = context[fn](...args);\n\n  // 删除对象中的函数\n  delete context[fn];\n\n  return result;\n}\n\n// 测试一下\nlet obj = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(name);\n  console.log(age);\n  console.log(this.value);\n}\n\nbar.newCall(obj, 'renbo', 27); \n```\n\n通过以上 call 的实现我们对apply的实现应该说也清楚了， 上述说过call 和 apply 的区别就在与参数上面，通过ES6实现的方法实际上 call, apply 一样<br/>\n\n### 模拟实现 apply\n```js\nFunction.prototype.newApply = function (context, args) {\n  // 如果传入参数 this 为 null，则默认为当前宿主环境\n  let ec = typeof window === 'object' ? window : global;\n\n  // 防止方法冲突覆盖\n  let fn = Symbol();\n  context = context || ec;\n\n  // 改变 this\n  context[fn] = this;\n\n  // 将参数放入函数内\n  let result = context[fn](...args);\n\n  // 删除对象中的函数\n  delete context[fn];\n\n  return result;\n}\n\n// 测试一下\nlet obj = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(name);\n  console.log(age);\n  console.log(this.value);\n}\n\nbar.newApply(obj, ['renbo', 27]); \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/call","published":1,"updated":"2019-10-15T01:29:42.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqu000qb0u6369hutby","content":"<p>谈起 call 和 apply 这两个 Function.prototype 上的方法可能很熟悉了，它在继承，改变this指针上有很多的应用场景。接下来我们简单的来重新回忆一下 call 和 apply 这两个函数的功能 <br></p>\n<h3 id=\"例子一\"><a href=\"#例子一\" class=\"headerlink\" title=\"例子一\"></a>例子一</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value <span class=\"token punctuation\">:</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> fun <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//20</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"例子二\"><a href=\"#例子二\" class=\"headerlink\" title=\"例子二\"></a>例子二</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span> <span class=\"token string\">'element'</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> func <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n      console<span class=\"token punctuation\">.</span>log <span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 指向element元素</span>\n  <span class=\"token punctuation\">}</span> \n  func<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"例子三\"><a href=\"#例子三\" class=\"headerlink\" title=\"例子三\"></a>例子三</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> FunA <span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> FunB <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  FunA<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nFunB<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>getValue <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> funb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FunB</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>funb<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//20</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>经过上面的例子我们可以直观的知道call apply 的作用大部分都是用作改变this的指针。那么接下来我们来模拟 call apply 实现简单的一下这两个函数<br></p>\n<h3 id=\"模拟实现第一步\"><a href=\"#模拟实现第一步\" class=\"headerlink\" title=\"模拟实现第一步\"></a>模拟实现第一步</h3><p>实现思路<br><br>1、将函数设为对象的属性用来改变 this 指向<br><br>2、调用对应函数<br><br>3、删除对象的函数<br></p>\n<p>接下来我们改造一下例子一的函数<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n  fun<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 20</span>\n<span class=\"token keyword\">delete</span> obj<span class=\"token punctuation\">.</span>fun\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// {value: 20}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来简单的把上面的函数封装一下<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>newCall <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  context<span class=\"token punctuation\">.</span>fn <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">delete</span> context<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 通过例子一测试</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value <span class=\"token punctuation\">:</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> fun <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 20</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"模拟实现第二步\"><a href=\"#模拟实现第二步\" class=\"headerlink\" title=\"模拟实现第二步\"></a>模拟实现第二步</h3><p>第一步的我们只实现了基础。没有考虑参数的情况。call，apply 的基本区别就是在参数上 call 参数数量不确定，apply 只接受两个参数。接下来我们继续优化上面的例子</p>\n<p>1、将函数设为对象的属性用来改变 this 指向<br><br>2、调用对应函数<br><br>3、删除对象的函数<br><br>4、取出不定长的参数放到执行的函数里面<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>newCall <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 如果传入参数 this 为 null，则默认为当前宿主环境</span>\n  <span class=\"token keyword\">let</span> ec <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> window <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">?</span> window <span class=\"token punctuation\">:</span> global<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 防止方法冲突覆盖</span>\n  <span class=\"token keyword\">let</span> fn <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  context <span class=\"token operator\">=</span> context <span class=\"token operator\">||</span> ec<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 改变 this</span>\n  context<span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 将参数放入函数内</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> context<span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 删除对象中的函数</span>\n  <span class=\"token keyword\">delete</span> context<span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 测试一下</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token string\">'renbo'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过以上 call 的实现我们对apply的实现应该说也清楚了， 上述说过call 和 apply 的区别就在与参数上面，通过ES6实现的方法实际上 call, apply 一样<br></p>\n<h3 id=\"模拟实现-apply\"><a href=\"#模拟实现-apply\" class=\"headerlink\" title=\"模拟实现 apply\"></a>模拟实现 apply</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>newApply <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果传入参数 this 为 null，则默认为当前宿主环境</span>\n  <span class=\"token keyword\">let</span> ec <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> window <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">?</span> window <span class=\"token punctuation\">:</span> global<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 防止方法冲突覆盖</span>\n  <span class=\"token keyword\">let</span> fn <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  context <span class=\"token operator\">=</span> context <span class=\"token operator\">||</span> ec<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 改变 this</span>\n  context<span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 将参数放入函数内</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> context<span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 删除对象中的函数</span>\n  <span class=\"token keyword\">delete</span> context<span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 测试一下</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">newApply</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'renbo'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>谈起 call 和 apply 这两个 Function.prototype 上的方法可能很熟悉了，它在继承，改变this指针上有很多的应用场景。接下来我们简单的来重新回忆一下 call 和 apply 这两个函数的功能 <br></p>\n<h3 id=\"例子一\"><a href=\"#例子一\" class=\"headerlink\" title=\"例子一\"></a>例子一</h3><pre><code class=\"js\">let obj = {\n  value : 20\n}\n\nfunction fun () {\n  console.log(this.value)\n}\n\nfun.call(obj) //20\n</code></pre>\n<h3 id=\"例子二\"><a href=\"#例子二\" class=\"headerlink\" title=\"例子二\"></a>例子二</h3><pre><code class=\"js\">document.getElementById( &#39;element&#39; ).onclick = function(){\n  let func = function(){ \n      console.log ( this ); // 指向element元素\n  } \n  func.call(this);\n}; </code></pre>\n<h3 id=\"例子三\"><a href=\"#例子三\" class=\"headerlink\" title=\"例子三\"></a>例子三</h3><pre><code class=\"js\">function FunA (val) {\n  this.value = val;\n}\n\nfunction FunB () {\n  FunA.apply(this, arguments);\n}\n\nFunB.prototype.getValue = function () {\n  return this.value\n}\n\nlet funb = new FunB(20);\nconsole.log(funb.getValue()) //20</code></pre>\n<p>经过上面的例子我们可以直观的知道call apply 的作用大部分都是用作改变this的指针。那么接下来我们来模拟 call apply 实现简单的一下这两个函数<br></p>\n<h3 id=\"模拟实现第一步\"><a href=\"#模拟实现第一步\" class=\"headerlink\" title=\"模拟实现第一步\"></a>模拟实现第一步</h3><p>实现思路<br><br>1、将函数设为对象的属性用来改变 this 指向<br><br>2、调用对应函数<br><br>3、删除对象的函数<br></p>\n<p>接下来我们改造一下例子一的函数<br></p>\n<pre><code class=\"js\">let obj = {\n  value: 20,\n  fun: function () {\n    this.value\n  }\n}\n\nobj.fun() // 20\ndelete obj.fun\n\nconsole.log(obj) // {value: 20}</code></pre>\n<p>接下来简单的把上面的函数封装一下<br></p>\n<pre><code class=\"js\">Function.prototype.newCall = function (context) {\n  context.fn = this;\n  context.fn();\n  delete context.fn;\n}\n\n// 通过例子一测试\nlet obj = {\n  value : 20\n}\n\nfunction fun () {\n  console.log(this.value)\n}\n\nfun.newCall(obj) // 20</code></pre>\n<h3 id=\"模拟实现第二步\"><a href=\"#模拟实现第二步\" class=\"headerlink\" title=\"模拟实现第二步\"></a>模拟实现第二步</h3><p>第一步的我们只实现了基础。没有考虑参数的情况。call，apply 的基本区别就是在参数上 call 参数数量不确定，apply 只接受两个参数。接下来我们继续优化上面的例子</p>\n<p>1、将函数设为对象的属性用来改变 this 指向<br><br>2、调用对应函数<br><br>3、删除对象的函数<br><br>4、取出不定长的参数放到执行的函数里面<br></p>\n<pre><code class=\"js\">Function.prototype.newCall = function (context, ...args) {\n\n  // 如果传入参数 this 为 null，则默认为当前宿主环境\n  let ec = typeof window === &#39;object&#39; ? window : global;\n\n  // 防止方法冲突覆盖\n  let fn = Symbol();\n  context = context || ec;\n\n  // 改变 this\n  context[fn] = this;\n\n  // 将参数放入函数内\n  let result = context[fn](...args);\n\n  // 删除对象中的函数\n  delete context[fn];\n\n  return result;\n}\n\n// 测试一下\nlet obj = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(name);\n  console.log(age);\n  console.log(this.value);\n}\n\nbar.newCall(obj, &#39;renbo&#39;, 27); </code></pre>\n<p>通过以上 call 的实现我们对apply的实现应该说也清楚了， 上述说过call 和 apply 的区别就在与参数上面，通过ES6实现的方法实际上 call, apply 一样<br></p>\n<h3 id=\"模拟实现-apply\"><a href=\"#模拟实现-apply\" class=\"headerlink\" title=\"模拟实现 apply\"></a>模拟实现 apply</h3><pre><code class=\"js\">Function.prototype.newApply = function (context, args) {\n  // 如果传入参数 this 为 null，则默认为当前宿主环境\n  let ec = typeof window === &#39;object&#39; ? window : global;\n\n  // 防止方法冲突覆盖\n  let fn = Symbol();\n  context = context || ec;\n\n  // 改变 this\n  context[fn] = this;\n\n  // 将参数放入函数内\n  let result = context[fn](...args);\n\n  // 删除对象中的函数\n  delete context[fn];\n\n  return result;\n}\n\n// 测试一下\nlet obj = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(name);\n  console.log(age);\n  console.log(this.value);\n}\n\nbar.newApply(obj, [&#39;renbo&#39;, 27]); </code></pre>\n"},{"title":"闭包","date":"2019-02-25T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n说起闭包那么首先先来了解一下js执行环境（execution context）、作用域以及作用域链（scope chain）\n\n### 上下文执行环境\n 执行环境定义了变量或者函数有权访问的其他数据，决定了各自的行为\n\n### 组成部分\n1. 变量对象（varible object）：存放当前执行环境中定义的变量和函数，**如果当前环境是函数则将活动对象（activation object）作为变量对象，但不包括函数表达式**\n2. 作用域链：当代码在执行环境中运行时，会创建**变量对象**的一个**作用域链（词法作用域）**，能够保证对执行环境中所有变量和函数有序访问\n3. this指向：根据调用的规则不同this指向不同产生的执行环境上下文不同\n\n### 类型\n\n1. 全局执行环境\n2. 局部执行环境\n\n### 执行过程  \n\n1. 在全局代码执行前, js引擎就会创建一个栈来存储管理所有的执行上下文对象\n2. 在全局执行环境(window)确定后, 将其push到栈中\n3. 在函数执行环境创建后, 将其push到栈中\n4. 在当前函数执行完后,将栈顶的对象pop\n5. 当所有的代码执行完后, 栈中只剩下window\n\n```js\n  // demo1:  先执行变量提升, 再执行函数提升\n  function a() {}\n  var a\n  console.log(typeof a) // 'function'\n\n  //demo2:\n  if (!(b in window)) {\n    var b = 1\n  }\n  console.log(b) // undefined\n\n  // demo3:\n  console.log(a);    // f a() {console.log(10)}\n  console.log(a());    //  undefined\n  var a = 1;\n  function a() {\n    console.log('nihao') //nihao\n  }\n  console.log(a)   //1\n  a = 3;\n  console.log(a());  //a is not a function;\n\n  // demo4:\n  function fun(){ var a=b=3;}\n  console.log(b)//B是全局变量 var a是局部变量  b=3;a=undefine\n```\n\n### 作用域\n- 概念： 执行上下文中声明的变量和声明的作用范围。\n- 分类：\n  - 全局作用域\n  - 函数作用域\n  - es6块级作用域\n- 作用： 隔离变量，不同作用域下同名变量不会有冲突\n- 区别：\n  - 创建时机不同，全局执行上下文是在全局作用域确定后js代码执行前创建而函数执行上下文是在调用函数时, 函数体代码执行之前创建\n  - 作用域是静态的，执行上下文是动态的\n\n### 作用域链\n- 从内到外多个作用域形成的链\n- 包含父级(**[[scope]]**)变量对象与作用域链和自身的变量对象(**如果是函数则为活动对象AO**)\n\n```js\nvar x = 10;\nfunction fn () {\n  console.log(x);\n}\nfunction show (fn) {\n  var x = 20;\n  fn();\n}\nshow(fn) // 10;\n```\n\n### 闭包概念 \n\n能够访问其他函数内变量的函数，是一个比较特殊的作用域函数\n\n### 闭包作用\n\n匿名自执行函数,减少内存消耗\n\n```js\n(function ($) {})(jQuery);\n```\n\n缓存计算结果\n\n```js\n  var fun1 = function(){\n    var a=1;\n    return function fun2(){\n      a++;\n      alert(a)\n    }\n  }\n  var b = fun1();\n  b(); // 2       \n  b(); // 3           \n```\n\n封装,管理私有方法和变量，避免全局变量冲突污染\n\n```js\n  var person = function(){    \n    var name = \"renbo\";       \n    return {    \n      getName : function(){    \n        return name;    \n      },    \n      setName : function(newName){    \n        name = newName;    \n      }    \n    }    \n  }() \n```\n实现类和继承等等\n\n### 闭包缺点\n\n1. 由于变量对象一直在内存中引用不被释放，导致内存过高。\n2. 由于多个函数共享一个父级，当父级有变量更改时，所有子函数受影响\n","source":"_posts/javascript/closure.md","raw":"---\ntitle: 闭包\ndate: 2019-2-25 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n说起闭包那么首先先来了解一下js执行环境（execution context）、作用域以及作用域链（scope chain）\n\n### 上下文执行环境\n 执行环境定义了变量或者函数有权访问的其他数据，决定了各自的行为\n\n### 组成部分\n1. 变量对象（varible object）：存放当前执行环境中定义的变量和函数，**如果当前环境是函数则将活动对象（activation object）作为变量对象，但不包括函数表达式**\n2. 作用域链：当代码在执行环境中运行时，会创建**变量对象**的一个**作用域链（词法作用域）**，能够保证对执行环境中所有变量和函数有序访问\n3. this指向：根据调用的规则不同this指向不同产生的执行环境上下文不同\n\n### 类型\n\n1. 全局执行环境\n2. 局部执行环境\n\n### 执行过程  \n\n1. 在全局代码执行前, js引擎就会创建一个栈来存储管理所有的执行上下文对象\n2. 在全局执行环境(window)确定后, 将其push到栈中\n3. 在函数执行环境创建后, 将其push到栈中\n4. 在当前函数执行完后,将栈顶的对象pop\n5. 当所有的代码执行完后, 栈中只剩下window\n\n```js\n  // demo1:  先执行变量提升, 再执行函数提升\n  function a() {}\n  var a\n  console.log(typeof a) // 'function'\n\n  //demo2:\n  if (!(b in window)) {\n    var b = 1\n  }\n  console.log(b) // undefined\n\n  // demo3:\n  console.log(a);    // f a() {console.log(10)}\n  console.log(a());    //  undefined\n  var a = 1;\n  function a() {\n    console.log('nihao') //nihao\n  }\n  console.log(a)   //1\n  a = 3;\n  console.log(a());  //a is not a function;\n\n  // demo4:\n  function fun(){ var a=b=3;}\n  console.log(b)//B是全局变量 var a是局部变量  b=3;a=undefine\n```\n\n### 作用域\n- 概念： 执行上下文中声明的变量和声明的作用范围。\n- 分类：\n  - 全局作用域\n  - 函数作用域\n  - es6块级作用域\n- 作用： 隔离变量，不同作用域下同名变量不会有冲突\n- 区别：\n  - 创建时机不同，全局执行上下文是在全局作用域确定后js代码执行前创建而函数执行上下文是在调用函数时, 函数体代码执行之前创建\n  - 作用域是静态的，执行上下文是动态的\n\n### 作用域链\n- 从内到外多个作用域形成的链\n- 包含父级(**[[scope]]**)变量对象与作用域链和自身的变量对象(**如果是函数则为活动对象AO**)\n\n```js\nvar x = 10;\nfunction fn () {\n  console.log(x);\n}\nfunction show (fn) {\n  var x = 20;\n  fn();\n}\nshow(fn) // 10;\n```\n\n### 闭包概念 \n\n能够访问其他函数内变量的函数，是一个比较特殊的作用域函数\n\n### 闭包作用\n\n匿名自执行函数,减少内存消耗\n\n```js\n(function ($) {})(jQuery);\n```\n\n缓存计算结果\n\n```js\n  var fun1 = function(){\n    var a=1;\n    return function fun2(){\n      a++;\n      alert(a)\n    }\n  }\n  var b = fun1();\n  b(); // 2       \n  b(); // 3           \n```\n\n封装,管理私有方法和变量，避免全局变量冲突污染\n\n```js\n  var person = function(){    \n    var name = \"renbo\";       \n    return {    \n      getName : function(){    \n        return name;    \n      },    \n      setName : function(newName){    \n        name = newName;    \n      }    \n    }    \n  }() \n```\n实现类和继承等等\n\n### 闭包缺点\n\n1. 由于变量对象一直在内存中引用不被释放，导致内存过高。\n2. 由于多个函数共享一个父级，当父级有变量更改时，所有子函数受影响\n","slug":"javascript/closure","published":1,"updated":"2019-10-15T01:29:42.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oqw000sb0u6zxxdqvxo","content":"<p>说起闭包那么首先先来了解一下js执行环境（execution context）、作用域以及作用域链（scope chain）</p>\n<h3 id=\"上下文执行环境\"><a href=\"#上下文执行环境\" class=\"headerlink\" title=\"上下文执行环境\"></a>上下文执行环境</h3><p> 执行环境定义了变量或者函数有权访问的其他数据，决定了各自的行为</p>\n<h3 id=\"组成部分\"><a href=\"#组成部分\" class=\"headerlink\" title=\"组成部分\"></a>组成部分</h3><ol>\n<li>变量对象（varible object）：存放当前执行环境中定义的变量和函数，<strong>如果当前环境是函数则将活动对象（activation object）作为变量对象，但不包括函数表达式</strong></li>\n<li>作用域链：当代码在执行环境中运行时，会创建<strong>变量对象</strong>的一个<strong>作用域链（词法作用域）</strong>，能够保证对执行环境中所有变量和函数有序访问</li>\n<li>this指向：根据调用的规则不同this指向不同产生的执行环境上下文不同</li>\n</ol>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><ol>\n<li>全局执行环境</li>\n<li>局部执行环境</li>\n</ol>\n<h3 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><ol>\n<li>在全局代码执行前, js引擎就会创建一个栈来存储管理所有的执行上下文对象</li>\n<li>在全局执行环境(window)确定后, 将其push到栈中</li>\n<li>在函数执行环境创建后, 将其push到栈中</li>\n<li>在当前函数执行完后,将栈顶的对象pop</li>\n<li>当所有的代码执行完后, 栈中只剩下window</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token comment\" spellcheck=\"true\">// demo1:  先执行变量提升, 再执行函数提升</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">var</span> a\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> a<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 'function'</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//demo2:</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>b <span class=\"token keyword\">in</span> window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// undefined</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// demo3:</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// f a() {console.log(10)}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//  undefined</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nihao'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//nihao</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">//1</span>\n  a <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//a is not a function;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// demo4:</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">var</span> a<span class=\"token operator\">=</span>b<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//B是全局变量 var a是局部变量  b=3;a=undefine</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>概念： 执行上下文中声明的变量和声明的作用范围。</li>\n<li>分类：<ul>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li>es6块级作用域</li>\n</ul>\n</li>\n<li>作用： 隔离变量，不同作用域下同名变量不会有冲突</li>\n<li>区别：<ul>\n<li>创建时机不同，全局执行上下文是在全局作用域确定后js代码执行前创建而函数执行上下文是在调用函数时, 函数体代码执行之前创建</li>\n<li>作用域是静态的，执行上下文是动态的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><ul>\n<li>从内到外多个作用域形成的链</li>\n<li>包含父级(<strong>[[scope]]</strong>)变量对象与作用域链和自身的变量对象(<strong>如果是函数则为活动对象AO</strong>)</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> fn <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> show <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">show</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 10;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"闭包概念\"><a href=\"#闭包概念\" class=\"headerlink\" title=\"闭包概念\"></a>闭包概念</h3><p>能够访问其他函数内变量的函数，是一个比较特殊的作用域函数</p>\n<h3 id=\"闭包作用\"><a href=\"#闭包作用\" class=\"headerlink\" title=\"闭包作用\"></a>闭包作用</h3><p>匿名自执行函数,减少内存消耗</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>$<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>jQuery<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>缓存计算结果</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">var</span> fun1 <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fun2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      a<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token function\">fun1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 2       </span>\n  <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 3           </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>封装,管理私有方法和变量，避免全局变量冲突污染</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    \n    <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"renbo\"</span><span class=\"token punctuation\">;</span>       \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>    \n      getName <span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    \n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>    \n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>    \n      setName <span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>newName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    \n        name <span class=\"token operator\">=</span> newName<span class=\"token punctuation\">;</span>    \n      <span class=\"token punctuation\">}</span>    \n    <span class=\"token punctuation\">}</span>    \n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>实现类和继承等等</p>\n<h3 id=\"闭包缺点\"><a href=\"#闭包缺点\" class=\"headerlink\" title=\"闭包缺点\"></a>闭包缺点</h3><ol>\n<li>由于变量对象一直在内存中引用不被释放，导致内存过高。</li>\n<li>由于多个函数共享一个父级，当父级有变量更改时，所有子函数受影响</li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>说起闭包那么首先先来了解一下js执行环境（execution context）、作用域以及作用域链（scope chain）</p>\n<h3 id=\"上下文执行环境\"><a href=\"#上下文执行环境\" class=\"headerlink\" title=\"上下文执行环境\"></a>上下文执行环境</h3><p> 执行环境定义了变量或者函数有权访问的其他数据，决定了各自的行为</p>\n<h3 id=\"组成部分\"><a href=\"#组成部分\" class=\"headerlink\" title=\"组成部分\"></a>组成部分</h3><ol>\n<li>变量对象（varible object）：存放当前执行环境中定义的变量和函数，<strong>如果当前环境是函数则将活动对象（activation object）作为变量对象，但不包括函数表达式</strong></li>\n<li>作用域链：当代码在执行环境中运行时，会创建<strong>变量对象</strong>的一个<strong>作用域链（词法作用域）</strong>，能够保证对执行环境中所有变量和函数有序访问</li>\n<li>this指向：根据调用的规则不同this指向不同产生的执行环境上下文不同</li>\n</ol>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><ol>\n<li>全局执行环境</li>\n<li>局部执行环境</li>\n</ol>\n<h3 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><ol>\n<li>在全局代码执行前, js引擎就会创建一个栈来存储管理所有的执行上下文对象</li>\n<li>在全局执行环境(window)确定后, 将其push到栈中</li>\n<li>在函数执行环境创建后, 将其push到栈中</li>\n<li>在当前函数执行完后,将栈顶的对象pop</li>\n<li>当所有的代码执行完后, 栈中只剩下window</li>\n</ol>\n<pre><code class=\"js\">  // demo1:  先执行变量提升, 再执行函数提升\n  function a() {}\n  var a\n  console.log(typeof a) // &#39;function&#39;\n\n  //demo2:\n  if (!(b in window)) {\n    var b = 1\n  }\n  console.log(b) // undefined\n\n  // demo3:\n  console.log(a);    // f a() {console.log(10)}\n  console.log(a());    //  undefined\n  var a = 1;\n  function a() {\n    console.log(&#39;nihao&#39;) //nihao\n  }\n  console.log(a)   //1\n  a = 3;\n  console.log(a());  //a is not a function;\n\n  // demo4:\n  function fun(){ var a=b=3;}\n  console.log(b)//B是全局变量 var a是局部变量  b=3;a=undefine</code></pre>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>概念： 执行上下文中声明的变量和声明的作用范围。</li>\n<li>分类：<ul>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li>es6块级作用域</li>\n</ul>\n</li>\n<li>作用： 隔离变量，不同作用域下同名变量不会有冲突</li>\n<li>区别：<ul>\n<li>创建时机不同，全局执行上下文是在全局作用域确定后js代码执行前创建而函数执行上下文是在调用函数时, 函数体代码执行之前创建</li>\n<li>作用域是静态的，执行上下文是动态的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><ul>\n<li>从内到外多个作用域形成的链</li>\n<li>包含父级(<strong>[[scope]]</strong>)变量对象与作用域链和自身的变量对象(<strong>如果是函数则为活动对象AO</strong>)</li>\n</ul>\n<pre><code class=\"js\">var x = 10;\nfunction fn () {\n  console.log(x);\n}\nfunction show (fn) {\n  var x = 20;\n  fn();\n}\nshow(fn) // 10;</code></pre>\n<h3 id=\"闭包概念\"><a href=\"#闭包概念\" class=\"headerlink\" title=\"闭包概念\"></a>闭包概念</h3><p>能够访问其他函数内变量的函数，是一个比较特殊的作用域函数</p>\n<h3 id=\"闭包作用\"><a href=\"#闭包作用\" class=\"headerlink\" title=\"闭包作用\"></a>闭包作用</h3><p>匿名自执行函数,减少内存消耗</p>\n<pre><code class=\"js\">(function ($) {})(jQuery);</code></pre>\n<p>缓存计算结果</p>\n<pre><code class=\"js\">  var fun1 = function(){\n    var a=1;\n    return function fun2(){\n      a++;\n      alert(a)\n    }\n  }\n  var b = fun1();\n  b(); // 2       \n  b(); // 3           </code></pre>\n<p>封装,管理私有方法和变量，避免全局变量冲突污染</p>\n<pre><code class=\"js\">  var person = function(){    \n    var name = &quot;renbo&quot;;       \n    return {    \n      getName : function(){    \n        return name;    \n      },    \n      setName : function(newName){    \n        name = newName;    \n      }    \n    }    \n  }() </code></pre>\n<p>实现类和继承等等</p>\n<h3 id=\"闭包缺点\"><a href=\"#闭包缺点\" class=\"headerlink\" title=\"闭包缺点\"></a>闭包缺点</h3><ol>\n<li>由于变量对象一直在内存中引用不被释放，导致内存过高。</li>\n<li>由于多个函数共享一个父级，当父级有变量更改时，所有子函数受影响</li>\n</ol>\n"},{"title":"偏应用函数、函数的柯里化","date":"2019-07-17T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n偏应用函数简称偏函数，在模拟 bind 的时候已经说明其概念和作为主要 bind 的实现<br/>\n\n函数柯里化主要是通过偏应用函数的实现，把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数<br/>\n\n```js\n// 柯里化之前\nfunction add (a, b) {\n  return a + b;\n}\n\n// 柯里化之后\nfunction add (a) {\n  return function (b) {\n    return a+b\n  }\n}\n\n// 等同于\nconst add = a => b => a + b;\nconst result = add(2)(3); // => 5\n```\n1. 首先函数接受 a 参数 然后返回一个新的匿名函数体确定了新的词法作用域,在该词法作用域中也拥有 a 参数\n2. 该匿名函数调用传入参数 3 返回 a+b 的和\n3. 通过上面程序了解到柯里化函数的特点是总是返回一个一元的函数：一个带有一个参数的新函数，不同的是普通函数可以根据需要一次获取尽可能多的参数\n\n\n### 为什么要柯里化\n\n1. 柯里化在函数组合的上下文中起到关键的作用,能够让你重新组合你的应用，将复杂的功能拆分成一个个简单的部分，这样容易更改，理解\n2. 柯里化也是一种函数预加载的方法，通过传递较少的参数得到一个在相同词法作用域当中缓存了这些参数的新函数，其实这也是一种对参数的缓存\n\n\n### 如何柯里化\n\n```js\n// 普通\nconst sayName = name => age => `my name is ${name}, Im years old ${age}` ;\nlet name = sayName('zhangsan');\nlet age = name(27);\n\n// 利用bind\n\nfunction person (name, age, height) {\n  console.log(`my name is ${name}, I,m years old ${age}, my height is ${height} meters`)\n}\nlet info = person.bind(null, 'zhangsan');\nconsole.log(info(27, 175));\n```\n\n### 柯里化函数的应用场景\n\n1. 延迟计算\n2. 参数复用\n3. 动态创建函数\n\n延迟计算<br/>\n```js\n\n// 普通实现\nvar sum = function(args){\n  return args.reduce(function(a,b){\n      return a+b\n  });\n};\nvar result = sum([1,2,3,4,5]); // 15\n\n// 柯里化实现\nfunction add() {\n  var _args = [].slice.call(arguments);\n  var adder = function () {\n\n      // 利用闭包特性保存_args的值\n      var _adder = function() {\n          [].push.apply(_args, [].slice.call(arguments));\n          return _adder;\n      };\n\n      // 利用隐式转换的特性，计算最终的值返回\n      _adder.toString = function () {\n          return _args.reduce(function (a, b) {\n              return a + b;\n          });\n      }\n\n      return _adder;\n  }\n  return adder.apply(null, [].slice.call(arguments));\n}\n\nvar sum = add();\nsum(1,2,3)(4);\nsum(5);\nsum() // 15\n\n优点：调用灵活，参数定义随意\n\n充分利用了柯里化提延迟执行的特点\n延迟执行 – 返回新函数可以进行任意调用\n```\n\nDOM操作中的事件绑定(动态创建函数)<br/>\n当在多次调用同一个函数，并且传递的参数绝大多数是相同的。\n``` js\n// 普通版本\nvar addEvent = function(el, type, fn, capture) {\n    if (window.addEventListener) {\n      el.addEventListener(type, function(e) {\n        fn.call(el, e);\n      }, capture);\n    } else if (window.attachEvent) {\n      el.attachEvent(\"on\" + type, function(e) {\n        fn.call(el, e);\n      });\n    } \n };\n\n // 柯里化版本\n var addEvent = (function(){\n    if (window.addEventListener) {\n      return function(el, type, fn, capture) {\n        el.addEventListener(type, function(e) {\n          fn.call(el, e);\n        }, (capture));\n      };\n    } else if (window.attachEvent) {\n      return function(el, type, fn, capture) {\n        el.attachEvent(\"on\" + type, function(e) {\n            fn.call(el, e);\n        });\n      };\n    }\n})();\n\n优点：不用每次调用进行 if () {}else {} 判断兼容性问题\n\n充分利用了柯里化提前返回和延迟执行的特点\n提前返回 – 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法\n延迟执行 – 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行\n```\n\n当然应用场景还有很多，比如我们经常提到的防抖和节流问题，充分的利用了函数式编程的延迟执行特性，将多个间隔接近的函数执行合并成一次函数执行来提高性能问题。<br/>\n关于事件节流和防抖动将会在后续的专题中单独指出<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/functionCurrying.md","raw":"---\ntitle: 偏应用函数、函数的柯里化\ndate: 2019-7-17 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- 函数式编程\ncategories:\n- 函数式编程\n---\n\n偏应用函数简称偏函数，在模拟 bind 的时候已经说明其概念和作为主要 bind 的实现<br/>\n\n函数柯里化主要是通过偏应用函数的实现，把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数<br/>\n\n```js\n// 柯里化之前\nfunction add (a, b) {\n  return a + b;\n}\n\n// 柯里化之后\nfunction add (a) {\n  return function (b) {\n    return a+b\n  }\n}\n\n// 等同于\nconst add = a => b => a + b;\nconst result = add(2)(3); // => 5\n```\n1. 首先函数接受 a 参数 然后返回一个新的匿名函数体确定了新的词法作用域,在该词法作用域中也拥有 a 参数\n2. 该匿名函数调用传入参数 3 返回 a+b 的和\n3. 通过上面程序了解到柯里化函数的特点是总是返回一个一元的函数：一个带有一个参数的新函数，不同的是普通函数可以根据需要一次获取尽可能多的参数\n\n\n### 为什么要柯里化\n\n1. 柯里化在函数组合的上下文中起到关键的作用,能够让你重新组合你的应用，将复杂的功能拆分成一个个简单的部分，这样容易更改，理解\n2. 柯里化也是一种函数预加载的方法，通过传递较少的参数得到一个在相同词法作用域当中缓存了这些参数的新函数，其实这也是一种对参数的缓存\n\n\n### 如何柯里化\n\n```js\n// 普通\nconst sayName = name => age => `my name is ${name}, Im years old ${age}` ;\nlet name = sayName('zhangsan');\nlet age = name(27);\n\n// 利用bind\n\nfunction person (name, age, height) {\n  console.log(`my name is ${name}, I,m years old ${age}, my height is ${height} meters`)\n}\nlet info = person.bind(null, 'zhangsan');\nconsole.log(info(27, 175));\n```\n\n### 柯里化函数的应用场景\n\n1. 延迟计算\n2. 参数复用\n3. 动态创建函数\n\n延迟计算<br/>\n```js\n\n// 普通实现\nvar sum = function(args){\n  return args.reduce(function(a,b){\n      return a+b\n  });\n};\nvar result = sum([1,2,3,4,5]); // 15\n\n// 柯里化实现\nfunction add() {\n  var _args = [].slice.call(arguments);\n  var adder = function () {\n\n      // 利用闭包特性保存_args的值\n      var _adder = function() {\n          [].push.apply(_args, [].slice.call(arguments));\n          return _adder;\n      };\n\n      // 利用隐式转换的特性，计算最终的值返回\n      _adder.toString = function () {\n          return _args.reduce(function (a, b) {\n              return a + b;\n          });\n      }\n\n      return _adder;\n  }\n  return adder.apply(null, [].slice.call(arguments));\n}\n\nvar sum = add();\nsum(1,2,3)(4);\nsum(5);\nsum() // 15\n\n优点：调用灵活，参数定义随意\n\n充分利用了柯里化提延迟执行的特点\n延迟执行 – 返回新函数可以进行任意调用\n```\n\nDOM操作中的事件绑定(动态创建函数)<br/>\n当在多次调用同一个函数，并且传递的参数绝大多数是相同的。\n``` js\n// 普通版本\nvar addEvent = function(el, type, fn, capture) {\n    if (window.addEventListener) {\n      el.addEventListener(type, function(e) {\n        fn.call(el, e);\n      }, capture);\n    } else if (window.attachEvent) {\n      el.attachEvent(\"on\" + type, function(e) {\n        fn.call(el, e);\n      });\n    } \n };\n\n // 柯里化版本\n var addEvent = (function(){\n    if (window.addEventListener) {\n      return function(el, type, fn, capture) {\n        el.addEventListener(type, function(e) {\n          fn.call(el, e);\n        }, (capture));\n      };\n    } else if (window.attachEvent) {\n      return function(el, type, fn, capture) {\n        el.attachEvent(\"on\" + type, function(e) {\n            fn.call(el, e);\n        });\n      };\n    }\n})();\n\n优点：不用每次调用进行 if () {}else {} 判断兼容性问题\n\n充分利用了柯里化提前返回和延迟执行的特点\n提前返回 – 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法\n延迟执行 – 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行\n```\n\n当然应用场景还有很多，比如我们经常提到的防抖和节流问题，充分的利用了函数式编程的延迟执行特性，将多个间隔接近的函数执行合并成一次函数执行来提高性能问题。<br/>\n关于事件节流和防抖动将会在后续的专题中单独指出<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/functionCurrying","published":1,"updated":"2019-10-15T01:29:42.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8or0000wb0u6ieov23d5","content":"<p>偏应用函数简称偏函数，在模拟 bind 的时候已经说明其概念和作为主要 bind 的实现<br></p>\n<p>函数柯里化主要是通过偏应用函数的实现，把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 柯里化之前</span>\n<span class=\"token keyword\">function</span> add <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 柯里化之后</span>\n<span class=\"token keyword\">function</span> add <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a<span class=\"token operator\">+</span>b\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 等同于</span>\n<span class=\"token keyword\">const</span> add <span class=\"token operator\">=</span> a <span class=\"token operator\">=</span><span class=\"token operator\">></span> b <span class=\"token operator\">=</span><span class=\"token operator\">></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => 5</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol>\n<li>首先函数接受 a 参数 然后返回一个新的匿名函数体确定了新的词法作用域,在该词法作用域中也拥有 a 参数</li>\n<li>该匿名函数调用传入参数 3 返回 a+b 的和</li>\n<li>通过上面程序了解到柯里化函数的特点是总是返回一个一元的函数：一个带有一个参数的新函数，不同的是普通函数可以根据需要一次获取尽可能多的参数</li>\n</ol>\n<h3 id=\"为什么要柯里化\"><a href=\"#为什么要柯里化\" class=\"headerlink\" title=\"为什么要柯里化\"></a>为什么要柯里化</h3><ol>\n<li>柯里化在函数组合的上下文中起到关键的作用,能够让你重新组合你的应用，将复杂的功能拆分成一个个简单的部分，这样容易更改，理解</li>\n<li>柯里化也是一种函数预加载的方法，通过传递较少的参数得到一个在相同词法作用域当中缓存了这些参数的新函数，其实这也是一种对参数的缓存</li>\n</ol>\n<h3 id=\"如何柯里化\"><a href=\"#如何柯里化\" class=\"headerlink\" title=\"如何柯里化\"></a>如何柯里化</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 普通</span>\n<span class=\"token keyword\">const</span> sayName <span class=\"token operator\">=</span> name <span class=\"token operator\">=</span><span class=\"token operator\">></span> age <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, Im years old </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span> <span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> age <span class=\"token operator\">=</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 利用bind</span>\n\n<span class=\"token keyword\">function</span> person <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, I,m years old </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, my height is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>height<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> meters`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> info <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"柯里化函数的应用场景\"><a href=\"#柯里化函数的应用场景\" class=\"headerlink\" title=\"柯里化函数的应用场景\"></a>柯里化函数的应用场景</h3><ol>\n<li>延迟计算</li>\n<li>参数复用</li>\n<li>动态创建函数</li>\n</ol>\n<p>延迟计算<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// 普通实现</span>\n<span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> args<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> a<span class=\"token operator\">+</span>b\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 15</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 柯里化实现</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> _args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> adder <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 利用闭包特性保存_args的值</span>\n      <span class=\"token keyword\">var</span> _adder <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>_args<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> _adder<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 利用隐式转换的特性，计算最终的值返回</span>\n      _adder<span class=\"token punctuation\">.</span>toString <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> _args<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">return</span> _adder<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> adder<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 15</span>\n\n优点：调用灵活，参数定义随意\n\n充分利用了柯里化提延迟执行的特点\n延迟执行 – 返回新函数可以进行任意调用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>DOM操作中的事件绑定(动态创建函数)<br><br>当在多次调用同一个函数，并且传递的参数绝大多数是相同的。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 普通版本</span>\n<span class=\"token keyword\">var</span> addEvent <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> capture<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>addEventListener<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      el<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> capture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>attachEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      el<span class=\"token punctuation\">.</span><span class=\"token function\">attachEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"on\"</span> <span class=\"token operator\">+</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n <span class=\"token comment\" spellcheck=\"true\">// 柯里化版本</span>\n <span class=\"token keyword\">var</span> addEvent <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>addEventListener<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> capture<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        el<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>capture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>attachEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> capture<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        el<span class=\"token punctuation\">.</span><span class=\"token function\">attachEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"on\"</span> <span class=\"token operator\">+</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n优点：不用每次调用进行 <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> 判断兼容性问题\n\n充分利用了柯里化提前返回和延迟执行的特点\n提前返回 – 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法\n延迟执行 – 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当然应用场景还有很多，比如我们经常提到的防抖和节流问题，充分的利用了函数式编程的延迟执行特性，将多个间隔接近的函数执行合并成一次函数执行来提高性能问题。<br><br>关于事件节流和防抖动将会在后续的专题中单独指出<br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>偏应用函数简称偏函数，在模拟 bind 的时候已经说明其概念和作为主要 bind 的实现<br></p>\n<p>函数柯里化主要是通过偏应用函数的实现，把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数<br></p>\n<pre><code class=\"js\">// 柯里化之前\nfunction add (a, b) {\n  return a + b;\n}\n\n// 柯里化之后\nfunction add (a) {\n  return function (b) {\n    return a+b\n  }\n}\n\n// 等同于\nconst add = a =&gt; b =&gt; a + b;\nconst result = add(2)(3); // =&gt; 5</code></pre>\n<ol>\n<li>首先函数接受 a 参数 然后返回一个新的匿名函数体确定了新的词法作用域,在该词法作用域中也拥有 a 参数</li>\n<li>该匿名函数调用传入参数 3 返回 a+b 的和</li>\n<li>通过上面程序了解到柯里化函数的特点是总是返回一个一元的函数：一个带有一个参数的新函数，不同的是普通函数可以根据需要一次获取尽可能多的参数</li>\n</ol>\n<h3 id=\"为什么要柯里化\"><a href=\"#为什么要柯里化\" class=\"headerlink\" title=\"为什么要柯里化\"></a>为什么要柯里化</h3><ol>\n<li>柯里化在函数组合的上下文中起到关键的作用,能够让你重新组合你的应用，将复杂的功能拆分成一个个简单的部分，这样容易更改，理解</li>\n<li>柯里化也是一种函数预加载的方法，通过传递较少的参数得到一个在相同词法作用域当中缓存了这些参数的新函数，其实这也是一种对参数的缓存</li>\n</ol>\n<h3 id=\"如何柯里化\"><a href=\"#如何柯里化\" class=\"headerlink\" title=\"如何柯里化\"></a>如何柯里化</h3><pre><code class=\"js\">// 普通\nconst sayName = name =&gt; age =&gt; `my name is ${name}, Im years old ${age}` ;\nlet name = sayName(&#39;zhangsan&#39;);\nlet age = name(27);\n\n// 利用bind\n\nfunction person (name, age, height) {\n  console.log(`my name is ${name}, I,m years old ${age}, my height is ${height} meters`)\n}\nlet info = person.bind(null, &#39;zhangsan&#39;);\nconsole.log(info(27, 175));</code></pre>\n<h3 id=\"柯里化函数的应用场景\"><a href=\"#柯里化函数的应用场景\" class=\"headerlink\" title=\"柯里化函数的应用场景\"></a>柯里化函数的应用场景</h3><ol>\n<li>延迟计算</li>\n<li>参数复用</li>\n<li>动态创建函数</li>\n</ol>\n<p>延迟计算<br></p>\n<pre><code class=\"js\">\n// 普通实现\nvar sum = function(args){\n  return args.reduce(function(a,b){\n      return a+b\n  });\n};\nvar result = sum([1,2,3,4,5]); // 15\n\n// 柯里化实现\nfunction add() {\n  var _args = [].slice.call(arguments);\n  var adder = function () {\n\n      // 利用闭包特性保存_args的值\n      var _adder = function() {\n          [].push.apply(_args, [].slice.call(arguments));\n          return _adder;\n      };\n\n      // 利用隐式转换的特性，计算最终的值返回\n      _adder.toString = function () {\n          return _args.reduce(function (a, b) {\n              return a + b;\n          });\n      }\n\n      return _adder;\n  }\n  return adder.apply(null, [].slice.call(arguments));\n}\n\nvar sum = add();\nsum(1,2,3)(4);\nsum(5);\nsum() // 15\n\n优点：调用灵活，参数定义随意\n\n充分利用了柯里化提延迟执行的特点\n延迟执行 – 返回新函数可以进行任意调用</code></pre>\n<p>DOM操作中的事件绑定(动态创建函数)<br><br>当在多次调用同一个函数，并且传递的参数绝大多数是相同的。</p>\n<pre><code class=\"js\">// 普通版本\nvar addEvent = function(el, type, fn, capture) {\n    if (window.addEventListener) {\n      el.addEventListener(type, function(e) {\n        fn.call(el, e);\n      }, capture);\n    } else if (window.attachEvent) {\n      el.attachEvent(&quot;on&quot; + type, function(e) {\n        fn.call(el, e);\n      });\n    } \n };\n\n // 柯里化版本\n var addEvent = (function(){\n    if (window.addEventListener) {\n      return function(el, type, fn, capture) {\n        el.addEventListener(type, function(e) {\n          fn.call(el, e);\n        }, (capture));\n      };\n    } else if (window.attachEvent) {\n      return function(el, type, fn, capture) {\n        el.attachEvent(&quot;on&quot; + type, function(e) {\n            fn.call(el, e);\n        });\n      };\n    }\n})();\n\n优点：不用每次调用进行 if () {}else {} 判断兼容性问题\n\n充分利用了柯里化提前返回和延迟执行的特点\n提前返回 – 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法\n延迟执行 – 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行</code></pre>\n<p>当然应用场景还有很多，比如我们经常提到的防抖和节流问题，充分的利用了函数式编程的延迟执行特性，将多个间隔接近的函数执行合并成一次函数执行来提高性能问题。<br><br>关于事件节流和防抖动将会在后续的专题中单独指出<br></p>\n"},{"title":"函数式编程-函数组合","date":"2019-07-22T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 概念\n函数组合是将两个或多个函数组合以产生新函数的过程。将功能组合在一起就像将一系列管道拼凑在一起，以便我们的数据流过<br/>\n\n简而言之，函数` f`和` g`的组合可以定义为`f（g（x））`，它从内到外 - 从右到左进行求值<br/>\n\n### demo toSlug\n\n举例子，想象一个场景，想要将用户的全名转换为URL slugs，以便为每个用户提供个人资料页面。为此，需要完成一系列步骤：\n1. 将名称拆分为空格中的数组\n2. 将名称映射到小写\n3. 加入破折号\n4. 编码URI组件\n\n```js\n// toslug.js hosted with ❤ by GitHub\n\nconst toSlug = input => encodeURIComponent(\n  input.split(' ')\n    .map(str => str.toLowerCase())\n    .join('-')\n);\n\n```\n\n### 组合功能\n\n不错......但如果我告诉你它可能更具可读性呢？想象一下，这些操作中的每一个都具有相应的可组合功能。可以写成<br/>\n```js\n// nesting-composition.js hosted with ❤ by GitHub\n\nconst toSlug = input => encodeURIComponent(\n  join('-')(\n    map(toLowerCase)(\n      split(' ')(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n\n```\n\n### 简单的偏应用函数\n\n这看起来比我们的第一次尝试更难阅读，但先放在这，我们继续以可组合形式的常用实用程序，如`split（）`，`join（）`和`map（）`。来实现<br/>\n```js\n// composables.js hosted with ❤ by GitHub\n\nconst curry = fn => (...args) => fn.bind(null, ...args);\n\nconst map = curry((fn, arr) => arr.map(fn));\n\nconst join = curry((str, arr) => arr.join(str));\n\nconst toLowerCase = str => str.toLowerCase();\n\nconst split = curry((splitOn, str) => str.split(splitOn));\n```\n\n上面的例子在技术上并不是真的柯里化，它总能产生一元函数，但是它是一个简单的偏应用函数。请参考<a href=\"https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8\">有关偏应用函数和柯里化的区别</a> <br/>\n\n\n回到我们的`toSlug（）`实现\n```js\n// nesting-composition.js hosted with ❤ by GitHub\n\nconst toSlug = input => encodeURIComponent(\n  join('-')(\n    map(toLowerCase)(\n      split(' ')(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n```\n\n### compose（）\n我们可以使用一个自动组合这些函数的函数来展平嵌套，这意味着它将从一个函数获取输出并自动将其到下一个函数的输入，直到它输出最终值<br/>\n想象一下我们实现函数 `reduce（）` 的功能，但为了匹配上面的compose行为，我们需要它从右到左，而不是从左到右<br/>\n\n```js\n// compose.js hosted with ❤ by GitHub\n\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n```\n\n上面的 `.reduceRight()` 与`.reduce（）`一样，数组`.reduceRight（）`方法采用reducer函数和初始值（`x`）。我们迭代数组函数（从右到左），依次将每个函数应用于累加值（`v`）<br/>\n\n使用compose，我们可以在没有嵌套的情况下重写 toSlug 的组合<br/>\n\n```js\n// using-compose.js hosted with ❤ by GitHub\nconst toSlug = compose(\n  encodeURIComponent,\n  join('-'),\n  map(toLowerCase),\n  split(' ')\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n```\n\n### pipe（）\n\n还有另一种通常称为“pipe（）”的形式。 Lodash称之为`flow（）`<br/>\n\n```js\n// pipe.js hosted with ❤ by GitHub\n\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\n\nconst fn1 = s => s.toLowerCase();\nconst fn2 = s => s.split('').reverse().join('');\nconst fn3 = s => s + '!'\n\nconst newFunc = pipe(fn1, fn2, fn3);\nconst result = newFunc('Time'); // emit!\n```\n\n我们看看用`pipe（）`实现的`toSlug（）`函数<br/>\n```js\n// using-pipe.js hosted with ❤ by GitHub\n\nconst toSlug = pipe(\n  split(' '),\n  map(toLowerCase),\n  join('-'),\n  encodeURIComponent\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n```\n\n在命令式编程中，当您对某个变量执行转换时，您将在转换的每个步骤中找到对该变量的引用。上面的`pipe（）`实现是以无点的方式编写的，这意味着它根本不识别它运行的参数。<br/>\n\n### trace\n\n我经常在单元测试和Redux状态之类的东西中使用管道来消除对中间变量的需要，这些中间变量只存在于一个操作和下一个操作之间的瞬态值。<br/>\n\n```js\n// using-trace.js hosted with ❤ by GitHub\n\nconst trace = curry((label, x) => {\n  console.log(`== ${ label }:  ${ x }`);\n  return x;\n});\n\nconst toSlug = pipe(\n  trace('input'),\n  split(' '),\n  map(toLowerCase),\n  trace('after map'),\n  join('-'),\n  encodeURIComponent\n);\n\nconsole.log(toSlug('JS Cheerleader'));\n// '== input:  JS Cheerleader'\n// '== after map:  js,cheerleader'\n// 'js-cheerleader'\n```\n\n\n`trace（）`只是更通用的`tap（）`的一种特殊形式，它允许你为流经管道的每个值执行一些操作<br/>\n```js\n// tap.js hosted with ❤ by GitHub\n\nconst tap = curry((fn, x) => {\n  fn(x);\n  return x;\n});\n```\n\n现在可以看到`trace（）`是一个特殊的`tap（）`\n\n```js\nconst trace = label => {\n  return tap(x => console.log(`== ${ label }:  ${ x }`));\n};\n```\n\n\n\n","source":"_posts/javascript/functionalCombination.md","raw":"---\ntitle: 函数式编程-函数组合\ndate: 2019-7-22 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- 函数式编程\ncategories:\n- 函数式编程\n---\n\n### 概念\n函数组合是将两个或多个函数组合以产生新函数的过程。将功能组合在一起就像将一系列管道拼凑在一起，以便我们的数据流过<br/>\n\n简而言之，函数` f`和` g`的组合可以定义为`f（g（x））`，它从内到外 - 从右到左进行求值<br/>\n\n### demo toSlug\n\n举例子，想象一个场景，想要将用户的全名转换为URL slugs，以便为每个用户提供个人资料页面。为此，需要完成一系列步骤：\n1. 将名称拆分为空格中的数组\n2. 将名称映射到小写\n3. 加入破折号\n4. 编码URI组件\n\n```js\n// toslug.js hosted with ❤ by GitHub\n\nconst toSlug = input => encodeURIComponent(\n  input.split(' ')\n    .map(str => str.toLowerCase())\n    .join('-')\n);\n\n```\n\n### 组合功能\n\n不错......但如果我告诉你它可能更具可读性呢？想象一下，这些操作中的每一个都具有相应的可组合功能。可以写成<br/>\n```js\n// nesting-composition.js hosted with ❤ by GitHub\n\nconst toSlug = input => encodeURIComponent(\n  join('-')(\n    map(toLowerCase)(\n      split(' ')(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n\n```\n\n### 简单的偏应用函数\n\n这看起来比我们的第一次尝试更难阅读，但先放在这，我们继续以可组合形式的常用实用程序，如`split（）`，`join（）`和`map（）`。来实现<br/>\n```js\n// composables.js hosted with ❤ by GitHub\n\nconst curry = fn => (...args) => fn.bind(null, ...args);\n\nconst map = curry((fn, arr) => arr.map(fn));\n\nconst join = curry((str, arr) => arr.join(str));\n\nconst toLowerCase = str => str.toLowerCase();\n\nconst split = curry((splitOn, str) => str.split(splitOn));\n```\n\n上面的例子在技术上并不是真的柯里化，它总能产生一元函数，但是它是一个简单的偏应用函数。请参考<a href=\"https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8\">有关偏应用函数和柯里化的区别</a> <br/>\n\n\n回到我们的`toSlug（）`实现\n```js\n// nesting-composition.js hosted with ❤ by GitHub\n\nconst toSlug = input => encodeURIComponent(\n  join('-')(\n    map(toLowerCase)(\n      split(' ')(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n```\n\n### compose（）\n我们可以使用一个自动组合这些函数的函数来展平嵌套，这意味着它将从一个函数获取输出并自动将其到下一个函数的输入，直到它输出最终值<br/>\n想象一下我们实现函数 `reduce（）` 的功能，但为了匹配上面的compose行为，我们需要它从右到左，而不是从左到右<br/>\n\n```js\n// compose.js hosted with ❤ by GitHub\n\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n```\n\n上面的 `.reduceRight()` 与`.reduce（）`一样，数组`.reduceRight（）`方法采用reducer函数和初始值（`x`）。我们迭代数组函数（从右到左），依次将每个函数应用于累加值（`v`）<br/>\n\n使用compose，我们可以在没有嵌套的情况下重写 toSlug 的组合<br/>\n\n```js\n// using-compose.js hosted with ❤ by GitHub\nconst toSlug = compose(\n  encodeURIComponent,\n  join('-'),\n  map(toLowerCase),\n  split(' ')\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n```\n\n### pipe（）\n\n还有另一种通常称为“pipe（）”的形式。 Lodash称之为`flow（）`<br/>\n\n```js\n// pipe.js hosted with ❤ by GitHub\n\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\n\nconst fn1 = s => s.toLowerCase();\nconst fn2 = s => s.split('').reverse().join('');\nconst fn3 = s => s + '!'\n\nconst newFunc = pipe(fn1, fn2, fn3);\nconst result = newFunc('Time'); // emit!\n```\n\n我们看看用`pipe（）`实现的`toSlug（）`函数<br/>\n```js\n// using-pipe.js hosted with ❤ by GitHub\n\nconst toSlug = pipe(\n  split(' '),\n  map(toLowerCase),\n  join('-'),\n  encodeURIComponent\n);\n\nconsole.log(toSlug('JS Cheerleader')); // 'js-cheerleader'\n```\n\n在命令式编程中，当您对某个变量执行转换时，您将在转换的每个步骤中找到对该变量的引用。上面的`pipe（）`实现是以无点的方式编写的，这意味着它根本不识别它运行的参数。<br/>\n\n### trace\n\n我经常在单元测试和Redux状态之类的东西中使用管道来消除对中间变量的需要，这些中间变量只存在于一个操作和下一个操作之间的瞬态值。<br/>\n\n```js\n// using-trace.js hosted with ❤ by GitHub\n\nconst trace = curry((label, x) => {\n  console.log(`== ${ label }:  ${ x }`);\n  return x;\n});\n\nconst toSlug = pipe(\n  trace('input'),\n  split(' '),\n  map(toLowerCase),\n  trace('after map'),\n  join('-'),\n  encodeURIComponent\n);\n\nconsole.log(toSlug('JS Cheerleader'));\n// '== input:  JS Cheerleader'\n// '== after map:  js,cheerleader'\n// 'js-cheerleader'\n```\n\n\n`trace（）`只是更通用的`tap（）`的一种特殊形式，它允许你为流经管道的每个值执行一些操作<br/>\n```js\n// tap.js hosted with ❤ by GitHub\n\nconst tap = curry((fn, x) => {\n  fn(x);\n  return x;\n});\n```\n\n现在可以看到`trace（）`是一个特殊的`tap（）`\n\n```js\nconst trace = label => {\n  return tap(x => console.log(`== ${ label }:  ${ x }`));\n};\n```\n\n\n\n","slug":"javascript/functionalCombination","published":1,"updated":"2019-10-15T01:29:42.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8or2000zb0u6kbnyyutt","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>函数组合是将两个或多个函数组合以产生新函数的过程。将功能组合在一起就像将一系列管道拼凑在一起，以便我们的数据流过<br></p>\n<p>简而言之，函数<code>f</code>和<code>g</code>的组合可以定义为<code>f（g（x））</code>，它从内到外 - 从右到左进行求值<br></p>\n<h3 id=\"demo-toSlug\"><a href=\"#demo-toSlug\" class=\"headerlink\" title=\"demo toSlug\"></a>demo toSlug</h3><p>举例子，想象一个场景，想要将用户的全名转换为URL slugs，以便为每个用户提供个人资料页面。为此，需要完成一系列步骤：</p>\n<ol>\n<li>将名称拆分为空格中的数组</li>\n<li>将名称映射到小写</li>\n<li>加入破折号</li>\n<li>编码URI组件</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// toslug.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> toSlug <span class=\"token operator\">=</span> input <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">encodeURIComponent</span><span class=\"token punctuation\">(</span>\n  input<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>str <span class=\"token operator\">=</span><span class=\"token operator\">></span> str<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"组合功能\"><a href=\"#组合功能\" class=\"headerlink\" title=\"组合功能\"></a>组合功能</h3><p>不错……但如果我告诉你它可能更具可读性呢？想象一下，这些操作中的每一个都具有相应的可组合功能。可以写成<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// nesting-composition.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> toSlug <span class=\"token operator\">=</span> input <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">encodeURIComponent</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n    <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>toLowerCase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n      <span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n        input\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">toSlug</span><span class=\"token punctuation\">(</span><span class=\"token string\">'JS Cheerleader'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 'js-cheerleader'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"简单的偏应用函数\"><a href=\"#简单的偏应用函数\" class=\"headerlink\" title=\"简单的偏应用函数\"></a>简单的偏应用函数</h3><p>这看起来比我们的第一次尝试更难阅读，但先放在这，我们继续以可组合形式的常用实用程序，如<code>split（）</code>，<code>join（）</code>和<code>map（）</code>。来实现<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// composables.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> curry <span class=\"token operator\">=</span> fn <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> fn<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> map <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> join <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> toLowerCase <span class=\"token operator\">=</span> str <span class=\"token operator\">=</span><span class=\"token operator\">></span> str<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> split <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>splitOn<span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> str<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span>splitOn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的例子在技术上并不是真的柯里化，它总能产生一元函数，但是它是一个简单的偏应用函数。请参考<a href=\"https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8\" target=\"_blank\" rel=\"noopener\">有关偏应用函数和柯里化的区别</a> <br></p>\n<p>回到我们的<code>toSlug（）</code>实现</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// nesting-composition.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> toSlug <span class=\"token operator\">=</span> input <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">encodeURIComponent</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n    <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>toLowerCase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n      <span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n        input\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">toSlug</span><span class=\"token punctuation\">(</span><span class=\"token string\">'JS Cheerleader'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 'js-cheerleader'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"compose（）\"><a href=\"#compose（）\" class=\"headerlink\" title=\"compose（）\"></a>compose（）</h3><p>我们可以使用一个自动组合这些函数的函数来展平嵌套，这意味着它将从一个函数获取输出并自动将其到下一个函数的输入，直到它输出最终值<br><br>想象一下我们实现函数 <code>reduce（）</code> 的功能，但为了匹配上面的compose行为，我们需要它从右到左，而不是从左到右<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// compose.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> compose <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>fns<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> x <span class=\"token operator\">=</span><span class=\"token operator\">></span> fns<span class=\"token punctuation\">.</span><span class=\"token function\">reduceRight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">const</span> compose <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>fns<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> x <span class=\"token operator\">=</span><span class=\"token operator\">></span> fns<span class=\"token punctuation\">.</span><span class=\"token function\">reduceRight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>上面的 <code>.reduceRight()</code> 与<code>.reduce（）</code>一样，数组<code>.reduceRight（）</code>方法采用reducer函数和初始值（<code>x</code>）。我们迭代数组函数（从右到左），依次将每个函数应用于累加值（<code>v</code>）<br></p>\n<p>使用compose，我们可以在没有嵌套的情况下重写 toSlug 的组合<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// using-compose.js hosted with ❤ by GitHub</span>\n<span class=\"token keyword\">const</span> toSlug <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>\n  encodeURIComponent<span class=\"token punctuation\">,</span>\n  <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>toLowerCase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">toSlug</span><span class=\"token punctuation\">(</span><span class=\"token string\">'JS Cheerleader'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 'js-cheerleader'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"pipe（）\"><a href=\"#pipe（）\" class=\"headerlink\" title=\"pipe（）\"></a>pipe（）</h3><p>还有另一种通常称为“pipe（）”的形式。 Lodash称之为<code>flow（）</code><br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// pipe.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> pipe <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>fns<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> x <span class=\"token operator\">=</span><span class=\"token operator\">></span> fns<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> fn1 <span class=\"token operator\">=</span> s <span class=\"token operator\">=</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fn2 <span class=\"token operator\">=</span> s <span class=\"token operator\">=</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fn3 <span class=\"token operator\">=</span> s <span class=\"token operator\">=</span><span class=\"token operator\">></span> s <span class=\"token operator\">+</span> <span class=\"token string\">'!'</span>\n\n<span class=\"token keyword\">const</span> newFunc <span class=\"token operator\">=</span> <span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>fn1<span class=\"token punctuation\">,</span> fn2<span class=\"token punctuation\">,</span> fn3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">newFunc</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Time'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// emit!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们看看用<code>pipe（）</code>实现的<code>toSlug（）</code>函数<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// using-pipe.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> toSlug <span class=\"token operator\">=</span> <span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>toLowerCase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  encodeURIComponent\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">toSlug</span><span class=\"token punctuation\">(</span><span class=\"token string\">'JS Cheerleader'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 'js-cheerleader'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在命令式编程中，当您对某个变量执行转换时，您将在转换的每个步骤中找到对该变量的引用。上面的<code>pipe（）</code>实现是以无点的方式编写的，这意味着它根本不识别它运行的参数。<br></p>\n<h3 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h3><p>我经常在单元测试和Redux状态之类的东西中使用管道来消除对中间变量的需要，这些中间变量只存在于一个操作和下一个操作之间的瞬态值。<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// using-trace.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> trace <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>label<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`== </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span> label <span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">:  </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span> x <span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> toSlug <span class=\"token operator\">=</span> <span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>toLowerCase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">trace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'after map'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  encodeURIComponent\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">toSlug</span><span class=\"token punctuation\">(</span><span class=\"token string\">'JS Cheerleader'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// '== input:  JS Cheerleader'</span>\n<span class=\"token comment\" spellcheck=\"true\">// '== after map:  js,cheerleader'</span>\n<span class=\"token comment\" spellcheck=\"true\">// 'js-cheerleader'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>trace（）</code>只是更通用的<code>tap（）</code>的一种特殊形式，它允许你为流经管道的每个值执行一些操作<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// tap.js hosted with ❤ by GitHub</span>\n\n<span class=\"token keyword\">const</span> tap <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在可以看到<code>trace（）</code>是一个特殊的<code>tap（）</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> trace <span class=\"token operator\">=</span> label <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">tap</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`== </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span> label <span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">:  </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span> x <span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>函数组合是将两个或多个函数组合以产生新函数的过程。将功能组合在一起就像将一系列管道拼凑在一起，以便我们的数据流过<br></p>\n<p>简而言之，函数<code>f</code>和<code>g</code>的组合可以定义为<code>f（g（x））</code>，它从内到外 - 从右到左进行求值<br></p>\n<h3 id=\"demo-toSlug\"><a href=\"#demo-toSlug\" class=\"headerlink\" title=\"demo toSlug\"></a>demo toSlug</h3><p>举例子，想象一个场景，想要将用户的全名转换为URL slugs，以便为每个用户提供个人资料页面。为此，需要完成一系列步骤：</p>\n<ol>\n<li>将名称拆分为空格中的数组</li>\n<li>将名称映射到小写</li>\n<li>加入破折号</li>\n<li>编码URI组件</li>\n</ol>\n<pre><code class=\"js\">// toslug.js hosted with ❤ by GitHub\n\nconst toSlug = input =&gt; encodeURIComponent(\n  input.split(&#39; &#39;)\n    .map(str =&gt; str.toLowerCase())\n    .join(&#39;-&#39;)\n);\n</code></pre>\n<h3 id=\"组合功能\"><a href=\"#组合功能\" class=\"headerlink\" title=\"组合功能\"></a>组合功能</h3><p>不错……但如果我告诉你它可能更具可读性呢？想象一下，这些操作中的每一个都具有相应的可组合功能。可以写成<br></p>\n<pre><code class=\"js\">// nesting-composition.js hosted with ❤ by GitHub\n\nconst toSlug = input =&gt; encodeURIComponent(\n  join(&#39;-&#39;)(\n    map(toLowerCase)(\n      split(&#39; &#39;)(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;\n</code></pre>\n<h3 id=\"简单的偏应用函数\"><a href=\"#简单的偏应用函数\" class=\"headerlink\" title=\"简单的偏应用函数\"></a>简单的偏应用函数</h3><p>这看起来比我们的第一次尝试更难阅读，但先放在这，我们继续以可组合形式的常用实用程序，如<code>split（）</code>，<code>join（）</code>和<code>map（）</code>。来实现<br></p>\n<pre><code class=\"js\">// composables.js hosted with ❤ by GitHub\n\nconst curry = fn =&gt; (...args) =&gt; fn.bind(null, ...args);\n\nconst map = curry((fn, arr) =&gt; arr.map(fn));\n\nconst join = curry((str, arr) =&gt; arr.join(str));\n\nconst toLowerCase = str =&gt; str.toLowerCase();\n\nconst split = curry((splitOn, str) =&gt; str.split(splitOn));</code></pre>\n<p>上面的例子在技术上并不是真的柯里化，它总能产生一元函数，但是它是一个简单的偏应用函数。请参考<a href=\"https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8\" target=\"_blank\" rel=\"noopener\">有关偏应用函数和柯里化的区别</a> <br></p>\n<p>回到我们的<code>toSlug（）</code>实现</p>\n<pre><code class=\"js\">// nesting-composition.js hosted with ❤ by GitHub\n\nconst toSlug = input =&gt; encodeURIComponent(\n  join(&#39;-&#39;)(\n    map(toLowerCase)(\n      split(&#39; &#39;)(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre>\n<h3 id=\"compose（）\"><a href=\"#compose（）\" class=\"headerlink\" title=\"compose（）\"></a>compose（）</h3><p>我们可以使用一个自动组合这些函数的函数来展平嵌套，这意味着它将从一个函数获取输出并自动将其到下一个函数的输入，直到它输出最终值<br><br>想象一下我们实现函数 <code>reduce（）</code> 的功能，但为了匹配上面的compose行为，我们需要它从右到左，而不是从左到右<br></p>\n<pre><code class=\"js\">// compose.js hosted with ❤ by GitHub\n\nconst compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x);const compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x);</code></pre>\n<p>上面的 <code>.reduceRight()</code> 与<code>.reduce（）</code>一样，数组<code>.reduceRight（）</code>方法采用reducer函数和初始值（<code>x</code>）。我们迭代数组函数（从右到左），依次将每个函数应用于累加值（<code>v</code>）<br></p>\n<p>使用compose，我们可以在没有嵌套的情况下重写 toSlug 的组合<br></p>\n<pre><code class=\"js\">// using-compose.js hosted with ❤ by GitHub\nconst toSlug = compose(\n  encodeURIComponent,\n  join(&#39;-&#39;),\n  map(toLowerCase),\n  split(&#39; &#39;)\n);\n\nconsole.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre>\n<h3 id=\"pipe（）\"><a href=\"#pipe（）\" class=\"headerlink\" title=\"pipe（）\"></a>pipe（）</h3><p>还有另一种通常称为“pipe（）”的形式。 Lodash称之为<code>flow（）</code><br></p>\n<pre><code class=\"js\">// pipe.js hosted with ❤ by GitHub\n\nconst pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x);\n\nconst fn1 = s =&gt; s.toLowerCase();\nconst fn2 = s =&gt; s.split(&#39;&#39;).reverse().join(&#39;&#39;);\nconst fn3 = s =&gt; s + &#39;!&#39;\n\nconst newFunc = pipe(fn1, fn2, fn3);\nconst result = newFunc(&#39;Time&#39;); // emit!</code></pre>\n<p>我们看看用<code>pipe（）</code>实现的<code>toSlug（）</code>函数<br></p>\n<pre><code class=\"js\">// using-pipe.js hosted with ❤ by GitHub\n\nconst toSlug = pipe(\n  split(&#39; &#39;),\n  map(toLowerCase),\n  join(&#39;-&#39;),\n  encodeURIComponent\n);\n\nconsole.log(toSlug(&#39;JS Cheerleader&#39;)); // &#39;js-cheerleader&#39;</code></pre>\n<p>在命令式编程中，当您对某个变量执行转换时，您将在转换的每个步骤中找到对该变量的引用。上面的<code>pipe（）</code>实现是以无点的方式编写的，这意味着它根本不识别它运行的参数。<br></p>\n<h3 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h3><p>我经常在单元测试和Redux状态之类的东西中使用管道来消除对中间变量的需要，这些中间变量只存在于一个操作和下一个操作之间的瞬态值。<br></p>\n<pre><code class=\"js\">// using-trace.js hosted with ❤ by GitHub\n\nconst trace = curry((label, x) =&gt; {\n  console.log(`== ${ label }:  ${ x }`);\n  return x;\n});\n\nconst toSlug = pipe(\n  trace(&#39;input&#39;),\n  split(&#39; &#39;),\n  map(toLowerCase),\n  trace(&#39;after map&#39;),\n  join(&#39;-&#39;),\n  encodeURIComponent\n);\n\nconsole.log(toSlug(&#39;JS Cheerleader&#39;));\n// &#39;== input:  JS Cheerleader&#39;\n// &#39;== after map:  js,cheerleader&#39;\n// &#39;js-cheerleader&#39;</code></pre>\n<p><code>trace（）</code>只是更通用的<code>tap（）</code>的一种特殊形式，它允许你为流经管道的每个值执行一些操作<br></p>\n<pre><code class=\"js\">// tap.js hosted with ❤ by GitHub\n\nconst tap = curry((fn, x) =&gt; {\n  fn(x);\n  return x;\n});</code></pre>\n<p>现在可以看到<code>trace（）</code>是一个特殊的<code>tap（）</code></p>\n<pre><code class=\"js\">const trace = label =&gt; {\n  return tap(x =&gt; console.log(`== ${ label }:  ${ x }`));\n};</code></pre>\n"},{"title":"原生拖拽","date":"2019-04-09T14:34:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n在实际开发中我们经常会遇到关于元素拖拽的场景，那么在我们今天实现一个简单的拖拽元素功能\n\n### css <hr>\n\n```css\n  * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .demo-box {\n      position: absolute;\n      width: 100px;\n      height: 100px;\n      background: #ccc;\n      border: solid 1px #ccc;\n      border-radius: 5px;\n      line-height: 100px;\n      text-align: center;\n    }\n```\n\n### html<hr>\n\n```html\n  <div id=\"demo\" class=\"demo-box\">按住左键拖动</div>\n```\n\n### js <hr>\n\n```js\n  window.onload = function () {\n    //用于确定是否是拖拽的对象\n    var drag;\n    //鼠标位于目标元素上的时候距离目标元素的位置\n    var x, y;\n    //取得元素\n    var ele = document.getElementById('demo');\n    /**\n     *鼠标按事件\n     *@param  evt 事件形参\n     */\n    ele.onmousedown = function (evt) {\n      //取得事件对象\n      _event = evt || window.event;\n      //设置drag元素,计算当前位置\n      _target = _event.target || _event.srcElement;\n      x = _event.clientX - _target.offsetLeft;\n      y = _event.clientY - _target.offsetTop;\n      drag = _target;\n    }\n    /**\n     *鼠标移动事件\n     * @param evt 事件形参\n     */\n    document.onmousemove = function (evt) {\n      //确定鼠标是在目标元素上按下去后才开始移动\n      if (drag) {\n        _event = evt || window.event;\n        //设置边界全局变量\n        var _left = _event.clientX - x;\n        var _top = _event.clientY - y;\n        var _windowInnerWidth = window.innerWidth;\n        var _windowInnerHeight = window.innerHeight\n        var _dragOffWidth = drag.offsetWidth\n        var _dragOffHeight = drag.offsetHeight\n        var _windowWidth = _windowInnerWidth - _dragOffWidth\n        var _windowHeight = _windowInnerHeight - _dragOffHeight\n\n        //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条  \n        if (_left < 0) {\n          _left = 0;\n        } else if (_left > _windowWidth) {\n          _left = _windowWidth;\n        }\n        if (_top < 0) {\n          _top = 0;\n        } else if (_top > _windowHeight) {\n          _top = _windowHeight;\n        }\n        //设置样式\n        drag.style.cursor = 'move';\n        drag.style.border = 'dashed 1px red';\n        drag.style.left = _left + 'px';\n        drag.style.top = _top + 'px';\n      }\n    }\n\n    /** \n     * 松开鼠标事件\n     * @param evt 事件形参 \n     */\n    document.onmouseup = function (evt) {\n      if (drag) {\n        //卸载样式\n        drag.style.cursor = '';\n        drag.style.border = 'dashed 1px #ccc';\n      }\n      drag = null;\n    }\n  }\n```","source":"_posts/javascript/drag.md","raw":"---\ntitle: 原生拖拽\ndate: 2019-4-09 22:34:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n在实际开发中我们经常会遇到关于元素拖拽的场景，那么在我们今天实现一个简单的拖拽元素功能\n\n### css <hr>\n\n```css\n  * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .demo-box {\n      position: absolute;\n      width: 100px;\n      height: 100px;\n      background: #ccc;\n      border: solid 1px #ccc;\n      border-radius: 5px;\n      line-height: 100px;\n      text-align: center;\n    }\n```\n\n### html<hr>\n\n```html\n  <div id=\"demo\" class=\"demo-box\">按住左键拖动</div>\n```\n\n### js <hr>\n\n```js\n  window.onload = function () {\n    //用于确定是否是拖拽的对象\n    var drag;\n    //鼠标位于目标元素上的时候距离目标元素的位置\n    var x, y;\n    //取得元素\n    var ele = document.getElementById('demo');\n    /**\n     *鼠标按事件\n     *@param  evt 事件形参\n     */\n    ele.onmousedown = function (evt) {\n      //取得事件对象\n      _event = evt || window.event;\n      //设置drag元素,计算当前位置\n      _target = _event.target || _event.srcElement;\n      x = _event.clientX - _target.offsetLeft;\n      y = _event.clientY - _target.offsetTop;\n      drag = _target;\n    }\n    /**\n     *鼠标移动事件\n     * @param evt 事件形参\n     */\n    document.onmousemove = function (evt) {\n      //确定鼠标是在目标元素上按下去后才开始移动\n      if (drag) {\n        _event = evt || window.event;\n        //设置边界全局变量\n        var _left = _event.clientX - x;\n        var _top = _event.clientY - y;\n        var _windowInnerWidth = window.innerWidth;\n        var _windowInnerHeight = window.innerHeight\n        var _dragOffWidth = drag.offsetWidth\n        var _dragOffHeight = drag.offsetHeight\n        var _windowWidth = _windowInnerWidth - _dragOffWidth\n        var _windowHeight = _windowInnerHeight - _dragOffHeight\n\n        //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条  \n        if (_left < 0) {\n          _left = 0;\n        } else if (_left > _windowWidth) {\n          _left = _windowWidth;\n        }\n        if (_top < 0) {\n          _top = 0;\n        } else if (_top > _windowHeight) {\n          _top = _windowHeight;\n        }\n        //设置样式\n        drag.style.cursor = 'move';\n        drag.style.border = 'dashed 1px red';\n        drag.style.left = _left + 'px';\n        drag.style.top = _top + 'px';\n      }\n    }\n\n    /** \n     * 松开鼠标事件\n     * @param evt 事件形参 \n     */\n    document.onmouseup = function (evt) {\n      if (drag) {\n        //卸载样式\n        drag.style.cursor = '';\n        drag.style.border = 'dashed 1px #ccc';\n      }\n      drag = null;\n    }\n  }\n```","slug":"javascript/drag","published":1,"updated":"2019-10-15T01:29:42.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8or50013b0u6510twzy4","content":"<p>在实际开发中我们经常会遇到关于元素拖拽的场景，那么在我们今天实现一个简单的拖拽元素功能</p>\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css \"></a>css <hr></h3><pre class=\"line-numbers language-css\"><code class=\"language-css\">  <span class=\"token selector\">* </span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n      <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token selector\"><span class=\"token class\">.demo-box</span> </span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n      <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> solid <span class=\"token number\">1</span>px <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n      <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html<hr></h3><pre class=\"line-numbers language-html\"><code class=\"language-html\">  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>demo<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>demo-box<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>按住左键拖动<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js \"></a>js <hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">  window<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用于确定是否是拖拽的对象</span>\n    <span class=\"token keyword\">var</span> drag<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//鼠标位于目标元素上的时候距离目标元素的位置</span>\n    <span class=\"token keyword\">var</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//取得元素</span>\n    <span class=\"token keyword\">var</span> ele <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'demo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     *鼠标按事件\n     *@param  evt 事件形参\n     */</span>\n    ele<span class=\"token punctuation\">.</span>onmousedown <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>evt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">//取得事件对象</span>\n      _event <span class=\"token operator\">=</span> evt <span class=\"token operator\">||</span> window<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">//设置drag元素,计算当前位置</span>\n      _target <span class=\"token operator\">=</span> _event<span class=\"token punctuation\">.</span>target <span class=\"token operator\">||</span> _event<span class=\"token punctuation\">.</span>srcElement<span class=\"token punctuation\">;</span>\n      x <span class=\"token operator\">=</span> _event<span class=\"token punctuation\">.</span>clientX <span class=\"token operator\">-</span> _target<span class=\"token punctuation\">.</span>offsetLeft<span class=\"token punctuation\">;</span>\n      y <span class=\"token operator\">=</span> _event<span class=\"token punctuation\">.</span>clientY <span class=\"token operator\">-</span> _target<span class=\"token punctuation\">.</span>offsetTop<span class=\"token punctuation\">;</span>\n      drag <span class=\"token operator\">=</span> _target<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     *鼠标移动事件\n     * @param evt 事件形参\n     */</span>\n    document<span class=\"token punctuation\">.</span>onmousemove <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>evt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">//确定鼠标是在目标元素上按下去后才开始移动</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>drag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _event <span class=\"token operator\">=</span> evt <span class=\"token operator\">||</span> window<span class=\"token punctuation\">.</span>event<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//设置边界全局变量</span>\n        <span class=\"token keyword\">var</span> _left <span class=\"token operator\">=</span> _event<span class=\"token punctuation\">.</span>clientX <span class=\"token operator\">-</span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> _top <span class=\"token operator\">=</span> _event<span class=\"token punctuation\">.</span>clientY <span class=\"token operator\">-</span> y<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> _windowInnerWidth <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>innerWidth<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> _windowInnerHeight <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>innerHeight\n        <span class=\"token keyword\">var</span> _dragOffWidth <span class=\"token operator\">=</span> drag<span class=\"token punctuation\">.</span>offsetWidth\n        <span class=\"token keyword\">var</span> _dragOffHeight <span class=\"token operator\">=</span> drag<span class=\"token punctuation\">.</span>offsetHeight\n        <span class=\"token keyword\">var</span> _windowWidth <span class=\"token operator\">=</span> _windowInnerWidth <span class=\"token operator\">-</span> _dragOffWidth\n        <span class=\"token keyword\">var</span> _windowHeight <span class=\"token operator\">=</span> _windowInnerHeight <span class=\"token operator\">-</span> _dragOffHeight\n\n        <span class=\"token comment\" spellcheck=\"true\">//控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条  </span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_left <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_left <span class=\"token operator\">></span> _windowWidth<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _left <span class=\"token operator\">=</span> _windowWidth<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_top <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _top <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_top <span class=\"token operator\">></span> _windowHeight<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _top <span class=\"token operator\">=</span> _windowHeight<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//设置样式</span>\n        drag<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>cursor <span class=\"token operator\">=</span> <span class=\"token string\">'move'</span><span class=\"token punctuation\">;</span>\n        drag<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>border <span class=\"token operator\">=</span> <span class=\"token string\">'dashed 1px red'</span><span class=\"token punctuation\">;</span>\n        drag<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> _left <span class=\"token operator\">+</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>\n        drag<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>top <span class=\"token operator\">=</span> _top <span class=\"token operator\">+</span> <span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/** \n     * 松开鼠标事件\n     * @param evt 事件形参 \n     */</span>\n    document<span class=\"token punctuation\">.</span>onmouseup <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>evt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>drag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//卸载样式</span>\n        drag<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>cursor <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n        drag<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>border <span class=\"token operator\">=</span> <span class=\"token string\">'dashed 1px #ccc'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      drag <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在实际开发中我们经常会遇到关于元素拖拽的场景，那么在我们今天实现一个简单的拖拽元素功能</p>\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css \"></a>css <hr></h3><pre><code class=\"css\">  * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .demo-box {\n      position: absolute;\n      width: 100px;\n      height: 100px;\n      background: #ccc;\n      border: solid 1px #ccc;\n      border-radius: 5px;\n      line-height: 100px;\n      text-align: center;\n    }</code></pre>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html<hr></h3><pre><code class=\"html\">  &lt;div id=&quot;demo&quot; class=&quot;demo-box&quot;&gt;按住左键拖动&lt;/div&gt;</code></pre>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js \"></a>js <hr></h3><pre><code class=\"js\">  window.onload = function () {\n    //用于确定是否是拖拽的对象\n    var drag;\n    //鼠标位于目标元素上的时候距离目标元素的位置\n    var x, y;\n    //取得元素\n    var ele = document.getElementById(&#39;demo&#39;);\n    /**\n     *鼠标按事件\n     *@param  evt 事件形参\n     */\n    ele.onmousedown = function (evt) {\n      //取得事件对象\n      _event = evt || window.event;\n      //设置drag元素,计算当前位置\n      _target = _event.target || _event.srcElement;\n      x = _event.clientX - _target.offsetLeft;\n      y = _event.clientY - _target.offsetTop;\n      drag = _target;\n    }\n    /**\n     *鼠标移动事件\n     * @param evt 事件形参\n     */\n    document.onmousemove = function (evt) {\n      //确定鼠标是在目标元素上按下去后才开始移动\n      if (drag) {\n        _event = evt || window.event;\n        //设置边界全局变量\n        var _left = _event.clientX - x;\n        var _top = _event.clientY - y;\n        var _windowInnerWidth = window.innerWidth;\n        var _windowInnerHeight = window.innerHeight\n        var _dragOffWidth = drag.offsetWidth\n        var _dragOffHeight = drag.offsetHeight\n        var _windowWidth = _windowInnerWidth - _dragOffWidth\n        var _windowHeight = _windowInnerHeight - _dragOffHeight\n\n        //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条  \n        if (_left &lt; 0) {\n          _left = 0;\n        } else if (_left &gt; _windowWidth) {\n          _left = _windowWidth;\n        }\n        if (_top &lt; 0) {\n          _top = 0;\n        } else if (_top &gt; _windowHeight) {\n          _top = _windowHeight;\n        }\n        //设置样式\n        drag.style.cursor = &#39;move&#39;;\n        drag.style.border = &#39;dashed 1px red&#39;;\n        drag.style.left = _left + &#39;px&#39;;\n        drag.style.top = _top + &#39;px&#39;;\n      }\n    }\n\n    /** \n     * 松开鼠标事件\n     * @param evt 事件形参 \n     */\n    document.onmouseup = function (evt) {\n      if (drag) {\n        //卸载样式\n        drag.style.cursor = &#39;&#39;;\n        drag.style.border = &#39;dashed 1px #ccc&#39;;\n      }\n      drag = null;\n    }\n  }</code></pre>\n"},{"title":"函数式编程-基本理论","date":"2019-07-12T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 什么是函数式编程\n\n函数式编程主要是范畴论数学中的一个分支，它认为所有的概念体系都可以抽象成一个个范畴，属于结构化编程的一种。运算过程尽量写成一系列嵌套的函数调用 <br/>\n```js\n//  函数式编程\nvar result = subtract(multiply(add(1,2), 3), 4);\n\n// 过程编程\nvar a = add(1,2);\nvar b = multiply(a, 3);\nvar c = subtract(b, 4);\n```\n\n### 为什么学习函数式编程\n\n其实个人觉的学习函数式编程就是为了更好的模块化，使其看起来更简洁。这也是<a href=\"http://en.wikipedia.org/wiki/Programming_paradigm\">范式编程</a>和<a href=\"http://en.wikipedia.org/wiki/Structured_programming\">结构化编程</a>的主要思想\n\n### 函数式编程特点\n\n1. 函数是\"第一等公民\"\n2. 只用表达式，不用语句\n3. 没有副作用（函数要保持独立，所有功能就是返回一个新的值，没有其他行为，更不能修改外部状态的值）\n4. 不修改状态（可以使用参数来保存状态，不可以使用变量来保存状态）\n5. 引用透明（函数运行只靠参数）\n\n### 函数式编程的优点\n\n1. 代码更简洁，易于理解，维护更方便\n2. 易于并发编程（由于不修改变量所以不存在锁线程的问题）\n3. 代码的热升级\n\n","source":"_posts/javascript/functionalBase.md","raw":"---\ntitle: 函数式编程-基本理论\ndate: 2019-7-12 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- 函数式编程\ncategories:\n- 函数式编程\n---\n\n### 什么是函数式编程\n\n函数式编程主要是范畴论数学中的一个分支，它认为所有的概念体系都可以抽象成一个个范畴，属于结构化编程的一种。运算过程尽量写成一系列嵌套的函数调用 <br/>\n```js\n//  函数式编程\nvar result = subtract(multiply(add(1,2), 3), 4);\n\n// 过程编程\nvar a = add(1,2);\nvar b = multiply(a, 3);\nvar c = subtract(b, 4);\n```\n\n### 为什么学习函数式编程\n\n其实个人觉的学习函数式编程就是为了更好的模块化，使其看起来更简洁。这也是<a href=\"http://en.wikipedia.org/wiki/Programming_paradigm\">范式编程</a>和<a href=\"http://en.wikipedia.org/wiki/Structured_programming\">结构化编程</a>的主要思想\n\n### 函数式编程特点\n\n1. 函数是\"第一等公民\"\n2. 只用表达式，不用语句\n3. 没有副作用（函数要保持独立，所有功能就是返回一个新的值，没有其他行为，更不能修改外部状态的值）\n4. 不修改状态（可以使用参数来保存状态，不可以使用变量来保存状态）\n5. 引用透明（函数运行只靠参数）\n\n### 函数式编程的优点\n\n1. 代码更简洁，易于理解，维护更方便\n2. 易于并发编程（由于不修改变量所以不存在锁线程的问题）\n3. 代码的热升级\n\n","slug":"javascript/functionalBase","published":1,"updated":"2019-10-15T01:29:42.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8or70015b0u6en5azt3s","content":"<h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><p>函数式编程主要是范畴论数学中的一个分支，它认为所有的概念体系都可以抽象成一个个范畴，属于结构化编程的一种。运算过程尽量写成一系列嵌套的函数调用 <br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//  函数式编程</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span><span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 过程编程</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"为什么学习函数式编程\"><a href=\"#为什么学习函数式编程\" class=\"headerlink\" title=\"为什么学习函数式编程\"></a>为什么学习函数式编程</h3><p>其实个人觉的学习函数式编程就是为了更好的模块化，使其看起来更简洁。这也是<a href=\"http://en.wikipedia.org/wiki/Programming_paradigm\" target=\"_blank\" rel=\"noopener\">范式编程</a>和<a href=\"http://en.wikipedia.org/wiki/Structured_programming\" target=\"_blank\" rel=\"noopener\">结构化编程</a>的主要思想</p>\n<h3 id=\"函数式编程特点\"><a href=\"#函数式编程特点\" class=\"headerlink\" title=\"函数式编程特点\"></a>函数式编程特点</h3><ol>\n<li>函数是”第一等公民”</li>\n<li>只用表达式，不用语句</li>\n<li>没有副作用（函数要保持独立，所有功能就是返回一个新的值，没有其他行为，更不能修改外部状态的值）</li>\n<li>不修改状态（可以使用参数来保存状态，不可以使用变量来保存状态）</li>\n<li>引用透明（函数运行只靠参数）</li>\n</ol>\n<h3 id=\"函数式编程的优点\"><a href=\"#函数式编程的优点\" class=\"headerlink\" title=\"函数式编程的优点\"></a>函数式编程的优点</h3><ol>\n<li>代码更简洁，易于理解，维护更方便</li>\n<li>易于并发编程（由于不修改变量所以不存在锁线程的问题）</li>\n<li>代码的热升级</li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><p>函数式编程主要是范畴论数学中的一个分支，它认为所有的概念体系都可以抽象成一个个范畴，属于结构化编程的一种。运算过程尽量写成一系列嵌套的函数调用 <br></p>\n<pre><code class=\"js\">//  函数式编程\nvar result = subtract(multiply(add(1,2), 3), 4);\n\n// 过程编程\nvar a = add(1,2);\nvar b = multiply(a, 3);\nvar c = subtract(b, 4);</code></pre>\n<h3 id=\"为什么学习函数式编程\"><a href=\"#为什么学习函数式编程\" class=\"headerlink\" title=\"为什么学习函数式编程\"></a>为什么学习函数式编程</h3><p>其实个人觉的学习函数式编程就是为了更好的模块化，使其看起来更简洁。这也是<a href=\"http://en.wikipedia.org/wiki/Programming_paradigm\" target=\"_blank\" rel=\"noopener\">范式编程</a>和<a href=\"http://en.wikipedia.org/wiki/Structured_programming\" target=\"_blank\" rel=\"noopener\">结构化编程</a>的主要思想</p>\n<h3 id=\"函数式编程特点\"><a href=\"#函数式编程特点\" class=\"headerlink\" title=\"函数式编程特点\"></a>函数式编程特点</h3><ol>\n<li>函数是”第一等公民”</li>\n<li>只用表达式，不用语句</li>\n<li>没有副作用（函数要保持独立，所有功能就是返回一个新的值，没有其他行为，更不能修改外部状态的值）</li>\n<li>不修改状态（可以使用参数来保存状态，不可以使用变量来保存状态）</li>\n<li>引用透明（函数运行只靠参数）</li>\n</ol>\n<h3 id=\"函数式编程的优点\"><a href=\"#函数式编程的优点\" class=\"headerlink\" title=\"函数式编程的优点\"></a>函数式编程的优点</h3><ol>\n<li>代码更简洁，易于理解，维护更方便</li>\n<li>易于并发编程（由于不修改变量所以不存在锁线程的问题）</li>\n<li>代码的热升级</li>\n</ol>\n"},{"title":"函数式编程-纯函数","date":"2019-07-15T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"### 概念\n\n说纯函数概念之前我们再来复习一下什么是函数\n\n函数是一个方法，有一些输入，称为变量，并产生一些输出称为返回值\n\n函数可以用于以下目的\n1. 映射：根据给定的输入生成一些输出，函数将输入值映射到输出值上\n2. 过程：调用函数按照一系列的步骤来执行。这就是我们说的过程编程\n3. I/O：与系统其他部分通信的功能。如存储系统日志，网络等\n\n纯函数都是关于映射的所以对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。\n\n```js\n// 纯函数\nconst double = x => x * 2;\nconsole.log（double（5））\n\n// 不纯\nlet val = 2;\nconst double = x => x * val;\nconsole.log（double（5））\n\n// 不纯\nMath.random()\nMath.random()\n```\n\n\n### 函数式编程-纯函数\n\n纯函数的优点<br/>\n1. 独立于外部状态，所以不会受外部全局环境的影响而产生的错误或者副作用\n2. 由于其独立，所以易于重构和重组和重用，使程序更加灵活\n\n\n### 函数式编程-幂等性\n执行多次所产生的影响均与一次执行的影响相同，也就是说执行一次和执行多次对系统内部的状态影响是一样的 <br/>\n```js\nclass Person {\n  constructor () {\n    this.name = name;\n  },\n  sayName () {\n    console.log(my name is + this.name);\n  } \n}\nvar person = new Person(zhangsan)\nperson.sayName();\nperson.sayName();\n```\n\n### 纯函数和幂等性的区别\n\n1. 法调用多次对内部的状态影响是一样的，则这么方法就具有幂等性，在函数式编程中，纯函数也具有幂等性，但具有幂等性的函数却不一定是纯函数。\n2. 纯函数主要强调相同的输入，多次调用，输出也相同且无副作用，而幂等主要强调多次调用，对内部的状态的影响是一样的，调用返回值可能不同。\n\n","source":"_posts/javascript/functionalPurity.md","raw":"---\ntitle: 函数式编程-纯函数\ndate: 2019-7-15 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- 函数式编程\ncategories:\n- 函数式编程\n---\n### 概念\n\n说纯函数概念之前我们再来复习一下什么是函数\n\n函数是一个方法，有一些输入，称为变量，并产生一些输出称为返回值\n\n函数可以用于以下目的\n1. 映射：根据给定的输入生成一些输出，函数将输入值映射到输出值上\n2. 过程：调用函数按照一系列的步骤来执行。这就是我们说的过程编程\n3. I/O：与系统其他部分通信的功能。如存储系统日志，网络等\n\n纯函数都是关于映射的所以对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。\n\n```js\n// 纯函数\nconst double = x => x * 2;\nconsole.log（double（5））\n\n// 不纯\nlet val = 2;\nconst double = x => x * val;\nconsole.log（double（5））\n\n// 不纯\nMath.random()\nMath.random()\n```\n\n\n### 函数式编程-纯函数\n\n纯函数的优点<br/>\n1. 独立于外部状态，所以不会受外部全局环境的影响而产生的错误或者副作用\n2. 由于其独立，所以易于重构和重组和重用，使程序更加灵活\n\n\n### 函数式编程-幂等性\n执行多次所产生的影响均与一次执行的影响相同，也就是说执行一次和执行多次对系统内部的状态影响是一样的 <br/>\n```js\nclass Person {\n  constructor () {\n    this.name = name;\n  },\n  sayName () {\n    console.log(my name is + this.name);\n  } \n}\nvar person = new Person(zhangsan)\nperson.sayName();\nperson.sayName();\n```\n\n### 纯函数和幂等性的区别\n\n1. 法调用多次对内部的状态影响是一样的，则这么方法就具有幂等性，在函数式编程中，纯函数也具有幂等性，但具有幂等性的函数却不一定是纯函数。\n2. 纯函数主要强调相同的输入，多次调用，输出也相同且无副作用，而幂等主要强调多次调用，对内部的状态的影响是一样的，调用返回值可能不同。\n\n","slug":"javascript/functionalPurity","published":1,"updated":"2019-10-15T01:29:42.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8or90019b0u6ty5zoaht","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>说纯函数概念之前我们再来复习一下什么是函数</p>\n<p>函数是一个方法，有一些输入，称为变量，并产生一些输出称为返回值</p>\n<p>函数可以用于以下目的</p>\n<ol>\n<li>映射：根据给定的输入生成一些输出，函数将输入值映射到输出值上</li>\n<li>过程：调用函数按照一系列的步骤来执行。这就是我们说的过程编程</li>\n<li>I/O：与系统其他部分通信的功能。如存储系统日志，网络等</li>\n</ol>\n<p>纯函数都是关于映射的所以对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 纯函数</span>\n<span class=\"token keyword\">const</span> double <span class=\"token operator\">=</span> x <span class=\"token operator\">=</span><span class=\"token operator\">></span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span>log（double（<span class=\"token number\">5</span>））\n\n<span class=\"token comment\" spellcheck=\"true\">// 不纯</span>\n<span class=\"token keyword\">let</span> val <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> double <span class=\"token operator\">=</span> x <span class=\"token operator\">=</span><span class=\"token operator\">></span> x <span class=\"token operator\">*</span> val<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span>log（double（<span class=\"token number\">5</span>））\n\n<span class=\"token comment\" spellcheck=\"true\">// 不纯</span>\nMath<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nMath<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数式编程-纯函数\"><a href=\"#函数式编程-纯函数\" class=\"headerlink\" title=\"函数式编程-纯函数\"></a>函数式编程-纯函数</h3><p>纯函数的优点<br></p>\n<ol>\n<li>独立于外部状态，所以不会受外部全局环境的影响而产生的错误或者副作用</li>\n<li>由于其独立，所以易于重构和重组和重用，使程序更加灵活</li>\n</ol>\n<h3 id=\"函数式编程-幂等性\"><a href=\"#函数式编程-幂等性\" class=\"headerlink\" title=\"函数式编程-幂等性\"></a>函数式编程-幂等性</h3><p>执行多次所产生的影响均与一次执行的影响相同，也就是说执行一次和执行多次对系统内部的状态影响是一样的 <br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  constructor <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  sayName <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>my name is <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span>zhangsan<span class=\"token punctuation\">)</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"纯函数和幂等性的区别\"><a href=\"#纯函数和幂等性的区别\" class=\"headerlink\" title=\"纯函数和幂等性的区别\"></a>纯函数和幂等性的区别</h3><ol>\n<li>法调用多次对内部的状态影响是一样的，则这么方法就具有幂等性，在函数式编程中，纯函数也具有幂等性，但具有幂等性的函数却不一定是纯函数。</li>\n<li>纯函数主要强调相同的输入，多次调用，输出也相同且无副作用，而幂等主要强调多次调用，对内部的状态的影响是一样的，调用返回值可能不同。</li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>说纯函数概念之前我们再来复习一下什么是函数</p>\n<p>函数是一个方法，有一些输入，称为变量，并产生一些输出称为返回值</p>\n<p>函数可以用于以下目的</p>\n<ol>\n<li>映射：根据给定的输入生成一些输出，函数将输入值映射到输出值上</li>\n<li>过程：调用函数按照一系列的步骤来执行。这就是我们说的过程编程</li>\n<li>I/O：与系统其他部分通信的功能。如存储系统日志，网络等</li>\n</ol>\n<p>纯函数都是关于映射的所以对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p>\n<pre><code class=\"js\">// 纯函数\nconst double = x =&gt; x * 2;\nconsole.log（double（5））\n\n// 不纯\nlet val = 2;\nconst double = x =&gt; x * val;\nconsole.log（double（5））\n\n// 不纯\nMath.random()\nMath.random()</code></pre>\n<h3 id=\"函数式编程-纯函数\"><a href=\"#函数式编程-纯函数\" class=\"headerlink\" title=\"函数式编程-纯函数\"></a>函数式编程-纯函数</h3><p>纯函数的优点<br></p>\n<ol>\n<li>独立于外部状态，所以不会受外部全局环境的影响而产生的错误或者副作用</li>\n<li>由于其独立，所以易于重构和重组和重用，使程序更加灵活</li>\n</ol>\n<h3 id=\"函数式编程-幂等性\"><a href=\"#函数式编程-幂等性\" class=\"headerlink\" title=\"函数式编程-幂等性\"></a>函数式编程-幂等性</h3><p>执行多次所产生的影响均与一次执行的影响相同，也就是说执行一次和执行多次对系统内部的状态影响是一样的 <br></p>\n<pre><code class=\"js\">class Person {\n  constructor () {\n    this.name = name;\n  },\n  sayName () {\n    console.log(my name is + this.name);\n  } \n}\nvar person = new Person(zhangsan)\nperson.sayName();\nperson.sayName();</code></pre>\n<h3 id=\"纯函数和幂等性的区别\"><a href=\"#纯函数和幂等性的区别\" class=\"headerlink\" title=\"纯函数和幂等性的区别\"></a>纯函数和幂等性的区别</h3><ol>\n<li>法调用多次对内部的状态影响是一样的，则这么方法就具有幂等性，在函数式编程中，纯函数也具有幂等性，但具有幂等性的函数却不一定是纯函数。</li>\n<li>纯函数主要强调相同的输入，多次调用，输出也相同且无副作用，而幂等主要强调多次调用，对内部的状态的影响是一样的，调用返回值可能不同。</li>\n</ol>\n"},{"title":"函数式编程-Point Free","date":"2019-07-25T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"### 概念\n\nPoint-free 是一种编程风格，其中函数定义不引用函数的参数。不用关心将要操作的数据是什样的。我们来看看 JavaScript 中的函数定义\n\n```js\n// 表达式\nfunction foo (/* parameters are declared here*/) {}\n\n// 声明式\nconst foo = (/* parameters are declared here */) => // ...\nconst foo = function (/* parameters are declared here */) {}\n```\n\n\n如何在不引用所需参数的情况下在 JavaScript 中定义函数？我们不能使用 functionkeyword，也不能使用箭头函数（=>），因为它们需要声明形参（这将引用它的参数）。所以我们需要做的是调用一个返回函数的函数<br/>\n\n### demo1\n\n\n```js\n// 非 Point-free. 因为函数引用了参数name\nvar greet = function(name) {\n  return ('hello ' + name).toUpperCase();\n}\n\n// Point-free 先定义基本的函数，不用关心中间变量str是什么，抽象基本结构\nvar toUpperCase = str => str.toUpperCase();\nvar hello = str => `hello ${str}`; \n\nvar greet = compose(hello, toUpperCase);\ngreet('renbo');\n```\n### demo2\n\n这个例子来自于<a href=\"https://fr.umio.us/favoring-curry/\">Favoring Curry</a><br/>\n假设我们从服务器获取这样的数据：\n\n```js\nvar data = {\n  result: \"SUCCESS\",\n  tasks: [\n    {id: 104, complete: false,            priority: \"high\",\n              dueDate: \"2013-11-29\",      username: \"Scott\",\n              title: \"Do something\",      created: \"9/22/2013\"},\n    {id: 105, complete: false,            priority: \"medium\",\n              dueDate: \"2013-11-22\",      username: \"Lena\",\n              title: \"Do something else\", created: \"9/22/2013\"},\n    {id: 107, complete: true,             priority: \"high\",\n              dueDate: \"2013-11-22\",      username: \"Mike\",\n              title: \"Fix the foo\",       created: \"9/22/2013\"},\n    {id: 108, complete: false,            priority: \"low\",\n              dueDate: \"2013-11-15\",      username: \"Punam\",\n              title: \"Adjust the bar\",    created: \"9/25/2013\"},\n    {id: 110, complete: false,            priority: \"medium\",\n              dueDate: \"2013-11-15\",      username: \"Scott\",\n              title: \"Rename everything\", created: \"10/2/2013\"},\n    {id: 112, complete: true,             priority: \"high\",\n              dueDate: \"2013-11-27\",      username: \"Lena\",\n              title: \"Alter all quuxes\",  created: \"10/5/2013\"}\n  ]\n};\n```\n\n\n### getIncompleteTaskSummaries 函数\n\n我们需要一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据之后筛选出这个用户未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。<br/>\n\n以 Scott 为例，最终筛选出的数据为<br/>\n```js\n[\n    {id: 110, title: \"Rename everything\", \n        dueDate: \"2013-11-15\", priority: \"medium\"},\n    {id: 104, title: \"Do something\", \n        dueDate: \"2013-11-29\", priority: \"high\"}\n]\n```\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n     return fetchData()\n         .then(function(data) {\n             return data.tasks;\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return task.username == membername\n             })\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return !task.complete\n             })\n         })\n         .then(function(tasks) {\n             return tasks.map(function(task) {\n                 return {\n                     id: task.id,\n                     dueDate: task.dueDate,\n                     title: task.title,\n                     priority: task.priority\n                 }\n             })\n         })\n         .then(function(tasks) {\n             return tasks.sort(function(first, second) {\n                 var a = first.dueDate,\n                     b = second.dueDate;\n                 return a < b ? -1 : a > b ? 1 : 0;\n             });\n         })\n         .then(function(task) {\n             console.log(task)\n         })\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### Point-free 模式<br/>\n\n```js\n// 拆分基础函数\ncurry 为封装的通用 curry 韩式\nvar prop = curry(function(name, obj) {\n    return obj[name];\n});\n\nvar propEq = curry(function(name, val, obj) {\n    return obj[name] === val;\n});\n\nvar filter = curry(function(fn, arr) {\n    return arr.filter(fn)\n});\n\nvar map = curry(function(fn, arr) {\n    return arr.map(fn)\n});\n\nvar pick = curry(function(args, obj){\n    var result = {};\n    for (var i = 0; i < args.length; i++) {\n        result[args[i]] = obj[args[i]]\n    }\n    return result;\n});\n\nvar sortBy = curry(function(fn, arr) {\n    return arr.sort(function(a, b){\n        var a = fn(a),\n            b = fn(b);\n        return a < b ? -1 : a > b ? 1 : 0;\n    })\n});\n// 拼装\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(prop('tasks'))\n        .then(filter(propEq('username', membername)))\n        .then(filter(propEq('complete', false)))\n        .then(map(pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(sortBy(prop('dueDate')))\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### 利用 ramda.js 实现 getIncompleteTaskSummarie\n\n如果直接使用 ramda.js，你可以省去编写基本函数<br/>\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.prop('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.filter(R.propEq('complete', false)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.prop('dueDate')))\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### 利用 compose 实现 getIncompleteTaskSummaries\n\n可以从左到右\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.compose(\n            R.sortBy(R.prop('dueDate')),\n            R.map(R.pick(['id', 'dueDate', 'title', 'priority'])),\n            R.filter(R.propEq('complete', false)),\n            R.filter(R.propEq('username', membername)),\n            R.prop('tasks')\n        ))\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### 利用 ramda.js 提供的 R.pipe 函数\n\n可以从左到右\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n      .then(R.pipe(\n          R.prop('tasks'),\n          R.filter(R.propEq('username', membername)),\n          R.filter(R.propEq('complete', false)),\n          R.map(R.pick(['id', 'dueDate', 'title', 'priority']),\n          R.sortBy(R.prop('dueDate'))\n      ))\n};\n```\n\n\n\n\n\n\n","source":"_posts/javascript/functionalPoint.md","raw":"---\ntitle: 函数式编程-Point Free\ndate: 2019-7-25 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- 函数式编程\ncategories:\n- 函数式编程\n---\n### 概念\n\nPoint-free 是一种编程风格，其中函数定义不引用函数的参数。不用关心将要操作的数据是什样的。我们来看看 JavaScript 中的函数定义\n\n```js\n// 表达式\nfunction foo (/* parameters are declared here*/) {}\n\n// 声明式\nconst foo = (/* parameters are declared here */) => // ...\nconst foo = function (/* parameters are declared here */) {}\n```\n\n\n如何在不引用所需参数的情况下在 JavaScript 中定义函数？我们不能使用 functionkeyword，也不能使用箭头函数（=>），因为它们需要声明形参（这将引用它的参数）。所以我们需要做的是调用一个返回函数的函数<br/>\n\n### demo1\n\n\n```js\n// 非 Point-free. 因为函数引用了参数name\nvar greet = function(name) {\n  return ('hello ' + name).toUpperCase();\n}\n\n// Point-free 先定义基本的函数，不用关心中间变量str是什么，抽象基本结构\nvar toUpperCase = str => str.toUpperCase();\nvar hello = str => `hello ${str}`; \n\nvar greet = compose(hello, toUpperCase);\ngreet('renbo');\n```\n### demo2\n\n这个例子来自于<a href=\"https://fr.umio.us/favoring-curry/\">Favoring Curry</a><br/>\n假设我们从服务器获取这样的数据：\n\n```js\nvar data = {\n  result: \"SUCCESS\",\n  tasks: [\n    {id: 104, complete: false,            priority: \"high\",\n              dueDate: \"2013-11-29\",      username: \"Scott\",\n              title: \"Do something\",      created: \"9/22/2013\"},\n    {id: 105, complete: false,            priority: \"medium\",\n              dueDate: \"2013-11-22\",      username: \"Lena\",\n              title: \"Do something else\", created: \"9/22/2013\"},\n    {id: 107, complete: true,             priority: \"high\",\n              dueDate: \"2013-11-22\",      username: \"Mike\",\n              title: \"Fix the foo\",       created: \"9/22/2013\"},\n    {id: 108, complete: false,            priority: \"low\",\n              dueDate: \"2013-11-15\",      username: \"Punam\",\n              title: \"Adjust the bar\",    created: \"9/25/2013\"},\n    {id: 110, complete: false,            priority: \"medium\",\n              dueDate: \"2013-11-15\",      username: \"Scott\",\n              title: \"Rename everything\", created: \"10/2/2013\"},\n    {id: 112, complete: true,             priority: \"high\",\n              dueDate: \"2013-11-27\",      username: \"Lena\",\n              title: \"Alter all quuxes\",  created: \"10/5/2013\"}\n  ]\n};\n```\n\n\n### getIncompleteTaskSummaries 函数\n\n我们需要一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据之后筛选出这个用户未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。<br/>\n\n以 Scott 为例，最终筛选出的数据为<br/>\n```js\n[\n    {id: 110, title: \"Rename everything\", \n        dueDate: \"2013-11-15\", priority: \"medium\"},\n    {id: 104, title: \"Do something\", \n        dueDate: \"2013-11-29\", priority: \"high\"}\n]\n```\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n     return fetchData()\n         .then(function(data) {\n             return data.tasks;\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return task.username == membername\n             })\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return !task.complete\n             })\n         })\n         .then(function(tasks) {\n             return tasks.map(function(task) {\n                 return {\n                     id: task.id,\n                     dueDate: task.dueDate,\n                     title: task.title,\n                     priority: task.priority\n                 }\n             })\n         })\n         .then(function(tasks) {\n             return tasks.sort(function(first, second) {\n                 var a = first.dueDate,\n                     b = second.dueDate;\n                 return a < b ? -1 : a > b ? 1 : 0;\n             });\n         })\n         .then(function(task) {\n             console.log(task)\n         })\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### Point-free 模式<br/>\n\n```js\n// 拆分基础函数\ncurry 为封装的通用 curry 韩式\nvar prop = curry(function(name, obj) {\n    return obj[name];\n});\n\nvar propEq = curry(function(name, val, obj) {\n    return obj[name] === val;\n});\n\nvar filter = curry(function(fn, arr) {\n    return arr.filter(fn)\n});\n\nvar map = curry(function(fn, arr) {\n    return arr.map(fn)\n});\n\nvar pick = curry(function(args, obj){\n    var result = {};\n    for (var i = 0; i < args.length; i++) {\n        result[args[i]] = obj[args[i]]\n    }\n    return result;\n});\n\nvar sortBy = curry(function(fn, arr) {\n    return arr.sort(function(a, b){\n        var a = fn(a),\n            b = fn(b);\n        return a < b ? -1 : a > b ? 1 : 0;\n    })\n});\n// 拼装\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(prop('tasks'))\n        .then(filter(propEq('username', membername)))\n        .then(filter(propEq('complete', false)))\n        .then(map(pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(sortBy(prop('dueDate')))\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### 利用 ramda.js 实现 getIncompleteTaskSummarie\n\n如果直接使用 ramda.js，你可以省去编写基本函数<br/>\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.prop('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.filter(R.propEq('complete', false)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.prop('dueDate')))\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### 利用 compose 实现 getIncompleteTaskSummaries\n\n可以从左到右\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.compose(\n            R.sortBy(R.prop('dueDate')),\n            R.map(R.pick(['id', 'dueDate', 'title', 'priority'])),\n            R.filter(R.propEq('complete', false)),\n            R.filter(R.propEq('username', membername)),\n            R.prop('tasks')\n        ))\n};\n\ngetIncompleteTaskSummaries('Scott')\n```\n\n### 利用 ramda.js 提供的 R.pipe 函数\n\n可以从左到右\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n      .then(R.pipe(\n          R.prop('tasks'),\n          R.filter(R.propEq('username', membername)),\n          R.filter(R.propEq('complete', false)),\n          R.map(R.pick(['id', 'dueDate', 'title', 'priority']),\n          R.sortBy(R.prop('dueDate'))\n      ))\n};\n```\n\n\n\n\n\n\n","slug":"javascript/functionalPoint","published":1,"updated":"2019-10-15T01:29:42.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ora001bb0u6jwzyur5t","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>Point-free 是一种编程风格，其中函数定义不引用函数的参数。不用关心将要操作的数据是什样的。我们来看看 JavaScript 中的函数定义</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 表达式</span>\n<span class=\"token keyword\">function</span> foo <span class=\"token punctuation\">(</span><span class=\"token comment\" spellcheck=\"true\">/* parameters are declared here*/</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 声明式</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token comment\" spellcheck=\"true\">/* parameters are declared here */</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token comment\" spellcheck=\"true\">/* parameters are declared here */</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如何在不引用所需参数的情况下在 JavaScript 中定义函数？我们不能使用 functionkeyword，也不能使用箭头函数（=&gt;），因为它们需要声明形参（这将引用它的参数）。所以我们需要做的是调用一个返回函数的函数<br></p>\n<h3 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 非 Point-free. 因为函数引用了参数name</span>\n<span class=\"token keyword\">var</span> greet <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'hello '</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Point-free 先定义基本的函数，不用关心中间变量str是什么，抽象基本结构</span>\n<span class=\"token keyword\">var</span> toUpperCase <span class=\"token operator\">=</span> str <span class=\"token operator\">=</span><span class=\"token operator\">></span> str<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> hello <span class=\"token operator\">=</span> str <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token template-string\"><span class=\"token string\">`hello </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>str<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">var</span> greet <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>hello<span class=\"token punctuation\">,</span> toUpperCase<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">'renbo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h3><p>这个例子来自于<a href=\"https://fr.umio.us/favoring-curry/\" target=\"_blank\" rel=\"noopener\">Favoring Curry</a><br><br>假设我们从服务器获取这样的数据：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  result<span class=\"token punctuation\">:</span> <span class=\"token string\">\"SUCCESS\"</span><span class=\"token punctuation\">,</span>\n  tasks<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">104</span><span class=\"token punctuation\">,</span> complete<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>            priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"high\"</span><span class=\"token punctuation\">,</span>\n              dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-29\"</span><span class=\"token punctuation\">,</span>      username<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Scott\"</span><span class=\"token punctuation\">,</span>\n              title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Do something\"</span><span class=\"token punctuation\">,</span>      created<span class=\"token punctuation\">:</span> <span class=\"token string\">\"9/22/2013\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">105</span><span class=\"token punctuation\">,</span> complete<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>            priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"medium\"</span><span class=\"token punctuation\">,</span>\n              dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-22\"</span><span class=\"token punctuation\">,</span>      username<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Lena\"</span><span class=\"token punctuation\">,</span>\n              title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Do something else\"</span><span class=\"token punctuation\">,</span> created<span class=\"token punctuation\">:</span> <span class=\"token string\">\"9/22/2013\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">107</span><span class=\"token punctuation\">,</span> complete<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>             priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"high\"</span><span class=\"token punctuation\">,</span>\n              dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-22\"</span><span class=\"token punctuation\">,</span>      username<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Mike\"</span><span class=\"token punctuation\">,</span>\n              title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Fix the foo\"</span><span class=\"token punctuation\">,</span>       created<span class=\"token punctuation\">:</span> <span class=\"token string\">\"9/22/2013\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">108</span><span class=\"token punctuation\">,</span> complete<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>            priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"low\"</span><span class=\"token punctuation\">,</span>\n              dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-15\"</span><span class=\"token punctuation\">,</span>      username<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Punam\"</span><span class=\"token punctuation\">,</span>\n              title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Adjust the bar\"</span><span class=\"token punctuation\">,</span>    created<span class=\"token punctuation\">:</span> <span class=\"token string\">\"9/25/2013\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">110</span><span class=\"token punctuation\">,</span> complete<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>            priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"medium\"</span><span class=\"token punctuation\">,</span>\n              dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-15\"</span><span class=\"token punctuation\">,</span>      username<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Scott\"</span><span class=\"token punctuation\">,</span>\n              title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Rename everything\"</span><span class=\"token punctuation\">,</span> created<span class=\"token punctuation\">:</span> <span class=\"token string\">\"10/2/2013\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">112</span><span class=\"token punctuation\">,</span> complete<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>             priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"high\"</span><span class=\"token punctuation\">,</span>\n              dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-27\"</span><span class=\"token punctuation\">,</span>      username<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Lena\"</span><span class=\"token punctuation\">,</span>\n              title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Alter all quuxes\"</span><span class=\"token punctuation\">,</span>  created<span class=\"token punctuation\">:</span> <span class=\"token string\">\"10/5/2013\"</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"getIncompleteTaskSummaries-函数\"><a href=\"#getIncompleteTaskSummaries-函数\" class=\"headerlink\" title=\"getIncompleteTaskSummaries 函数\"></a>getIncompleteTaskSummaries 函数</h3><p>我们需要一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据之后筛选出这个用户未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。<br></p>\n<p>以 Scott 为例，最终筛选出的数据为<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">110</span><span class=\"token punctuation\">,</span> title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Rename everything\"</span><span class=\"token punctuation\">,</span> \n        dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-15\"</span><span class=\"token punctuation\">,</span> priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"medium\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>id<span class=\"token punctuation\">:</span> <span class=\"token number\">104</span><span class=\"token punctuation\">,</span> title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Do something\"</span><span class=\"token punctuation\">,</span> \n        dueDate<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2013-11-29\"</span><span class=\"token punctuation\">,</span> priority<span class=\"token punctuation\">:</span> <span class=\"token string\">\"high\"</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> getIncompleteTaskSummaries <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>membername<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span>tasks<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>tasks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">return</span> tasks<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">return</span> task<span class=\"token punctuation\">.</span>username <span class=\"token operator\">==</span> membername\n             <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>tasks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">return</span> tasks<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>task<span class=\"token punctuation\">.</span>complete\n             <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>tasks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">return</span> tasks<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n                     id<span class=\"token punctuation\">:</span> task<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n                     dueDate<span class=\"token punctuation\">:</span> task<span class=\"token punctuation\">.</span>dueDate<span class=\"token punctuation\">,</span>\n                     title<span class=\"token punctuation\">:</span> task<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">,</span>\n                     priority<span class=\"token punctuation\">:</span> task<span class=\"token punctuation\">.</span>priority\n                 <span class=\"token punctuation\">}</span>\n             <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>tasks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">return</span> tasks<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>dueDate<span class=\"token punctuation\">,</span>\n                     b <span class=\"token operator\">=</span> second<span class=\"token punctuation\">.</span>dueDate<span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> a <span class=\"token operator\">></span> b <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">getIncompleteTaskSummaries</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Scott'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"Point-free-模式\"><a href=\"#Point-free-模式\" class=\"headerlink\" title=\"Point-free 模式\"></a>Point-free 模式<br></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 拆分基础函数</span>\ncurry 为封装的通用 curry 韩式\n<span class=\"token keyword\">var</span> prop <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> propEq <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> filter <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> map <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> pick <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> args<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        result<span class=\"token punctuation\">[</span>args<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">[</span>args<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> sortBy <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            b <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> a <span class=\"token operator\">></span> b <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 拼装</span>\n<span class=\"token keyword\">var</span> getIncompleteTaskSummaries <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>membername<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'tasks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'username'</span><span class=\"token punctuation\">,</span> membername<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'complete'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token function\">pick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'priority'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">getIncompleteTaskSummaries</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Scott'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"利用-ramda-js-实现-getIncompleteTaskSummarie\"><a href=\"#利用-ramda-js-实现-getIncompleteTaskSummarie\" class=\"headerlink\" title=\"利用 ramda.js 实现 getIncompleteTaskSummarie\"></a>利用 ramda.js 实现 getIncompleteTaskSummarie</h3><p>如果直接使用 ramda.js，你可以省去编写基本函数<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> getIncompleteTaskSummaries <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>membername<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'tasks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'username'</span><span class=\"token punctuation\">,</span> membername<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'complete'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">pick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'priority'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">getIncompleteTaskSummaries</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Scott'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"利用-compose-实现-getIncompleteTaskSummaries\"><a href=\"#利用-compose-实现-getIncompleteTaskSummaries\" class=\"headerlink\" title=\"利用 compose 实现 getIncompleteTaskSummaries\"></a>利用 compose 实现 getIncompleteTaskSummaries</h3><p>可以从左到右</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> getIncompleteTaskSummaries <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>membername<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>\n            R<span class=\"token punctuation\">.</span><span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            R<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">pick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'priority'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            R<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'complete'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            R<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'username'</span><span class=\"token punctuation\">,</span> membername<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            R<span class=\"token punctuation\">.</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'tasks'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">getIncompleteTaskSummaries</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Scott'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"利用-ramda-js-提供的-R-pipe-函数\"><a href=\"#利用-ramda-js-提供的-R-pipe-函数\" class=\"headerlink\" title=\"利用 ramda.js 提供的 R.pipe 函数\"></a>利用 ramda.js 提供的 R.pipe 函数</h3><p>可以从左到右</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> getIncompleteTaskSummaries <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>membername<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>\n          R<span class=\"token punctuation\">.</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'tasks'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          R<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'username'</span><span class=\"token punctuation\">,</span> membername<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          R<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">propEq</span><span class=\"token punctuation\">(</span><span class=\"token string\">'complete'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          R<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">pick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'priority'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          R<span class=\"token punctuation\">.</span><span class=\"token function\">sortBy</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span><span class=\"token function\">prop</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dueDate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>Point-free 是一种编程风格，其中函数定义不引用函数的参数。不用关心将要操作的数据是什样的。我们来看看 JavaScript 中的函数定义</p>\n<pre><code class=\"js\">// 表达式\nfunction foo (/* parameters are declared here*/) {}\n\n// 声明式\nconst foo = (/* parameters are declared here */) =&gt; // ...\nconst foo = function (/* parameters are declared here */) {}</code></pre>\n<p>如何在不引用所需参数的情况下在 JavaScript 中定义函数？我们不能使用 functionkeyword，也不能使用箭头函数（=&gt;），因为它们需要声明形参（这将引用它的参数）。所以我们需要做的是调用一个返回函数的函数<br></p>\n<h3 id=\"demo1\"><a href=\"#demo1\" class=\"headerlink\" title=\"demo1\"></a>demo1</h3><pre><code class=\"js\">// 非 Point-free. 因为函数引用了参数name\nvar greet = function(name) {\n  return (&#39;hello &#39; + name).toUpperCase();\n}\n\n// Point-free 先定义基本的函数，不用关心中间变量str是什么，抽象基本结构\nvar toUpperCase = str =&gt; str.toUpperCase();\nvar hello = str =&gt; `hello ${str}`; \n\nvar greet = compose(hello, toUpperCase);\ngreet(&#39;renbo&#39;);</code></pre>\n<h3 id=\"demo2\"><a href=\"#demo2\" class=\"headerlink\" title=\"demo2\"></a>demo2</h3><p>这个例子来自于<a href=\"https://fr.umio.us/favoring-curry/\" target=\"_blank\" rel=\"noopener\">Favoring Curry</a><br><br>假设我们从服务器获取这样的数据：</p>\n<pre><code class=\"js\">var data = {\n  result: &quot;SUCCESS&quot;,\n  tasks: [\n    {id: 104, complete: false,            priority: &quot;high&quot;,\n              dueDate: &quot;2013-11-29&quot;,      username: &quot;Scott&quot;,\n              title: &quot;Do something&quot;,      created: &quot;9/22/2013&quot;},\n    {id: 105, complete: false,            priority: &quot;medium&quot;,\n              dueDate: &quot;2013-11-22&quot;,      username: &quot;Lena&quot;,\n              title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;},\n    {id: 107, complete: true,             priority: &quot;high&quot;,\n              dueDate: &quot;2013-11-22&quot;,      username: &quot;Mike&quot;,\n              title: &quot;Fix the foo&quot;,       created: &quot;9/22/2013&quot;},\n    {id: 108, complete: false,            priority: &quot;low&quot;,\n              dueDate: &quot;2013-11-15&quot;,      username: &quot;Punam&quot;,\n              title: &quot;Adjust the bar&quot;,    created: &quot;9/25/2013&quot;},\n    {id: 110, complete: false,            priority: &quot;medium&quot;,\n              dueDate: &quot;2013-11-15&quot;,      username: &quot;Scott&quot;,\n              title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;},\n    {id: 112, complete: true,             priority: &quot;high&quot;,\n              dueDate: &quot;2013-11-27&quot;,      username: &quot;Lena&quot;,\n              title: &quot;Alter all quuxes&quot;,  created: &quot;10/5/2013&quot;}\n  ]\n};</code></pre>\n<h3 id=\"getIncompleteTaskSummaries-函数\"><a href=\"#getIncompleteTaskSummaries-函数\" class=\"headerlink\" title=\"getIncompleteTaskSummaries 函数\"></a>getIncompleteTaskSummaries 函数</h3><p>我们需要一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据之后筛选出这个用户未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。<br></p>\n<p>以 Scott 为例，最终筛选出的数据为<br></p>\n<pre><code class=\"js\">[\n    {id: 110, title: &quot;Rename everything&quot;, \n        dueDate: &quot;2013-11-15&quot;, priority: &quot;medium&quot;},\n    {id: 104, title: &quot;Do something&quot;, \n        dueDate: &quot;2013-11-29&quot;, priority: &quot;high&quot;}\n]</code></pre>\n<pre><code class=\"js\">var getIncompleteTaskSummaries = function(membername) {\n     return fetchData()\n         .then(function(data) {\n             return data.tasks;\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return task.username == membername\n             })\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return !task.complete\n             })\n         })\n         .then(function(tasks) {\n             return tasks.map(function(task) {\n                 return {\n                     id: task.id,\n                     dueDate: task.dueDate,\n                     title: task.title,\n                     priority: task.priority\n                 }\n             })\n         })\n         .then(function(tasks) {\n             return tasks.sort(function(first, second) {\n                 var a = first.dueDate,\n                     b = second.dueDate;\n                 return a &lt; b ? -1 : a &gt; b ? 1 : 0;\n             });\n         })\n         .then(function(task) {\n             console.log(task)\n         })\n};\n\ngetIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre>\n<h3 id=\"Point-free-模式\"><a href=\"#Point-free-模式\" class=\"headerlink\" title=\"Point-free 模式\"></a>Point-free 模式<br></h3><pre><code class=\"js\">// 拆分基础函数\ncurry 为封装的通用 curry 韩式\nvar prop = curry(function(name, obj) {\n    return obj[name];\n});\n\nvar propEq = curry(function(name, val, obj) {\n    return obj[name] === val;\n});\n\nvar filter = curry(function(fn, arr) {\n    return arr.filter(fn)\n});\n\nvar map = curry(function(fn, arr) {\n    return arr.map(fn)\n});\n\nvar pick = curry(function(args, obj){\n    var result = {};\n    for (var i = 0; i &lt; args.length; i++) {\n        result[args[i]] = obj[args[i]]\n    }\n    return result;\n});\n\nvar sortBy = curry(function(fn, arr) {\n    return arr.sort(function(a, b){\n        var a = fn(a),\n            b = fn(b);\n        return a &lt; b ? -1 : a &gt; b ? 1 : 0;\n    })\n});\n// 拼装\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(prop(&#39;tasks&#39;))\n        .then(filter(propEq(&#39;username&#39;, membername)))\n        .then(filter(propEq(&#39;complete&#39;, false)))\n        .then(map(pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;])))\n        .then(sortBy(prop(&#39;dueDate&#39;)))\n};\n\ngetIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre>\n<h3 id=\"利用-ramda-js-实现-getIncompleteTaskSummarie\"><a href=\"#利用-ramda-js-实现-getIncompleteTaskSummarie\" class=\"headerlink\" title=\"利用 ramda.js 实现 getIncompleteTaskSummarie\"></a>利用 ramda.js 实现 getIncompleteTaskSummarie</h3><p>如果直接使用 ramda.js，你可以省去编写基本函数<br></p>\n<pre><code class=\"js\">var getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.prop(&#39;tasks&#39;))\n        .then(R.filter(R.propEq(&#39;username&#39;, membername)))\n        .then(R.filter(R.propEq(&#39;complete&#39;, false)))\n        .then(R.map(R.pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;])))\n        .then(R.sortBy(R.prop(&#39;dueDate&#39;)))\n};\n\ngetIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre>\n<h3 id=\"利用-compose-实现-getIncompleteTaskSummaries\"><a href=\"#利用-compose-实现-getIncompleteTaskSummaries\" class=\"headerlink\" title=\"利用 compose 实现 getIncompleteTaskSummaries\"></a>利用 compose 实现 getIncompleteTaskSummaries</h3><p>可以从左到右</p>\n<pre><code class=\"js\">var getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.compose(\n            R.sortBy(R.prop(&#39;dueDate&#39;)),\n            R.map(R.pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;])),\n            R.filter(R.propEq(&#39;complete&#39;, false)),\n            R.filter(R.propEq(&#39;username&#39;, membername)),\n            R.prop(&#39;tasks&#39;)\n        ))\n};\n\ngetIncompleteTaskSummaries(&#39;Scott&#39;)</code></pre>\n<h3 id=\"利用-ramda-js-提供的-R-pipe-函数\"><a href=\"#利用-ramda-js-提供的-R-pipe-函数\" class=\"headerlink\" title=\"利用 ramda.js 提供的 R.pipe 函数\"></a>利用 ramda.js 提供的 R.pipe 函数</h3><p>可以从左到右</p>\n<pre><code class=\"js\">var getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n      .then(R.pipe(\n          R.prop(&#39;tasks&#39;),\n          R.filter(R.propEq(&#39;username&#39;, membername)),\n          R.filter(R.propEq(&#39;complete&#39;, false)),\n          R.map(R.pick([&#39;id&#39;, &#39;dueDate&#39;, &#39;title&#39;, &#39;priority&#39;]),\n          R.sortBy(R.prop(&#39;dueDate&#39;))\n      ))\n};</code></pre>\n"},{"title":"面向对象之继承","date":"2019-03-15T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n原型链虽然很强大，也可以用它来实现继承，但是总会有这样那样的问题。其中最主要的问题是原型链的引用问题。下面借鉴JS高程中的几种方式来学习JS继承,JS继承也是面向对象（oo）编程，但不使用类或者接口，而是使用创建对象的形式。虽然在ES6中实现了Class但其实只是语法糖，原理依然是__proto__。在JS超集中（TypeScript）用类与接口实现继承，会在后续文章中学习记录。\n\n### 原型链继承\n\n```js\nfunction Parent () {\n  this.name = 'zhansan';\n}\n\nParent.prototype.sayName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n}\n\nChild.prototype = new Parent();\n\nvar child = new Child();\nchild.sayName() // zhangsan\n```\n\n  问题\n\n  - 引用类型的值的原型属性会被所有实例共享\n  - 在创建子类型的实例时不能向超类型的构造函数传参（没法办在不影响所有对象实例的情况下传参）\n\n### 借用构造函数继承（经典继承）\n\n在子类构造函数内部调用超类型构造函数\n\n```js\nfunction Parent () {\n  this.name = ['zhangsan', 'lisi'];\n}\n\nfunction Child () {\n  Parent.call(this);\n}\n\nvar child = new Child();\nchild.name.push('wangyu');\nchild.name() // ['zhangsan', 'lisi' ,'wangyu']\n\nvar child1 = new Child();\nchild1.name() //  ['zhangsan', 'lisi']\n```\n\n优点：解决了原型链继承的问题\n\n缺点：方法都在构造函数中定义，函数无法复用，创建实例时方法都会被创建一遍\n\n\n### 组合继承（伪经典继承）\n\n```js\nfunction Parent (name) {\n  this.name = name;\n  this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n  console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n  Parent.call(this, name);\n  this.age = age;\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child = new Child('zhangsan', '20');\nchild.colors.push('black');\n\nconsole.log(child.name); // zhangsan\nconsole.log(child.age); // 20\nconsole.log(child.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\nvar child1 = new Child('lisi', '28');\nconsole.log(child1.name); // lisi\nconsole.log(child1.age); // 28\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\"]\n```\n\n优点：融合原型链继承和构造函数的优\n\n缺点：调用多次超类构造函数\n\n\n### 原型式继承（道格拉斯）\n\n```js\nfunction createObj(o) {\n  function F(){}\n  F.prototype = o;\n  return new F();\n}\n\nvar person = {\n  name: 'zhansan',\n  hobbies: ['swimming', 'reading']\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = 'person';\nconsole.log(person2.name); // zhangsan\n\nperson2.hobbies.push('running');\nconsole.log(person2.hobbies); // [\"swimming\", \"reading\", \"running\"]\n\n```\n\n缺点：引用类型的值的原型属性会被所有实例共享\n\n### 寄生式继承（道格拉斯升级版）\n\n```js\nfunction createObj (o) {\n  var clone = Object.create(o);\n  clone.sayName = function () {\n      console.log('zhangsan');\n  }\n  return clone;\n}\n```\n\n缺点：跟借用构造函数模式一样，创建实例时方法都会被创建一遍\n\n### 寄生组合式继承\n\n```js\nfunction inheritPrototype(Child, Parent){\n  var prototype = Object.create(superType.prototype);\n  prototype.constructor = Child;\n  Child.prototype = prototype;\n}\nfunction Parent(name){\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nParent.prototype.sayName = function(){\n  console.log(this.name);\n};\nfunction Child(name, age){\n  Parent.call(this, name);\n  this.age = age;\n}\ninheritPrototype(Child, Parent);//实现继承\nChild.prototype.sayAge = function(){\n  console.log(this.age);\n}; \n\n```\n\n优点：保证了原型链链路的正确性,没有多余的属性等优点，所以最为理想的ES5继承\n\n### ES6继承\n\n```js\n//class 相当于es5中构造函数\n//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中\n//class中定义的所有方法是不可枚举的\n//class中只能定义方法，不能定义对象，变量等\n//class和方法内默认都是严格模式\n//es5中constructor为隐式属性\nclass Parent{\n  constructor(name='wang',age='27'){\n    this.name = name;\n    this.age = age;\n  }\n  eat(){\n    console.log(`${this.name} ${this.age} eat food`)\n  }\n}\n//继承父类\nclass Child extends Parent{ \n  constructor(name = 'ren',age = '27'){ \n    //继承父类属性\n    super(name, age); \n  } \n    eat(){ \n    //继承父类方法\n      super.eat() \n    } \n} \nlet child =new Child('xiaoxiami'); \nchild.eat();\n```\n\n优点\n\n- 在语法糖下代码量明显减少，和ES6区别ES5继承首先是在子类中创建自己的this指向，最后将方法添加到this中\n\n```js\nChild.prototype=new Parent() || Parent.apply(this) || Parent.call(this)\n```\n\n- es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this\n\n\n\n\n\n\n\n","source":"_posts/javascript/inheritance.md","raw":"---\ntitle: 面向对象之继承\ndate: 2019-3-15 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n原型链虽然很强大，也可以用它来实现继承，但是总会有这样那样的问题。其中最主要的问题是原型链的引用问题。下面借鉴JS高程中的几种方式来学习JS继承,JS继承也是面向对象（oo）编程，但不使用类或者接口，而是使用创建对象的形式。虽然在ES6中实现了Class但其实只是语法糖，原理依然是__proto__。在JS超集中（TypeScript）用类与接口实现继承，会在后续文章中学习记录。\n\n### 原型链继承\n\n```js\nfunction Parent () {\n  this.name = 'zhansan';\n}\n\nParent.prototype.sayName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n}\n\nChild.prototype = new Parent();\n\nvar child = new Child();\nchild.sayName() // zhangsan\n```\n\n  问题\n\n  - 引用类型的值的原型属性会被所有实例共享\n  - 在创建子类型的实例时不能向超类型的构造函数传参（没法办在不影响所有对象实例的情况下传参）\n\n### 借用构造函数继承（经典继承）\n\n在子类构造函数内部调用超类型构造函数\n\n```js\nfunction Parent () {\n  this.name = ['zhangsan', 'lisi'];\n}\n\nfunction Child () {\n  Parent.call(this);\n}\n\nvar child = new Child();\nchild.name.push('wangyu');\nchild.name() // ['zhangsan', 'lisi' ,'wangyu']\n\nvar child1 = new Child();\nchild1.name() //  ['zhangsan', 'lisi']\n```\n\n优点：解决了原型链继承的问题\n\n缺点：方法都在构造函数中定义，函数无法复用，创建实例时方法都会被创建一遍\n\n\n### 组合继承（伪经典继承）\n\n```js\nfunction Parent (name) {\n  this.name = name;\n  this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n  console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n  Parent.call(this, name);\n  this.age = age;\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child = new Child('zhangsan', '20');\nchild.colors.push('black');\n\nconsole.log(child.name); // zhangsan\nconsole.log(child.age); // 20\nconsole.log(child.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\nvar child1 = new Child('lisi', '28');\nconsole.log(child1.name); // lisi\nconsole.log(child1.age); // 28\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\"]\n```\n\n优点：融合原型链继承和构造函数的优\n\n缺点：调用多次超类构造函数\n\n\n### 原型式继承（道格拉斯）\n\n```js\nfunction createObj(o) {\n  function F(){}\n  F.prototype = o;\n  return new F();\n}\n\nvar person = {\n  name: 'zhansan',\n  hobbies: ['swimming', 'reading']\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = 'person';\nconsole.log(person2.name); // zhangsan\n\nperson2.hobbies.push('running');\nconsole.log(person2.hobbies); // [\"swimming\", \"reading\", \"running\"]\n\n```\n\n缺点：引用类型的值的原型属性会被所有实例共享\n\n### 寄生式继承（道格拉斯升级版）\n\n```js\nfunction createObj (o) {\n  var clone = Object.create(o);\n  clone.sayName = function () {\n      console.log('zhangsan');\n  }\n  return clone;\n}\n```\n\n缺点：跟借用构造函数模式一样，创建实例时方法都会被创建一遍\n\n### 寄生组合式继承\n\n```js\nfunction inheritPrototype(Child, Parent){\n  var prototype = Object.create(superType.prototype);\n  prototype.constructor = Child;\n  Child.prototype = prototype;\n}\nfunction Parent(name){\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nParent.prototype.sayName = function(){\n  console.log(this.name);\n};\nfunction Child(name, age){\n  Parent.call(this, name);\n  this.age = age;\n}\ninheritPrototype(Child, Parent);//实现继承\nChild.prototype.sayAge = function(){\n  console.log(this.age);\n}; \n\n```\n\n优点：保证了原型链链路的正确性,没有多余的属性等优点，所以最为理想的ES5继承\n\n### ES6继承\n\n```js\n//class 相当于es5中构造函数\n//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中\n//class中定义的所有方法是不可枚举的\n//class中只能定义方法，不能定义对象，变量等\n//class和方法内默认都是严格模式\n//es5中constructor为隐式属性\nclass Parent{\n  constructor(name='wang',age='27'){\n    this.name = name;\n    this.age = age;\n  }\n  eat(){\n    console.log(`${this.name} ${this.age} eat food`)\n  }\n}\n//继承父类\nclass Child extends Parent{ \n  constructor(name = 'ren',age = '27'){ \n    //继承父类属性\n    super(name, age); \n  } \n    eat(){ \n    //继承父类方法\n      super.eat() \n    } \n} \nlet child =new Child('xiaoxiami'); \nchild.eat();\n```\n\n优点\n\n- 在语法糖下代码量明显减少，和ES6区别ES5继承首先是在子类中创建自己的this指向，最后将方法添加到this中\n\n```js\nChild.prototype=new Parent() || Parent.apply(this) || Parent.call(this)\n```\n\n- es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this\n\n\n\n\n\n\n\n","slug":"javascript/inheritance","published":1,"updated":"2019-10-15T01:29:42.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ord001fb0u6aaeyzzra","content":"<p>原型链虽然很强大，也可以用它来实现继承，但是总会有这样那样的问题。其中最主要的问题是原型链的引用问题。下面借鉴JS高程中的几种方式来学习JS继承,JS继承也是面向对象（oo）编程，但不使用类或者接口，而是使用创建对象的形式。虽然在ES6中实现了Class但其实只是语法糖，原理依然是<strong>proto</strong>。在JS超集中（TypeScript）用类与接口实现继承，会在后续文章中学习记录。</p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Parent <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'zhansan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nParent<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> Child <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n\nChild<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> child <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// zhangsan</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  问题</p>\n<ul>\n<li>引用类型的值的原型属性会被所有实例共享</li>\n<li>在创建子类型的实例时不能向超类型的构造函数传参（没法办在不影响所有对象实例的情况下传参）</li>\n</ul>\n<h3 id=\"借用构造函数继承（经典继承）\"><a href=\"#借用构造函数继承（经典继承）\" class=\"headerlink\" title=\"借用构造函数继承（经典继承）\"></a>借用构造函数继承（经典继承）</h3><p>在子类构造函数内部调用超类型构造函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Parent <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'lisi'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> Child <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Parent<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> child <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchild<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'wangyu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchild<span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// ['zhangsan', 'lisi' ,'wangyu']</span>\n\n<span class=\"token keyword\">var</span> child1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchild1<span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//  ['zhangsan', 'lisi']</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>优点：解决了原型链继承的问题</p>\n<p>缺点：方法都在构造函数中定义，函数无法复用，创建实例时方法都会被创建一遍</p>\n<h3 id=\"组合继承（伪经典继承）\"><a href=\"#组合继承（伪经典继承）\" class=\"headerlink\" title=\"组合继承（伪经典继承）\"></a>组合继承（伪经典继承）</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Parent <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>colors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'red'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'green'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nParent<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>getName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> Child <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  Parent<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nChild<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nChild<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> Child<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> child <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'20'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nchild<span class=\"token punctuation\">.</span>colors<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'black'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// zhangsan</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 20</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">.</span>colors<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"red\", \"blue\", \"green\", \"black\"]</span>\n\n<span class=\"token keyword\">var</span> child1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lisi'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'28'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>child1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// lisi</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>child1<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 28</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>child1<span class=\"token punctuation\">.</span>colors<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"red\", \"blue\", \"green\"]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>优点：融合原型链继承和构造函数的优</p>\n<p>缺点：调用多次超类构造函数</p>\n<h3 id=\"原型式继承（道格拉斯）\"><a href=\"#原型式继承（道格拉斯）\" class=\"headerlink\" title=\"原型式继承（道格拉斯）\"></a>原型式继承（道格拉斯）</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createObj</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  F<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> o<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'zhansan'</span><span class=\"token punctuation\">,</span>\n  hobbies<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'swimming'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'reading'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token function\">createObj</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token function\">createObj</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'person'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// zhangsan</span>\n\nperson2<span class=\"token punctuation\">.</span>hobbies<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'running'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person2<span class=\"token punctuation\">.</span>hobbies<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [\"swimming\", \"reading\", \"running\"]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>缺点：引用类型的值的原型属性会被所有实例共享</p>\n<h3 id=\"寄生式继承（道格拉斯升级版）\"><a href=\"#寄生式继承（道格拉斯升级版）\" class=\"headerlink\" title=\"寄生式继承（道格拉斯升级版）\"></a>寄生式继承（道格拉斯升级版）</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> createObj <span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> clone <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  clone<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> clone<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>缺点：跟借用构造函数模式一样，创建实例时方法都会被创建一遍</p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">inheritPrototype</span><span class=\"token punctuation\">(</span>Child<span class=\"token punctuation\">,</span> Parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>superType<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> Child<span class=\"token punctuation\">;</span>\n  Child<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> prototype<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>colors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"green\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nParent<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Child</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  Parent<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">inheritPrototype</span><span class=\"token punctuation\">(</span>Child<span class=\"token punctuation\">,</span> Parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//实现继承</span>\nChild<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayAge <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>优点：保证了原型链链路的正确性,没有多余的属性等优点，所以最为理想的ES5继承</p>\n<h3 id=\"ES6继承\"><a href=\"#ES6继承\" class=\"headerlink\" title=\"ES6继承\"></a>ES6继承</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//class 相当于es5中构造函数</span>\n<span class=\"token comment\" spellcheck=\"true\">//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中</span>\n<span class=\"token comment\" spellcheck=\"true\">//class中定义的所有方法是不可枚举的</span>\n<span class=\"token comment\" spellcheck=\"true\">//class中只能定义方法，不能定义对象，变量等</span>\n<span class=\"token comment\" spellcheck=\"true\">//class和方法内默认都是严格模式</span>\n<span class=\"token comment\" spellcheck=\"true\">//es5中constructor为隐式属性</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">'wang'</span><span class=\"token punctuation\">,</span>age<span class=\"token operator\">=</span><span class=\"token string\">'27'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> eat food`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//继承父类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">{</span> \n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'ren'</span><span class=\"token punctuation\">,</span>age <span class=\"token operator\">=</span> <span class=\"token string\">'27'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n    <span class=\"token comment\" spellcheck=\"true\">//继承父类属性</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span> \n    <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n    <span class=\"token comment\" spellcheck=\"true\">//继承父类方法</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span> \n<span class=\"token keyword\">let</span> child <span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xiaoxiami'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nchild<span class=\"token punctuation\">.</span><span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>优点</p>\n<ul>\n<li>在语法糖下代码量明显减少，和ES6区别ES5继承首先是在子类中创建自己的this指向，最后将方法添加到this中</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Child<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> Parent<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> Parent<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>原型链虽然很强大，也可以用它来实现继承，但是总会有这样那样的问题。其中最主要的问题是原型链的引用问题。下面借鉴JS高程中的几种方式来学习JS继承,JS继承也是面向对象（oo）编程，但不使用类或者接口，而是使用创建对象的形式。虽然在ES6中实现了Class但其实只是语法糖，原理依然是<strong>proto</strong>。在JS超集中（TypeScript）用类与接口实现继承，会在后续文章中学习记录。</p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><pre><code class=\"js\">function Parent () {\n  this.name = &#39;zhansan&#39;;\n}\n\nParent.prototype.sayName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n}\n\nChild.prototype = new Parent();\n\nvar child = new Child();\nchild.sayName() // zhangsan</code></pre>\n<p>  问题</p>\n<ul>\n<li>引用类型的值的原型属性会被所有实例共享</li>\n<li>在创建子类型的实例时不能向超类型的构造函数传参（没法办在不影响所有对象实例的情况下传参）</li>\n</ul>\n<h3 id=\"借用构造函数继承（经典继承）\"><a href=\"#借用构造函数继承（经典继承）\" class=\"headerlink\" title=\"借用构造函数继承（经典继承）\"></a>借用构造函数继承（经典继承）</h3><p>在子类构造函数内部调用超类型构造函数</p>\n<pre><code class=\"js\">function Parent () {\n  this.name = [&#39;zhangsan&#39;, &#39;lisi&#39;];\n}\n\nfunction Child () {\n  Parent.call(this);\n}\n\nvar child = new Child();\nchild.name.push(&#39;wangyu&#39;);\nchild.name() // [&#39;zhangsan&#39;, &#39;lisi&#39; ,&#39;wangyu&#39;]\n\nvar child1 = new Child();\nchild1.name() //  [&#39;zhangsan&#39;, &#39;lisi&#39;]</code></pre>\n<p>优点：解决了原型链继承的问题</p>\n<p>缺点：方法都在构造函数中定义，函数无法复用，创建实例时方法都会被创建一遍</p>\n<h3 id=\"组合继承（伪经典继承）\"><a href=\"#组合继承（伪经典继承）\" class=\"headerlink\" title=\"组合继承（伪经典继承）\"></a>组合继承（伪经典继承）</h3><pre><code class=\"js\">function Parent (name) {\n  this.name = name;\n  this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n}\n\nParent.prototype.getName = function () {\n  console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n  Parent.call(this, name);\n  this.age = age;\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child = new Child(&#39;zhangsan&#39;, &#39;20&#39;);\nchild.colors.push(&#39;black&#39;);\n\nconsole.log(child.name); // zhangsan\nconsole.log(child.age); // 20\nconsole.log(child.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]\n\nvar child1 = new Child(&#39;lisi&#39;, &#39;28&#39;);\nconsole.log(child1.name); // lisi\nconsole.log(child1.age); // 28\nconsole.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</code></pre>\n<p>优点：融合原型链继承和构造函数的优</p>\n<p>缺点：调用多次超类构造函数</p>\n<h3 id=\"原型式继承（道格拉斯）\"><a href=\"#原型式继承（道格拉斯）\" class=\"headerlink\" title=\"原型式继承（道格拉斯）\"></a>原型式继承（道格拉斯）</h3><pre><code class=\"js\">function createObj(o) {\n  function F(){}\n  F.prototype = o;\n  return new F();\n}\n\nvar person = {\n  name: &#39;zhansan&#39;,\n  hobbies: [&#39;swimming&#39;, &#39;reading&#39;]\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = &#39;person&#39;;\nconsole.log(person2.name); // zhangsan\n\nperson2.hobbies.push(&#39;running&#39;);\nconsole.log(person2.hobbies); // [&quot;swimming&quot;, &quot;reading&quot;, &quot;running&quot;]\n</code></pre>\n<p>缺点：引用类型的值的原型属性会被所有实例共享</p>\n<h3 id=\"寄生式继承（道格拉斯升级版）\"><a href=\"#寄生式继承（道格拉斯升级版）\" class=\"headerlink\" title=\"寄生式继承（道格拉斯升级版）\"></a>寄生式继承（道格拉斯升级版）</h3><pre><code class=\"js\">function createObj (o) {\n  var clone = Object.create(o);\n  clone.sayName = function () {\n      console.log(&#39;zhangsan&#39;);\n  }\n  return clone;\n}</code></pre>\n<p>缺点：跟借用构造函数模式一样，创建实例时方法都会被创建一遍</p>\n<h3 id=\"寄生组合式继承\"><a href=\"#寄生组合式继承\" class=\"headerlink\" title=\"寄生组合式继承\"></a>寄生组合式继承</h3><pre><code class=\"js\">function inheritPrototype(Child, Parent){\n  var prototype = Object.create(superType.prototype);\n  prototype.constructor = Child;\n  Child.prototype = prototype;\n}\nfunction Parent(name){\n  this.name = name;\n  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];\n}\nParent.prototype.sayName = function(){\n  console.log(this.name);\n};\nfunction Child(name, age){\n  Parent.call(this, name);\n  this.age = age;\n}\ninheritPrototype(Child, Parent);//实现继承\nChild.prototype.sayAge = function(){\n  console.log(this.age);\n}; \n</code></pre>\n<p>优点：保证了原型链链路的正确性,没有多余的属性等优点，所以最为理想的ES5继承</p>\n<h3 id=\"ES6继承\"><a href=\"#ES6继承\" class=\"headerlink\" title=\"ES6继承\"></a>ES6继承</h3><pre><code class=\"js\">//class 相当于es5中构造函数\n//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中\n//class中定义的所有方法是不可枚举的\n//class中只能定义方法，不能定义对象，变量等\n//class和方法内默认都是严格模式\n//es5中constructor为隐式属性\nclass Parent{\n  constructor(name=&#39;wang&#39;,age=&#39;27&#39;){\n    this.name = name;\n    this.age = age;\n  }\n  eat(){\n    console.log(`${this.name} ${this.age} eat food`)\n  }\n}\n//继承父类\nclass Child extends Parent{ \n  constructor(name = &#39;ren&#39;,age = &#39;27&#39;){ \n    //继承父类属性\n    super(name, age); \n  } \n    eat(){ \n    //继承父类方法\n      super.eat() \n    } \n} \nlet child =new Child(&#39;xiaoxiami&#39;); \nchild.eat();</code></pre>\n<p>优点</p>\n<ul>\n<li>在语法糖下代码量明显减少，和ES6区别ES5继承首先是在子类中创建自己的this指向，最后将方法添加到this中</li>\n</ul>\n<pre><code class=\"js\">Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)</code></pre>\n<ul>\n<li>es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this</li>\n</ul>\n"},{"title":"json 对象","date":"2019-05-11T10:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## JSON.stringify\n\n- 将值转换为相应的JSON格式\n- 布尔值、数字、字符串在序列化过程中会自动转换成对应的原始值 (字符串需要单独处理)\n- NaN和Infinity格式的数值及null都会被当做null\n- 不可枚举的属性会被忽略\n- undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）\n- 函数、undefine,Sysmbol被单独转换时，会返回undefined\n- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误\n\n\n### 语法\n\n```js\nJSON.stringify(value[, replacer [, space]])\n```\n\n### 实现\n\n通过上述说明处理不同情况下的数据情况，此实现不包括第二个和第三个参数\n\n```js\nfunction jsonStringify(data) {\n\n  let dataType = typeof data\n\n  if (dataType !== \"object\") {\n\n    let isString = dataType === 'string'\n    let isNull = Number.isNaN(data) || data === Infinity\n    let isUndefined = dataType === \"undefined\" || dataType === \"function\" || dataType === \"symbol\"\n\n    if (isNull) {\n      return String(\"null\")\n    } else if (isUndefined) {\n      return undefined\n    } else if (isString) {\n      return String('\"' + data + '\"')\n    } else {\n      return String(data)\n    }\n\n  } else if (dataType === \"object\") {\n\n    if (data === null) {\n\n      return \"null\"\n\n    } else if (data.toJSON && typeof data.toJSON === \"function\") {\n\n      return jsonStringify(data.toJSON())\n\n    } else if (data instanceof Array) {\n\n      let result = []\n      data.forEach(function (item, index) {\n\n        let isNull = typeof item === \"undefined\" || typeof item === \"function\" || typeof item === \"symbol\"\n        if (isNull) {\n          result[index] = \"null\"\n        } else {\n          result[index] = jsonStringify(item)\n        }\n      })\n      result = \"[\" + result + \"]\"\n      return result.replace(/'/g, '\"')\n\n    } else if (data instanceof Object) {\n\n      let result = []\n      Object.keys(data).forEach(function (item, index) {\n\n        let dataType = typeof data[item] !== \"undefined\" && typeof data[item] !== \"function\" && typeof data[item] !== \"symbol\"\n        if (typeof item !== \"symbol\") {\n          if (dataType) {\n            result.push('\"' + item + '\"' + \":\" + jsonStringify(data[item]))\n          }\n        }\n      })\n      return (\"{\" + result + \"}\").replace(/'/g, '\"');\n    }\n  }\n}\n```\n\n\n## JSON.pase\n\n解析 JSON 字符串\n\n### 语法\n```js\nJSON.parse(text[, reviver])\n```\n\n### evel 版本实现\n\n```js\nfunction jsonPase (data) {\n  return evel('('+ data + ')')\n} \n```\n\n直接调用存在 xss 漏洞，数据中可能不是json 数据，所以需要对数据进行校验\n\n```js\nvar rx_one = /^[\\],:{}\\s]*$/;\nvar rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n\nif (\n    rx_one.test(\n        json\n            .replace(rx_two, \"@\")\n            .replace(rx_three, \"]\")\n            .replace(rx_four, \"\")\n    )\n) {\n    var obj = eval(\"(\" +json + \")\");\n}\n```\n\n### Function 版本实现\n```js\nvar jsonStr = '{ \"age\": 20, \"name\": \"renbo\" }'\nvar json = (new Function('return ' + jsonStr))();\n```\n\n\n\n\n\n","source":"_posts/javascript/json.md","raw":"---\ntitle: json 对象\ndate: 2019-5-11 18:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n## JSON.stringify\n\n- 将值转换为相应的JSON格式\n- 布尔值、数字、字符串在序列化过程中会自动转换成对应的原始值 (字符串需要单独处理)\n- NaN和Infinity格式的数值及null都会被当做null\n- 不可枚举的属性会被忽略\n- undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）\n- 函数、undefine,Sysmbol被单独转换时，会返回undefined\n- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误\n\n\n### 语法\n\n```js\nJSON.stringify(value[, replacer [, space]])\n```\n\n### 实现\n\n通过上述说明处理不同情况下的数据情况，此实现不包括第二个和第三个参数\n\n```js\nfunction jsonStringify(data) {\n\n  let dataType = typeof data\n\n  if (dataType !== \"object\") {\n\n    let isString = dataType === 'string'\n    let isNull = Number.isNaN(data) || data === Infinity\n    let isUndefined = dataType === \"undefined\" || dataType === \"function\" || dataType === \"symbol\"\n\n    if (isNull) {\n      return String(\"null\")\n    } else if (isUndefined) {\n      return undefined\n    } else if (isString) {\n      return String('\"' + data + '\"')\n    } else {\n      return String(data)\n    }\n\n  } else if (dataType === \"object\") {\n\n    if (data === null) {\n\n      return \"null\"\n\n    } else if (data.toJSON && typeof data.toJSON === \"function\") {\n\n      return jsonStringify(data.toJSON())\n\n    } else if (data instanceof Array) {\n\n      let result = []\n      data.forEach(function (item, index) {\n\n        let isNull = typeof item === \"undefined\" || typeof item === \"function\" || typeof item === \"symbol\"\n        if (isNull) {\n          result[index] = \"null\"\n        } else {\n          result[index] = jsonStringify(item)\n        }\n      })\n      result = \"[\" + result + \"]\"\n      return result.replace(/'/g, '\"')\n\n    } else if (data instanceof Object) {\n\n      let result = []\n      Object.keys(data).forEach(function (item, index) {\n\n        let dataType = typeof data[item] !== \"undefined\" && typeof data[item] !== \"function\" && typeof data[item] !== \"symbol\"\n        if (typeof item !== \"symbol\") {\n          if (dataType) {\n            result.push('\"' + item + '\"' + \":\" + jsonStringify(data[item]))\n          }\n        }\n      })\n      return (\"{\" + result + \"}\").replace(/'/g, '\"');\n    }\n  }\n}\n```\n\n\n## JSON.pase\n\n解析 JSON 字符串\n\n### 语法\n```js\nJSON.parse(text[, reviver])\n```\n\n### evel 版本实现\n\n```js\nfunction jsonPase (data) {\n  return evel('('+ data + ')')\n} \n```\n\n直接调用存在 xss 漏洞，数据中可能不是json 数据，所以需要对数据进行校验\n\n```js\nvar rx_one = /^[\\],:{}\\s]*$/;\nvar rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n\nif (\n    rx_one.test(\n        json\n            .replace(rx_two, \"@\")\n            .replace(rx_three, \"]\")\n            .replace(rx_four, \"\")\n    )\n) {\n    var obj = eval(\"(\" +json + \")\");\n}\n```\n\n### Function 版本实现\n```js\nvar jsonStr = '{ \"age\": 20, \"name\": \"renbo\" }'\nvar json = (new Function('return ' + jsonStr))();\n```\n\n\n\n\n\n","slug":"javascript/json","published":1,"updated":"2019-10-15T01:29:42.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8orf001hb0u69c8mqojw","content":"<h2 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h2><ul>\n<li>将值转换为相应的JSON格式</li>\n<li>布尔值、数字、字符串在序列化过程中会自动转换成对应的原始值 (字符串需要单独处理)</li>\n<li>NaN和Infinity格式的数值及null都会被当做null</li>\n<li>不可枚举的属性会被忽略</li>\n<li>undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）</li>\n<li>函数、undefine,Sysmbol被单独转换时，会返回undefined</li>\n<li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误</li>\n</ul>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> replacer <span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> space<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>通过上述说明处理不同情况下的数据情况，此实现不包括第二个和第三个参数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">jsonStringify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">let</span> dataType <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> data\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dataType <span class=\"token operator\">!==</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">let</span> isString <span class=\"token operator\">=</span> dataType <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span>\n    <span class=\"token keyword\">let</span> isNull <span class=\"token operator\">=</span> Number<span class=\"token punctuation\">.</span><span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> data <span class=\"token operator\">===</span> <span class=\"token number\">Infinity</span>\n    <span class=\"token keyword\">let</span> isUndefined <span class=\"token operator\">=</span> dataType <span class=\"token operator\">===</span> <span class=\"token string\">\"undefined\"</span> <span class=\"token operator\">||</span> dataType <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span> <span class=\"token operator\">||</span> dataType <span class=\"token operator\">===</span> <span class=\"token string\">\"symbol\"</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isNull<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"null\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isUndefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> undefined\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isString<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\"'</span> <span class=\"token operator\">+</span> data <span class=\"token operator\">+</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dataType <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">return</span> <span class=\"token string\">\"null\"</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>toJSON <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> data<span class=\"token punctuation\">.</span>toJSON <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">return</span> <span class=\"token function\">jsonStringify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">toJSON</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n      data<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">let</span> isNull <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> item <span class=\"token operator\">===</span> <span class=\"token string\">\"undefined\"</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span> item <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span> item <span class=\"token operator\">===</span> <span class=\"token string\">\"symbol\"</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isNull<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          result<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"null\"</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          result<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">jsonStringify</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      result <span class=\"token operator\">=</span> <span class=\"token string\">\"[\"</span> <span class=\"token operator\">+</span> result <span class=\"token operator\">+</span> <span class=\"token string\">\"]\"</span>\n      <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token operator\">/</span><span class=\"token string\">'/g, '</span>\"'<span class=\"token punctuation\">)</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n      Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">let</span> dataType <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> data<span class=\"token punctuation\">[</span>item<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token string\">\"undefined\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> data<span class=\"token punctuation\">[</span>item<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token string\">\"function\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> data<span class=\"token punctuation\">[</span>item<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token string\">\"symbol\"</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> item <span class=\"token operator\">!==</span> <span class=\"token string\">\"symbol\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dataType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\"'</span> <span class=\"token operator\">+</span> item <span class=\"token operator\">+</span> <span class=\"token string\">'\"'</span> <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">jsonStringify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span>item<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"{\"</span> <span class=\"token operator\">+</span> result <span class=\"token operator\">+</span> <span class=\"token string\">\"}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token operator\">/</span><span class=\"token string\">'/g, '</span>\"'<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"JSON-pase\"><a href=\"#JSON-pase\" class=\"headerlink\" title=\"JSON.pase\"></a>JSON.pase</h2><p>解析 JSON 字符串</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> reviver<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"evel-版本实现\"><a href=\"#evel-版本实现\" class=\"headerlink\" title=\"evel 版本实现\"></a>evel 版本实现</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> jsonPase <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">evel</span><span class=\"token punctuation\">(</span><span class=\"token string\">'('</span><span class=\"token operator\">+</span> data <span class=\"token operator\">+</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>直接调用存在 xss 漏洞，数据中可能不是json 数据，所以需要对数据进行校验</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> rx_one <span class=\"token operator\">=</span> <span class=\"token regex\">/^[\\],:{}\\s]*$/</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> rx_two <span class=\"token operator\">=</span> <span class=\"token regex\">/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> rx_three <span class=\"token operator\">=</span> <span class=\"token regex\">/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> rx_four <span class=\"token operator\">=</span> <span class=\"token regex\">/(?:^|:|,)(?:\\s*\\[)+/g</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    rx_one<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>\n        json\n            <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>rx_two<span class=\"token punctuation\">,</span> <span class=\"token string\">\"@\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>rx_three<span class=\"token punctuation\">,</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>rx_four<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token function\">eval</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span>json <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"Function-版本实现\"><a href=\"#Function-版本实现\" class=\"headerlink\" title=\"Function 版本实现\"></a>Function 版本实现</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> jsonStr <span class=\"token operator\">=</span> <span class=\"token string\">'{ \"age\": 20, \"name\": \"renbo\" }'</span>\n<span class=\"token keyword\">var</span> json <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'return '</span> <span class=\"token operator\">+</span> jsonStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h2><ul>\n<li>将值转换为相应的JSON格式</li>\n<li>布尔值、数字、字符串在序列化过程中会自动转换成对应的原始值 (字符串需要单独处理)</li>\n<li>NaN和Infinity格式的数值及null都会被当做null</li>\n<li>不可枚举的属性会被忽略</li>\n<li>undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）</li>\n<li>函数、undefine,Sysmbol被单独转换时，会返回undefined</li>\n<li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误</li>\n</ul>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code class=\"js\">JSON.stringify(value[, replacer [, space]])</code></pre>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>通过上述说明处理不同情况下的数据情况，此实现不包括第二个和第三个参数</p>\n<pre><code class=\"js\">function jsonStringify(data) {\n\n  let dataType = typeof data\n\n  if (dataType !== &quot;object&quot;) {\n\n    let isString = dataType === &#39;string&#39;\n    let isNull = Number.isNaN(data) || data === Infinity\n    let isUndefined = dataType === &quot;undefined&quot; || dataType === &quot;function&quot; || dataType === &quot;symbol&quot;\n\n    if (isNull) {\n      return String(&quot;null&quot;)\n    } else if (isUndefined) {\n      return undefined\n    } else if (isString) {\n      return String(&#39;&quot;&#39; + data + &#39;&quot;&#39;)\n    } else {\n      return String(data)\n    }\n\n  } else if (dataType === &quot;object&quot;) {\n\n    if (data === null) {\n\n      return &quot;null&quot;\n\n    } else if (data.toJSON &amp;&amp; typeof data.toJSON === &quot;function&quot;) {\n\n      return jsonStringify(data.toJSON())\n\n    } else if (data instanceof Array) {\n\n      let result = []\n      data.forEach(function (item, index) {\n\n        let isNull = typeof item === &quot;undefined&quot; || typeof item === &quot;function&quot; || typeof item === &quot;symbol&quot;\n        if (isNull) {\n          result[index] = &quot;null&quot;\n        } else {\n          result[index] = jsonStringify(item)\n        }\n      })\n      result = &quot;[&quot; + result + &quot;]&quot;\n      return result.replace(/&#39;/g, &#39;&quot;&#39;)\n\n    } else if (data instanceof Object) {\n\n      let result = []\n      Object.keys(data).forEach(function (item, index) {\n\n        let dataType = typeof data[item] !== &quot;undefined&quot; &amp;&amp; typeof data[item] !== &quot;function&quot; &amp;&amp; typeof data[item] !== &quot;symbol&quot;\n        if (typeof item !== &quot;symbol&quot;) {\n          if (dataType) {\n            result.push(&#39;&quot;&#39; + item + &#39;&quot;&#39; + &quot;:&quot; + jsonStringify(data[item]))\n          }\n        }\n      })\n      return (&quot;{&quot; + result + &quot;}&quot;).replace(/&#39;/g, &#39;&quot;&#39;);\n    }\n  }\n}</code></pre>\n<h2 id=\"JSON-pase\"><a href=\"#JSON-pase\" class=\"headerlink\" title=\"JSON.pase\"></a>JSON.pase</h2><p>解析 JSON 字符串</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code class=\"js\">JSON.parse(text[, reviver])</code></pre>\n<h3 id=\"evel-版本实现\"><a href=\"#evel-版本实现\" class=\"headerlink\" title=\"evel 版本实现\"></a>evel 版本实现</h3><pre><code class=\"js\">function jsonPase (data) {\n  return evel(&#39;(&#39;+ data + &#39;)&#39;)\n} </code></pre>\n<p>直接调用存在 xss 漏洞，数据中可能不是json 数据，所以需要对数据进行校验</p>\n<pre><code class=\"js\">var rx_one = /^[\\],:{}\\s]*$/;\nvar rx_two = /\\\\(?:[&quot;\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rx_three = /&quot;[^&quot;\\\\\\n\\r]*&quot;|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n\nif (\n    rx_one.test(\n        json\n            .replace(rx_two, &quot;@&quot;)\n            .replace(rx_three, &quot;]&quot;)\n            .replace(rx_four, &quot;&quot;)\n    )\n) {\n    var obj = eval(&quot;(&quot; +json + &quot;)&quot;);\n}</code></pre>\n<h3 id=\"Function-版本实现\"><a href=\"#Function-版本实现\" class=\"headerlink\" title=\"Function 版本实现\"></a>Function 版本实现</h3><pre><code class=\"js\">var jsonStr = &#39;{ &quot;age&quot;: 20, &quot;name&quot;: &quot;renbo&quot; }&#39;\nvar json = (new Function(&#39;return &#39; + jsonStr))();</code></pre>\n"},{"title":"new 运算符","date":"2019-04-27T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n实现 new 运算符也算是 JS 中经典的面试题了。在实际应用中其实 new 运算符的应用场景是定义对象类型的实例\n\n### demo\n\n```js\n/**\n * 定义构造函数\n * @param {*} name \n * @param {*} age \n */\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayName = function () {\n  console.log(`my name is ${this.name}, I'm ${this.age} years old`);\n}\n\nPerson.prototype.study = function () {\n  console.log(`my name is ${this.name}, I'm learning to swim`);\n}\n\nlet person = new Person('renbo', 28);\nconsole.log(person.name)\nconsole.log(person.sayName())\n\n\n// 调用内置函数\nlet array = new Array();\nlet obj = new Object();\n\n```\n\n\n### 模拟实现\n\n用构造函数实际上会经历以下4个步骤（实现思路）\n\n- 创建一个新对象\n- 将构造函数的作用域赋给新对象（因此this就指向了这个对象）\n- 执行构造函数中的代码（为这个新对象添加属性）\n- 返回新对象\n\n```js\nfunction newFun (constructor) {\n  var o = {};\n\n  // 将 o 的原型指向构造函数，这样 o 就可以访问到构造函数原型中的属性\n  o.__proto__ = constructor.prototype;\n\n  // 改变构造函数 this 的指向到新建的对象，这样 o 就可以访问到构造函数中的属性\n  var ret = constructor.apply(o, Array.prototype.slice.call(arguments, 1));\n\n  // 需要判断返回的值是否是对象，如果不是对象返回正常数据类型\n  return typeof ret === 'object' ? ret : o;\n}\n\n\n// 再次使用上面的例子\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayName = function () {\n  return `my name is ${this.name}, I'm ${this.age} years old`;\n}\n\nPerson.prototype.study = function () {\n  return `my name is ${this.name}, I'm learning to swim`;\n}\n\nlet person =  newFun(Person, 'renbo', 28);\nconsole.log(person.name); // renbo\nconsole.log(person.sayName()); // my name is renbo, I'm 28 years old\nconsole.log(person.study()); // my name is renbo, I'm learning to swim\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/new.md","raw":"---\ntitle: new 运算符\ndate: 2019-4-27 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n实现 new 运算符也算是 JS 中经典的面试题了。在实际应用中其实 new 运算符的应用场景是定义对象类型的实例\n\n### demo\n\n```js\n/**\n * 定义构造函数\n * @param {*} name \n * @param {*} age \n */\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayName = function () {\n  console.log(`my name is ${this.name}, I'm ${this.age} years old`);\n}\n\nPerson.prototype.study = function () {\n  console.log(`my name is ${this.name}, I'm learning to swim`);\n}\n\nlet person = new Person('renbo', 28);\nconsole.log(person.name)\nconsole.log(person.sayName())\n\n\n// 调用内置函数\nlet array = new Array();\nlet obj = new Object();\n\n```\n\n\n### 模拟实现\n\n用构造函数实际上会经历以下4个步骤（实现思路）\n\n- 创建一个新对象\n- 将构造函数的作用域赋给新对象（因此this就指向了这个对象）\n- 执行构造函数中的代码（为这个新对象添加属性）\n- 返回新对象\n\n```js\nfunction newFun (constructor) {\n  var o = {};\n\n  // 将 o 的原型指向构造函数，这样 o 就可以访问到构造函数原型中的属性\n  o.__proto__ = constructor.prototype;\n\n  // 改变构造函数 this 的指向到新建的对象，这样 o 就可以访问到构造函数中的属性\n  var ret = constructor.apply(o, Array.prototype.slice.call(arguments, 1));\n\n  // 需要判断返回的值是否是对象，如果不是对象返回正常数据类型\n  return typeof ret === 'object' ? ret : o;\n}\n\n\n// 再次使用上面的例子\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayName = function () {\n  return `my name is ${this.name}, I'm ${this.age} years old`;\n}\n\nPerson.prototype.study = function () {\n  return `my name is ${this.name}, I'm learning to swim`;\n}\n\nlet person =  newFun(Person, 'renbo', 28);\nconsole.log(person.name); // renbo\nconsole.log(person.sayName()); // my name is renbo, I'm 28 years old\nconsole.log(person.study()); // my name is renbo, I'm learning to swim\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/new","published":1,"updated":"2019-10-15T01:29:42.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8orj001mb0u61k5dtizf","content":"<p>实现 new 运算符也算是 JS 中经典的面试题了。在实际应用中其实 new 运算符的应用场景是定义对象类型的实例</p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 定义构造函数\n * @param {*} name \n * @param {*} age \n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, I'm </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> years old`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>study <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, I'm learning to swim`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'renbo'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 调用内置函数</span>\n<span class=\"token keyword\">let</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"模拟实现\"><a href=\"#模拟实现\" class=\"headerlink\" title=\"模拟实现\"></a>模拟实现</h3><p>用构造函数实际上会经历以下4个步骤（实现思路）</p>\n<ul>\n<li>创建一个新对象</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个对象）</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）</li>\n<li>返回新对象</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> newFun <span class=\"token punctuation\">(</span>constructor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 将 o 的原型指向构造函数，这样 o 就可以访问到构造函数原型中的属性</span>\n  o<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> constructor<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 改变构造函数 this 的指向到新建的对象，这样 o 就可以访问到构造函数中的属性</span>\n  <span class=\"token keyword\">var</span> ret <span class=\"token operator\">=</span> constructor<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 需要判断返回的值是否是对象，如果不是对象返回正常数据类型</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> ret <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">?</span> ret <span class=\"token punctuation\">:</span> o<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 再次使用上面的例子</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, I'm </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> years old`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>study <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, I'm learning to swim`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span>  <span class=\"token function\">newFun</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">,</span> <span class=\"token string\">'renbo'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// renbo</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// my name is renbo, I'm 28 years old</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span><span class=\"token function\">study</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// my name is renbo, I'm learning to swim</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>实现 new 运算符也算是 JS 中经典的面试题了。在实际应用中其实 new 运算符的应用场景是定义对象类型的实例</p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><pre><code class=\"js\">/**\n * 定义构造函数\n * @param {*} name \n * @param {*} age \n */\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayName = function () {\n  console.log(`my name is ${this.name}, I&#39;m ${this.age} years old`);\n}\n\nPerson.prototype.study = function () {\n  console.log(`my name is ${this.name}, I&#39;m learning to swim`);\n}\n\nlet person = new Person(&#39;renbo&#39;, 28);\nconsole.log(person.name)\nconsole.log(person.sayName())\n\n\n// 调用内置函数\nlet array = new Array();\nlet obj = new Object();\n</code></pre>\n<h3 id=\"模拟实现\"><a href=\"#模拟实现\" class=\"headerlink\" title=\"模拟实现\"></a>模拟实现</h3><p>用构造函数实际上会经历以下4个步骤（实现思路）</p>\n<ul>\n<li>创建一个新对象</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个对象）</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）</li>\n<li>返回新对象</li>\n</ul>\n<pre><code class=\"js\">function newFun (constructor) {\n  var o = {};\n\n  // 将 o 的原型指向构造函数，这样 o 就可以访问到构造函数原型中的属性\n  o.__proto__ = constructor.prototype;\n\n  // 改变构造函数 this 的指向到新建的对象，这样 o 就可以访问到构造函数中的属性\n  var ret = constructor.apply(o, Array.prototype.slice.call(arguments, 1));\n\n  // 需要判断返回的值是否是对象，如果不是对象返回正常数据类型\n  return typeof ret === &#39;object&#39; ? ret : o;\n}\n\n\n// 再次使用上面的例子\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayName = function () {\n  return `my name is ${this.name}, I&#39;m ${this.age} years old`;\n}\n\nPerson.prototype.study = function () {\n  return `my name is ${this.name}, I&#39;m learning to swim`;\n}\n\nlet person =  newFun(Person, &#39;renbo&#39;, 28);\nconsole.log(person.name); // renbo\nconsole.log(person.sayName()); // my name is renbo, I&#39;m 28 years old\nconsole.log(person.study()); // my name is renbo, I&#39;m learning to swim</code></pre>\n"},{"title":"原型及原型链","date":"2019-03-10T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 普通对象和函数对象\n\n```js\n  // 普通对象\n  var obj1 = {}; \n  var obj2 = new Object();\n  var obj3 = new person();\n  // 函数对象\n  function person(){}; \n  var person1 = function(){};\n  var person2 = new Function('aaa','console.warn(aaaa)');\n\n  console.log(typeof Object); //function \n  console.log(typeof Function); //function \n  \n  console.log(typeof person); //function \n  console.log(typeof person1); //function \n  console.log(typeof person2); //function  \n  console.log(person instanceof Function) // true \n\n  console.log(typeof obj1); //object \n  console.log(typeof obj2); //object \n  console.log(typeof obj3); //object\n  console.log(obj3 instanceof Object)  // true\n```\n\n通过以上实例我们知道 new Function 构建的都是函数对象(关于普通函数与new Function的区别请参考 <a href= \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\">mozilla开发者</a>), 其余都是普通对象,关于Object与Function的区别会在这章节最后总结\n\n\n### 通过构造函数模式创建对象\n\n在js高程中我们知道创建对象有很多种模式如下\n\n- 工厂模式\n- 构造函数模式\n- 原型模式\n- 组合使用构造函数和原型模式\n- 动态原型模式\n- 寄生构造函数模式\n- 稳妥构造函数模式\n\n当然这几种模式在这里暂时不展开说明，后续继承的时候在分别用讨论，我们这里简单的回忆一下用构造函数创建对象\n\n```js\n  function Person(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  Person.prototype.sayName = function () {\n    console.log(this.name)\n  }\n  var person1 = new Person('zhansan', 29);\n  var person2 = new Person('lisi', 29);\n```\n\n### __proto__,prototype,constructor\n\n- `__proto__`:在JavaScript权威指南中指出每个js对象一定对应一个原型对象，并从原型对象继承属性和方法。\n- `prototype`: 当创建函数对象时，js会自动为这个函数添加prototype属性（**这里明确一下只有函数对象才会有此属性**）\n- 每个原型都有一个 constructor 属性指向关联的构造函数。\n\n通过上述三点我们针对2中的代码解释为\n\n当创建`Person`函数时，js会自动为该函数创建`prototype`属性，这个属性指向函数的原型对象，函数的原型对象（`Person.prototype`）会自动获取一个`constructor`属性指向关联的Person。当我们通过new关键字调用时，js就会创建该构造函数的实例`person1`或`person2`，此时我们就可以通过`prototype`来存储要共享的属性和方法\n\n下面我们通过图例来说明我们上面的文字\n\n<image src='/images/Person.png'></image>\n\n这里我们注意虽然person1和person2这两个个实例都不包含属性和方法，但是我们可以通过查找对象属性来实现调用person1.sayName()\n\n此时我们来确定两个实例对象返回的原型指针是否一样(**Object.getPrototypeOf 此方法可以获取对象的原型**)\n\n```js\nObject.getPrototypeOf(person1) === Person.prototype (true)\nObject.getPrototypeOf(person1) === Person.prototype (true)\n```\n\n通过如上输出结果得知他们内部都有一个指向Person.prototype的指针也就是\n\n```js\nperson1.__proto__ === Person.prototype\nperson2.__proto__ === Person.prototype\n```\n\n经过上面解释这么多我们得出的结果就是如下 \n\n```js\nperson1.__proto__ === Person.prototype\nPerson.prototype.constructor == Person\n```\n\n### Object\n\n- js几乎所有对象都是Object; 典型对象继承属性（包括方法）\n- 所有引用类型的原型链上必然存在Object的原型\n- new Object 出来的实例是普通对象我们前面说过只有函数对象才有prototype\n- Object 实际是function Object跟function Function 类似\n- Object.prototype是Object构造函数的属性。它也是原型链的终结\n\n```js\nfunction Object (name,age) {\n  this.name = name;\n  this.age = age;\n}\nObject.prototype.sayName = function () {\n  console.log(this.name)\n}\nobject = new Object('zhangsan',20)\nobject.sayName()\n```\n\n我们通样以图例的形式来说明Object的__proto__,prototype,constructor\n\n<image src='/images/Object.png'></image>\n\n通过以上图例我们得出结论`Object.prototype.__proto__ === null`\n\n这里面扩展一下null和undefined区别\n\n- null === undefined为false，null == undefined为true 说明只是值相等\n- null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。\n- null表示变量未指向任何对象，undefined表示变量被声明但是没有被赋值\n\n### Function\n\n- 在js中每个函数实际上都是一个Function对象。\n- 使用Function构造器生成的Function对象是在函数创建时解析的,而其他函数方式是跟其他代码一起解析，所以较为低效\n- 全局的Function对象没有自己的属性和方法，通过Function.prototype上继承部分属性和方法。\n- 我们说js中万物皆对象，Function也也是对象，只不过是函数对象所以`Function.prototype.__proto__`指针指向`Object.prototype`\n- `Object.__proto__` 指针指向`Function.prototype`\n\n**Function创建的函数一般在全局作用域中被创建，但并不会像其他函数一样产生闭包，所以只能自己内部和全局的变量**\n       \n```js\nfunction Function (name,age){\n  this.name  = name\n  this.age = age\n}\nFunction.prototype.sayName = function () {\n  console.log(this.name)\n}\nf = new Function('zhangsan', 20)\nf.sayName ()\n\n```\n\n我们同样以图例的形式来说明Function的__proto__,prototype,constructor\n\n<image src='/images/Function.png'></image>\n\n通过以上图例我们得出结论`Object.prototype === Function.prototype.__proto__`\n\n### 将Function，Object，Person链接起来\n\n此时我们同样通过图例的形式将上面整合起来。来看看整个链路是什么样子\n\n<image src='/images/prototype.png'></image>\n\n 通过以上图例我们可以观察到其实js原型链就是由相互关联的链条组成，查找属性或者方法的过程就是图中红色链条的过程，如果找到则终止否则直到返回null\n\n`person1` > `person1.__proto__` > `Person.prototype` > `Person.prototype.__proto__` > `Object.prototype` > `Object.prototype.__proto__` > `null`\n\n\n最后我们来看一下Object和Function的关系，上面已经提到`Object.prototype === Function.prototype.__proto__`\n\n- `Function.__proto__` > `Function.prototype` > `Function.prototype.__proto__` > `Object.prototype` --> `Object.prototype.__proto__` --> 'null';简写为`Function.__proto__.__proto__.__proto__` > `null`\n- `Object.__proto__` > `Funtion.prototype` > `Function.prototype.__proto__` > `Object.prototype` >`Object.prototype.__proto__` > `null`;简写为`Object.__proto__.__proto__.__proto__` > `null`\n\n通过上面我们可以得出结论\n\n- 只有函数对象才有 prototype，但是每个对象（普通对象和函数对象）都拥有__proto__属性\n- 原型对象都有一个 constructor 属性指向它们的构造函数（也就是自己）\n- 原生对象既是对象，也是构造函数\n- 实例对象的隐式原型始终指向构造函数的显式原型（`person1.__proto__` > `Person.prototype`）\n- 原型链的查找过程链接依赖 __proto__ 指针逐级向上，并且原型链的尽头始终为null\n","source":"_posts/javascript/prototype.md","raw":"---\ntitle: 原型及原型链\ndate: 2019-3-10 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n### 普通对象和函数对象\n\n```js\n  // 普通对象\n  var obj1 = {}; \n  var obj2 = new Object();\n  var obj3 = new person();\n  // 函数对象\n  function person(){}; \n  var person1 = function(){};\n  var person2 = new Function('aaa','console.warn(aaaa)');\n\n  console.log(typeof Object); //function \n  console.log(typeof Function); //function \n  \n  console.log(typeof person); //function \n  console.log(typeof person1); //function \n  console.log(typeof person2); //function  \n  console.log(person instanceof Function) // true \n\n  console.log(typeof obj1); //object \n  console.log(typeof obj2); //object \n  console.log(typeof obj3); //object\n  console.log(obj3 instanceof Object)  // true\n```\n\n通过以上实例我们知道 new Function 构建的都是函数对象(关于普通函数与new Function的区别请参考 <a href= \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\">mozilla开发者</a>), 其余都是普通对象,关于Object与Function的区别会在这章节最后总结\n\n\n### 通过构造函数模式创建对象\n\n在js高程中我们知道创建对象有很多种模式如下\n\n- 工厂模式\n- 构造函数模式\n- 原型模式\n- 组合使用构造函数和原型模式\n- 动态原型模式\n- 寄生构造函数模式\n- 稳妥构造函数模式\n\n当然这几种模式在这里暂时不展开说明，后续继承的时候在分别用讨论，我们这里简单的回忆一下用构造函数创建对象\n\n```js\n  function Person(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  Person.prototype.sayName = function () {\n    console.log(this.name)\n  }\n  var person1 = new Person('zhansan', 29);\n  var person2 = new Person('lisi', 29);\n```\n\n### __proto__,prototype,constructor\n\n- `__proto__`:在JavaScript权威指南中指出每个js对象一定对应一个原型对象，并从原型对象继承属性和方法。\n- `prototype`: 当创建函数对象时，js会自动为这个函数添加prototype属性（**这里明确一下只有函数对象才会有此属性**）\n- 每个原型都有一个 constructor 属性指向关联的构造函数。\n\n通过上述三点我们针对2中的代码解释为\n\n当创建`Person`函数时，js会自动为该函数创建`prototype`属性，这个属性指向函数的原型对象，函数的原型对象（`Person.prototype`）会自动获取一个`constructor`属性指向关联的Person。当我们通过new关键字调用时，js就会创建该构造函数的实例`person1`或`person2`，此时我们就可以通过`prototype`来存储要共享的属性和方法\n\n下面我们通过图例来说明我们上面的文字\n\n<image src='/images/Person.png'></image>\n\n这里我们注意虽然person1和person2这两个个实例都不包含属性和方法，但是我们可以通过查找对象属性来实现调用person1.sayName()\n\n此时我们来确定两个实例对象返回的原型指针是否一样(**Object.getPrototypeOf 此方法可以获取对象的原型**)\n\n```js\nObject.getPrototypeOf(person1) === Person.prototype (true)\nObject.getPrototypeOf(person1) === Person.prototype (true)\n```\n\n通过如上输出结果得知他们内部都有一个指向Person.prototype的指针也就是\n\n```js\nperson1.__proto__ === Person.prototype\nperson2.__proto__ === Person.prototype\n```\n\n经过上面解释这么多我们得出的结果就是如下 \n\n```js\nperson1.__proto__ === Person.prototype\nPerson.prototype.constructor == Person\n```\n\n### Object\n\n- js几乎所有对象都是Object; 典型对象继承属性（包括方法）\n- 所有引用类型的原型链上必然存在Object的原型\n- new Object 出来的实例是普通对象我们前面说过只有函数对象才有prototype\n- Object 实际是function Object跟function Function 类似\n- Object.prototype是Object构造函数的属性。它也是原型链的终结\n\n```js\nfunction Object (name,age) {\n  this.name = name;\n  this.age = age;\n}\nObject.prototype.sayName = function () {\n  console.log(this.name)\n}\nobject = new Object('zhangsan',20)\nobject.sayName()\n```\n\n我们通样以图例的形式来说明Object的__proto__,prototype,constructor\n\n<image src='/images/Object.png'></image>\n\n通过以上图例我们得出结论`Object.prototype.__proto__ === null`\n\n这里面扩展一下null和undefined区别\n\n- null === undefined为false，null == undefined为true 说明只是值相等\n- null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。\n- null表示变量未指向任何对象，undefined表示变量被声明但是没有被赋值\n\n### Function\n\n- 在js中每个函数实际上都是一个Function对象。\n- 使用Function构造器生成的Function对象是在函数创建时解析的,而其他函数方式是跟其他代码一起解析，所以较为低效\n- 全局的Function对象没有自己的属性和方法，通过Function.prototype上继承部分属性和方法。\n- 我们说js中万物皆对象，Function也也是对象，只不过是函数对象所以`Function.prototype.__proto__`指针指向`Object.prototype`\n- `Object.__proto__` 指针指向`Function.prototype`\n\n**Function创建的函数一般在全局作用域中被创建，但并不会像其他函数一样产生闭包，所以只能自己内部和全局的变量**\n       \n```js\nfunction Function (name,age){\n  this.name  = name\n  this.age = age\n}\nFunction.prototype.sayName = function () {\n  console.log(this.name)\n}\nf = new Function('zhangsan', 20)\nf.sayName ()\n\n```\n\n我们同样以图例的形式来说明Function的__proto__,prototype,constructor\n\n<image src='/images/Function.png'></image>\n\n通过以上图例我们得出结论`Object.prototype === Function.prototype.__proto__`\n\n### 将Function，Object，Person链接起来\n\n此时我们同样通过图例的形式将上面整合起来。来看看整个链路是什么样子\n\n<image src='/images/prototype.png'></image>\n\n 通过以上图例我们可以观察到其实js原型链就是由相互关联的链条组成，查找属性或者方法的过程就是图中红色链条的过程，如果找到则终止否则直到返回null\n\n`person1` > `person1.__proto__` > `Person.prototype` > `Person.prototype.__proto__` > `Object.prototype` > `Object.prototype.__proto__` > `null`\n\n\n最后我们来看一下Object和Function的关系，上面已经提到`Object.prototype === Function.prototype.__proto__`\n\n- `Function.__proto__` > `Function.prototype` > `Function.prototype.__proto__` > `Object.prototype` --> `Object.prototype.__proto__` --> 'null';简写为`Function.__proto__.__proto__.__proto__` > `null`\n- `Object.__proto__` > `Funtion.prototype` > `Function.prototype.__proto__` > `Object.prototype` >`Object.prototype.__proto__` > `null`;简写为`Object.__proto__.__proto__.__proto__` > `null`\n\n通过上面我们可以得出结论\n\n- 只有函数对象才有 prototype，但是每个对象（普通对象和函数对象）都拥有__proto__属性\n- 原型对象都有一个 constructor 属性指向它们的构造函数（也就是自己）\n- 原生对象既是对象，也是构造函数\n- 实例对象的隐式原型始终指向构造函数的显式原型（`person1.__proto__` > `Person.prototype`）\n- 原型链的查找过程链接依赖 __proto__ 指针逐级向上，并且原型链的尽头始终为null\n","slug":"javascript/prototype","published":1,"updated":"2019-10-15T01:29:42.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8orl001ob0u6h1v00ljx","content":"<h3 id=\"普通对象和函数对象\"><a href=\"#普通对象和函数对象\" class=\"headerlink\" title=\"普通对象和函数对象\"></a>普通对象和函数对象</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token comment\" spellcheck=\"true\">// 普通对象</span>\n  <span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> obj3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 函数对象</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'aaa'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'console.warn(aaaa)'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function </span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function </span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function </span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> person1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function </span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> person2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function  </span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// true </span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//object </span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//object </span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//object</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj3 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过以上实例我们知道 new Function 构建的都是函数对象(关于普通函数与new Function的区别请参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" target=\"_blank\" rel=\"noopener\">mozilla开发者</a>), 其余都是普通对象,关于Object与Function的区别会在这章节最后总结</p>\n<h3 id=\"通过构造函数模式创建对象\"><a href=\"#通过构造函数模式创建对象\" class=\"headerlink\" title=\"通过构造函数模式创建对象\"></a>通过构造函数模式创建对象</h3><p>在js高程中我们知道创建对象有很多种模式如下</p>\n<ul>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>组合使用构造函数和原型模式</li>\n<li>动态原型模式</li>\n<li>寄生构造函数模式</li>\n<li>稳妥构造函数模式</li>\n</ul>\n<p>当然这几种模式在这里暂时不展开说明，后续继承的时候在分别用讨论，我们这里简单的回忆一下用构造函数创建对象</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhansan'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lisi'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"proto-prototype-constructor\"><a href=\"#proto-prototype-constructor\" class=\"headerlink\" title=\"proto,prototype,constructor\"></a><strong>proto</strong>,prototype,constructor</h3><ul>\n<li><code>__proto__</code>:在JavaScript权威指南中指出每个js对象一定对应一个原型对象，并从原型对象继承属性和方法。</li>\n<li><code>prototype</code>: 当创建函数对象时，js会自动为这个函数添加prototype属性（<strong>这里明确一下只有函数对象才会有此属性</strong>）</li>\n<li>每个原型都有一个 constructor 属性指向关联的构造函数。</li>\n</ul>\n<p>通过上述三点我们针对2中的代码解释为</p>\n<p>当创建<code>Person</code>函数时，js会自动为该函数创建<code>prototype</code>属性，这个属性指向函数的原型对象，函数的原型对象（<code>Person.prototype</code>）会自动获取一个<code>constructor</code>属性指向关联的Person。当我们通过new关键字调用时，js就会创建该构造函数的实例<code>person1</code>或<code>person2</code>，此时我们就可以通过<code>prototype</code>来存储要共享的属性和方法</p>\n<p>下面我们通过图例来说明我们上面的文字</p>\n<p><image src=\"/images/Person.png\"></image></p>\n<p>这里我们注意虽然person1和person2这两个个实例都不包含属性和方法，但是我们可以通过查找对象属性来实现调用person1.sayName()</p>\n<p>此时我们来确定两个实例对象返回的原型指针是否一样(<strong>Object.getPrototypeOf 此方法可以获取对象的原型</strong>)</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> Person<span class=\"token punctuation\">.</span>prototype <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> Person<span class=\"token punctuation\">.</span>prototype <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>通过如上输出结果得知他们内部都有一个指向Person.prototype的指针也就是</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">person1<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> Person<span class=\"token punctuation\">.</span>prototype\nperson2<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> Person<span class=\"token punctuation\">.</span>prototype<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>经过上面解释这么多我们得出的结果就是如下 </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">person1<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> Person<span class=\"token punctuation\">.</span>prototype\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">==</span> Person<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><ul>\n<li>js几乎所有对象都是Object; 典型对象继承属性（包括方法）</li>\n<li>所有引用类型的原型链上必然存在Object的原型</li>\n<li>new Object 出来的实例是普通对象我们前面说过只有函数对象才有prototype</li>\n<li>Object 实际是function Object跟function Function 类似</li>\n<li>Object.prototype是Object构造函数的属性。它也是原型链的终结</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Object <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nObject<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nobject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\nobject<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们通样以图例的形式来说明Object的<strong>proto</strong>,prototype,constructor</p>\n<p><image src=\"/images/Object.png\"></image></p>\n<p>通过以上图例我们得出结论<code>Object.prototype.__proto__ === null</code></p>\n<p>这里面扩展一下null和undefined区别</p>\n<ul>\n<li>null === undefined为false，null == undefined为true 说明只是值相等</li>\n<li>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</li>\n<li>null表示变量未指向任何对象，undefined表示变量被声明但是没有被赋值</li>\n</ul>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h3><ul>\n<li>在js中每个函数实际上都是一个Function对象。</li>\n<li>使用Function构造器生成的Function对象是在函数创建时解析的,而其他函数方式是跟其他代码一起解析，所以较为低效</li>\n<li>全局的Function对象没有自己的属性和方法，通过Function.prototype上继承部分属性和方法。</li>\n<li>我们说js中万物皆对象，Function也也是对象，只不过是函数对象所以<code>Function.prototype.__proto__</code>指针指向<code>Object.prototype</code></li>\n<li><code>Object.__proto__</code> 指针指向<code>Function.prototype</code></li>\n</ul>\n<p><strong>Function创建的函数一般在全局作用域中被创建，但并不会像其他函数一样产生闭包，所以只能自己内部和全局的变量</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Function <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name  <span class=\"token operator\">=</span> name\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age\n<span class=\"token punctuation\">}</span>\nFunction<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\nf<span class=\"token punctuation\">.</span>sayName <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们同样以图例的形式来说明Function的<strong>proto</strong>,prototype,constructor</p>\n<p><image src=\"/images/Function.png\"></image></p>\n<p>通过以上图例我们得出结论<code>Object.prototype === Function.prototype.__proto__</code></p>\n<h3 id=\"将Function，Object，Person链接起来\"><a href=\"#将Function，Object，Person链接起来\" class=\"headerlink\" title=\"将Function，Object，Person链接起来\"></a>将Function，Object，Person链接起来</h3><p>此时我们同样通过图例的形式将上面整合起来。来看看整个链路是什么样子</p>\n<p><image src=\"/images/prototype.png\"></image></p>\n<p> 通过以上图例我们可以观察到其实js原型链就是由相互关联的链条组成，查找属性或者方法的过程就是图中红色链条的过程，如果找到则终止否则直到返回null</p>\n<p><code>person1</code> &gt; <code>person1.__proto__</code> &gt; <code>Person.prototype</code> &gt; <code>Person.prototype.__proto__</code> &gt; <code>Object.prototype</code> &gt; <code>Object.prototype.__proto__</code> &gt; <code>null</code></p>\n<p>最后我们来看一下Object和Function的关系，上面已经提到<code>Object.prototype === Function.prototype.__proto__</code></p>\n<ul>\n<li><code>Function.__proto__</code> &gt; <code>Function.prototype</code> &gt; <code>Function.prototype.__proto__</code> &gt; <code>Object.prototype</code> –&gt; <code>Object.prototype.__proto__</code> –&gt; ‘null’;简写为<code>Function.__proto__.__proto__.__proto__</code> &gt; <code>null</code></li>\n<li><code>Object.__proto__</code> &gt; <code>Funtion.prototype</code> &gt; <code>Function.prototype.__proto__</code> &gt; <code>Object.prototype</code> &gt;<code>Object.prototype.__proto__</code> &gt; <code>null</code>;简写为<code>Object.__proto__.__proto__.__proto__</code> &gt; <code>null</code></li>\n</ul>\n<p>通过上面我们可以得出结论</p>\n<ul>\n<li>只有函数对象才有 prototype，但是每个对象（普通对象和函数对象）都拥有<strong>proto</strong>属性</li>\n<li>原型对象都有一个 constructor 属性指向它们的构造函数（也就是自己）</li>\n<li>原生对象既是对象，也是构造函数</li>\n<li>实例对象的隐式原型始终指向构造函数的显式原型（<code>person1.__proto__</code> &gt; <code>Person.prototype</code>）</li>\n<li>原型链的查找过程链接依赖 <strong>proto</strong> 指针逐级向上，并且原型链的尽头始终为null</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"普通对象和函数对象\"><a href=\"#普通对象和函数对象\" class=\"headerlink\" title=\"普通对象和函数对象\"></a>普通对象和函数对象</h3><pre><code class=\"js\">  // 普通对象\n  var obj1 = {}; \n  var obj2 = new Object();\n  var obj3 = new person();\n  // 函数对象\n  function person(){}; \n  var person1 = function(){};\n  var person2 = new Function(&#39;aaa&#39;,&#39;console.warn(aaaa)&#39;);\n\n  console.log(typeof Object); //function \n  console.log(typeof Function); //function \n\n  console.log(typeof person); //function \n  console.log(typeof person1); //function \n  console.log(typeof person2); //function  \n  console.log(person instanceof Function) // true \n\n  console.log(typeof obj1); //object \n  console.log(typeof obj2); //object \n  console.log(typeof obj3); //object\n  console.log(obj3 instanceof Object)  // true</code></pre>\n<p>通过以上实例我们知道 new Function 构建的都是函数对象(关于普通函数与new Function的区别请参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" target=\"_blank\" rel=\"noopener\">mozilla开发者</a>), 其余都是普通对象,关于Object与Function的区别会在这章节最后总结</p>\n<h3 id=\"通过构造函数模式创建对象\"><a href=\"#通过构造函数模式创建对象\" class=\"headerlink\" title=\"通过构造函数模式创建对象\"></a>通过构造函数模式创建对象</h3><p>在js高程中我们知道创建对象有很多种模式如下</p>\n<ul>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>组合使用构造函数和原型模式</li>\n<li>动态原型模式</li>\n<li>寄生构造函数模式</li>\n<li>稳妥构造函数模式</li>\n</ul>\n<p>当然这几种模式在这里暂时不展开说明，后续继承的时候在分别用讨论，我们这里简单的回忆一下用构造函数创建对象</p>\n<pre><code class=\"js\">  function Person(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  Person.prototype.sayName = function () {\n    console.log(this.name)\n  }\n  var person1 = new Person(&#39;zhansan&#39;, 29);\n  var person2 = new Person(&#39;lisi&#39;, 29);</code></pre>\n<h3 id=\"proto-prototype-constructor\"><a href=\"#proto-prototype-constructor\" class=\"headerlink\" title=\"proto,prototype,constructor\"></a><strong>proto</strong>,prototype,constructor</h3><ul>\n<li><code>__proto__</code>:在JavaScript权威指南中指出每个js对象一定对应一个原型对象，并从原型对象继承属性和方法。</li>\n<li><code>prototype</code>: 当创建函数对象时，js会自动为这个函数添加prototype属性（<strong>这里明确一下只有函数对象才会有此属性</strong>）</li>\n<li>每个原型都有一个 constructor 属性指向关联的构造函数。</li>\n</ul>\n<p>通过上述三点我们针对2中的代码解释为</p>\n<p>当创建<code>Person</code>函数时，js会自动为该函数创建<code>prototype</code>属性，这个属性指向函数的原型对象，函数的原型对象（<code>Person.prototype</code>）会自动获取一个<code>constructor</code>属性指向关联的Person。当我们通过new关键字调用时，js就会创建该构造函数的实例<code>person1</code>或<code>person2</code>，此时我们就可以通过<code>prototype</code>来存储要共享的属性和方法</p>\n<p>下面我们通过图例来说明我们上面的文字</p>\n<p><image src=\"/images/Person.png\"></image></p>\n<p>这里我们注意虽然person1和person2这两个个实例都不包含属性和方法，但是我们可以通过查找对象属性来实现调用person1.sayName()</p>\n<p>此时我们来确定两个实例对象返回的原型指针是否一样(<strong>Object.getPrototypeOf 此方法可以获取对象的原型</strong>)</p>\n<pre><code class=\"js\">Object.getPrototypeOf(person1) === Person.prototype (true)\nObject.getPrototypeOf(person1) === Person.prototype (true)</code></pre>\n<p>通过如上输出结果得知他们内部都有一个指向Person.prototype的指针也就是</p>\n<pre><code class=\"js\">person1.__proto__ === Person.prototype\nperson2.__proto__ === Person.prototype</code></pre>\n<p>经过上面解释这么多我们得出的结果就是如下 </p>\n<pre><code class=\"js\">person1.__proto__ === Person.prototype\nPerson.prototype.constructor == Person</code></pre>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><ul>\n<li>js几乎所有对象都是Object; 典型对象继承属性（包括方法）</li>\n<li>所有引用类型的原型链上必然存在Object的原型</li>\n<li>new Object 出来的实例是普通对象我们前面说过只有函数对象才有prototype</li>\n<li>Object 实际是function Object跟function Function 类似</li>\n<li>Object.prototype是Object构造函数的属性。它也是原型链的终结</li>\n</ul>\n<pre><code class=\"js\">function Object (name,age) {\n  this.name = name;\n  this.age = age;\n}\nObject.prototype.sayName = function () {\n  console.log(this.name)\n}\nobject = new Object(&#39;zhangsan&#39;,20)\nobject.sayName()</code></pre>\n<p>我们通样以图例的形式来说明Object的<strong>proto</strong>,prototype,constructor</p>\n<p><image src=\"/images/Object.png\"></image></p>\n<p>通过以上图例我们得出结论<code>Object.prototype.__proto__ === null</code></p>\n<p>这里面扩展一下null和undefined区别</p>\n<ul>\n<li>null === undefined为false，null == undefined为true 说明只是值相等</li>\n<li>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</li>\n<li>null表示变量未指向任何对象，undefined表示变量被声明但是没有被赋值</li>\n</ul>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h3><ul>\n<li>在js中每个函数实际上都是一个Function对象。</li>\n<li>使用Function构造器生成的Function对象是在函数创建时解析的,而其他函数方式是跟其他代码一起解析，所以较为低效</li>\n<li>全局的Function对象没有自己的属性和方法，通过Function.prototype上继承部分属性和方法。</li>\n<li>我们说js中万物皆对象，Function也也是对象，只不过是函数对象所以<code>Function.prototype.__proto__</code>指针指向<code>Object.prototype</code></li>\n<li><code>Object.__proto__</code> 指针指向<code>Function.prototype</code></li>\n</ul>\n<p><strong>Function创建的函数一般在全局作用域中被创建，但并不会像其他函数一样产生闭包，所以只能自己内部和全局的变量</strong></p>\n<pre><code class=\"js\">function Function (name,age){\n  this.name  = name\n  this.age = age\n}\nFunction.prototype.sayName = function () {\n  console.log(this.name)\n}\nf = new Function(&#39;zhangsan&#39;, 20)\nf.sayName ()\n</code></pre>\n<p>我们同样以图例的形式来说明Function的<strong>proto</strong>,prototype,constructor</p>\n<p><image src=\"/images/Function.png\"></image></p>\n<p>通过以上图例我们得出结论<code>Object.prototype === Function.prototype.__proto__</code></p>\n<h3 id=\"将Function，Object，Person链接起来\"><a href=\"#将Function，Object，Person链接起来\" class=\"headerlink\" title=\"将Function，Object，Person链接起来\"></a>将Function，Object，Person链接起来</h3><p>此时我们同样通过图例的形式将上面整合起来。来看看整个链路是什么样子</p>\n<p><image src=\"/images/prototype.png\"></image></p>\n<p> 通过以上图例我们可以观察到其实js原型链就是由相互关联的链条组成，查找属性或者方法的过程就是图中红色链条的过程，如果找到则终止否则直到返回null</p>\n<p><code>person1</code> &gt; <code>person1.__proto__</code> &gt; <code>Person.prototype</code> &gt; <code>Person.prototype.__proto__</code> &gt; <code>Object.prototype</code> &gt; <code>Object.prototype.__proto__</code> &gt; <code>null</code></p>\n<p>最后我们来看一下Object和Function的关系，上面已经提到<code>Object.prototype === Function.prototype.__proto__</code></p>\n<ul>\n<li><code>Function.__proto__</code> &gt; <code>Function.prototype</code> &gt; <code>Function.prototype.__proto__</code> &gt; <code>Object.prototype</code> –&gt; <code>Object.prototype.__proto__</code> –&gt; ‘null’;简写为<code>Function.__proto__.__proto__.__proto__</code> &gt; <code>null</code></li>\n<li><code>Object.__proto__</code> &gt; <code>Funtion.prototype</code> &gt; <code>Function.prototype.__proto__</code> &gt; <code>Object.prototype</code> &gt;<code>Object.prototype.__proto__</code> &gt; <code>null</code>;简写为<code>Object.__proto__.__proto__.__proto__</code> &gt; <code>null</code></li>\n</ul>\n<p>通过上面我们可以得出结论</p>\n<ul>\n<li>只有函数对象才有 prototype，但是每个对象（普通对象和函数对象）都拥有<strong>proto</strong>属性</li>\n<li>原型对象都有一个 constructor 属性指向它们的构造函数（也就是自己）</li>\n<li>原生对象既是对象，也是构造函数</li>\n<li>实例对象的隐式原型始终指向构造函数的显式原型（<code>person1.__proto__</code> &gt; <code>Person.prototype</code>）</li>\n<li>原型链的查找过程链接依赖 <strong>proto</strong> 指针逐级向上，并且原型链的尽头始终为null</li>\n</ul>\n"},{"title":"数据类型","date":"2019-02-12T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## 基本数据类型\n\n  ### 概念\n  基本数据类型是按值进行进行访问，变量是放在栈（stack）内存里\n\n  ### 种类\n  Undefined、Null、Boolean、String、Number、Symbol（es6）\n\n  基本数据类型的值是不可变的\n\n    ```js\n    var str = \"renbo\";\n    str.toUpperCase(); // RENBO\n    console.log(str); // renbo\n    ```\n\n  按值进行比较\n\n    ```js\n    var a = 1;\n    var b = true;\n    console.log(a == b); // true\n    console.log(a === b); // false\n    ```\n  虽然数据类型不相同（true为bool,1为Number)但在比较之前js自动进行了数据类型的隐式转换\n\n  == 是进行值比较所以为true\n\n  === 不仅比较值还要比较数据类型所以为false\n\n  栈内存中保存了变量的标识符和变量的值\n\n    ```js\n    var a,b;\n    a = 1;\n    b = a;\n    console.log(a); // 1\n    console.log(b); // 1\n    a = 2;\n    console.log(a); // 2\n    console.log(b); // 1\n    ```\n    <image src='/images/javascript-stack.png'></image>\n\n## 引用数据类型\n\n  ### 概念\n  引用类型的值是保存在堆内存（Heap）中的对象（Object）\n\n  ### 种类\n  统称为Object，细分有：Object，Array，Function，Data，RegExp等\n\n  引用类型的值式可变化的\n\n    ```js\n    var obj = {name:'renbo'};\n    obj.name = 'zhangsan';\n    obj.age = 28;\n    obj.say = function () {\n      return 'My name is' + this.name + 'I‘m' + this.age+ 'years old';\n    }\n    obj.say(); //My name is zhangsan I‘m 28 years old\n    ```\n\n  按引用地址比较\n\n    ```js\n    var obj = {};\n    var obj1 = {};\n    console.log(obj == obj1); // false\n    console.log(obj === obj1) // false\n    ```\n  栈内存中保存了变量标识符和指向堆内存中该对象的指针\n\n  堆内存中保存了对象的内容\n\n  ```js\n  var a = {name: 'renbo'};\n  var b = a;\n  a.name = 'zhangsan';\n  console.log(b.name); // zhangsan\n  b.age = 28;\n  console.log(b.age) // 28\n  b.say = function () {\n    return 'My name is' + this.name + 'I‘m' + this.age+ 'years old';\n  }\n  console.log(a.say()); //My name is zhangsan I‘m 28 years old\n  var c = {\n    name:'zhangsan',\n    age:28\n  }\n  ```\n  \n  <image src='/images/javascript-stack1.png'></image>\n\n## 类型检测\n  ### typeof\n  \n  经常检查变量是不是基本数据类型\n\n    ```js\n    var a;\n\n    a = \"hello\";\n    typeof a; // string\n\n    a = true;\n    typeof a; // boolean\n\n    a = 1;\n    typeof a; // number \n\n    a = null;\n    typeof a; // object\n\n    typeof a; // undefined\n    \n    a = Symbol();\n    typeof a; // symbol\n\n    a = function(){}\n    typeof a; // function\n\n    a = [];\n    typeof a; // object\n\n    a = {};\n    typeof a; // object\n\n    a = /renbo/g;\n    typeof a; // object   \n    ```\n  ### instanceof\n  \n  经常用来判断引用类型的变量具体是某种类型\n\n    ```js\n    var a;\n    a = function(){}\n    a instanceof Function; // true\n\n    a = [];\n    a instanceof Array; // true\n\n    a = {};\n    a instanceof Object; // true\n\n    a = /renbo/g;\n    a instanceof RegExp ; // true    \n    ```\n\n","source":"_posts/javascript/type.md","raw":"---\ntitle: 数据类型\ndate: 2019-2-12 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n## 基本数据类型\n\n  ### 概念\n  基本数据类型是按值进行进行访问，变量是放在栈（stack）内存里\n\n  ### 种类\n  Undefined、Null、Boolean、String、Number、Symbol（es6）\n\n  基本数据类型的值是不可变的\n\n    ```js\n    var str = \"renbo\";\n    str.toUpperCase(); // RENBO\n    console.log(str); // renbo\n    ```\n\n  按值进行比较\n\n    ```js\n    var a = 1;\n    var b = true;\n    console.log(a == b); // true\n    console.log(a === b); // false\n    ```\n  虽然数据类型不相同（true为bool,1为Number)但在比较之前js自动进行了数据类型的隐式转换\n\n  == 是进行值比较所以为true\n\n  === 不仅比较值还要比较数据类型所以为false\n\n  栈内存中保存了变量的标识符和变量的值\n\n    ```js\n    var a,b;\n    a = 1;\n    b = a;\n    console.log(a); // 1\n    console.log(b); // 1\n    a = 2;\n    console.log(a); // 2\n    console.log(b); // 1\n    ```\n    <image src='/images/javascript-stack.png'></image>\n\n## 引用数据类型\n\n  ### 概念\n  引用类型的值是保存在堆内存（Heap）中的对象（Object）\n\n  ### 种类\n  统称为Object，细分有：Object，Array，Function，Data，RegExp等\n\n  引用类型的值式可变化的\n\n    ```js\n    var obj = {name:'renbo'};\n    obj.name = 'zhangsan';\n    obj.age = 28;\n    obj.say = function () {\n      return 'My name is' + this.name + 'I‘m' + this.age+ 'years old';\n    }\n    obj.say(); //My name is zhangsan I‘m 28 years old\n    ```\n\n  按引用地址比较\n\n    ```js\n    var obj = {};\n    var obj1 = {};\n    console.log(obj == obj1); // false\n    console.log(obj === obj1) // false\n    ```\n  栈内存中保存了变量标识符和指向堆内存中该对象的指针\n\n  堆内存中保存了对象的内容\n\n  ```js\n  var a = {name: 'renbo'};\n  var b = a;\n  a.name = 'zhangsan';\n  console.log(b.name); // zhangsan\n  b.age = 28;\n  console.log(b.age) // 28\n  b.say = function () {\n    return 'My name is' + this.name + 'I‘m' + this.age+ 'years old';\n  }\n  console.log(a.say()); //My name is zhangsan I‘m 28 years old\n  var c = {\n    name:'zhangsan',\n    age:28\n  }\n  ```\n  \n  <image src='/images/javascript-stack1.png'></image>\n\n## 类型检测\n  ### typeof\n  \n  经常检查变量是不是基本数据类型\n\n    ```js\n    var a;\n\n    a = \"hello\";\n    typeof a; // string\n\n    a = true;\n    typeof a; // boolean\n\n    a = 1;\n    typeof a; // number \n\n    a = null;\n    typeof a; // object\n\n    typeof a; // undefined\n    \n    a = Symbol();\n    typeof a; // symbol\n\n    a = function(){}\n    typeof a; // function\n\n    a = [];\n    typeof a; // object\n\n    a = {};\n    typeof a; // object\n\n    a = /renbo/g;\n    typeof a; // object   \n    ```\n  ### instanceof\n  \n  经常用来判断引用类型的变量具体是某种类型\n\n    ```js\n    var a;\n    a = function(){}\n    a instanceof Function; // true\n\n    a = [];\n    a instanceof Array; // true\n\n    a = {};\n    a instanceof Object; // true\n\n    a = /renbo/g;\n    a instanceof RegExp ; // true    \n    ```\n\n","slug":"javascript/type","published":1,"updated":"2019-10-15T01:29:42.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8orn001tb0u67t2cu9x3","content":"<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>  基本数据类型是按值进行进行访问，变量是放在栈（stack）内存里</p>\n<h3 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h3><p>  Undefined、Null、Boolean、String、Number、Symbol（es6）</p>\n<p>  基本数据类型的值是不可变的</p>\n<pre><code>```js\nvar str = &quot;renbo&quot;;\nstr.toUpperCase(); // RENBO\nconsole.log(str); // renbo\n```</code></pre><p>  按值进行比较</p>\n<pre><code>```js\nvar a = 1;\nvar b = true;\nconsole.log(a == b); // true\nconsole.log(a === b); // false\n```</code></pre><p>  虽然数据类型不相同（true为bool,1为Number)但在比较之前js自动进行了数据类型的隐式转换</p>\n<p>  == 是进行值比较所以为true</p>\n<p>  === 不仅比较值还要比较数据类型所以为false</p>\n<p>  栈内存中保存了变量的标识符和变量的值</p>\n<pre><code>```js\nvar a,b;\na = 1;\nb = a;\nconsole.log(a); // 1\nconsole.log(b); // 1\na = 2;\nconsole.log(a); // 2\nconsole.log(b); // 1\n```\n&lt;image src=&#39;/images/javascript-stack.png&#39;&gt;&lt;/image&gt;</code></pre><h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>  引用类型的值是保存在堆内存（Heap）中的对象（Object）</p>\n<h3 id=\"种类-1\"><a href=\"#种类-1\" class=\"headerlink\" title=\"种类\"></a>种类</h3><p>  统称为Object，细分有：Object，Array，Function，Data，RegExp等</p>\n<p>  引用类型的值式可变化的</p>\n<pre><code>```js\nvar obj = {name:&#39;renbo&#39;};\nobj.name = &#39;zhangsan&#39;;\nobj.age = 28;\nobj.say = function () {\n  return &#39;My name is&#39; + this.name + &#39;I‘m&#39; + this.age+ &#39;years old&#39;;\n}\nobj.say(); //My name is zhangsan I‘m 28 years old\n```</code></pre><p>  按引用地址比较</p>\n<pre><code>```js\nvar obj = {};\nvar obj1 = {};\nconsole.log(obj == obj1); // false\nconsole.log(obj === obj1) // false\n```</code></pre><p>  栈内存中保存了变量标识符和指向堆内存中该对象的指针</p>\n<p>  堆内存中保存了对象的内容</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'renbo'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n  a<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// zhangsan</span>\n  b<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">28</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 28</span>\n  b<span class=\"token punctuation\">.</span>say <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'My name is'</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">'I‘m'</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">+</span> <span class=\"token string\">'years old'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//My name is zhangsan I‘m 28 years old</span>\n  <span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span><span class=\"token number\">28</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  <image src=\"/images/javascript-stack1.png\"></image></p>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><p>  经常检查变量是不是基本数据类型</p>\n<pre><code>```js\nvar a;\n\na = &quot;hello&quot;;\ntypeof a; // string\n\na = true;\ntypeof a; // boolean\n\na = 1;\ntypeof a; // number \n\na = null;\ntypeof a; // object\n\ntypeof a; // undefined\n\na = Symbol();\ntypeof a; // symbol\n\na = function(){}\ntypeof a; // function\n\na = [];\ntypeof a; // object\n\na = {};\ntypeof a; // object\n\na = /renbo/g;\ntypeof a; // object   \n```</code></pre><h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>  经常用来判断引用类型的变量具体是某种类型</p>\n<pre><code>```js\nvar a;\na = function(){}\na instanceof Function; // true\n\na = [];\na instanceof Array; // true\n\na = {};\na instanceof Object; // true\n\na = /renbo/g;\na instanceof RegExp ; // true    \n```</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>  基本数据类型是按值进行进行访问，变量是放在栈（stack）内存里</p>\n<h3 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h3><p>  Undefined、Null、Boolean、String、Number、Symbol（es6）</p>\n<p>  基本数据类型的值是不可变的</p>\n<pre><code>```js\nvar str = &quot;renbo&quot;;\nstr.toUpperCase(); // RENBO\nconsole.log(str); // renbo\n```</code></pre><p>  按值进行比较</p>\n<pre><code>```js\nvar a = 1;\nvar b = true;\nconsole.log(a == b); // true\nconsole.log(a === b); // false\n```</code></pre><p>  虽然数据类型不相同（true为bool,1为Number)但在比较之前js自动进行了数据类型的隐式转换</p>\n<p>  == 是进行值比较所以为true</p>\n<p>  === 不仅比较值还要比较数据类型所以为false</p>\n<p>  栈内存中保存了变量的标识符和变量的值</p>\n<pre><code>```js\nvar a,b;\na = 1;\nb = a;\nconsole.log(a); // 1\nconsole.log(b); // 1\na = 2;\nconsole.log(a); // 2\nconsole.log(b); // 1\n```\n&lt;image src=&#39;/images/javascript-stack.png&#39;&gt;&lt;/image&gt;</code></pre><h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>  引用类型的值是保存在堆内存（Heap）中的对象（Object）</p>\n<h3 id=\"种类-1\"><a href=\"#种类-1\" class=\"headerlink\" title=\"种类\"></a>种类</h3><p>  统称为Object，细分有：Object，Array，Function，Data，RegExp等</p>\n<p>  引用类型的值式可变化的</p>\n<pre><code>```js\nvar obj = {name:&#39;renbo&#39;};\nobj.name = &#39;zhangsan&#39;;\nobj.age = 28;\nobj.say = function () {\n  return &#39;My name is&#39; + this.name + &#39;I‘m&#39; + this.age+ &#39;years old&#39;;\n}\nobj.say(); //My name is zhangsan I‘m 28 years old\n```</code></pre><p>  按引用地址比较</p>\n<pre><code>```js\nvar obj = {};\nvar obj1 = {};\nconsole.log(obj == obj1); // false\nconsole.log(obj === obj1) // false\n```</code></pre><p>  栈内存中保存了变量标识符和指向堆内存中该对象的指针</p>\n<p>  堆内存中保存了对象的内容</p>\n<pre><code class=\"js\">  var a = {name: &#39;renbo&#39;};\n  var b = a;\n  a.name = &#39;zhangsan&#39;;\n  console.log(b.name); // zhangsan\n  b.age = 28;\n  console.log(b.age) // 28\n  b.say = function () {\n    return &#39;My name is&#39; + this.name + &#39;I‘m&#39; + this.age+ &#39;years old&#39;;\n  }\n  console.log(a.say()); //My name is zhangsan I‘m 28 years old\n  var c = {\n    name:&#39;zhangsan&#39;,\n    age:28\n  }</code></pre>\n<p>  <image src=\"/images/javascript-stack1.png\"></image></p>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><p>  经常检查变量是不是基本数据类型</p>\n<pre><code>```js\nvar a;\n\na = &quot;hello&quot;;\ntypeof a; // string\n\na = true;\ntypeof a; // boolean\n\na = 1;\ntypeof a; // number \n\na = null;\ntypeof a; // object\n\ntypeof a; // undefined\n\na = Symbol();\ntypeof a; // symbol\n\na = function(){}\ntypeof a; // function\n\na = [];\ntypeof a; // object\n\na = {};\ntypeof a; // object\n\na = /renbo/g;\ntypeof a; // object   \n```</code></pre><h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><p>  经常用来判断引用类型的变量具体是某种类型</p>\n<pre><code>```js\nvar a;\na = function(){}\na instanceof Function; // true\n\na = [];\na instanceof Array; // true\n\na = {};\na instanceof Object; // true\n\na = /renbo/g;\na instanceof RegExp ; // true    \n```</code></pre>"},{"title":"this","date":"2019-03-05T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 概念\njs的关键字，在执行上下文环境时被绑定\n\n### 绑定规则\n默认绑定、隐式绑定、apply,call、new绑定。优先级从低到高\n\n### 默认绑定\n\n```js\nconsole.log(this); //window\nfunction fun() {\nconsole.log(this.a) // 非严格模式下1 ，严格模式下undefined\n}\nvar a = 1;\nfun(); \n```\n\n### 隐式调用\n作为对象方法调用，this 指代上下文对象\n\n```js\nfunction fun() { \n  console.log( this.a );\n}\nvar a = 1;\nvar obj = { \n  a: 2,\n  fun: fun \n};\nobj.fun(); // 2\nvar c = obj.fun;\nconsole.log(c()); // 1\n```\n\n### apply,call\n改变对象的prototype关联对象来改变this,对于null，undefined绑定会失效\n\n```js\nfunction fun() { \n  console.log( this.a );\n}\nvar a = 1;\nvar obj1 = { \n  a: 2,\n};\nvar obj2 = { \n  a: 3,\n};\nfun.call( obj1 ); // 2\nfun.call( obj2 ); // 3\nfun.call( null ); // 1\nfun.call( undefined ); // 1\n```\n\n### 作为构造函数调用\n\nthis 指代new 出的对象\n使用new来调用函数，会自动执行如下操作：\n- 创建一个全新的对象。\n- 这个新对象会被执行[[原型]]连接。\n- 这个新对象会绑定到函数调用的this。\n- 如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。\n  ```js\n  function fun(a) { \n    this.a = a;\n  }\n  var a = 1;\n  var obj = new fun(3);\n  console.log(obj.a); // 3\n  var obj1 = new fun(4);\n  console.log(obj1.a); // 4\n  ```\n\n### es6中箭头函数this指向\n  取决于外层（函数或全局）作用域。\n","source":"_posts/javascript/this.md","raw":"---\ntitle: this\ndate: 2019-3-5 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n### 概念\njs的关键字，在执行上下文环境时被绑定\n\n### 绑定规则\n默认绑定、隐式绑定、apply,call、new绑定。优先级从低到高\n\n### 默认绑定\n\n```js\nconsole.log(this); //window\nfunction fun() {\nconsole.log(this.a) // 非严格模式下1 ，严格模式下undefined\n}\nvar a = 1;\nfun(); \n```\n\n### 隐式调用\n作为对象方法调用，this 指代上下文对象\n\n```js\nfunction fun() { \n  console.log( this.a );\n}\nvar a = 1;\nvar obj = { \n  a: 2,\n  fun: fun \n};\nobj.fun(); // 2\nvar c = obj.fun;\nconsole.log(c()); // 1\n```\n\n### apply,call\n改变对象的prototype关联对象来改变this,对于null，undefined绑定会失效\n\n```js\nfunction fun() { \n  console.log( this.a );\n}\nvar a = 1;\nvar obj1 = { \n  a: 2,\n};\nvar obj2 = { \n  a: 3,\n};\nfun.call( obj1 ); // 2\nfun.call( obj2 ); // 3\nfun.call( null ); // 1\nfun.call( undefined ); // 1\n```\n\n### 作为构造函数调用\n\nthis 指代new 出的对象\n使用new来调用函数，会自动执行如下操作：\n- 创建一个全新的对象。\n- 这个新对象会被执行[[原型]]连接。\n- 这个新对象会绑定到函数调用的this。\n- 如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。\n  ```js\n  function fun(a) { \n    this.a = a;\n  }\n  var a = 1;\n  var obj = new fun(3);\n  console.log(obj.a); // 3\n  var obj1 = new fun(4);\n  console.log(obj1.a); // 4\n  ```\n\n### es6中箭头函数this指向\n  取决于外层（函数或全局）作用域。\n","slug":"javascript/this","published":1,"updated":"2019-10-15T01:29:42.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8orq001wb0u6v55qp0xc","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>js的关键字，在执行上下文环境时被绑定</p>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>默认绑定、隐式绑定、apply,call、new绑定。优先级从低到高</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//window</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 非严格模式下1 ，严格模式下undefined</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"隐式调用\"><a href=\"#隐式调用\" class=\"headerlink\" title=\"隐式调用\"></a>隐式调用</h3><p>作为对象方法调用，this 指代上下文对象</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n  fun<span class=\"token punctuation\">:</span> fun \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 2</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>fun<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"apply-call\"><a href=\"#apply-call\" class=\"headerlink\" title=\"apply,call\"></a>apply,call</h3><p>改变对象的prototype关联对象来改变this,对于null，undefined绑定会失效</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> obj1 <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 2</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> obj2 <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 3</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span> undefined <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"作为构造函数调用\"><a href=\"#作为构造函数调用\" class=\"headerlink\" title=\"作为构造函数调用\"></a>作为构造函数调用</h3><p>this 指代new 出的对象<br>使用new来调用函数，会自动执行如下操作：</p>\n<ul>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">fun</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 3</span>\n<span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">fun</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 4</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"es6中箭头函数this指向\"><a href=\"#es6中箭头函数this指向\" class=\"headerlink\" title=\"es6中箭头函数this指向\"></a>es6中箭头函数this指向</h3><p>  取决于外层（函数或全局）作用域。</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>js的关键字，在执行上下文环境时被绑定</p>\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>默认绑定、隐式绑定、apply,call、new绑定。优先级从低到高</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><pre><code class=\"js\">console.log(this); //window\nfunction fun() {\nconsole.log(this.a) // 非严格模式下1 ，严格模式下undefined\n}\nvar a = 1;\nfun(); </code></pre>\n<h3 id=\"隐式调用\"><a href=\"#隐式调用\" class=\"headerlink\" title=\"隐式调用\"></a>隐式调用</h3><p>作为对象方法调用，this 指代上下文对象</p>\n<pre><code class=\"js\">function fun() { \n  console.log( this.a );\n}\nvar a = 1;\nvar obj = { \n  a: 2,\n  fun: fun \n};\nobj.fun(); // 2\nvar c = obj.fun;\nconsole.log(c()); // 1</code></pre>\n<h3 id=\"apply-call\"><a href=\"#apply-call\" class=\"headerlink\" title=\"apply,call\"></a>apply,call</h3><p>改变对象的prototype关联对象来改变this,对于null，undefined绑定会失效</p>\n<pre><code class=\"js\">function fun() { \n  console.log( this.a );\n}\nvar a = 1;\nvar obj1 = { \n  a: 2,\n};\nvar obj2 = { \n  a: 3,\n};\nfun.call( obj1 ); // 2\nfun.call( obj2 ); // 3\nfun.call( null ); // 1\nfun.call( undefined ); // 1</code></pre>\n<h3 id=\"作为构造函数调用\"><a href=\"#作为构造函数调用\" class=\"headerlink\" title=\"作为构造函数调用\"></a>作为构造函数调用</h3><p>this 指代new 出的对象<br>使用new来调用函数，会自动执行如下操作：</p>\n<ul>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行[[原型]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。<pre><code class=\"js\">function fun(a) { \n  this.a = a;\n}\nvar a = 1;\nvar obj = new fun(3);\nconsole.log(obj.a); // 3\nvar obj1 = new fun(4);\nconsole.log(obj1.a); // 4</code></pre>\n</li>\n</ul>\n<h3 id=\"es6中箭头函数this指向\"><a href=\"#es6中箭头函数this指向\" class=\"headerlink\" title=\"es6中箭头函数this指向\"></a>es6中箭头函数this指向</h3><p>  取决于外层（函数或全局）作用域。</p>\n"},{"title":"vo 和 ao","date":"2019-02-20T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## 变量提升\n\n### 执行步骤\njs代码虽然是逐行向下执行的，但执行的时候分为两个步骤**\n- 编译阶段（词法解释/预解释）\n- 执行\n\n### 编译阶段\n函数声明和变量声明总是会被解释器(编译阶段)悄悄地被“提升”到最顶部，最后执行\n\n### 解析顺序\n- this和arguments（语言内置）\n- 函数的形式参数\n- 函数声明\n- 变量声明\n\n### 优先级\n函数的声明比变量的声明的优先级要高\n\n### es6中let关键字及块及作用域\n\n  demo1\n\n     ```js\n     a = 'renbo';\n     var a;\n     console.log( a ); // renbo\n\n     // 编译后的代码\n     var a;\n     a = 'renbo';\n     console.log(a); \n     ```\n  demo2\n\n      ```js\n      function demo() {\n        a = 'renbo';\n        console.log(a);\n        console.log(window.a);\n        var a = 'zhangsan';\n        console.log(a);\n      }\n      demo(); \n\n      // 编译后的代码\n      function demo() {\n        var a;\n        a = 'renbo';\n        console.log(a);\n        console.log(window.a);\n        a = 'zhangsan';\n        console.log(a);\n      }\n      demo(); // renbo undefined zhangsan\n      ``` \n ## 函数提升\n  \n   ```js\n   // 两种函数的书写方式\n   var fn = function fn(){} //函数表达式\n   function fn(){} //函数声明方式 \n   ```\n\n   只有声明方式的函数才会有函数提升\n   \n   ```js\n    test();\n    function test(){\n      console.log( a );\n      var a = 'renbo';\n    }\n\n    // 编译后\n    function test () {\n      var a; // 在函数作用域内，被提升最前面\n      console.log(a); // undefined\n      a = renbo; \n    }\n    test();\n   ```\n","source":"_posts/javascript/voao.md","raw":"---\ntitle: vo 和 ao\ndate: 2019-2-20 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n## 变量提升\n\n### 执行步骤\njs代码虽然是逐行向下执行的，但执行的时候分为两个步骤**\n- 编译阶段（词法解释/预解释）\n- 执行\n\n### 编译阶段\n函数声明和变量声明总是会被解释器(编译阶段)悄悄地被“提升”到最顶部，最后执行\n\n### 解析顺序\n- this和arguments（语言内置）\n- 函数的形式参数\n- 函数声明\n- 变量声明\n\n### 优先级\n函数的声明比变量的声明的优先级要高\n\n### es6中let关键字及块及作用域\n\n  demo1\n\n     ```js\n     a = 'renbo';\n     var a;\n     console.log( a ); // renbo\n\n     // 编译后的代码\n     var a;\n     a = 'renbo';\n     console.log(a); \n     ```\n  demo2\n\n      ```js\n      function demo() {\n        a = 'renbo';\n        console.log(a);\n        console.log(window.a);\n        var a = 'zhangsan';\n        console.log(a);\n      }\n      demo(); \n\n      // 编译后的代码\n      function demo() {\n        var a;\n        a = 'renbo';\n        console.log(a);\n        console.log(window.a);\n        a = 'zhangsan';\n        console.log(a);\n      }\n      demo(); // renbo undefined zhangsan\n      ``` \n ## 函数提升\n  \n   ```js\n   // 两种函数的书写方式\n   var fn = function fn(){} //函数表达式\n   function fn(){} //函数声明方式 \n   ```\n\n   只有声明方式的函数才会有函数提升\n   \n   ```js\n    test();\n    function test(){\n      console.log( a );\n      var a = 'renbo';\n    }\n\n    // 编译后\n    function test () {\n      var a; // 在函数作用域内，被提升最前面\n      console.log(a); // undefined\n      a = renbo; \n    }\n    test();\n   ```\n","slug":"javascript/voao","published":1,"updated":"2019-10-15T01:29:42.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ort0021b0u6bq43jabe","content":"<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><h3 id=\"执行步骤\"><a href=\"#执行步骤\" class=\"headerlink\" title=\"执行步骤\"></a>执行步骤</h3><p>js代码虽然是逐行向下执行的，但执行的时候分为两个步骤**</p>\n<ul>\n<li>编译阶段（词法解释/预解释）</li>\n<li>执行</li>\n</ul>\n<h3 id=\"编译阶段\"><a href=\"#编译阶段\" class=\"headerlink\" title=\"编译阶段\"></a>编译阶段</h3><p>函数声明和变量声明总是会被解释器(编译阶段)悄悄地被“提升”到最顶部，最后执行</p>\n<h3 id=\"解析顺序\"><a href=\"#解析顺序\" class=\"headerlink\" title=\"解析顺序\"></a>解析顺序</h3><ul>\n<li>this和arguments（语言内置）</li>\n<li>函数的形式参数</li>\n<li>函数声明</li>\n<li>变量声明</li>\n</ul>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>函数的声明比变量的声明的优先级要高</p>\n<h3 id=\"es6中let关键字及块及作用域\"><a href=\"#es6中let关键字及块及作用域\" class=\"headerlink\" title=\"es6中let关键字及块及作用域\"></a>es6中let关键字及块及作用域</h3><p>  demo1</p>\n<pre><code> ```js\n a = &#39;renbo&#39;;\n var a;\n console.log( a ); // renbo\n\n // 编译后的代码\n var a;\n a = &#39;renbo&#39;;\n console.log(a); \n ```</code></pre><p>  demo2</p>\n<pre><code>  ```js\n  function demo() {\n    a = &#39;renbo&#39;;\n    console.log(a);\n    console.log(window.a);\n    var a = &#39;zhangsan&#39;;\n    console.log(a);\n  }\n  demo(); \n\n  // 编译后的代码\n  function demo() {\n    var a;\n    a = &#39;renbo&#39;;\n    console.log(a);\n    console.log(window.a);\n    a = &#39;zhangsan&#39;;\n    console.log(a);\n  }\n  demo(); // renbo undefined zhangsan\n  ``` </code></pre><h2 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h2><pre class=\"line-numbers language-js\"><code class=\"language-js\">   <span class=\"token comment\" spellcheck=\"true\">// 两种函数的书写方式</span>\n   <span class=\"token keyword\">var</span> fn <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">//函数表达式</span>\n   <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">//函数声明方式 </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>   只有声明方式的函数才会有函数提升</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> a <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">'renbo'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 编译后</span>\n    <span class=\"token keyword\">function</span> test <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 在函数作用域内，被提升最前面</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// undefined</span>\n      a <span class=\"token operator\">=</span> renbo<span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><h3 id=\"执行步骤\"><a href=\"#执行步骤\" class=\"headerlink\" title=\"执行步骤\"></a>执行步骤</h3><p>js代码虽然是逐行向下执行的，但执行的时候分为两个步骤**</p>\n<ul>\n<li>编译阶段（词法解释/预解释）</li>\n<li>执行</li>\n</ul>\n<h3 id=\"编译阶段\"><a href=\"#编译阶段\" class=\"headerlink\" title=\"编译阶段\"></a>编译阶段</h3><p>函数声明和变量声明总是会被解释器(编译阶段)悄悄地被“提升”到最顶部，最后执行</p>\n<h3 id=\"解析顺序\"><a href=\"#解析顺序\" class=\"headerlink\" title=\"解析顺序\"></a>解析顺序</h3><ul>\n<li>this和arguments（语言内置）</li>\n<li>函数的形式参数</li>\n<li>函数声明</li>\n<li>变量声明</li>\n</ul>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>函数的声明比变量的声明的优先级要高</p>\n<h3 id=\"es6中let关键字及块及作用域\"><a href=\"#es6中let关键字及块及作用域\" class=\"headerlink\" title=\"es6中let关键字及块及作用域\"></a>es6中let关键字及块及作用域</h3><p>  demo1</p>\n<pre><code> ```js\n a = &#39;renbo&#39;;\n var a;\n console.log( a ); // renbo\n\n // 编译后的代码\n var a;\n a = &#39;renbo&#39;;\n console.log(a); \n ```</code></pre><p>  demo2</p>\n<pre><code>  ```js\n  function demo() {\n    a = &#39;renbo&#39;;\n    console.log(a);\n    console.log(window.a);\n    var a = &#39;zhangsan&#39;;\n    console.log(a);\n  }\n  demo(); \n\n  // 编译后的代码\n  function demo() {\n    var a;\n    a = &#39;renbo&#39;;\n    console.log(a);\n    console.log(window.a);\n    a = &#39;zhangsan&#39;;\n    console.log(a);\n  }\n  demo(); // renbo undefined zhangsan\n  ``` </code></pre><h2 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h2><pre><code class=\"js\">   // 两种函数的书写方式\n   var fn = function fn(){} //函数表达式\n   function fn(){} //函数声明方式 </code></pre>\n<p>   只有声明方式的函数才会有函数提升</p>\n<pre><code class=\"js\">    test();\n    function test(){\n      console.log( a );\n      var a = &#39;renbo&#39;;\n    }\n\n    // 编译后\n    function test () {\n      var a; // 在函数作用域内，被提升最前面\n      console.log(a); // undefined\n      a = renbo; \n    }\n    test();</code></pre>\n"},{"title":"文件权限","date":"2018-07-25T14:05:25.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### 三种基本权限\n\n```\nR  读  数值表示为4\nW  写  数值表示为2\nX  可执行  数值表示为1\n```\n\n1.执行ls -al命令行会出现<br/>\n```\ndrwxr-xr-x  19 renbo  staff   608B Mar 27 11:31 -notes-summary\ndrwxr-xr-x  41 renbo  staff   1.3K Mar 12 17:05 ant-design-pro\ndrwxr-xr-x   7 renbo  staff   224B May 18  2018 canvas\ndrwxr-xr-x   8 renbo  staff   256B Sep 11  2017 doT-demo\ndrwxr-xr-x  19 renbo  staff   608B May 24  2018 egg-example\ndrwxr-xr-x   4 renbo  staff   128B Nov 21 13:52 express\ndrwxr-xr-x   3 renbo  staff    96B Aug 13  2018 flutter\n```\n2.解释：\n```\nd ：第一位表示文件类型，d是目录文件、l是链接文件、-是普通文件、p是管道\n\nrwx ：第2-4位表示这个文件的属主拥有的权限。r是读、w是写、x是执行\n\nr-x ：第5-7位表示和这个文件属主所在同一个组的用户所具有的权限\n\nr-x ：第8-10位表示其他用户所具有的权限\n\nr:read就是读权限     --数字4表示\n\nw:write就是写权限    --数字2表示\n\nx:excute就是执行权限 --数字1表示\n```\n\n### 更改权限\n\n```\nsudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 \n\n例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为\"-rwxrw-r-x\"，用数值表示为765\n\nsudo chmod u+x g+w o+r  filename\n\n上面的例子可以用数值表示\n\nsudo chmod 765 filename\n\n一般超级权限为sudo chmod 777 filename\n```\n\n","source":"_posts/linux/fileauth.md","raw":"---\ntitle: 文件权限\ndate: 2018-7-25 22:05:25\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n\n### 三种基本权限\n\n```\nR  读  数值表示为4\nW  写  数值表示为2\nX  可执行  数值表示为1\n```\n\n1.执行ls -al命令行会出现<br/>\n```\ndrwxr-xr-x  19 renbo  staff   608B Mar 27 11:31 -notes-summary\ndrwxr-xr-x  41 renbo  staff   1.3K Mar 12 17:05 ant-design-pro\ndrwxr-xr-x   7 renbo  staff   224B May 18  2018 canvas\ndrwxr-xr-x   8 renbo  staff   256B Sep 11  2017 doT-demo\ndrwxr-xr-x  19 renbo  staff   608B May 24  2018 egg-example\ndrwxr-xr-x   4 renbo  staff   128B Nov 21 13:52 express\ndrwxr-xr-x   3 renbo  staff    96B Aug 13  2018 flutter\n```\n2.解释：\n```\nd ：第一位表示文件类型，d是目录文件、l是链接文件、-是普通文件、p是管道\n\nrwx ：第2-4位表示这个文件的属主拥有的权限。r是读、w是写、x是执行\n\nr-x ：第5-7位表示和这个文件属主所在同一个组的用户所具有的权限\n\nr-x ：第8-10位表示其他用户所具有的权限\n\nr:read就是读权限     --数字4表示\n\nw:write就是写权限    --数字2表示\n\nx:excute就是执行权限 --数字1表示\n```\n\n### 更改权限\n\n```\nsudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 \n\n例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为\"-rwxrw-r-x\"，用数值表示为765\n\nsudo chmod u+x g+w o+r  filename\n\n上面的例子可以用数值表示\n\nsudo chmod 765 filename\n\n一般超级权限为sudo chmod 777 filename\n```\n\n","slug":"linux/fileauth","published":1,"updated":"2019-10-15T01:29:42.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8orv0024b0u6azbikh0k","content":"<h3 id=\"三种基本权限\"><a href=\"#三种基本权限\" class=\"headerlink\" title=\"三种基本权限\"></a>三种基本权限</h3><pre><code>R  读  数值表示为4\nW  写  数值表示为2\nX  可执行  数值表示为1</code></pre><p>1.执行ls -al命令行会出现<br></p>\n<pre><code>drwxr-xr-x  19 renbo  staff   608B Mar 27 11:31 -notes-summary\ndrwxr-xr-x  41 renbo  staff   1.3K Mar 12 17:05 ant-design-pro\ndrwxr-xr-x   7 renbo  staff   224B May 18  2018 canvas\ndrwxr-xr-x   8 renbo  staff   256B Sep 11  2017 doT-demo\ndrwxr-xr-x  19 renbo  staff   608B May 24  2018 egg-example\ndrwxr-xr-x   4 renbo  staff   128B Nov 21 13:52 express\ndrwxr-xr-x   3 renbo  staff    96B Aug 13  2018 flutter</code></pre><p>2.解释：</p>\n<pre><code>d ：第一位表示文件类型，d是目录文件、l是链接文件、-是普通文件、p是管道\n\nrwx ：第2-4位表示这个文件的属主拥有的权限。r是读、w是写、x是执行\n\nr-x ：第5-7位表示和这个文件属主所在同一个组的用户所具有的权限\n\nr-x ：第8-10位表示其他用户所具有的权限\n\nr:read就是读权限     --数字4表示\n\nw:write就是写权限    --数字2表示\n\nx:excute就是执行权限 --数字1表示</code></pre><h3 id=\"更改权限\"><a href=\"#更改权限\" class=\"headerlink\" title=\"更改权限\"></a>更改权限</h3><pre><code>sudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 \n\n例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765\n\nsudo chmod u+x g+w o+r  filename\n\n上面的例子可以用数值表示\n\nsudo chmod 765 filename\n\n一般超级权限为sudo chmod 777 filename</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"三种基本权限\"><a href=\"#三种基本权限\" class=\"headerlink\" title=\"三种基本权限\"></a>三种基本权限</h3><pre><code>R  读  数值表示为4\nW  写  数值表示为2\nX  可执行  数值表示为1</code></pre><p>1.执行ls -al命令行会出现<br></p>\n<pre><code>drwxr-xr-x  19 renbo  staff   608B Mar 27 11:31 -notes-summary\ndrwxr-xr-x  41 renbo  staff   1.3K Mar 12 17:05 ant-design-pro\ndrwxr-xr-x   7 renbo  staff   224B May 18  2018 canvas\ndrwxr-xr-x   8 renbo  staff   256B Sep 11  2017 doT-demo\ndrwxr-xr-x  19 renbo  staff   608B May 24  2018 egg-example\ndrwxr-xr-x   4 renbo  staff   128B Nov 21 13:52 express\ndrwxr-xr-x   3 renbo  staff    96B Aug 13  2018 flutter</code></pre><p>2.解释：</p>\n<pre><code>d ：第一位表示文件类型，d是目录文件、l是链接文件、-是普通文件、p是管道\n\nrwx ：第2-4位表示这个文件的属主拥有的权限。r是读、w是写、x是执行\n\nr-x ：第5-7位表示和这个文件属主所在同一个组的用户所具有的权限\n\nr-x ：第8-10位表示其他用户所具有的权限\n\nr:read就是读权限     --数字4表示\n\nw:write就是写权限    --数字2表示\n\nx:excute就是执行权限 --数字1表示</code></pre><h3 id=\"更改权限\"><a href=\"#更改权限\" class=\"headerlink\" title=\"更改权限\"></a>更改权限</h3><pre><code>sudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 \n\n例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765\n\nsudo chmod u+x g+w o+r  filename\n\n上面的例子可以用数值表示\n\nsudo chmod 765 filename\n\n一般超级权限为sudo chmod 777 filename</code></pre>"},{"title":"Linux打包压缩相关指令","date":"2018-07-10T12:48:35.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### bzip2(选项)(参数)\n\n命令用于创建和管理（包括解压缩）\n\n  ```\n  -c或——stdout：将压缩与解压缩的结果送到标准输出；\n  -d或——decompress：执行解压缩；\n  -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；\n  -h或——help：在线帮助；\n  -k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；\n  -s或——small：降低程序执行时内存的使用量；\n  -t或——test：测试.bz2压缩文件的完整性；\n  -v或——verbose：压缩或解压缩文件时，显示详细的信息；\n  -z或——compress：强制执行压缩；\n  -V或——version：显示版本信息；\n  --repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；\n  --repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。\n  ```\n\n### gunzip(选项)(参数)\n\n命令用来解压缩文件\n\n  ```\n  -a或——ascii：使用ASCII文字模式；\n  -c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；\n  -f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；\n  -N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；\n  ```\n\n### gzip(选项)(参数)\n\n命令用来压缩文件\n\n  ```\n  -a或——ascii：使用ASCII文字模式；\n  -d或--decompress或----uncompress：解开压缩文件；\n  -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；\n  -N或——name：压缩文件时，保存原来的文件名称及时间戳记；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；\n  -<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；\n  --best：此参数的效果和指定“-9”参数相同；\n  --fast：此参数的效果和指定“-1”参数相同。\n  ```\n\n### tar(选项)(参数)\n\n命令用来解压压缩文件\n\n  ```\n  -A或--catenate：新增文件到以存在的备份文件；\n  -B：设置区块大小；\n  -c或--create：建立新的备份文件；\n  -C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n  -d：记录文件的差别；\n  -x或--extract或--get：从备份文件中还原文件；\n  -t或--list：列出备份文件的内容；\n  -z或--gzip或--ungzip：通过gzip指令处理备份文件；\n  -Z或--compress或--uncompress：通过compress指令处理备份文件；\n  -f<备份文件>或--file=<备份文件>：指定备份文件；\n  -v或--verbose：显示指令执行过程；\n  -r：添加文件到已经压缩的文件；\n  -u：添加改变了和现有的文件到已经存在的压缩文件；\n  -j：支持bzip2解压文件；\n  -v：显示操作过程；\n  -l：文件系统边界设置；\n  -k：保留原有文件不覆盖；\n  -m：保留文件不被覆盖；\n  -w：确认压缩文件的正确性；\n  -p或--same-permissions：用原来的文件权限还原文件；\n  -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；\n  -N <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；\n  --exclude=<范本样式>：排除符合范本样式的文件。\n  ```\n  实例<br/>\n  ```\n  tar -cvf log.tar log2012.log    仅打包，不压缩！ \n  tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n  tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n  ```\n\n### zip(选项)(参数)\n\n命令可以用来解压缩文件\n\n  ```\n  -A：调整可执行的自动解压缩文件；\n  -b<工作目录>：指定暂时存放文件的目录；\n  -c：替每个被压缩的文件加上注释；\n  -d：从压缩文件内删除指定的文件；\n  -D：压缩文件内不建立目录名称；\n  -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；\n  -F：尝试修复已损坏的压缩文件；\n  -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；\n  -h：在线帮助；\n  -i<范本样式>：只压缩符合条件的文件；\n  -j：只保存文件名称及其内容，而不存放任何目录名称；\n  -J：删除压缩文件前面不必要的数据；\n  -k：使用MS-DOS兼容格式的文件名称；\n  -l：压缩文件时，把LF字符置换成LF+CR字符；\n  -ll：压缩文件时，把LF+cp字符置换成LF字符；\n  -L：显示版权信息；\n  -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；\n  -n<字尾字符串>：不压缩具有特定字尾字符串的文件；\n  -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；\n  -q：不显示指令执行过程；\n  -r：递归处理，将指定目录下的所有文件和子目录一并处理；\n  -S：包含系统和隐藏文件；\n  -t<日期时间>：把压缩文件的日期设成指定的日期；\n  -T：检查备份文件内的每个文件是否正确无误；\n  -u：更换较新的文件到压缩文件内；\n  -v：显示指令执行过程或显示版本信息；\n  -V：保存VMS操作系统的文件属性；\n  -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；\n  -x<范本样式>：压缩时排除符合条件的文件；\n  -X：不保存额外的文件属性；\n  -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；\n  -z：替压缩文件加上注释；\n  -$：保存第一个被压缩文件所在磁盘的卷册名称；\n  -<压缩效率>：压缩效率是一个介于1~9的数值。\n  ```\n  实例<br/>\n  ```\n  zip file1.zip file1 创建一个zip格式的压缩包 \n  zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \n  unzip file1.zip 解压一个zip格式压缩包 \n  ```\n\n\n\n","source":"_posts/linux/compression.md","raw":"---\ntitle: Linux打包压缩相关指令\ndate: 2018-7-10 20:48:35\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n\n### bzip2(选项)(参数)\n\n命令用于创建和管理（包括解压缩）\n\n  ```\n  -c或——stdout：将压缩与解压缩的结果送到标准输出；\n  -d或——decompress：执行解压缩；\n  -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；\n  -h或——help：在线帮助；\n  -k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；\n  -s或——small：降低程序执行时内存的使用量；\n  -t或——test：测试.bz2压缩文件的完整性；\n  -v或——verbose：压缩或解压缩文件时，显示详细的信息；\n  -z或——compress：强制执行压缩；\n  -V或——version：显示版本信息；\n  --repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；\n  --repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。\n  ```\n\n### gunzip(选项)(参数)\n\n命令用来解压缩文件\n\n  ```\n  -a或——ascii：使用ASCII文字模式；\n  -c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；\n  -f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；\n  -N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；\n  ```\n\n### gzip(选项)(参数)\n\n命令用来压缩文件\n\n  ```\n  -a或——ascii：使用ASCII文字模式；\n  -d或--decompress或----uncompress：解开压缩文件；\n  -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；\n  -N或——name：压缩文件时，保存原来的文件名称及时间戳记；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；\n  -<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；\n  --best：此参数的效果和指定“-9”参数相同；\n  --fast：此参数的效果和指定“-1”参数相同。\n  ```\n\n### tar(选项)(参数)\n\n命令用来解压压缩文件\n\n  ```\n  -A或--catenate：新增文件到以存在的备份文件；\n  -B：设置区块大小；\n  -c或--create：建立新的备份文件；\n  -C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n  -d：记录文件的差别；\n  -x或--extract或--get：从备份文件中还原文件；\n  -t或--list：列出备份文件的内容；\n  -z或--gzip或--ungzip：通过gzip指令处理备份文件；\n  -Z或--compress或--uncompress：通过compress指令处理备份文件；\n  -f<备份文件>或--file=<备份文件>：指定备份文件；\n  -v或--verbose：显示指令执行过程；\n  -r：添加文件到已经压缩的文件；\n  -u：添加改变了和现有的文件到已经存在的压缩文件；\n  -j：支持bzip2解压文件；\n  -v：显示操作过程；\n  -l：文件系统边界设置；\n  -k：保留原有文件不覆盖；\n  -m：保留文件不被覆盖；\n  -w：确认压缩文件的正确性；\n  -p或--same-permissions：用原来的文件权限还原文件；\n  -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；\n  -N <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；\n  --exclude=<范本样式>：排除符合范本样式的文件。\n  ```\n  实例<br/>\n  ```\n  tar -cvf log.tar log2012.log    仅打包，不压缩！ \n  tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n  tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n  ```\n\n### zip(选项)(参数)\n\n命令可以用来解压缩文件\n\n  ```\n  -A：调整可执行的自动解压缩文件；\n  -b<工作目录>：指定暂时存放文件的目录；\n  -c：替每个被压缩的文件加上注释；\n  -d：从压缩文件内删除指定的文件；\n  -D：压缩文件内不建立目录名称；\n  -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；\n  -F：尝试修复已损坏的压缩文件；\n  -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；\n  -h：在线帮助；\n  -i<范本样式>：只压缩符合条件的文件；\n  -j：只保存文件名称及其内容，而不存放任何目录名称；\n  -J：删除压缩文件前面不必要的数据；\n  -k：使用MS-DOS兼容格式的文件名称；\n  -l：压缩文件时，把LF字符置换成LF+CR字符；\n  -ll：压缩文件时，把LF+cp字符置换成LF字符；\n  -L：显示版权信息；\n  -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；\n  -n<字尾字符串>：不压缩具有特定字尾字符串的文件；\n  -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；\n  -q：不显示指令执行过程；\n  -r：递归处理，将指定目录下的所有文件和子目录一并处理；\n  -S：包含系统和隐藏文件；\n  -t<日期时间>：把压缩文件的日期设成指定的日期；\n  -T：检查备份文件内的每个文件是否正确无误；\n  -u：更换较新的文件到压缩文件内；\n  -v：显示指令执行过程或显示版本信息；\n  -V：保存VMS操作系统的文件属性；\n  -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；\n  -x<范本样式>：压缩时排除符合条件的文件；\n  -X：不保存额外的文件属性；\n  -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；\n  -z：替压缩文件加上注释；\n  -$：保存第一个被压缩文件所在磁盘的卷册名称；\n  -<压缩效率>：压缩效率是一个介于1~9的数值。\n  ```\n  实例<br/>\n  ```\n  zip file1.zip file1 创建一个zip格式的压缩包 \n  zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \n  unzip file1.zip 解压一个zip格式压缩包 \n  ```\n\n\n\n","slug":"linux/compression","published":1,"updated":"2019-10-15T01:29:42.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ory0029b0u6m9z4o23n","content":"<h3 id=\"bzip2-选项-参数\"><a href=\"#bzip2-选项-参数\" class=\"headerlink\" title=\"bzip2(选项)(参数)\"></a>bzip2(选项)(参数)</h3><p>命令用于创建和管理（包括解压缩）</p>\n<pre><code>  -c或——stdout：将压缩与解压缩的结果送到标准输出；\n  -d或——decompress：执行解压缩；\n  -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；\n  -h或——help：在线帮助；\n  -k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；\n  -s或——small：降低程序执行时内存的使用量；\n  -t或——test：测试.bz2压缩文件的完整性；\n  -v或——verbose：压缩或解压缩文件时，显示详细的信息；\n  -z或——compress：强制执行压缩；\n  -V或——version：显示版本信息；\n  --repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；\n  --repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。</code></pre><h3 id=\"gunzip-选项-参数\"><a href=\"#gunzip-选项-参数\" class=\"headerlink\" title=\"gunzip(选项)(参数)\"></a>gunzip(选项)(参数)</h3><p>命令用来解压缩文件</p>\n<pre><code>  -a或——ascii：使用ASCII文字模式；\n  -c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；\n  -f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；\n  -N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；</code></pre><h3 id=\"gzip-选项-参数\"><a href=\"#gzip-选项-参数\" class=\"headerlink\" title=\"gzip(选项)(参数)\"></a>gzip(选项)(参数)</h3><p>命令用来压缩文件</p>\n<pre><code>  -a或——ascii：使用ASCII文字模式；\n  -d或--decompress或----uncompress：解开压缩文件；\n  -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；\n  -N或——name：压缩文件时，保存原来的文件名称及时间戳记；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；\n  -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；\n  --best：此参数的效果和指定“-9”参数相同；\n  --fast：此参数的效果和指定“-1”参数相同。</code></pre><h3 id=\"tar-选项-参数\"><a href=\"#tar-选项-参数\" class=\"headerlink\" title=\"tar(选项)(参数)\"></a>tar(选项)(参数)</h3><p>命令用来解压压缩文件</p>\n<pre><code>  -A或--catenate：新增文件到以存在的备份文件；\n  -B：设置区块大小；\n  -c或--create：建立新的备份文件；\n  -C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n  -d：记录文件的差别；\n  -x或--extract或--get：从备份文件中还原文件；\n  -t或--list：列出备份文件的内容；\n  -z或--gzip或--ungzip：通过gzip指令处理备份文件；\n  -Z或--compress或--uncompress：通过compress指令处理备份文件；\n  -f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；\n  -v或--verbose：显示指令执行过程；\n  -r：添加文件到已经压缩的文件；\n  -u：添加改变了和现有的文件到已经存在的压缩文件；\n  -j：支持bzip2解压文件；\n  -v：显示操作过程；\n  -l：文件系统边界设置；\n  -k：保留原有文件不覆盖；\n  -m：保留文件不被覆盖；\n  -w：确认压缩文件的正确性；\n  -p或--same-permissions：用原来的文件权限还原文件；\n  -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；\n  -N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；\n  --exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</code></pre><p>  实例<br></p>\n<pre><code>  tar -cvf log.tar log2012.log    仅打包，不压缩！ \n  tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n  tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 </code></pre><h3 id=\"zip-选项-参数\"><a href=\"#zip-选项-参数\" class=\"headerlink\" title=\"zip(选项)(参数)\"></a>zip(选项)(参数)</h3><p>命令可以用来解压缩文件</p>\n<pre><code>  -A：调整可执行的自动解压缩文件；\n  -b&lt;工作目录&gt;：指定暂时存放文件的目录；\n  -c：替每个被压缩的文件加上注释；\n  -d：从压缩文件内删除指定的文件；\n  -D：压缩文件内不建立目录名称；\n  -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；\n  -F：尝试修复已损坏的压缩文件；\n  -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；\n  -h：在线帮助；\n  -i&lt;范本样式&gt;：只压缩符合条件的文件；\n  -j：只保存文件名称及其内容，而不存放任何目录名称；\n  -J：删除压缩文件前面不必要的数据；\n  -k：使用MS-DOS兼容格式的文件名称；\n  -l：压缩文件时，把LF字符置换成LF+CR字符；\n  -ll：压缩文件时，把LF+cp字符置换成LF字符；\n  -L：显示版权信息；\n  -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；\n  -n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件；\n  -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；\n  -q：不显示指令执行过程；\n  -r：递归处理，将指定目录下的所有文件和子目录一并处理；\n  -S：包含系统和隐藏文件；\n  -t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期；\n  -T：检查备份文件内的每个文件是否正确无误；\n  -u：更换较新的文件到压缩文件内；\n  -v：显示指令执行过程或显示版本信息；\n  -V：保存VMS操作系统的文件属性；\n  -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；\n  -x&lt;范本样式&gt;：压缩时排除符合条件的文件；\n  -X：不保存额外的文件属性；\n  -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；\n  -z：替压缩文件加上注释；\n  -$：保存第一个被压缩文件所在磁盘的卷册名称；\n  -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值。</code></pre><p>  实例<br></p>\n<pre><code>  zip file1.zip file1 创建一个zip格式的压缩包 \n  zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \n  unzip file1.zip 解压一个zip格式压缩包 </code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"bzip2-选项-参数\"><a href=\"#bzip2-选项-参数\" class=\"headerlink\" title=\"bzip2(选项)(参数)\"></a>bzip2(选项)(参数)</h3><p>命令用于创建和管理（包括解压缩）</p>\n<pre><code>  -c或——stdout：将压缩与解压缩的结果送到标准输出；\n  -d或——decompress：执行解压缩；\n  -f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；\n  -h或——help：在线帮助；\n  -k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；\n  -s或——small：降低程序执行时内存的使用量；\n  -t或——test：测试.bz2压缩文件的完整性；\n  -v或——verbose：压缩或解压缩文件时，显示详细的信息；\n  -z或——compress：强制执行压缩；\n  -V或——version：显示版本信息；\n  --repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；\n  --repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。</code></pre><h3 id=\"gunzip-选项-参数\"><a href=\"#gunzip-选项-参数\" class=\"headerlink\" title=\"gunzip(选项)(参数)\"></a>gunzip(选项)(参数)</h3><p>命令用来解压缩文件</p>\n<pre><code>  -a或——ascii：使用ASCII文字模式；\n  -c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；\n  -f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；\n  -N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；</code></pre><h3 id=\"gzip-选项-参数\"><a href=\"#gzip-选项-参数\" class=\"headerlink\" title=\"gzip(选项)(参数)\"></a>gzip(选项)(参数)</h3><p>命令用来压缩文件</p>\n<pre><code>  -a或——ascii：使用ASCII文字模式；\n  -d或--decompress或----uncompress：解开压缩文件；\n  -f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；\n  -h或——help：在线帮助；\n  -l或——list：列出压缩文件的相关信息；\n  -L或——license：显示版本与版权信息；\n  -n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；\n  -N或——name：压缩文件时，保存原来的文件名称及时间戳记；\n  -q或——quiet：不显示警告信息；\n  -r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n  -S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；\n  -t或——test：测试压缩文件是否正确无误；\n  -v或——verbose：显示指令执行过程；\n  -V或——version：显示版本信息；\n  -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；\n  --best：此参数的效果和指定“-9”参数相同；\n  --fast：此参数的效果和指定“-1”参数相同。</code></pre><h3 id=\"tar-选项-参数\"><a href=\"#tar-选项-参数\" class=\"headerlink\" title=\"tar(选项)(参数)\"></a>tar(选项)(参数)</h3><p>命令用来解压压缩文件</p>\n<pre><code>  -A或--catenate：新增文件到以存在的备份文件；\n  -B：设置区块大小；\n  -c或--create：建立新的备份文件；\n  -C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。\n  -d：记录文件的差别；\n  -x或--extract或--get：从备份文件中还原文件；\n  -t或--list：列出备份文件的内容；\n  -z或--gzip或--ungzip：通过gzip指令处理备份文件；\n  -Z或--compress或--uncompress：通过compress指令处理备份文件；\n  -f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；\n  -v或--verbose：显示指令执行过程；\n  -r：添加文件到已经压缩的文件；\n  -u：添加改变了和现有的文件到已经存在的压缩文件；\n  -j：支持bzip2解压文件；\n  -v：显示操作过程；\n  -l：文件系统边界设置；\n  -k：保留原有文件不覆盖；\n  -m：保留文件不被覆盖；\n  -w：确认压缩文件的正确性；\n  -p或--same-permissions：用原来的文件权限还原文件；\n  -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；\n  -N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；\n  --exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</code></pre><p>  实例<br></p>\n<pre><code>  tar -cvf log.tar log2012.log    仅打包，不压缩！ \n  tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n  tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 </code></pre><h3 id=\"zip-选项-参数\"><a href=\"#zip-选项-参数\" class=\"headerlink\" title=\"zip(选项)(参数)\"></a>zip(选项)(参数)</h3><p>命令可以用来解压缩文件</p>\n<pre><code>  -A：调整可执行的自动解压缩文件；\n  -b&lt;工作目录&gt;：指定暂时存放文件的目录；\n  -c：替每个被压缩的文件加上注释；\n  -d：从压缩文件内删除指定的文件；\n  -D：压缩文件内不建立目录名称；\n  -f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；\n  -F：尝试修复已损坏的压缩文件；\n  -g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；\n  -h：在线帮助；\n  -i&lt;范本样式&gt;：只压缩符合条件的文件；\n  -j：只保存文件名称及其内容，而不存放任何目录名称；\n  -J：删除压缩文件前面不必要的数据；\n  -k：使用MS-DOS兼容格式的文件名称；\n  -l：压缩文件时，把LF字符置换成LF+CR字符；\n  -ll：压缩文件时，把LF+cp字符置换成LF字符；\n  -L：显示版权信息；\n  -m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；\n  -n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件；\n  -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；\n  -q：不显示指令执行过程；\n  -r：递归处理，将指定目录下的所有文件和子目录一并处理；\n  -S：包含系统和隐藏文件；\n  -t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期；\n  -T：检查备份文件内的每个文件是否正确无误；\n  -u：更换较新的文件到压缩文件内；\n  -v：显示指令执行过程或显示版本信息；\n  -V：保存VMS操作系统的文件属性；\n  -w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；\n  -x&lt;范本样式&gt;：压缩时排除符合条件的文件；\n  -X：不保存额外的文件属性；\n  -y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；\n  -z：替压缩文件加上注释；\n  -$：保存第一个被压缩文件所在磁盘的卷册名称；\n  -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值。</code></pre><p>  实例<br></p>\n<pre><code>  zip file1.zip file1 创建一个zip格式的压缩包 \n  zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \n  unzip file1.zip 解压一个zip格式压缩包 </code></pre>"},{"title":"Linux备份操作","date":"2018-07-15T15:05:38.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### tar\n\n```\ntar -cvf log.tar log2012.log    仅打包，不压缩！ \n\ntar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n\ntar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n\ntar -zxvf /opt/soft/test/log.tar.gz 解压缩\n```\n\n### dump\n\n```\ndump -0aj -f /tmp/home0.bak /home  制作一个 '/home' 目录的完整备份\n\ndump -1aj -f /tmp/home0.bak /home  制作一个 '/home' 目录的交互式备份\n```\n\n### restore\n\n```\nrestore -if /tmp/home0.bak  还原备份\n```\n\n### rsync\n\n```\nrsync -rogpav --delete /home /tmp  同步两边的目录 \n\nrsync -rogpav -e ssh --delete /home ip_address:/tmp  通过SSH通道rsync \n\nrsync -az -e ssh --delete ip_addr:/home/public /home/local  通过ssh和压缩将一个远程目录同步到本地目录 \n\nrsync -az -e ssh --delete /home/local ip_addr:/home/public  通过ssh和压缩将本地目录同步到远程目录 \n```\n\n\n\n","source":"_posts/linux/backup.md","raw":"---\ntitle: Linux备份操作\ndate: 2018-7-15 23:05:38\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n### tar\n\n```\ntar -cvf log.tar log2012.log    仅打包，不压缩！ \n\ntar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n\ntar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n\ntar -zxvf /opt/soft/test/log.tar.gz 解压缩\n```\n\n### dump\n\n```\ndump -0aj -f /tmp/home0.bak /home  制作一个 '/home' 目录的完整备份\n\ndump -1aj -f /tmp/home0.bak /home  制作一个 '/home' 目录的交互式备份\n```\n\n### restore\n\n```\nrestore -if /tmp/home0.bak  还原备份\n```\n\n### rsync\n\n```\nrsync -rogpav --delete /home /tmp  同步两边的目录 \n\nrsync -rogpav -e ssh --delete /home ip_address:/tmp  通过SSH通道rsync \n\nrsync -az -e ssh --delete ip_addr:/home/public /home/local  通过ssh和压缩将一个远程目录同步到本地目录 \n\nrsync -az -e ssh --delete /home/local ip_addr:/home/public  通过ssh和压缩将本地目录同步到远程目录 \n```\n\n\n\n","slug":"linux/backup","published":1,"updated":"2019-10-15T01:29:42.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8os0002cb0u6sbs1qma6","content":"<h3 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h3><pre><code>tar -cvf log.tar log2012.log    仅打包，不压缩！ \n\ntar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n\ntar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n\ntar -zxvf /opt/soft/test/log.tar.gz 解压缩</code></pre><h3 id=\"dump\"><a href=\"#dump\" class=\"headerlink\" title=\"dump\"></a>dump</h3><pre><code>dump -0aj -f /tmp/home0.bak /home  制作一个 &#39;/home&#39; 目录的完整备份\n\ndump -1aj -f /tmp/home0.bak /home  制作一个 &#39;/home&#39; 目录的交互式备份</code></pre><h3 id=\"restore\"><a href=\"#restore\" class=\"headerlink\" title=\"restore\"></a>restore</h3><pre><code>restore -if /tmp/home0.bak  还原备份</code></pre><h3 id=\"rsync\"><a href=\"#rsync\" class=\"headerlink\" title=\"rsync\"></a>rsync</h3><pre><code>rsync -rogpav --delete /home /tmp  同步两边的目录 \n\nrsync -rogpav -e ssh --delete /home ip_address:/tmp  通过SSH通道rsync \n\nrsync -az -e ssh --delete ip_addr:/home/public /home/local  通过ssh和压缩将一个远程目录同步到本地目录 \n\nrsync -az -e ssh --delete /home/local ip_addr:/home/public  通过ssh和压缩将本地目录同步到远程目录 </code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h3><pre><code>tar -cvf log.tar log2012.log    仅打包，不压缩！ \n\ntar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n\ntar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n\ntar -zxvf /opt/soft/test/log.tar.gz 解压缩</code></pre><h3 id=\"dump\"><a href=\"#dump\" class=\"headerlink\" title=\"dump\"></a>dump</h3><pre><code>dump -0aj -f /tmp/home0.bak /home  制作一个 &#39;/home&#39; 目录的完整备份\n\ndump -1aj -f /tmp/home0.bak /home  制作一个 &#39;/home&#39; 目录的交互式备份</code></pre><h3 id=\"restore\"><a href=\"#restore\" class=\"headerlink\" title=\"restore\"></a>restore</h3><pre><code>restore -if /tmp/home0.bak  还原备份</code></pre><h3 id=\"rsync\"><a href=\"#rsync\" class=\"headerlink\" title=\"rsync\"></a>rsync</h3><pre><code>rsync -rogpav --delete /home /tmp  同步两边的目录 \n\nrsync -rogpav -e ssh --delete /home ip_address:/tmp  通过SSH通道rsync \n\nrsync -az -e ssh --delete ip_addr:/home/public /home/local  通过ssh和压缩将一个远程目录同步到本地目录 \n\nrsync -az -e ssh --delete /home/local ip_addr:/home/public  通过ssh和压缩将本地目录同步到远程目录 </code></pre>"},{"title":"在mac中配置多个github账号ssh密钥","date":"2018-08-10T15:28:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 概述\n很多时候我们本地生成的只有一个自己的ssh，但是多个ssh配置的场景也是蛮多的，所以想要commit，push等操作需要配置私钥ssh或者http，才能连接远程git仓库\n\n### 步骤\n我们假设原来在~/.ssh目录下已经生成了一对密钥,此密钥文件名字是默认生成\n\n```\nid_rsa\nid_rsa.pub\n```\n\n生成第二个ssh key\n\n```\nssh-keygen -t rsa -C \"yourmail@gmail.com\"\n```\n\n这里面不要一路回车，第一步需要我们手动填写保存文件的名字和路径\n\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/renbo/.ssh/id_rsa): /Users/renbo/.ssh/id_rsa_github\n<剩下两个直接回车>\n```\n\n这里我们用id_rsa_github来区别原有密钥对，避免被覆盖。\n完成之后，我们可以看到~/.ssh目录下多了两个文件，变成：\n\n```\nid_rsa\nid_ras.pub\nid_rsa_github\nid_rsa_github.pub\nknown_hosts\n```\n\n打开ssh-agent(关于ssh-agent后续介绍)\n\n这里如果你用的github官方的bash，用：\n\n```\nssh-agent -s\n```\n\n如果是其他的，比如msysgit，用：\n\n```\neval $(ssh-agent -s)\n```\n\n略过这一步的话，下一步会提示这样的错误：Could not open a connection to your authentication agent.\n  \n### 添加私钥\n\n```\nssh-add ~/.ssh/id_rsa\nssh-add ~/.ssh/id_rsa_github\n```\n### 创建config文件\n在~/.ssh目录下创建名为config的文件。mkdir config\n\n打开文件sudo vim config添加一下内容：\n\n```\n# gitlab\n  Host gitlab.com\n  HostName gitlab.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_gitlab\n\n# github\n  Host github.com\n  HostName github.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_github\n```\n\n其中，Host和HostName填写git服务器的域名。\n\nIdentityFile指定私钥的路径。\n\n如果在Linux系统下提示错误：Bad owner or permissions on /home/gary/.ssh/config\n\n说明config权限过大，chmod命令调整：\n\n```\nchmod 644 ~/.ssh/config\n```\n\n然后在github和gitlab上添加公钥即可。githua 在右上角的头像的设置中\n\n### 测试\n然后用ssh命令分别测试：\n\n```\nssh -T git@github.com\n```\n\n### 调试\n  如果到这里你没有成功的话，别急，教你解决问题的终极办法--debug\n\n  比如测试github：\n\n  ```\n  ssh -vT git@github.com\n  ```\n\n  -v 是输出编译信息，然后根据编译信息自己去解决问题吧。\n\n### 关于https用户名\n\n  如果之前有设置全局用户名和邮箱的话，需要unset一下\n\n  ```\n  git config --global --unset user.name\n  git config --global --unset user.email\n  ```\n\n  然后在不同的仓库下设置局部的用户名和邮箱\n\n  比如在公司的repository下\n\n  ```\n  git config user.name \"yourname\" \n  git config user.email \"youremail\"\n  ```\n\n  在自己的github的仓库在执行刚刚的命令一遍即可。\n  \n  这样就可以在不同的仓库，已不同的账号登录。\n\n\n\n\n\n","source":"_posts/linux/git.md","raw":"---\ntitle: 在mac中配置多个github账号ssh密钥\ndate: 2018-8-10 23:28:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n### 概述\n很多时候我们本地生成的只有一个自己的ssh，但是多个ssh配置的场景也是蛮多的，所以想要commit，push等操作需要配置私钥ssh或者http，才能连接远程git仓库\n\n### 步骤\n我们假设原来在~/.ssh目录下已经生成了一对密钥,此密钥文件名字是默认生成\n\n```\nid_rsa\nid_rsa.pub\n```\n\n生成第二个ssh key\n\n```\nssh-keygen -t rsa -C \"yourmail@gmail.com\"\n```\n\n这里面不要一路回车，第一步需要我们手动填写保存文件的名字和路径\n\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/renbo/.ssh/id_rsa): /Users/renbo/.ssh/id_rsa_github\n<剩下两个直接回车>\n```\n\n这里我们用id_rsa_github来区别原有密钥对，避免被覆盖。\n完成之后，我们可以看到~/.ssh目录下多了两个文件，变成：\n\n```\nid_rsa\nid_ras.pub\nid_rsa_github\nid_rsa_github.pub\nknown_hosts\n```\n\n打开ssh-agent(关于ssh-agent后续介绍)\n\n这里如果你用的github官方的bash，用：\n\n```\nssh-agent -s\n```\n\n如果是其他的，比如msysgit，用：\n\n```\neval $(ssh-agent -s)\n```\n\n略过这一步的话，下一步会提示这样的错误：Could not open a connection to your authentication agent.\n  \n### 添加私钥\n\n```\nssh-add ~/.ssh/id_rsa\nssh-add ~/.ssh/id_rsa_github\n```\n### 创建config文件\n在~/.ssh目录下创建名为config的文件。mkdir config\n\n打开文件sudo vim config添加一下内容：\n\n```\n# gitlab\n  Host gitlab.com\n  HostName gitlab.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_gitlab\n\n# github\n  Host github.com\n  HostName github.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_github\n```\n\n其中，Host和HostName填写git服务器的域名。\n\nIdentityFile指定私钥的路径。\n\n如果在Linux系统下提示错误：Bad owner or permissions on /home/gary/.ssh/config\n\n说明config权限过大，chmod命令调整：\n\n```\nchmod 644 ~/.ssh/config\n```\n\n然后在github和gitlab上添加公钥即可。githua 在右上角的头像的设置中\n\n### 测试\n然后用ssh命令分别测试：\n\n```\nssh -T git@github.com\n```\n\n### 调试\n  如果到这里你没有成功的话，别急，教你解决问题的终极办法--debug\n\n  比如测试github：\n\n  ```\n  ssh -vT git@github.com\n  ```\n\n  -v 是输出编译信息，然后根据编译信息自己去解决问题吧。\n\n### 关于https用户名\n\n  如果之前有设置全局用户名和邮箱的话，需要unset一下\n\n  ```\n  git config --global --unset user.name\n  git config --global --unset user.email\n  ```\n\n  然后在不同的仓库下设置局部的用户名和邮箱\n\n  比如在公司的repository下\n\n  ```\n  git config user.name \"yourname\" \n  git config user.email \"youremail\"\n  ```\n\n  在自己的github的仓库在执行刚刚的命令一遍即可。\n  \n  这样就可以在不同的仓库，已不同的账号登录。\n\n\n\n\n\n","slug":"linux/git","published":1,"updated":"2019-10-15T01:29:42.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8os3002hb0u67006nywb","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>很多时候我们本地生成的只有一个自己的ssh，但是多个ssh配置的场景也是蛮多的，所以想要commit，push等操作需要配置私钥ssh或者http，才能连接远程git仓库</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>我们假设原来在~/.ssh目录下已经生成了一对密钥,此密钥文件名字是默认生成</p>\n<pre><code>id_rsa\nid_rsa.pub</code></pre><p>生成第二个ssh key</p>\n<pre><code>ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot;</code></pre><p>这里面不要一路回车，第一步需要我们手动填写保存文件的名字和路径</p>\n<pre><code>Generating public/private rsa key pair.\nEnter file in which to save the key (/Users/renbo/.ssh/id_rsa): /Users/renbo/.ssh/id_rsa_github\n&lt;剩下两个直接回车&gt;</code></pre><p>这里我们用id_rsa_github来区别原有密钥对，避免被覆盖。<br>完成之后，我们可以看到~/.ssh目录下多了两个文件，变成：</p>\n<pre><code>id_rsa\nid_ras.pub\nid_rsa_github\nid_rsa_github.pub\nknown_hosts</code></pre><p>打开ssh-agent(关于ssh-agent后续介绍)</p>\n<p>这里如果你用的github官方的bash，用：</p>\n<pre><code>ssh-agent -s</code></pre><p>如果是其他的，比如msysgit，用：</p>\n<pre><code>eval $(ssh-agent -s)</code></pre><p>略过这一步的话，下一步会提示这样的错误：Could not open a connection to your authentication agent.</p>\n<h3 id=\"添加私钥\"><a href=\"#添加私钥\" class=\"headerlink\" title=\"添加私钥\"></a>添加私钥</h3><pre><code>ssh-add ~/.ssh/id_rsa\nssh-add ~/.ssh/id_rsa_github</code></pre><h3 id=\"创建config文件\"><a href=\"#创建config文件\" class=\"headerlink\" title=\"创建config文件\"></a>创建config文件</h3><p>在~/.ssh目录下创建名为config的文件。mkdir config</p>\n<p>打开文件sudo vim config添加一下内容：</p>\n<pre><code># gitlab\n  Host gitlab.com\n  HostName gitlab.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_gitlab\n\n# github\n  Host github.com\n  HostName github.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_github</code></pre><p>其中，Host和HostName填写git服务器的域名。</p>\n<p>IdentityFile指定私钥的路径。</p>\n<p>如果在Linux系统下提示错误：Bad owner or permissions on /home/gary/.ssh/config</p>\n<p>说明config权限过大，chmod命令调整：</p>\n<pre><code>chmod 644 ~/.ssh/config</code></pre><p>然后在github和gitlab上添加公钥即可。githua 在右上角的头像的设置中</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>然后用ssh命令分别测试：</p>\n<pre><code>ssh -T git@github.com</code></pre><h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>  如果到这里你没有成功的话，别急，教你解决问题的终极办法–debug</p>\n<p>  比如测试github：</p>\n<pre><code>  ssh -vT git@github.com</code></pre><p>  -v 是输出编译信息，然后根据编译信息自己去解决问题吧。</p>\n<h3 id=\"关于https用户名\"><a href=\"#关于https用户名\" class=\"headerlink\" title=\"关于https用户名\"></a>关于https用户名</h3><p>  如果之前有设置全局用户名和邮箱的话，需要unset一下</p>\n<pre><code>  git config --global --unset user.name\n  git config --global --unset user.email</code></pre><p>  然后在不同的仓库下设置局部的用户名和邮箱</p>\n<p>  比如在公司的repository下</p>\n<pre><code>  git config user.name &quot;yourname&quot; \n  git config user.email &quot;youremail&quot;</code></pre><p>  在自己的github的仓库在执行刚刚的命令一遍即可。</p>\n<p>  这样就可以在不同的仓库，已不同的账号登录。</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>很多时候我们本地生成的只有一个自己的ssh，但是多个ssh配置的场景也是蛮多的，所以想要commit，push等操作需要配置私钥ssh或者http，才能连接远程git仓库</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>我们假设原来在~/.ssh目录下已经生成了一对密钥,此密钥文件名字是默认生成</p>\n<pre><code>id_rsa\nid_rsa.pub</code></pre><p>生成第二个ssh key</p>\n<pre><code>ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot;</code></pre><p>这里面不要一路回车，第一步需要我们手动填写保存文件的名字和路径</p>\n<pre><code>Generating public/private rsa key pair.\nEnter file in which to save the key (/Users/renbo/.ssh/id_rsa): /Users/renbo/.ssh/id_rsa_github\n&lt;剩下两个直接回车&gt;</code></pre><p>这里我们用id_rsa_github来区别原有密钥对，避免被覆盖。<br>完成之后，我们可以看到~/.ssh目录下多了两个文件，变成：</p>\n<pre><code>id_rsa\nid_ras.pub\nid_rsa_github\nid_rsa_github.pub\nknown_hosts</code></pre><p>打开ssh-agent(关于ssh-agent后续介绍)</p>\n<p>这里如果你用的github官方的bash，用：</p>\n<pre><code>ssh-agent -s</code></pre><p>如果是其他的，比如msysgit，用：</p>\n<pre><code>eval $(ssh-agent -s)</code></pre><p>略过这一步的话，下一步会提示这样的错误：Could not open a connection to your authentication agent.</p>\n<h3 id=\"添加私钥\"><a href=\"#添加私钥\" class=\"headerlink\" title=\"添加私钥\"></a>添加私钥</h3><pre><code>ssh-add ~/.ssh/id_rsa\nssh-add ~/.ssh/id_rsa_github</code></pre><h3 id=\"创建config文件\"><a href=\"#创建config文件\" class=\"headerlink\" title=\"创建config文件\"></a>创建config文件</h3><p>在~/.ssh目录下创建名为config的文件。mkdir config</p>\n<p>打开文件sudo vim config添加一下内容：</p>\n<pre><code># gitlab\n  Host gitlab.com\n  HostName gitlab.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_gitlab\n\n# github\n  Host github.com\n  HostName github.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_github</code></pre><p>其中，Host和HostName填写git服务器的域名。</p>\n<p>IdentityFile指定私钥的路径。</p>\n<p>如果在Linux系统下提示错误：Bad owner or permissions on /home/gary/.ssh/config</p>\n<p>说明config权限过大，chmod命令调整：</p>\n<pre><code>chmod 644 ~/.ssh/config</code></pre><p>然后在github和gitlab上添加公钥即可。githua 在右上角的头像的设置中</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>然后用ssh命令分别测试：</p>\n<pre><code>ssh -T git@github.com</code></pre><h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>  如果到这里你没有成功的话，别急，教你解决问题的终极办法–debug</p>\n<p>  比如测试github：</p>\n<pre><code>  ssh -vT git@github.com</code></pre><p>  -v 是输出编译信息，然后根据编译信息自己去解决问题吧。</p>\n<h3 id=\"关于https用户名\"><a href=\"#关于https用户名\" class=\"headerlink\" title=\"关于https用户名\"></a>关于https用户名</h3><p>  如果之前有设置全局用户名和邮箱的话，需要unset一下</p>\n<pre><code>  git config --global --unset user.name\n  git config --global --unset user.email</code></pre><p>  然后在不同的仓库下设置局部的用户名和邮箱</p>\n<p>  比如在公司的repository下</p>\n<pre><code>  git config user.name &quot;yourname&quot; \n  git config user.email &quot;youremail&quot;</code></pre><p>  在自己的github的仓库在执行刚刚的命令一遍即可。</p>\n<p>  这样就可以在不同的仓库，已不同的账号登录。</p>\n"},{"title":"常用指令","date":"2018-06-23T08:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### ls\n\n显示文件或目录\n\n```\nls -F  //显示文件或目录\nls -l  //列出文件详细信息l(list)\nls -a  //列出当前目录下所有文件及目录，包括隐藏的a(all)\n```\n\n### mkdir\n\n创建目录\n\n```\nmkdir dir  //创建一个dir的目录\n```\nmkdir -p 创建目录，若无父目录，则创建p(parent) <br/>\n```\nmkdir -p /study/dir1/dir2  //创建一个的目录树\n```\n\n### cd\n\n切换目录\n\n```\ncd ..  //返回上级目录\ncd /home  //进入指定目录\ncd - //返回上次所在的目录 \n```\n\n### touch\n\n修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件\n\n```\ntouch temp  //创建名为temp的空文件\ntouch temp  //如果temp存在则是修改文件的时间属性 可通过ls -l temp 查看文件属性\n```\n\n### echo\n\n命令行输出内容\n\n```\necho 'zhangsan' >> temp //创建名为temp带有zhangsan内容的文件\n```\n\n### cat\n\n查看文件内容\n\n```\ncat temp  //查看temp文件中的内容\ncat -n temp  //标示文件的行数\n```\n\n### cp\n\n拷贝\n\n```\ncp temp newtemp  //复制temp文件\ncp temp/* .  //复制temp目录下的所有文件到当前工作目录 \ncp -a /temp/dir1 . //复制/temp/dir1目录到当前工作目录 \ncp -a temp newtemp //复制temp目录 \n```\n\n### mv\n\n移动或重命名\n\n```\nmv temp newtemp //重命名/移动一个目录 \n```\n\n### rm\n删除文件\n\n```\nrm -f file  //删除file文件' \nrmdir dir1  //删除dir1的目录' \nrm -rf dir1 //递归删除dir1目录所有的内容\nrm -rf dir1 dir2 //同时删除两个目录及它们的内容 \n```\n\n### find\n\n在文件系统中查找某文件\n\n```\nfind / -name file1  //从根文件系统查找文件和目录 \nfind / -user renbo  //查找属于用户 'renbo' 的文件和目录 \nfind /home/renbo -name \\*.bin  // 查找带home/renbo目录中有.bin结尾的文件 \nfind / -name \\*.rpm -exec chmod 755 '{}' \\ //查找以.rpm结尾的文件并定义其权限 \nfind / -xdev -name \\*.rpm  //查找所有以.rpm结尾的文件\n```\n\n### wc\n\n统计文本中行数、字数、字符数\n\n```\nwc gitcommit.sh  //3   13  73 gitcommit.sh\n```\n\n### grep\n\n在文本文件中查找某个字符串\n\n```\ngrep Aug /var/log/messages  //在文件 '/var/log/messages'中查找关键词\"Aug\" \ngrep ^Aug /var/log/messages  //在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇 \ngrep [0-9] /var/log/messages //选择 '/var/log/messages' 文件中所有包含数字的行 \ngrep Aug -R /var/log/*  //在目录 '/var/log' 及随后的目录中搜索字符串\"Aug\" \n```\n\n### tree\n\n树形结构显示目录，需要安装tree包\n\n```\ntree  //显示文件和目录由根目录开始的树形结构 \n```\n\n### pwd\n\n显示当前目录\n\n```\npwd 显示当前路径\n```\n\n### ln \n\n创建链接文件\n\n```\nln -s file1 lnk1  //创建一个指向文件或目录的软链接 \nln file1 lnk1  //创建一个指向文件或目录的物理链接 \n```\n\n### more、less  \n\n分页显示文本文件内容\n\n```\nmore file1  //查看一个长文件的内容 \nless file1  //类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 \n```\n\n### head、tail\n\n```\nhead -2 file1 //查看一个文件的前两行 \ntail -2 file1 //查看一个文件的最后两行 \ntail -f /var/log/messages //实时查看被添加到一个文件中的内容 \n```\n\n\n\n\n\n\n\n","source":"_posts/linux/instructions.md","raw":"---\ntitle: 常用指令\ndate: 2018-6-23 16:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n\n### ls\n\n显示文件或目录\n\n```\nls -F  //显示文件或目录\nls -l  //列出文件详细信息l(list)\nls -a  //列出当前目录下所有文件及目录，包括隐藏的a(all)\n```\n\n### mkdir\n\n创建目录\n\n```\nmkdir dir  //创建一个dir的目录\n```\nmkdir -p 创建目录，若无父目录，则创建p(parent) <br/>\n```\nmkdir -p /study/dir1/dir2  //创建一个的目录树\n```\n\n### cd\n\n切换目录\n\n```\ncd ..  //返回上级目录\ncd /home  //进入指定目录\ncd - //返回上次所在的目录 \n```\n\n### touch\n\n修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件\n\n```\ntouch temp  //创建名为temp的空文件\ntouch temp  //如果temp存在则是修改文件的时间属性 可通过ls -l temp 查看文件属性\n```\n\n### echo\n\n命令行输出内容\n\n```\necho 'zhangsan' >> temp //创建名为temp带有zhangsan内容的文件\n```\n\n### cat\n\n查看文件内容\n\n```\ncat temp  //查看temp文件中的内容\ncat -n temp  //标示文件的行数\n```\n\n### cp\n\n拷贝\n\n```\ncp temp newtemp  //复制temp文件\ncp temp/* .  //复制temp目录下的所有文件到当前工作目录 \ncp -a /temp/dir1 . //复制/temp/dir1目录到当前工作目录 \ncp -a temp newtemp //复制temp目录 \n```\n\n### mv\n\n移动或重命名\n\n```\nmv temp newtemp //重命名/移动一个目录 \n```\n\n### rm\n删除文件\n\n```\nrm -f file  //删除file文件' \nrmdir dir1  //删除dir1的目录' \nrm -rf dir1 //递归删除dir1目录所有的内容\nrm -rf dir1 dir2 //同时删除两个目录及它们的内容 \n```\n\n### find\n\n在文件系统中查找某文件\n\n```\nfind / -name file1  //从根文件系统查找文件和目录 \nfind / -user renbo  //查找属于用户 'renbo' 的文件和目录 \nfind /home/renbo -name \\*.bin  // 查找带home/renbo目录中有.bin结尾的文件 \nfind / -name \\*.rpm -exec chmod 755 '{}' \\ //查找以.rpm结尾的文件并定义其权限 \nfind / -xdev -name \\*.rpm  //查找所有以.rpm结尾的文件\n```\n\n### wc\n\n统计文本中行数、字数、字符数\n\n```\nwc gitcommit.sh  //3   13  73 gitcommit.sh\n```\n\n### grep\n\n在文本文件中查找某个字符串\n\n```\ngrep Aug /var/log/messages  //在文件 '/var/log/messages'中查找关键词\"Aug\" \ngrep ^Aug /var/log/messages  //在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇 \ngrep [0-9] /var/log/messages //选择 '/var/log/messages' 文件中所有包含数字的行 \ngrep Aug -R /var/log/*  //在目录 '/var/log' 及随后的目录中搜索字符串\"Aug\" \n```\n\n### tree\n\n树形结构显示目录，需要安装tree包\n\n```\ntree  //显示文件和目录由根目录开始的树形结构 \n```\n\n### pwd\n\n显示当前目录\n\n```\npwd 显示当前路径\n```\n\n### ln \n\n创建链接文件\n\n```\nln -s file1 lnk1  //创建一个指向文件或目录的软链接 \nln file1 lnk1  //创建一个指向文件或目录的物理链接 \n```\n\n### more、less  \n\n分页显示文本文件内容\n\n```\nmore file1  //查看一个长文件的内容 \nless file1  //类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 \n```\n\n### head、tail\n\n```\nhead -2 file1 //查看一个文件的前两行 \ntail -2 file1 //查看一个文件的最后两行 \ntail -f /var/log/messages //实时查看被添加到一个文件中的内容 \n```\n\n\n\n\n\n\n\n","slug":"linux/instructions","published":1,"updated":"2019-10-15T01:29:42.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8os6002kb0u6qxwz5ijm","content":"<h3 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h3><p>显示文件或目录</p>\n<pre><code>ls -F  //显示文件或目录\nls -l  //列出文件详细信息l(list)\nls -a  //列出当前目录下所有文件及目录，包括隐藏的a(all)</code></pre><h3 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h3><p>创建目录</p>\n<pre><code>mkdir dir  //创建一个dir的目录</code></pre><p>mkdir -p 创建目录，若无父目录，则创建p(parent) <br></p>\n<pre><code>mkdir -p /study/dir1/dir2  //创建一个的目录树</code></pre><h3 id=\"cd\"><a href=\"#cd\" class=\"headerlink\" title=\"cd\"></a>cd</h3><p>切换目录</p>\n<pre><code>cd ..  //返回上级目录\ncd /home  //进入指定目录\ncd - //返回上次所在的目录 </code></pre><h3 id=\"touch\"><a href=\"#touch\" class=\"headerlink\" title=\"touch\"></a>touch</h3><p>修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</p>\n<pre><code>touch temp  //创建名为temp的空文件\ntouch temp  //如果temp存在则是修改文件的时间属性 可通过ls -l temp 查看文件属性</code></pre><h3 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h3><p>命令行输出内容</p>\n<pre><code>echo &#39;zhangsan&#39; &gt;&gt; temp //创建名为temp带有zhangsan内容的文件</code></pre><h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><p>查看文件内容</p>\n<pre><code>cat temp  //查看temp文件中的内容\ncat -n temp  //标示文件的行数</code></pre><h3 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h3><p>拷贝</p>\n<pre><code>cp temp newtemp  //复制temp文件\ncp temp/* .  //复制temp目录下的所有文件到当前工作目录 \ncp -a /temp/dir1 . //复制/temp/dir1目录到当前工作目录 \ncp -a temp newtemp //复制temp目录 </code></pre><h3 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h3><p>移动或重命名</p>\n<pre><code>mv temp newtemp //重命名/移动一个目录 </code></pre><h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>删除文件</p>\n<pre><code>rm -f file  //删除file文件&#39; \nrmdir dir1  //删除dir1的目录&#39; \nrm -rf dir1 //递归删除dir1目录所有的内容\nrm -rf dir1 dir2 //同时删除两个目录及它们的内容 </code></pre><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>在文件系统中查找某文件</p>\n<pre><code>find / -name file1  //从根文件系统查找文件和目录 \nfind / -user renbo  //查找属于用户 &#39;renbo&#39; 的文件和目录 \nfind /home/renbo -name \\*.bin  // 查找带home/renbo目录中有.bin结尾的文件 \nfind / -name \\*.rpm -exec chmod 755 &#39;{}&#39; \\ //查找以.rpm结尾的文件并定义其权限 \nfind / -xdev -name \\*.rpm  //查找所有以.rpm结尾的文件</code></pre><h3 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h3><p>统计文本中行数、字数、字符数</p>\n<pre><code>wc gitcommit.sh  //3   13  73 gitcommit.sh</code></pre><h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>在文本文件中查找某个字符串</p>\n<pre><code>grep Aug /var/log/messages  //在文件 &#39;/var/log/messages&#39;中查找关键词&quot;Aug&quot; \ngrep ^Aug /var/log/messages  //在文件 &#39;/var/log/messages&#39;中查找以&quot;Aug&quot;开始的词汇 \ngrep [0-9] /var/log/messages //选择 &#39;/var/log/messages&#39; 文件中所有包含数字的行 \ngrep Aug -R /var/log/*  //在目录 &#39;/var/log&#39; 及随后的目录中搜索字符串&quot;Aug&quot; </code></pre><h3 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h3><p>树形结构显示目录，需要安装tree包</p>\n<pre><code>tree  //显示文件和目录由根目录开始的树形结构 </code></pre><h3 id=\"pwd\"><a href=\"#pwd\" class=\"headerlink\" title=\"pwd\"></a>pwd</h3><p>显示当前目录</p>\n<pre><code>pwd 显示当前路径</code></pre><h3 id=\"ln\"><a href=\"#ln\" class=\"headerlink\" title=\"ln\"></a>ln</h3><p>创建链接文件</p>\n<pre><code>ln -s file1 lnk1  //创建一个指向文件或目录的软链接 \nln file1 lnk1  //创建一个指向文件或目录的物理链接 </code></pre><h3 id=\"more、less\"><a href=\"#more、less\" class=\"headerlink\" title=\"more、less\"></a>more、less</h3><p>分页显示文本文件内容</p>\n<pre><code>more file1  //查看一个长文件的内容 \nless file1  //类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 </code></pre><h3 id=\"head、tail\"><a href=\"#head、tail\" class=\"headerlink\" title=\"head、tail\"></a>head、tail</h3><pre><code>head -2 file1 //查看一个文件的前两行 \ntail -2 file1 //查看一个文件的最后两行 \ntail -f /var/log/messages //实时查看被添加到一个文件中的内容 </code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h3><p>显示文件或目录</p>\n<pre><code>ls -F  //显示文件或目录\nls -l  //列出文件详细信息l(list)\nls -a  //列出当前目录下所有文件及目录，包括隐藏的a(all)</code></pre><h3 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h3><p>创建目录</p>\n<pre><code>mkdir dir  //创建一个dir的目录</code></pre><p>mkdir -p 创建目录，若无父目录，则创建p(parent) <br></p>\n<pre><code>mkdir -p /study/dir1/dir2  //创建一个的目录树</code></pre><h3 id=\"cd\"><a href=\"#cd\" class=\"headerlink\" title=\"cd\"></a>cd</h3><p>切换目录</p>\n<pre><code>cd ..  //返回上级目录\ncd /home  //进入指定目录\ncd - //返回上次所在的目录 </code></pre><h3 id=\"touch\"><a href=\"#touch\" class=\"headerlink\" title=\"touch\"></a>touch</h3><p>修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</p>\n<pre><code>touch temp  //创建名为temp的空文件\ntouch temp  //如果temp存在则是修改文件的时间属性 可通过ls -l temp 查看文件属性</code></pre><h3 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h3><p>命令行输出内容</p>\n<pre><code>echo &#39;zhangsan&#39; &gt;&gt; temp //创建名为temp带有zhangsan内容的文件</code></pre><h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><p>查看文件内容</p>\n<pre><code>cat temp  //查看temp文件中的内容\ncat -n temp  //标示文件的行数</code></pre><h3 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h3><p>拷贝</p>\n<pre><code>cp temp newtemp  //复制temp文件\ncp temp/* .  //复制temp目录下的所有文件到当前工作目录 \ncp -a /temp/dir1 . //复制/temp/dir1目录到当前工作目录 \ncp -a temp newtemp //复制temp目录 </code></pre><h3 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h3><p>移动或重命名</p>\n<pre><code>mv temp newtemp //重命名/移动一个目录 </code></pre><h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>删除文件</p>\n<pre><code>rm -f file  //删除file文件&#39; \nrmdir dir1  //删除dir1的目录&#39; \nrm -rf dir1 //递归删除dir1目录所有的内容\nrm -rf dir1 dir2 //同时删除两个目录及它们的内容 </code></pre><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>在文件系统中查找某文件</p>\n<pre><code>find / -name file1  //从根文件系统查找文件和目录 \nfind / -user renbo  //查找属于用户 &#39;renbo&#39; 的文件和目录 \nfind /home/renbo -name \\*.bin  // 查找带home/renbo目录中有.bin结尾的文件 \nfind / -name \\*.rpm -exec chmod 755 &#39;{}&#39; \\ //查找以.rpm结尾的文件并定义其权限 \nfind / -xdev -name \\*.rpm  //查找所有以.rpm结尾的文件</code></pre><h3 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h3><p>统计文本中行数、字数、字符数</p>\n<pre><code>wc gitcommit.sh  //3   13  73 gitcommit.sh</code></pre><h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>在文本文件中查找某个字符串</p>\n<pre><code>grep Aug /var/log/messages  //在文件 &#39;/var/log/messages&#39;中查找关键词&quot;Aug&quot; \ngrep ^Aug /var/log/messages  //在文件 &#39;/var/log/messages&#39;中查找以&quot;Aug&quot;开始的词汇 \ngrep [0-9] /var/log/messages //选择 &#39;/var/log/messages&#39; 文件中所有包含数字的行 \ngrep Aug -R /var/log/*  //在目录 &#39;/var/log&#39; 及随后的目录中搜索字符串&quot;Aug&quot; </code></pre><h3 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h3><p>树形结构显示目录，需要安装tree包</p>\n<pre><code>tree  //显示文件和目录由根目录开始的树形结构 </code></pre><h3 id=\"pwd\"><a href=\"#pwd\" class=\"headerlink\" title=\"pwd\"></a>pwd</h3><p>显示当前目录</p>\n<pre><code>pwd 显示当前路径</code></pre><h3 id=\"ln\"><a href=\"#ln\" class=\"headerlink\" title=\"ln\"></a>ln</h3><p>创建链接文件</p>\n<pre><code>ln -s file1 lnk1  //创建一个指向文件或目录的软链接 \nln file1 lnk1  //创建一个指向文件或目录的物理链接 </code></pre><h3 id=\"more、less\"><a href=\"#more、less\" class=\"headerlink\" title=\"more、less\"></a>more、less</h3><p>分页显示文本文件内容</p>\n<pre><code>more file1  //查看一个长文件的内容 \nless file1  //类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 </code></pre><h3 id=\"head、tail\"><a href=\"#head、tail\" class=\"headerlink\" title=\"head、tail\"></a>head、tail</h3><pre><code>head -2 file1 //查看一个文件的前两行 \ntail -2 file1 //查看一个文件的最后两行 \ntail -f /var/log/messages //实时查看被添加到一个文件中的内容 </code></pre>"},{"title":"Linux软件包管理","date":"2018-07-12T14:28:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### dpkg \n\n(Debian Package)管理工具，软件包名以.deb后缀\n\n```\nsudo dpkg -i package.deb 安装/更新 deb 包 \n\nsudo dpkg -r package 删除 deb 包 \n\nsudo dpkg -l 获取所有已经安装的 deb 包 \n\nsudo dpkg -s package 获得已经安装的包的信息\n```\n\n### APT\n\n（Advanced Packaging Tool）\n\n```\nsudo apt-get install package 安装package包\n\nsudo apt-get remove package 卸载package包\n\nsudo apt-get upgrade 更新所有package包  \n\nsudo apt-get update 更新package包                             \n```    \n\n \n### YUM 软件包升级器\n\n```\nyum install package 下载并安装rpm包 \n\nyum update package 更新rpm包 \n\nyum remove package 删除rpm包 \n\nyum list 列出当前系统中安装的所有包\n\nyum search package 在rpm仓库中搜寻软件包 \n\nyum clean packages 清理rpm缓存删除下载的包 \n\nyum clean headers 删除所有头文件\n\nyum clean all 删除所有缓存的包和头文件 \n```\n\n \n### RPM包\n\n```\nrpm -ivh package.rpm 安装rpm包 \nrpm -ivh --nodeeps package.rpm 安装rpm包而忽略依赖关系警告 \nrpm -U package.rpm 更新rpm包但不改变其配置文件 \nrpm -F package.rpm 更新确定已经安装的rpm包 \nrpm -e package.rpm 删除rpm包 \nrpm -qa 显示系统中所有已经安装的rpm包 \n```\n\n### 注意\n\nrpm文件是Redhat支持的软件包格式，而.deb是Debian上支持软件包的扩展名\n\n由于ubuntu是对Debian的扩展，在ubuntu下不能直接使.rpm文件的，需要将.rmp转换成.deb\n\n解决方法\n\n1.安装alien，执行`sudo apt-get install alien`\n\n2.使用alien，执行`sudo alien abc.rpm`\n\n3.执行完成后，目录下会生成一个abc.deb文件\n\n4.安装并使用dpkg\n","source":"_posts/linux/package.md","raw":"---\ntitle: Linux软件包管理\ndate: 2018-7-12 22:28:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n\n### dpkg \n\n(Debian Package)管理工具，软件包名以.deb后缀\n\n```\nsudo dpkg -i package.deb 安装/更新 deb 包 \n\nsudo dpkg -r package 删除 deb 包 \n\nsudo dpkg -l 获取所有已经安装的 deb 包 \n\nsudo dpkg -s package 获得已经安装的包的信息\n```\n\n### APT\n\n（Advanced Packaging Tool）\n\n```\nsudo apt-get install package 安装package包\n\nsudo apt-get remove package 卸载package包\n\nsudo apt-get upgrade 更新所有package包  \n\nsudo apt-get update 更新package包                             \n```    \n\n \n### YUM 软件包升级器\n\n```\nyum install package 下载并安装rpm包 \n\nyum update package 更新rpm包 \n\nyum remove package 删除rpm包 \n\nyum list 列出当前系统中安装的所有包\n\nyum search package 在rpm仓库中搜寻软件包 \n\nyum clean packages 清理rpm缓存删除下载的包 \n\nyum clean headers 删除所有头文件\n\nyum clean all 删除所有缓存的包和头文件 \n```\n\n \n### RPM包\n\n```\nrpm -ivh package.rpm 安装rpm包 \nrpm -ivh --nodeeps package.rpm 安装rpm包而忽略依赖关系警告 \nrpm -U package.rpm 更新rpm包但不改变其配置文件 \nrpm -F package.rpm 更新确定已经安装的rpm包 \nrpm -e package.rpm 删除rpm包 \nrpm -qa 显示系统中所有已经安装的rpm包 \n```\n\n### 注意\n\nrpm文件是Redhat支持的软件包格式，而.deb是Debian上支持软件包的扩展名\n\n由于ubuntu是对Debian的扩展，在ubuntu下不能直接使.rpm文件的，需要将.rmp转换成.deb\n\n解决方法\n\n1.安装alien，执行`sudo apt-get install alien`\n\n2.使用alien，执行`sudo alien abc.rpm`\n\n3.执行完成后，目录下会生成一个abc.deb文件\n\n4.安装并使用dpkg\n","slug":"linux/package","published":1,"updated":"2019-10-15T01:29:42.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8os8002pb0u6pmjh5w1s","content":"<h3 id=\"dpkg\"><a href=\"#dpkg\" class=\"headerlink\" title=\"dpkg\"></a>dpkg</h3><p>(Debian Package)管理工具，软件包名以.deb后缀</p>\n<pre><code>sudo dpkg -i package.deb 安装/更新 deb 包 \n\nsudo dpkg -r package 删除 deb 包 \n\nsudo dpkg -l 获取所有已经安装的 deb 包 \n\nsudo dpkg -s package 获得已经安装的包的信息</code></pre><h3 id=\"APT\"><a href=\"#APT\" class=\"headerlink\" title=\"APT\"></a>APT</h3><p>（Advanced Packaging Tool）</p>\n<pre><code>sudo apt-get install package 安装package包\n\nsudo apt-get remove package 卸载package包\n\nsudo apt-get upgrade 更新所有package包  \n\nsudo apt-get update 更新package包                             </code></pre><h3 id=\"YUM-软件包升级器\"><a href=\"#YUM-软件包升级器\" class=\"headerlink\" title=\"YUM 软件包升级器\"></a>YUM 软件包升级器</h3><pre><code>yum install package 下载并安装rpm包 \n\nyum update package 更新rpm包 \n\nyum remove package 删除rpm包 \n\nyum list 列出当前系统中安装的所有包\n\nyum search package 在rpm仓库中搜寻软件包 \n\nyum clean packages 清理rpm缓存删除下载的包 \n\nyum clean headers 删除所有头文件\n\nyum clean all 删除所有缓存的包和头文件 </code></pre><h3 id=\"RPM包\"><a href=\"#RPM包\" class=\"headerlink\" title=\"RPM包\"></a>RPM包</h3><pre><code>rpm -ivh package.rpm 安装rpm包 \nrpm -ivh --nodeeps package.rpm 安装rpm包而忽略依赖关系警告 \nrpm -U package.rpm 更新rpm包但不改变其配置文件 \nrpm -F package.rpm 更新确定已经安装的rpm包 \nrpm -e package.rpm 删除rpm包 \nrpm -qa 显示系统中所有已经安装的rpm包 </code></pre><h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>rpm文件是Redhat支持的软件包格式，而.deb是Debian上支持软件包的扩展名</p>\n<p>由于ubuntu是对Debian的扩展，在ubuntu下不能直接使.rpm文件的，需要将.rmp转换成.deb</p>\n<p>解决方法</p>\n<p>1.安装alien，执行<code>sudo apt-get install alien</code></p>\n<p>2.使用alien，执行<code>sudo alien abc.rpm</code></p>\n<p>3.执行完成后，目录下会生成一个abc.deb文件</p>\n<p>4.安装并使用dpkg</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"dpkg\"><a href=\"#dpkg\" class=\"headerlink\" title=\"dpkg\"></a>dpkg</h3><p>(Debian Package)管理工具，软件包名以.deb后缀</p>\n<pre><code>sudo dpkg -i package.deb 安装/更新 deb 包 \n\nsudo dpkg -r package 删除 deb 包 \n\nsudo dpkg -l 获取所有已经安装的 deb 包 \n\nsudo dpkg -s package 获得已经安装的包的信息</code></pre><h3 id=\"APT\"><a href=\"#APT\" class=\"headerlink\" title=\"APT\"></a>APT</h3><p>（Advanced Packaging Tool）</p>\n<pre><code>sudo apt-get install package 安装package包\n\nsudo apt-get remove package 卸载package包\n\nsudo apt-get upgrade 更新所有package包  \n\nsudo apt-get update 更新package包                             </code></pre><h3 id=\"YUM-软件包升级器\"><a href=\"#YUM-软件包升级器\" class=\"headerlink\" title=\"YUM 软件包升级器\"></a>YUM 软件包升级器</h3><pre><code>yum install package 下载并安装rpm包 \n\nyum update package 更新rpm包 \n\nyum remove package 删除rpm包 \n\nyum list 列出当前系统中安装的所有包\n\nyum search package 在rpm仓库中搜寻软件包 \n\nyum clean packages 清理rpm缓存删除下载的包 \n\nyum clean headers 删除所有头文件\n\nyum clean all 删除所有缓存的包和头文件 </code></pre><h3 id=\"RPM包\"><a href=\"#RPM包\" class=\"headerlink\" title=\"RPM包\"></a>RPM包</h3><pre><code>rpm -ivh package.rpm 安装rpm包 \nrpm -ivh --nodeeps package.rpm 安装rpm包而忽略依赖关系警告 \nrpm -U package.rpm 更新rpm包但不改变其配置文件 \nrpm -F package.rpm 更新确定已经安装的rpm包 \nrpm -e package.rpm 删除rpm包 \nrpm -qa 显示系统中所有已经安装的rpm包 </code></pre><h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>rpm文件是Redhat支持的软件包格式，而.deb是Debian上支持软件包的扩展名</p>\n<p>由于ubuntu是对Debian的扩展，在ubuntu下不能直接使.rpm文件的，需要将.rmp转换成.deb</p>\n<p>解决方法</p>\n<p>1.安装alien，执行<code>sudo apt-get install alien</code></p>\n<p>2.使用alien，执行<code>sudo alien abc.rpm</code></p>\n<p>3.执行完成后，目录下会生成一个abc.deb文件</p>\n<p>4.安装并使用dpkg</p>\n"},{"title":"关机重启操作","date":"2018-07-16T10:02:45.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### shutdown\n\n```\nshutdown -r  关机重启\nshutdown -h  关机不重启\nshutdown now  立刻关机\n\n```\n\n### halt\n关机\n\n### reboot\n重启\n\n\n\n\n\n          \n\n","source":"_posts/linux/shutdown.md","raw":"---\ntitle: 关机重启操作\ndate: 2018-7-16 18:02:45\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n\n### shutdown\n\n```\nshutdown -r  关机重启\nshutdown -h  关机不重启\nshutdown now  立刻关机\n\n```\n\n### halt\n关机\n\n### reboot\n重启\n\n\n\n\n\n          \n\n","slug":"linux/shutdown","published":1,"updated":"2019-10-15T01:29:42.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osa002sb0u63dogfmp5","content":"<h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><pre><code>shutdown -r  关机重启\nshutdown -h  关机不重启\nshutdown now  立刻关机\n</code></pre><h3 id=\"halt\"><a href=\"#halt\" class=\"headerlink\" title=\"halt\"></a>halt</h3><p>关机</p>\n<h3 id=\"reboot\"><a href=\"#reboot\" class=\"headerlink\" title=\"reboot\"></a>reboot</h3><p>重启</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><pre><code>shutdown -r  关机重启\nshutdown -h  关机不重启\nshutdown now  立刻关机\n</code></pre><h3 id=\"halt\"><a href=\"#halt\" class=\"headerlink\" title=\"halt\"></a>halt</h3><p>关机</p>\n<h3 id=\"reboot\"><a href=\"#reboot\" class=\"headerlink\" title=\"reboot\"></a>reboot</h3><p>重启</p>\n"},{"title":"系统管理指令","date":"2018-07-02T05:28:25.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### stat  \n显示指定文件的详细信息\n\n### who\n显示在线登陆用户\n\n### whoami\n显示当前操作用户\n\n### hostname\n显示主机名\n\n### uname\n显示系统信息\n\n### top  \n动态显示当前耗费资源最多进程信息\n\n### ps  \n查看进程状态 \n\n```\nps -aux\n\n-A ：所有的进程均显示出来，与 -e 具有同样的效用\n-a ：显示现行终端机下的所有进程，包括其他用户的进程\n-u ：以用户为主的进程状态\nx ：通常与 a 这个参数一起使用，可列出较完整信息\n\n```\n\n### du  \n查看目录大小 `du -h /home`带有单位显示目录信息\n\n### df\n查看磁盘大小 `df -h `带有单位显示磁盘信息\n\n### ifconfig  \n查看网络情况\n\n### ping\n测试网络连通\n\n### netstat \n显示网络状态信息\n\n### man  \n命令帮助文档如：`man ls`\n\n### clear\n清屏\n\n### alias\n对命令重命名\n\n```\nalias l=\"ls\" \n``` \n\n### kill   \n杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。\n","source":"_posts/linux/system.md","raw":"---\ntitle: 系统管理指令\ndate: 2018-7-2 13:28:25\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n\n### stat  \n显示指定文件的详细信息\n\n### who\n显示在线登陆用户\n\n### whoami\n显示当前操作用户\n\n### hostname\n显示主机名\n\n### uname\n显示系统信息\n\n### top  \n动态显示当前耗费资源最多进程信息\n\n### ps  \n查看进程状态 \n\n```\nps -aux\n\n-A ：所有的进程均显示出来，与 -e 具有同样的效用\n-a ：显示现行终端机下的所有进程，包括其他用户的进程\n-u ：以用户为主的进程状态\nx ：通常与 a 这个参数一起使用，可列出较完整信息\n\n```\n\n### du  \n查看目录大小 `du -h /home`带有单位显示目录信息\n\n### df\n查看磁盘大小 `df -h `带有单位显示磁盘信息\n\n### ifconfig  \n查看网络情况\n\n### ping\n测试网络连通\n\n### netstat \n显示网络状态信息\n\n### man  \n命令帮助文档如：`man ls`\n\n### clear\n清屏\n\n### alias\n对命令重命名\n\n```\nalias l=\"ls\" \n``` \n\n### kill   \n杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。\n","slug":"linux/system","published":1,"updated":"2019-10-15T01:29:42.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osc002xb0u6ab4vzqjz","content":"<h3 id=\"stat\"><a href=\"#stat\" class=\"headerlink\" title=\"stat\"></a>stat</h3><p>显示指定文件的详细信息</p>\n<h3 id=\"who\"><a href=\"#who\" class=\"headerlink\" title=\"who\"></a>who</h3><p>显示在线登陆用户</p>\n<h3 id=\"whoami\"><a href=\"#whoami\" class=\"headerlink\" title=\"whoami\"></a>whoami</h3><p>显示当前操作用户</p>\n<h3 id=\"hostname\"><a href=\"#hostname\" class=\"headerlink\" title=\"hostname\"></a>hostname</h3><p>显示主机名</p>\n<h3 id=\"uname\"><a href=\"#uname\" class=\"headerlink\" title=\"uname\"></a>uname</h3><p>显示系统信息</p>\n<h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><p>动态显示当前耗费资源最多进程信息</p>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>查看进程状态 </p>\n<pre><code>ps -aux\n\n-A ：所有的进程均显示出来，与 -e 具有同样的效用\n-a ：显示现行终端机下的所有进程，包括其他用户的进程\n-u ：以用户为主的进程状态\nx ：通常与 a 这个参数一起使用，可列出较完整信息\n</code></pre><h3 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h3><p>查看目录大小 <code>du -h /home</code>带有单位显示目录信息</p>\n<h3 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h3><p>查看磁盘大小 <code>df -h</code>带有单位显示磁盘信息</p>\n<h3 id=\"ifconfig\"><a href=\"#ifconfig\" class=\"headerlink\" title=\"ifconfig\"></a>ifconfig</h3><p>查看网络情况</p>\n<h3 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h3><p>测试网络连通</p>\n<h3 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h3><p>显示网络状态信息</p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>命令帮助文档如：<code>man ls</code></p>\n<h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><p>清屏</p>\n<h3 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h3><p>对命令重命名</p>\n<pre><code>alias l=&quot;ls&quot; </code></pre><h3 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h3><p>杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"stat\"><a href=\"#stat\" class=\"headerlink\" title=\"stat\"></a>stat</h3><p>显示指定文件的详细信息</p>\n<h3 id=\"who\"><a href=\"#who\" class=\"headerlink\" title=\"who\"></a>who</h3><p>显示在线登陆用户</p>\n<h3 id=\"whoami\"><a href=\"#whoami\" class=\"headerlink\" title=\"whoami\"></a>whoami</h3><p>显示当前操作用户</p>\n<h3 id=\"hostname\"><a href=\"#hostname\" class=\"headerlink\" title=\"hostname\"></a>hostname</h3><p>显示主机名</p>\n<h3 id=\"uname\"><a href=\"#uname\" class=\"headerlink\" title=\"uname\"></a>uname</h3><p>显示系统信息</p>\n<h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><p>动态显示当前耗费资源最多进程信息</p>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>查看进程状态 </p>\n<pre><code>ps -aux\n\n-A ：所有的进程均显示出来，与 -e 具有同样的效用\n-a ：显示现行终端机下的所有进程，包括其他用户的进程\n-u ：以用户为主的进程状态\nx ：通常与 a 这个参数一起使用，可列出较完整信息\n</code></pre><h3 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h3><p>查看目录大小 <code>du -h /home</code>带有单位显示目录信息</p>\n<h3 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h3><p>查看磁盘大小 <code>df -h</code>带有单位显示磁盘信息</p>\n<h3 id=\"ifconfig\"><a href=\"#ifconfig\" class=\"headerlink\" title=\"ifconfig\"></a>ifconfig</h3><p>查看网络情况</p>\n<h3 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h3><p>测试网络连通</p>\n<h3 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h3><p>显示网络状态信息</p>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>命令帮助文档如：<code>man ls</code></p>\n<h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><p>清屏</p>\n<h3 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h3><p>对命令重命名</p>\n<pre><code>alias l=&quot;ls&quot; </code></pre><h3 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h3><p>杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>\n"},{"title":"用户及用户组管理","date":"2018-07-22T10:02:45.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 查看存储用户账号\n\n```\ncat /etc/passwd\n\n输出的结构\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n```\n\n### 查看存储组账号\n\n```\ncat /etc/group  \n```\n\n### 查看存储用户账号的密码\n\n```\ncat /etc/shadow   \n\n输出结构\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n```\n  \n### 查看存储用户组账号的密码\n\n```\ncat /etc/gshadow  \n```\n\n\n### 建立用户帐号\n\n```\n参数\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\nuseradd renbo  添加一般用户\n\nuseradd -g root renbo  为添加用户指定用户组\n\nuseradd -r renbo  创建系统用户\n\nuseradd -d /home renbo  为新添加的用户指定home目录\n\nuseradd caojh -u 544  建立用户且制定ID\n```\n\n### 删除用户帐号\n\n```\nuserdel  同建立账号用法相同 \n```\n\n### 新建组\n\n```\ngroupadd 组名\n```\n\n### 删除组\n\n```\ngroupdel 组名\n```\n\n### 修改账号\n\n```\nusermod 选项 用户名和useradd用法相同\n```\n\n### 指定口令\n\n用户口令管理给root设置密码(用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令)\n\n```\npasswd root \n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n```\n\n### 切换用户\n\n```\nsu root \n\nsu - root   切换到root用户改变环境变量\n\nsu user   切换用户，加载配置文件.bashrc\n\nsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile\n```\n\n\n### 系统环境变量文件\n\n```\ncat /etc/profile 查看\n\nvim /etc/profile 编辑\n```\n\n### 用户环境变量文件\n\n```\ncat /etc/bash_profile 查看\n\nvim /etc/bash_profile 编辑\n\ncat .bashrc\n```\n\n\n### 更改文件的用户及用户组\n\n```\nsudo chown [-R] owner[:group] {File|Directory}\n\n例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop\n\n```\n\n### 切换此文件所属的用户及组\n\n```\nsudo chown root:root jdk-7u21-linux-i586.tar.gz\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/linux/user.md","raw":"---\ntitle: 用户及用户组管理\ndate: 2018-7-22 18:02:45\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n### 查看存储用户账号\n\n```\ncat /etc/passwd\n\n输出的结构\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n```\n\n### 查看存储组账号\n\n```\ncat /etc/group  \n```\n\n### 查看存储用户账号的密码\n\n```\ncat /etc/shadow   \n\n输出结构\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n```\n  \n### 查看存储用户组账号的密码\n\n```\ncat /etc/gshadow  \n```\n\n\n### 建立用户帐号\n\n```\n参数\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\nuseradd renbo  添加一般用户\n\nuseradd -g root renbo  为添加用户指定用户组\n\nuseradd -r renbo  创建系统用户\n\nuseradd -d /home renbo  为新添加的用户指定home目录\n\nuseradd caojh -u 544  建立用户且制定ID\n```\n\n### 删除用户帐号\n\n```\nuserdel  同建立账号用法相同 \n```\n\n### 新建组\n\n```\ngroupadd 组名\n```\n\n### 删除组\n\n```\ngroupdel 组名\n```\n\n### 修改账号\n\n```\nusermod 选项 用户名和useradd用法相同\n```\n\n### 指定口令\n\n用户口令管理给root设置密码(用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令)\n\n```\npasswd root \n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n```\n\n### 切换用户\n\n```\nsu root \n\nsu - root   切换到root用户改变环境变量\n\nsu user   切换用户，加载配置文件.bashrc\n\nsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile\n```\n\n\n### 系统环境变量文件\n\n```\ncat /etc/profile 查看\n\nvim /etc/profile 编辑\n```\n\n### 用户环境变量文件\n\n```\ncat /etc/bash_profile 查看\n\nvim /etc/bash_profile 编辑\n\ncat .bashrc\n```\n\n\n### 更改文件的用户及用户组\n\n```\nsudo chown [-R] owner[:group] {File|Directory}\n\n例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop\n\n```\n\n### 切换此文件所属的用户及组\n\n```\nsudo chown root:root jdk-7u21-linux-i586.tar.gz\n```\n\n\n\n\n\n\n\n\n\n","slug":"linux/user","published":1,"updated":"2019-10-15T01:29:42.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ose0030b0u6xblhun6o","content":"<h3 id=\"查看存储用户账号\"><a href=\"#查看存储用户账号\" class=\"headerlink\" title=\"查看存储用户账号\"></a>查看存储用户账号</h3><pre><code>cat /etc/passwd\n\n输出的结构\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre><h3 id=\"查看存储组账号\"><a href=\"#查看存储组账号\" class=\"headerlink\" title=\"查看存储组账号\"></a>查看存储组账号</h3><pre><code>cat /etc/group  </code></pre><h3 id=\"查看存储用户账号的密码\"><a href=\"#查看存储用户账号的密码\" class=\"headerlink\" title=\"查看存储用户账号的密码\"></a>查看存储用户账号的密码</h3><pre><code>cat /etc/shadow   \n\n输出结构\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre><h3 id=\"查看存储用户组账号的密码\"><a href=\"#查看存储用户组账号的密码\" class=\"headerlink\" title=\"查看存储用户组账号的密码\"></a>查看存储用户组账号的密码</h3><pre><code>cat /etc/gshadow  </code></pre><h3 id=\"建立用户帐号\"><a href=\"#建立用户帐号\" class=\"headerlink\" title=\"建立用户帐号\"></a>建立用户帐号</h3><pre><code>参数\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\nuseradd renbo  添加一般用户\n\nuseradd -g root renbo  为添加用户指定用户组\n\nuseradd -r renbo  创建系统用户\n\nuseradd -d /home renbo  为新添加的用户指定home目录\n\nuseradd caojh -u 544  建立用户且制定ID</code></pre><h3 id=\"删除用户帐号\"><a href=\"#删除用户帐号\" class=\"headerlink\" title=\"删除用户帐号\"></a>删除用户帐号</h3><pre><code>userdel  同建立账号用法相同 </code></pre><h3 id=\"新建组\"><a href=\"#新建组\" class=\"headerlink\" title=\"新建组\"></a>新建组</h3><pre><code>groupadd 组名</code></pre><h3 id=\"删除组\"><a href=\"#删除组\" class=\"headerlink\" title=\"删除组\"></a>删除组</h3><pre><code>groupdel 组名</code></pre><h3 id=\"修改账号\"><a href=\"#修改账号\" class=\"headerlink\" title=\"修改账号\"></a>修改账号</h3><pre><code>usermod 选项 用户名和useradd用法相同</code></pre><h3 id=\"指定口令\"><a href=\"#指定口令\" class=\"headerlink\" title=\"指定口令\"></a>指定口令</h3><p>用户口令管理给root设置密码(用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令)</p>\n<pre><code>passwd root \n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。</code></pre><h3 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h3><pre><code>su root \n\nsu - root   切换到root用户改变环境变量\n\nsu user   切换用户，加载配置文件.bashrc\n\nsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile</code></pre><h3 id=\"系统环境变量文件\"><a href=\"#系统环境变量文件\" class=\"headerlink\" title=\"系统环境变量文件\"></a>系统环境变量文件</h3><pre><code>cat /etc/profile 查看\n\nvim /etc/profile 编辑</code></pre><h3 id=\"用户环境变量文件\"><a href=\"#用户环境变量文件\" class=\"headerlink\" title=\"用户环境变量文件\"></a>用户环境变量文件</h3><pre><code>cat /etc/bash_profile 查看\n\nvim /etc/bash_profile 编辑\n\ncat .bashrc</code></pre><h3 id=\"更改文件的用户及用户组\"><a href=\"#更改文件的用户及用户组\" class=\"headerlink\" title=\"更改文件的用户及用户组\"></a>更改文件的用户及用户组</h3><pre><code>sudo chown [-R] owner[:group] {File|Directory}\n\n例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop\n</code></pre><h3 id=\"切换此文件所属的用户及组\"><a href=\"#切换此文件所属的用户及组\" class=\"headerlink\" title=\"切换此文件所属的用户及组\"></a>切换此文件所属的用户及组</h3><pre><code>sudo chown root:root jdk-7u21-linux-i586.tar.gz</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"查看存储用户账号\"><a href=\"#查看存储用户账号\" class=\"headerlink\" title=\"查看存储用户账号\"></a>查看存储用户账号</h3><pre><code>cat /etc/passwd\n\n输出的结构\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre><h3 id=\"查看存储组账号\"><a href=\"#查看存储组账号\" class=\"headerlink\" title=\"查看存储组账号\"></a>查看存储组账号</h3><pre><code>cat /etc/group  </code></pre><h3 id=\"查看存储用户账号的密码\"><a href=\"#查看存储用户账号的密码\" class=\"headerlink\" title=\"查看存储用户账号的密码\"></a>查看存储用户账号的密码</h3><pre><code>cat /etc/shadow   \n\n输出结构\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></pre><h3 id=\"查看存储用户组账号的密码\"><a href=\"#查看存储用户组账号的密码\" class=\"headerlink\" title=\"查看存储用户组账号的密码\"></a>查看存储用户组账号的密码</h3><pre><code>cat /etc/gshadow  </code></pre><h3 id=\"建立用户帐号\"><a href=\"#建立用户帐号\" class=\"headerlink\" title=\"建立用户帐号\"></a>建立用户帐号</h3><pre><code>参数\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\nuseradd renbo  添加一般用户\n\nuseradd -g root renbo  为添加用户指定用户组\n\nuseradd -r renbo  创建系统用户\n\nuseradd -d /home renbo  为新添加的用户指定home目录\n\nuseradd caojh -u 544  建立用户且制定ID</code></pre><h3 id=\"删除用户帐号\"><a href=\"#删除用户帐号\" class=\"headerlink\" title=\"删除用户帐号\"></a>删除用户帐号</h3><pre><code>userdel  同建立账号用法相同 </code></pre><h3 id=\"新建组\"><a href=\"#新建组\" class=\"headerlink\" title=\"新建组\"></a>新建组</h3><pre><code>groupadd 组名</code></pre><h3 id=\"删除组\"><a href=\"#删除组\" class=\"headerlink\" title=\"删除组\"></a>删除组</h3><pre><code>groupdel 组名</code></pre><h3 id=\"修改账号\"><a href=\"#修改账号\" class=\"headerlink\" title=\"修改账号\"></a>修改账号</h3><pre><code>usermod 选项 用户名和useradd用法相同</code></pre><h3 id=\"指定口令\"><a href=\"#指定口令\" class=\"headerlink\" title=\"指定口令\"></a>指定口令</h3><p>用户口令管理给root设置密码(用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令)</p>\n<pre><code>passwd root \n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。</code></pre><h3 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h3><pre><code>su root \n\nsu - root   切换到root用户改变环境变量\n\nsu user   切换用户，加载配置文件.bashrc\n\nsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile</code></pre><h3 id=\"系统环境变量文件\"><a href=\"#系统环境变量文件\" class=\"headerlink\" title=\"系统环境变量文件\"></a>系统环境变量文件</h3><pre><code>cat /etc/profile 查看\n\nvim /etc/profile 编辑</code></pre><h3 id=\"用户环境变量文件\"><a href=\"#用户环境变量文件\" class=\"headerlink\" title=\"用户环境变量文件\"></a>用户环境变量文件</h3><pre><code>cat /etc/bash_profile 查看\n\nvim /etc/bash_profile 编辑\n\ncat .bashrc</code></pre><h3 id=\"更改文件的用户及用户组\"><a href=\"#更改文件的用户及用户组\" class=\"headerlink\" title=\"更改文件的用户及用户组\"></a>更改文件的用户及用户组</h3><pre><code>sudo chown [-R] owner[:group] {File|Directory}\n\n例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop\n</code></pre><h3 id=\"切换此文件所属的用户及组\"><a href=\"#切换此文件所属的用户及组\" class=\"headerlink\" title=\"切换此文件所属的用户及组\"></a>切换此文件所属的用户及组</h3><pre><code>sudo chown root:root jdk-7u21-linux-i586.tar.gz</code></pre>"},{"title":"Linux vim使用","date":"2018-07-28T09:30:45.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### vim三种模式\n命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式\n\n\n### 基本命令\n\n```\n:q  退出\n\n:q! 强制退出\n\n:wq 保存并退出\n\n:set number  显示行号\n\n:set nonumber  隐藏行号\n\n/host  在文档中查找host 按n跳到查找下一个，shift+n查找上一个\n\nyyp  复制光标所在行，并粘贴\n\nh(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)\n```\n\n\n\n","source":"_posts/linux/vim.md","raw":"---\ntitle: Linux vim使用\ndate: 2018-7-28 17:30:45\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Linux\ncategories:\n- Linux\n---\n\n### vim三种模式\n命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式\n\n\n### 基本命令\n\n```\n:q  退出\n\n:q! 强制退出\n\n:wq 保存并退出\n\n:set number  显示行号\n\n:set nonumber  隐藏行号\n\n/host  在文档中查找host 按n跳到查找下一个，shift+n查找上一个\n\nyyp  复制光标所在行，并粘贴\n\nh(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)\n```\n\n\n\n","slug":"linux/vim","published":1,"updated":"2019-10-15T01:29:42.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osf0034b0u6h0b6ukg5","content":"<h3 id=\"vim三种模式\"><a href=\"#vim三种模式\" class=\"headerlink\" title=\"vim三种模式\"></a>vim三种模式</h3><p>命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><pre><code>:q  退出\n\n:q! 强制退出\n\n:wq 保存并退出\n\n:set number  显示行号\n\n:set nonumber  隐藏行号\n\n/host  在文档中查找host 按n跳到查找下一个，shift+n查找上一个\n\nyyp  复制光标所在行，并粘贴\n\nh(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"vim三种模式\"><a href=\"#vim三种模式\" class=\"headerlink\" title=\"vim三种模式\"></a>vim三种模式</h3><p>命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><pre><code>:q  退出\n\n:q! 强制退出\n\n:wq 保存并退出\n\n:set number  显示行号\n\n:set nonumber  隐藏行号\n\n/host  在文档中查找host 按n跳到查找下一个，shift+n查找上一个\n\nyyp  复制光标所在行，并粘贴\n\nh(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</code></pre>"},{"title":"crypto 加密模块","date":"2019-04-08T13:12:35.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\ncrypto 模块也是核心模块之一，提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。上文中提到过核心 C/C++ 模块运行速度比其他模块要快。<br/>\n\n**MD5和SHA1**<br/>\nMD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n\n// 创建 Hash 实例\nconst hash = crypto.createHash('md5');\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhash.update('Hello, nodejs!');\n\n// encoding 值可以是 'hex', 'latin1' 或者 'base64'. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hash.digest('hex'));\n\nHash 对象在 hash.digest() 方法调用之后不能再次被使用。多次的调用会引发错误并抛出\n\n```\n\n**Hmac**<br/>\nHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n\n// 创建 hmac 实例\nconst hmac = crypto.createHmac('sha256', 'secret-key');\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhmac.update('Hello, nodejs!');\n\n// encoding 值可以是 'hex', 'latin1' 或者 'base64'. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hmac.digest('hex'));\n\n只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法\n```\n\n**AES**<br/>\nAES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n// 加密函数\nfunction aesEncrypt(data, key) {\n  const cipher = crypto.createCipher('aes192', key);\n  let crypted = cipher.update(data, 'utf8', 'hex');\n  crypted += cipher.final('hex');\n  return crypted;\n}\n// 解密函数\nfunction aesDecrypt(encrypted, key) {\n  const decipher = crypto.createDecipher('aes192', key);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nlet data = 'Hello, this is a secret message!';\nlet key = 'Password!';\nlet encrypted = aesEncrypt(data, key);\nlet decrypted = aesDecrypt(encrypted, key);\n\nconsole.log('Plain text: ' + data);\nconsole.log('Encrypted text: ' + encrypted);\nconsole.log('Decrypted text: ' + decrypted);\n```\n运行结果如下：<br/>\n```\nPlain text: Hello, this is a secret message!\nEncrypted text: 8a944d97bdabc157a5b7a40cb180e7...\nDecrypted text: Hello, this is a secret message!\n```\n\n**Diffie-Hellman**<br/>\n\nDH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于离散对数数学原理<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n\n// 进行加密交换 crypto_a\nlet crypto_a = crypto.createDiffieHellman(512);\nlet crypto_a_keys = crypto_a.generateKeys();\n\n\nlet prime = crypto_a.getPrime();\nlet generator = crypto_a.getGenerator();\n\nconsole.log('Prime: ' + prime.toString('hex'));\nconsole.log('Generator: ' + generator.toString('hex'));\n\n\n// 进行加密交换 crypto_b\nlet crypto_b = crypto.createDiffieHellman(prime, generator);\nlet crypto_b_keys = crypto_b.generateKeys();\n\n\n// 交换生成密钥\nlet a_secret = crypto_a.computeSecret(crypto_b_keys);\nlet b_secret = crypto_b.computeSecret(crypto_a_keys);\n\n```\n\n**RSA**\n\nRSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密<br/>\n\n1、生成一个RSA密钥对：<br/>\n```\nopenssl genrsa -aes256 -out rsa-key.pem 2048\n```\n2、通过上面的rsa-key.pem加密文件，导出原始的私钥<br/>\n```\nopenssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem\n```\n3、命令导出原始的公钥<br/>\n```\nopenssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem\n这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM\n```\n\n\n使用crypto模块提供的方法，即可实现非对称加解密<br/>\n\n```\nconst fs = require('fs');\nconst crypto = require('crypto');\n\n// 从文件加载key:\nfunction loadKey(file) {\n  // key实际上就是PEM编码的字符串:\n  return fs.readFileSync(file, 'utf8');\n}\n\nlet prvKey = loadKey('./rsa-prv.pem');\nlet pubKey = loadKey('./rsa-pub.pem');\nlet message = 'Hello, world!';\n\n// 使用私钥加密:\nlet enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, 'utf8'));\nconsole.log('encrypted by private key: ' + enc_by_prv.toString('hex'));\n\n\nlet dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);\nconsole.log('decrypted by public key: ' + dec_by_pub.toString('utf8'));\n\n\n执行后，可以得到解密后的消息，与原始消息相同。\n\n接下来我们使用公钥加密，私钥解密：\n\n// 使用公钥加密:\nlet enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, 'utf8'));\nconsole.log('encrypted by public key: ' + enc_by_pub.toString('hex'));\n\n// 使用私钥解密:\nlet dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);\nconsole.log('decrypted by private key: ' + dec_by_prv.toString('utf8'));\n执行得到的解密后的消息仍与原始消息相同。\n\n```\n\n**证书**\ncrypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。<br/>\n\n\n## 更多参考<br/>\n<a href='https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000'>廖雪峰老师的Crypto</a>\n\n<a href='http://nodejs.cn/api/crypto.html'>Node Api crypto 加密模块 </a>\n","source":"_posts/node/crypto.md","raw":"---\ntitle: crypto 加密模块\ndate:  2019-04-08 21:12:35\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\ncrypto 模块也是核心模块之一，提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。上文中提到过核心 C/C++ 模块运行速度比其他模块要快。<br/>\n\n**MD5和SHA1**<br/>\nMD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n\n// 创建 Hash 实例\nconst hash = crypto.createHash('md5');\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhash.update('Hello, nodejs!');\n\n// encoding 值可以是 'hex', 'latin1' 或者 'base64'. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hash.digest('hex'));\n\nHash 对象在 hash.digest() 方法调用之后不能再次被使用。多次的调用会引发错误并抛出\n\n```\n\n**Hmac**<br/>\nHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n\n// 创建 hmac 实例\nconst hmac = crypto.createHmac('sha256', 'secret-key');\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhmac.update('Hello, nodejs!');\n\n// encoding 值可以是 'hex', 'latin1' 或者 'base64'. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hmac.digest('hex'));\n\n只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法\n```\n\n**AES**<br/>\nAES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n// 加密函数\nfunction aesEncrypt(data, key) {\n  const cipher = crypto.createCipher('aes192', key);\n  let crypted = cipher.update(data, 'utf8', 'hex');\n  crypted += cipher.final('hex');\n  return crypted;\n}\n// 解密函数\nfunction aesDecrypt(encrypted, key) {\n  const decipher = crypto.createDecipher('aes192', key);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nlet data = 'Hello, this is a secret message!';\nlet key = 'Password!';\nlet encrypted = aesEncrypt(data, key);\nlet decrypted = aesDecrypt(encrypted, key);\n\nconsole.log('Plain text: ' + data);\nconsole.log('Encrypted text: ' + encrypted);\nconsole.log('Decrypted text: ' + decrypted);\n```\n运行结果如下：<br/>\n```\nPlain text: Hello, this is a secret message!\nEncrypted text: 8a944d97bdabc157a5b7a40cb180e7...\nDecrypted text: Hello, this is a secret message!\n```\n\n**Diffie-Hellman**<br/>\n\nDH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于离散对数数学原理<br/>\n\n```\n// 引入加密模块\nconst crypto = require('crypto');\n\n// 进行加密交换 crypto_a\nlet crypto_a = crypto.createDiffieHellman(512);\nlet crypto_a_keys = crypto_a.generateKeys();\n\n\nlet prime = crypto_a.getPrime();\nlet generator = crypto_a.getGenerator();\n\nconsole.log('Prime: ' + prime.toString('hex'));\nconsole.log('Generator: ' + generator.toString('hex'));\n\n\n// 进行加密交换 crypto_b\nlet crypto_b = crypto.createDiffieHellman(prime, generator);\nlet crypto_b_keys = crypto_b.generateKeys();\n\n\n// 交换生成密钥\nlet a_secret = crypto_a.computeSecret(crypto_b_keys);\nlet b_secret = crypto_b.computeSecret(crypto_a_keys);\n\n```\n\n**RSA**\n\nRSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密<br/>\n\n1、生成一个RSA密钥对：<br/>\n```\nopenssl genrsa -aes256 -out rsa-key.pem 2048\n```\n2、通过上面的rsa-key.pem加密文件，导出原始的私钥<br/>\n```\nopenssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem\n```\n3、命令导出原始的公钥<br/>\n```\nopenssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem\n这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM\n```\n\n\n使用crypto模块提供的方法，即可实现非对称加解密<br/>\n\n```\nconst fs = require('fs');\nconst crypto = require('crypto');\n\n// 从文件加载key:\nfunction loadKey(file) {\n  // key实际上就是PEM编码的字符串:\n  return fs.readFileSync(file, 'utf8');\n}\n\nlet prvKey = loadKey('./rsa-prv.pem');\nlet pubKey = loadKey('./rsa-pub.pem');\nlet message = 'Hello, world!';\n\n// 使用私钥加密:\nlet enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, 'utf8'));\nconsole.log('encrypted by private key: ' + enc_by_prv.toString('hex'));\n\n\nlet dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);\nconsole.log('decrypted by public key: ' + dec_by_pub.toString('utf8'));\n\n\n执行后，可以得到解密后的消息，与原始消息相同。\n\n接下来我们使用公钥加密，私钥解密：\n\n// 使用公钥加密:\nlet enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, 'utf8'));\nconsole.log('encrypted by public key: ' + enc_by_pub.toString('hex'));\n\n// 使用私钥解密:\nlet dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);\nconsole.log('decrypted by private key: ' + dec_by_prv.toString('utf8'));\n执行得到的解密后的消息仍与原始消息相同。\n\n```\n\n**证书**\ncrypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。<br/>\n\n\n## 更多参考<br/>\n<a href='https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000'>廖雪峰老师的Crypto</a>\n\n<a href='http://nodejs.cn/api/crypto.html'>Node Api crypto 加密模块 </a>\n","slug":"node/crypto","published":1,"updated":"2019-10-15T01:29:42.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osh0037b0u68yhnczld","content":"<p>crypto 模块也是核心模块之一，提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。上文中提到过核心 C/C++ 模块运行速度比其他模块要快。<br></p>\n<p><strong>MD5和SHA1</strong><br><br>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n\n// 创建 Hash 实例\nconst hash = crypto.createHash(&#39;md5&#39;);\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhash.update(&#39;Hello, nodejs!&#39;);\n\n// encoding 值可以是 &#39;hex&#39;, &#39;latin1&#39; 或者 &#39;base64&#39;. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hash.digest(&#39;hex&#39;));\n\nHash 对象在 hash.digest() 方法调用之后不能再次被使用。多次的调用会引发错误并抛出\n</code></pre><p><strong>Hmac</strong><br><br>Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n\n// 创建 hmac 实例\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;secret-key&#39;);\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhmac.update(&#39;Hello, nodejs!&#39;);\n\n// encoding 值可以是 &#39;hex&#39;, &#39;latin1&#39; 或者 &#39;base64&#39;. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hmac.digest(&#39;hex&#39;));\n\n只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法</code></pre><p><strong>AES</strong><br><br>AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n// 加密函数\nfunction aesEncrypt(data, key) {\n  const cipher = crypto.createCipher(&#39;aes192&#39;, key);\n  let crypted = cipher.update(data, &#39;utf8&#39;, &#39;hex&#39;);\n  crypted += cipher.final(&#39;hex&#39;);\n  return crypted;\n}\n// 解密函数\nfunction aesDecrypt(encrypted, key) {\n  const decipher = crypto.createDecipher(&#39;aes192&#39;, key);\n  let decrypted = decipher.update(encrypted, &#39;hex&#39;, &#39;utf8&#39;);\n  decrypted += decipher.final(&#39;utf8&#39;);\n  return decrypted;\n}\n\nlet data = &#39;Hello, this is a secret message!&#39;;\nlet key = &#39;Password!&#39;;\nlet encrypted = aesEncrypt(data, key);\nlet decrypted = aesDecrypt(encrypted, key);\n\nconsole.log(&#39;Plain text: &#39; + data);\nconsole.log(&#39;Encrypted text: &#39; + encrypted);\nconsole.log(&#39;Decrypted text: &#39; + decrypted);</code></pre><p>运行结果如下：<br></p>\n<pre><code>Plain text: Hello, this is a secret message!\nEncrypted text: 8a944d97bdabc157a5b7a40cb180e7...\nDecrypted text: Hello, this is a secret message!</code></pre><p><strong>Diffie-Hellman</strong><br></p>\n<p>DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于离散对数数学原理<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n\n// 进行加密交换 crypto_a\nlet crypto_a = crypto.createDiffieHellman(512);\nlet crypto_a_keys = crypto_a.generateKeys();\n\n\nlet prime = crypto_a.getPrime();\nlet generator = crypto_a.getGenerator();\n\nconsole.log(&#39;Prime: &#39; + prime.toString(&#39;hex&#39;));\nconsole.log(&#39;Generator: &#39; + generator.toString(&#39;hex&#39;));\n\n\n// 进行加密交换 crypto_b\nlet crypto_b = crypto.createDiffieHellman(prime, generator);\nlet crypto_b_keys = crypto_b.generateKeys();\n\n\n// 交换生成密钥\nlet a_secret = crypto_a.computeSecret(crypto_b_keys);\nlet b_secret = crypto_b.computeSecret(crypto_a_keys);\n</code></pre><p><strong>RSA</strong></p>\n<p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密<br></p>\n<p>1、生成一个RSA密钥对：<br></p>\n<pre><code>openssl genrsa -aes256 -out rsa-key.pem 2048</code></pre><p>2、通过上面的rsa-key.pem加密文件，导出原始的私钥<br></p>\n<pre><code>openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem</code></pre><p>3、命令导出原始的公钥<br></p>\n<pre><code>openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem\n这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM</code></pre><p>使用crypto模块提供的方法，即可实现非对称加解密<br></p>\n<pre><code>const fs = require(&#39;fs&#39;);\nconst crypto = require(&#39;crypto&#39;);\n\n// 从文件加载key:\nfunction loadKey(file) {\n  // key实际上就是PEM编码的字符串:\n  return fs.readFileSync(file, &#39;utf8&#39;);\n}\n\nlet prvKey = loadKey(&#39;./rsa-prv.pem&#39;);\nlet pubKey = loadKey(&#39;./rsa-pub.pem&#39;);\nlet message = &#39;Hello, world!&#39;;\n\n// 使用私钥加密:\nlet enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, &#39;utf8&#39;));\nconsole.log(&#39;encrypted by private key: &#39; + enc_by_prv.toString(&#39;hex&#39;));\n\n\nlet dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);\nconsole.log(&#39;decrypted by public key: &#39; + dec_by_pub.toString(&#39;utf8&#39;));\n\n\n执行后，可以得到解密后的消息，与原始消息相同。\n\n接下来我们使用公钥加密，私钥解密：\n\n// 使用公钥加密:\nlet enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, &#39;utf8&#39;));\nconsole.log(&#39;encrypted by public key: &#39; + enc_by_pub.toString(&#39;hex&#39;));\n\n// 使用私钥解密:\nlet dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);\nconsole.log(&#39;decrypted by private key: &#39; + dec_by_prv.toString(&#39;utf8&#39;));\n执行得到的解密后的消息仍与原始消息相同。\n</code></pre><p><strong>证书</strong><br>crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。<br></p>\n<h2 id=\"更多参考\"><a href=\"#更多参考\" class=\"headerlink\" title=\"更多参考\"></a>更多参考<br></h2><p><a href=\"https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000\" target=\"_blank\" rel=\"noopener\">廖雪峰老师的Crypto</a></p>\n<p><a href=\"http://nodejs.cn/api/crypto.html\" target=\"_blank\" rel=\"noopener\">Node Api crypto 加密模块 </a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>crypto 模块也是核心模块之一，提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。上文中提到过核心 C/C++ 模块运行速度比其他模块要快。<br></p>\n<p><strong>MD5和SHA1</strong><br><br>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n\n// 创建 Hash 实例\nconst hash = crypto.createHash(&#39;md5&#39;);\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhash.update(&#39;Hello, nodejs!&#39;);\n\n// encoding 值可以是 &#39;hex&#39;, &#39;latin1&#39; 或者 &#39;base64&#39;. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hash.digest(&#39;hex&#39;));\n\nHash 对象在 hash.digest() 方法调用之后不能再次被使用。多次的调用会引发错误并抛出\n</code></pre><p><strong>Hmac</strong><br><br>Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n\n// 创建 hmac 实例\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;secret-key&#39;);\n\n// 计算后的HMAC摘要 update() 方法默认字符串编码为UTF-8，也可以传入Buffer\nhmac.update(&#39;Hello, nodejs!&#39;);\n\n// encoding 值可以是 &#39;hex&#39;, &#39;latin1&#39; 或者 &#39;base64&#39;. \n  如果encoding 是字符串会被直接返回，其它情况会返回一个 a Buffer.\nconsole.log(hmac.digest(&#39;hex&#39;));\n\n只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法</code></pre><p><strong>AES</strong><br><br>AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n// 加密函数\nfunction aesEncrypt(data, key) {\n  const cipher = crypto.createCipher(&#39;aes192&#39;, key);\n  let crypted = cipher.update(data, &#39;utf8&#39;, &#39;hex&#39;);\n  crypted += cipher.final(&#39;hex&#39;);\n  return crypted;\n}\n// 解密函数\nfunction aesDecrypt(encrypted, key) {\n  const decipher = crypto.createDecipher(&#39;aes192&#39;, key);\n  let decrypted = decipher.update(encrypted, &#39;hex&#39;, &#39;utf8&#39;);\n  decrypted += decipher.final(&#39;utf8&#39;);\n  return decrypted;\n}\n\nlet data = &#39;Hello, this is a secret message!&#39;;\nlet key = &#39;Password!&#39;;\nlet encrypted = aesEncrypt(data, key);\nlet decrypted = aesDecrypt(encrypted, key);\n\nconsole.log(&#39;Plain text: &#39; + data);\nconsole.log(&#39;Encrypted text: &#39; + encrypted);\nconsole.log(&#39;Decrypted text: &#39; + decrypted);</code></pre><p>运行结果如下：<br></p>\n<pre><code>Plain text: Hello, this is a secret message!\nEncrypted text: 8a944d97bdabc157a5b7a40cb180e7...\nDecrypted text: Hello, this is a secret message!</code></pre><p><strong>Diffie-Hellman</strong><br></p>\n<p>DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于离散对数数学原理<br></p>\n<pre><code>// 引入加密模块\nconst crypto = require(&#39;crypto&#39;);\n\n// 进行加密交换 crypto_a\nlet crypto_a = crypto.createDiffieHellman(512);\nlet crypto_a_keys = crypto_a.generateKeys();\n\n\nlet prime = crypto_a.getPrime();\nlet generator = crypto_a.getGenerator();\n\nconsole.log(&#39;Prime: &#39; + prime.toString(&#39;hex&#39;));\nconsole.log(&#39;Generator: &#39; + generator.toString(&#39;hex&#39;));\n\n\n// 进行加密交换 crypto_b\nlet crypto_b = crypto.createDiffieHellman(prime, generator);\nlet crypto_b_keys = crypto_b.generateKeys();\n\n\n// 交换生成密钥\nlet a_secret = crypto_a.computeSecret(crypto_b_keys);\nlet b_secret = crypto_b.computeSecret(crypto_a_keys);\n</code></pre><p><strong>RSA</strong></p>\n<p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密<br></p>\n<p>1、生成一个RSA密钥对：<br></p>\n<pre><code>openssl genrsa -aes256 -out rsa-key.pem 2048</code></pre><p>2、通过上面的rsa-key.pem加密文件，导出原始的私钥<br></p>\n<pre><code>openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem</code></pre><p>3、命令导出原始的公钥<br></p>\n<pre><code>openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem\n这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM</code></pre><p>使用crypto模块提供的方法，即可实现非对称加解密<br></p>\n<pre><code>const fs = require(&#39;fs&#39;);\nconst crypto = require(&#39;crypto&#39;);\n\n// 从文件加载key:\nfunction loadKey(file) {\n  // key实际上就是PEM编码的字符串:\n  return fs.readFileSync(file, &#39;utf8&#39;);\n}\n\nlet prvKey = loadKey(&#39;./rsa-prv.pem&#39;);\nlet pubKey = loadKey(&#39;./rsa-pub.pem&#39;);\nlet message = &#39;Hello, world!&#39;;\n\n// 使用私钥加密:\nlet enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, &#39;utf8&#39;));\nconsole.log(&#39;encrypted by private key: &#39; + enc_by_prv.toString(&#39;hex&#39;));\n\n\nlet dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);\nconsole.log(&#39;decrypted by public key: &#39; + dec_by_pub.toString(&#39;utf8&#39;));\n\n\n执行后，可以得到解密后的消息，与原始消息相同。\n\n接下来我们使用公钥加密，私钥解密：\n\n// 使用公钥加密:\nlet enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, &#39;utf8&#39;));\nconsole.log(&#39;encrypted by public key: &#39; + enc_by_pub.toString(&#39;hex&#39;));\n\n// 使用私钥解密:\nlet dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);\nconsole.log(&#39;decrypted by private key: &#39; + dec_by_prv.toString(&#39;utf8&#39;));\n执行得到的解密后的消息仍与原始消息相同。\n</code></pre><p><strong>证书</strong><br>crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。<br></p>\n<h2 id=\"更多参考\"><a href=\"#更多参考\" class=\"headerlink\" title=\"更多参考\"></a>更多参考<br></h2><p><a href=\"https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000\" target=\"_blank\" rel=\"noopener\">廖雪峰老师的Crypto</a></p>\n<p><a href=\"http://nodejs.cn/api/crypto.html\" target=\"_blank\" rel=\"noopener\">Node Api crypto 加密模块 </a></p>\n"},{"title":"event 事件驱动模型","date":"2019-04-10T10:11:35.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n说起node的事件驱动模型首先我们来搞清楚几个概念CPU，线程、进程、调度、事件驱动<br/>\n\n**CPU**<br/>\n\n1、CPU 是中央处理器，是计算机的核心<br/>\n2、CPU 通过和寄存器，高速缓存，以及内存交互来执行程序<br/>\n3、32位 CPU 最多寻址4g内存，而64位 CPU 目前来说没有上限<br/>\n\n\n**进程（Process）**<br/>\n\n1、进程是资源分配最小单位，对于操作系统而言打开一个浏览器就是启动一个浏览器进程，打开 QQ 就是一个 QQ 进程<br/>\n2、操作系统为进程开辟一段内存空间，每个进程占用一个进程表项，包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、帐号和调度信息等，cpu根据这些信息配合寄存器进行函数调用和程序执行<br/>\n\n3、 CPU利用率=1－pⁿ<br/>\n  - 一个进程等待I/O操作的时间与其停留在内存中的时间比为p<br/>\n  - 内存中同时有n个进程<br/>\n\n**线程（Thread）**<br/>\n\n线程是程序执行的最小单位，比如打开一个 QQ 进程在里面可以打字，发表情同时和很多人聊天。同时运行多个子任务，这样的子任务就可以成为线程，每一个进程中至少有一个线程。<br/>\n\n**调度**<br/>\n\n1、 *调度程序（scheduler）*-多进程同时竞争CPU时，超过两个的进程处于就绪态，那么单CPU必须选择下一个要运行的进程，完成选择工作的程序称为调度程序（另称CPU调度器）<br/>\n2、 *CPU分配器（Dispatcher*- 决定了将CPU分配给谁，然后分配器将CPU控制权交给该进程<br/>\n3、 *进程行为* - 一般分为I/O和计算（CPU），根据占用时间不同，分为I/O密集型（I/O burst）进程和CPU密集型（CPU burst）进程<br/>\n4、 当然调度是一个复杂的操作会有调度算法具体请参考<a href=\"https://yq.aliyun.com/articles/278727\">阿里云社区博客</a>\n\n\n**计算密集型和IO密集型**<br/>\n\n1、计算密集型任务的特点是要进行大量的计算，消耗CPU资源，计算密集型任务同时进行的数量应当等于CPU的核心数<br/>\n\n2、IO密集型特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用<br/>\n\n\n**多进程-多线程**<br/>\n\n1、多进程模式最大的优点就是稳定性高，因为子进程崩溃，不会影响主进程和其他子进程。著名的Apache最早就是采用多进程模式，多进程模式的缺点是创建进程的代价大<br/>\n\n2、多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存，但创建线程相对于进程开销较小，，所以运行速度较比多进程快，并且线程之间可以共享数据。可以有效解决多进程内存浪费问题。但由于每个线程都拥有自己独立的堆栈，需要占用一定的内存空间，而且操作系统内核在切换线程时也要切换线程上下文。所以在大并发量时，多线程结构无法做到强大的伸缩性<br/>\n\n**异步I/O**<br/>\n\n1、一个任务在执行的过程中大部分时间都在等待 I/O 操作，单进程单线程模型会导致别的任务无法并行执行<br/>\n2、充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种模型称为事件驱动模型<br/>\n3、在单核CPU上采用单进程模型可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效<br/>\n\n\n**事件驱动模型**<br/>\n\n1、事件驱动模型是为了解决高并发（如Node，Nginx)<br/>\n2、操作系统在调度时较少的切换上下文，没有线程同步等问题<br/>\n3、所有处理都在单线程上进行，所以影响性能的点都在 CPU 的计算能力上，由于不受多进程或多线程模式中资源上线的影响，可伸缩性较强<br/>\n\n**Node事件驱动模型**\n\n1、每一个 I/O 工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用<br/>\n\n<img src=\"/images/event.png\"><br/>\n\n2、Node 在启动进程中会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，直到事件队列全部执行完毕，node应用就会终<br/>\n3、Node 对于堵塞 I/O 使用线程池来在操作，通过取其中一个子线程线程来执行复杂任务，而不占用主循环线程。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作，这样就防止堵塞 I/O 占用空闲资源，这就是所谓的非阻塞式 I/O<br/>\n\n<img src=\"/images/event-loop.png\"><br/>\n\n**事件队列调度（通过回调函数将任务添加事件队列中）**<br/>\n1、内置的事件和事件监听器（http、server的一些事件）<br/>\n2、异步堵塞 I/O 库(db处理、fs处理等)<br/>\n3、定时器setTimeout、setInterval<br/>\n4、全局对象process的.nextTick()API<br/>\n5、自定义的事件和监听器<br/>\n\n\n**内置事件(举例)**<br/>\n```\n// 引入 events 模块\nlet events = require('events');\n\n// 创建事件对象\nlet eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nlet connectHandler = function connected() {\n   // 开始触发事件 \n   eventEmitter.emit('start');\n}\n\n// 绑定事件处理程序\neventEmitter.on('connection', connectHandler);\neventEmitter.on('start', function(){});\n\n// 触发事件处理程序\neventEmitter.emit('connection');\n\nconsole.log(\"程序执行完毕。\");\n```\n\n\n以上是Node 事件驱动模型的基本概念。在下篇进程文章中会介绍在 Node 中怎样创建多进程架构，也会在**node高级系列-v8与异步I/O**中详细介绍 Node的异步 I/O <br/>\n\n\n\n## 更多方法参考<br/>\n<a href='http://nodejs.cn/api/events.html'>Node Api events 事件模块 </a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/node/event.md","raw":"---\ntitle: event 事件驱动模型\ndate:  2019-04-10 18:11:35\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\n\n说起node的事件驱动模型首先我们来搞清楚几个概念CPU，线程、进程、调度、事件驱动<br/>\n\n**CPU**<br/>\n\n1、CPU 是中央处理器，是计算机的核心<br/>\n2、CPU 通过和寄存器，高速缓存，以及内存交互来执行程序<br/>\n3、32位 CPU 最多寻址4g内存，而64位 CPU 目前来说没有上限<br/>\n\n\n**进程（Process）**<br/>\n\n1、进程是资源分配最小单位，对于操作系统而言打开一个浏览器就是启动一个浏览器进程，打开 QQ 就是一个 QQ 进程<br/>\n2、操作系统为进程开辟一段内存空间，每个进程占用一个进程表项，包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、帐号和调度信息等，cpu根据这些信息配合寄存器进行函数调用和程序执行<br/>\n\n3、 CPU利用率=1－pⁿ<br/>\n  - 一个进程等待I/O操作的时间与其停留在内存中的时间比为p<br/>\n  - 内存中同时有n个进程<br/>\n\n**线程（Thread）**<br/>\n\n线程是程序执行的最小单位，比如打开一个 QQ 进程在里面可以打字，发表情同时和很多人聊天。同时运行多个子任务，这样的子任务就可以成为线程，每一个进程中至少有一个线程。<br/>\n\n**调度**<br/>\n\n1、 *调度程序（scheduler）*-多进程同时竞争CPU时，超过两个的进程处于就绪态，那么单CPU必须选择下一个要运行的进程，完成选择工作的程序称为调度程序（另称CPU调度器）<br/>\n2、 *CPU分配器（Dispatcher*- 决定了将CPU分配给谁，然后分配器将CPU控制权交给该进程<br/>\n3、 *进程行为* - 一般分为I/O和计算（CPU），根据占用时间不同，分为I/O密集型（I/O burst）进程和CPU密集型（CPU burst）进程<br/>\n4、 当然调度是一个复杂的操作会有调度算法具体请参考<a href=\"https://yq.aliyun.com/articles/278727\">阿里云社区博客</a>\n\n\n**计算密集型和IO密集型**<br/>\n\n1、计算密集型任务的特点是要进行大量的计算，消耗CPU资源，计算密集型任务同时进行的数量应当等于CPU的核心数<br/>\n\n2、IO密集型特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用<br/>\n\n\n**多进程-多线程**<br/>\n\n1、多进程模式最大的优点就是稳定性高，因为子进程崩溃，不会影响主进程和其他子进程。著名的Apache最早就是采用多进程模式，多进程模式的缺点是创建进程的代价大<br/>\n\n2、多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存，但创建线程相对于进程开销较小，，所以运行速度较比多进程快，并且线程之间可以共享数据。可以有效解决多进程内存浪费问题。但由于每个线程都拥有自己独立的堆栈，需要占用一定的内存空间，而且操作系统内核在切换线程时也要切换线程上下文。所以在大并发量时，多线程结构无法做到强大的伸缩性<br/>\n\n**异步I/O**<br/>\n\n1、一个任务在执行的过程中大部分时间都在等待 I/O 操作，单进程单线程模型会导致别的任务无法并行执行<br/>\n2、充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种模型称为事件驱动模型<br/>\n3、在单核CPU上采用单进程模型可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效<br/>\n\n\n**事件驱动模型**<br/>\n\n1、事件驱动模型是为了解决高并发（如Node，Nginx)<br/>\n2、操作系统在调度时较少的切换上下文，没有线程同步等问题<br/>\n3、所有处理都在单线程上进行，所以影响性能的点都在 CPU 的计算能力上，由于不受多进程或多线程模式中资源上线的影响，可伸缩性较强<br/>\n\n**Node事件驱动模型**\n\n1、每一个 I/O 工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用<br/>\n\n<img src=\"/images/event.png\"><br/>\n\n2、Node 在启动进程中会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，直到事件队列全部执行完毕，node应用就会终<br/>\n3、Node 对于堵塞 I/O 使用线程池来在操作，通过取其中一个子线程线程来执行复杂任务，而不占用主循环线程。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作，这样就防止堵塞 I/O 占用空闲资源，这就是所谓的非阻塞式 I/O<br/>\n\n<img src=\"/images/event-loop.png\"><br/>\n\n**事件队列调度（通过回调函数将任务添加事件队列中）**<br/>\n1、内置的事件和事件监听器（http、server的一些事件）<br/>\n2、异步堵塞 I/O 库(db处理、fs处理等)<br/>\n3、定时器setTimeout、setInterval<br/>\n4、全局对象process的.nextTick()API<br/>\n5、自定义的事件和监听器<br/>\n\n\n**内置事件(举例)**<br/>\n```\n// 引入 events 模块\nlet events = require('events');\n\n// 创建事件对象\nlet eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nlet connectHandler = function connected() {\n   // 开始触发事件 \n   eventEmitter.emit('start');\n}\n\n// 绑定事件处理程序\neventEmitter.on('connection', connectHandler);\neventEmitter.on('start', function(){});\n\n// 触发事件处理程序\neventEmitter.emit('connection');\n\nconsole.log(\"程序执行完毕。\");\n```\n\n\n以上是Node 事件驱动模型的基本概念。在下篇进程文章中会介绍在 Node 中怎样创建多进程架构，也会在**node高级系列-v8与异步I/O**中详细介绍 Node的异步 I/O <br/>\n\n\n\n## 更多方法参考<br/>\n<a href='http://nodejs.cn/api/events.html'>Node Api events 事件模块 </a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"node/event","published":1,"updated":"2019-10-15T01:29:42.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osj0039b0u6our1cj0q","content":"<p>说起node的事件驱动模型首先我们来搞清楚几个概念CPU，线程、进程、调度、事件驱动<br></p>\n<p><strong>CPU</strong><br></p>\n<p>1、CPU 是中央处理器，是计算机的核心<br><br>2、CPU 通过和寄存器，高速缓存，以及内存交互来执行程序<br><br>3、32位 CPU 最多寻址4g内存，而64位 CPU 目前来说没有上限<br></p>\n<p><strong>进程（Process）</strong><br></p>\n<p>1、进程是资源分配最小单位，对于操作系统而言打开一个浏览器就是启动一个浏览器进程，打开 QQ 就是一个 QQ 进程<br><br>2、操作系统为进程开辟一段内存空间，每个进程占用一个进程表项，包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、帐号和调度信息等，cpu根据这些信息配合寄存器进行函数调用和程序执行<br></p>\n<p>3、 CPU利用率=1－pⁿ<br></p>\n<ul>\n<li>一个进程等待I/O操作的时间与其停留在内存中的时间比为p<br></li>\n<li>内存中同时有n个进程<br></li>\n</ul>\n<p><strong>线程（Thread）</strong><br></p>\n<p>线程是程序执行的最小单位，比如打开一个 QQ 进程在里面可以打字，发表情同时和很多人聊天。同时运行多个子任务，这样的子任务就可以成为线程，每一个进程中至少有一个线程。<br></p>\n<p><strong>调度</strong><br></p>\n<p>1、 <em>调度程序（scheduler）</em>-多进程同时竞争CPU时，超过两个的进程处于就绪态，那么单CPU必须选择下一个要运行的进程，完成选择工作的程序称为调度程序（另称CPU调度器）<br><br>2、 <em>CPU分配器（Dispatcher</em>- 决定了将CPU分配给谁，然后分配器将CPU控制权交给该进程<br><br>3、 <em>进程行为</em> - 一般分为I/O和计算（CPU），根据占用时间不同，分为I/O密集型（I/O burst）进程和CPU密集型（CPU burst）进程<br><br>4、 当然调度是一个复杂的操作会有调度算法具体请参考<a href=\"https://yq.aliyun.com/articles/278727\" target=\"_blank\" rel=\"noopener\">阿里云社区博客</a></p>\n<p><strong>计算密集型和IO密集型</strong><br></p>\n<p>1、计算密集型任务的特点是要进行大量的计算，消耗CPU资源，计算密集型任务同时进行的数量应当等于CPU的核心数<br></p>\n<p>2、IO密集型特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用<br></p>\n<p><strong>多进程-多线程</strong><br></p>\n<p>1、多进程模式最大的优点就是稳定性高，因为子进程崩溃，不会影响主进程和其他子进程。著名的Apache最早就是采用多进程模式，多进程模式的缺点是创建进程的代价大<br></p>\n<p>2、多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存，但创建线程相对于进程开销较小，，所以运行速度较比多进程快，并且线程之间可以共享数据。可以有效解决多进程内存浪费问题。但由于每个线程都拥有自己独立的堆栈，需要占用一定的内存空间，而且操作系统内核在切换线程时也要切换线程上下文。所以在大并发量时，多线程结构无法做到强大的伸缩性<br></p>\n<p><strong>异步I/O</strong><br></p>\n<p>1、一个任务在执行的过程中大部分时间都在等待 I/O 操作，单进程单线程模型会导致别的任务无法并行执行<br><br>2、充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种模型称为事件驱动模型<br><br>3、在单核CPU上采用单进程模型可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效<br></p>\n<p><strong>事件驱动模型</strong><br></p>\n<p>1、事件驱动模型是为了解决高并发（如Node，Nginx)<br><br>2、操作系统在调度时较少的切换上下文，没有线程同步等问题<br><br>3、所有处理都在单线程上进行，所以影响性能的点都在 CPU 的计算能力上，由于不受多进程或多线程模式中资源上线的影响，可伸缩性较强<br></p>\n<p><strong>Node事件驱动模型</strong></p>\n<p>1、每一个 I/O 工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用<br></p>\n<p><img src=\"/images/event.png\"><br></p>\n<p>2、Node 在启动进程中会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，直到事件队列全部执行完毕，node应用就会终<br><br>3、Node 对于堵塞 I/O 使用线程池来在操作，通过取其中一个子线程线程来执行复杂任务，而不占用主循环线程。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作，这样就防止堵塞 I/O 占用空闲资源，这就是所谓的非阻塞式 I/O<br></p>\n<p><img src=\"/images/event-loop.png\"><br></p>\n<p><strong>事件队列调度（通过回调函数将任务添加事件队列中）</strong><br><br>1、内置的事件和事件监听器（http、server的一些事件）<br><br>2、异步堵塞 I/O 库(db处理、fs处理等)<br><br>3、定时器setTimeout、setInterval<br><br>4、全局对象process的.nextTick()API<br><br>5、自定义的事件和监听器<br></p>\n<p><strong>内置事件(举例)</strong><br></p>\n<pre><code>// 引入 events 模块\nlet events = require(&#39;events&#39;);\n\n// 创建事件对象\nlet eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nlet connectHandler = function connected() {\n   // 开始触发事件 \n   eventEmitter.emit(&#39;start&#39;);\n}\n\n// 绑定事件处理程序\neventEmitter.on(&#39;connection&#39;, connectHandler);\neventEmitter.on(&#39;start&#39;, function(){});\n\n// 触发事件处理程序\neventEmitter.emit(&#39;connection&#39;);\n\nconsole.log(&quot;程序执行完毕。&quot;);</code></pre><p>以上是Node 事件驱动模型的基本概念。在下篇进程文章中会介绍在 Node 中怎样创建多进程架构，也会在<strong>node高级系列-v8与异步I/O</strong>中详细介绍 Node的异步 I/O <br></p>\n<h2 id=\"更多方法参考\"><a href=\"#更多方法参考\" class=\"headerlink\" title=\"更多方法参考\"></a>更多方法参考<br></h2><p><a href=\"http://nodejs.cn/api/events.html\" target=\"_blank\" rel=\"noopener\">Node Api events 事件模块 </a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>说起node的事件驱动模型首先我们来搞清楚几个概念CPU，线程、进程、调度、事件驱动<br></p>\n<p><strong>CPU</strong><br></p>\n<p>1、CPU 是中央处理器，是计算机的核心<br><br>2、CPU 通过和寄存器，高速缓存，以及内存交互来执行程序<br><br>3、32位 CPU 最多寻址4g内存，而64位 CPU 目前来说没有上限<br></p>\n<p><strong>进程（Process）</strong><br></p>\n<p>1、进程是资源分配最小单位，对于操作系统而言打开一个浏览器就是启动一个浏览器进程，打开 QQ 就是一个 QQ 进程<br><br>2、操作系统为进程开辟一段内存空间，每个进程占用一个进程表项，包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、帐号和调度信息等，cpu根据这些信息配合寄存器进行函数调用和程序执行<br></p>\n<p>3、 CPU利用率=1－pⁿ<br></p>\n<ul>\n<li>一个进程等待I/O操作的时间与其停留在内存中的时间比为p<br></li>\n<li>内存中同时有n个进程<br></li>\n</ul>\n<p><strong>线程（Thread）</strong><br></p>\n<p>线程是程序执行的最小单位，比如打开一个 QQ 进程在里面可以打字，发表情同时和很多人聊天。同时运行多个子任务，这样的子任务就可以成为线程，每一个进程中至少有一个线程。<br></p>\n<p><strong>调度</strong><br></p>\n<p>1、 <em>调度程序（scheduler）</em>-多进程同时竞争CPU时，超过两个的进程处于就绪态，那么单CPU必须选择下一个要运行的进程，完成选择工作的程序称为调度程序（另称CPU调度器）<br><br>2、 <em>CPU分配器（Dispatcher</em>- 决定了将CPU分配给谁，然后分配器将CPU控制权交给该进程<br><br>3、 <em>进程行为</em> - 一般分为I/O和计算（CPU），根据占用时间不同，分为I/O密集型（I/O burst）进程和CPU密集型（CPU burst）进程<br><br>4、 当然调度是一个复杂的操作会有调度算法具体请参考<a href=\"https://yq.aliyun.com/articles/278727\" target=\"_blank\" rel=\"noopener\">阿里云社区博客</a></p>\n<p><strong>计算密集型和IO密集型</strong><br></p>\n<p>1、计算密集型任务的特点是要进行大量的计算，消耗CPU资源，计算密集型任务同时进行的数量应当等于CPU的核心数<br></p>\n<p>2、IO密集型特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用<br></p>\n<p><strong>多进程-多线程</strong><br></p>\n<p>1、多进程模式最大的优点就是稳定性高，因为子进程崩溃，不会影响主进程和其他子进程。著名的Apache最早就是采用多进程模式，多进程模式的缺点是创建进程的代价大<br></p>\n<p>2、多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存，但创建线程相对于进程开销较小，，所以运行速度较比多进程快，并且线程之间可以共享数据。可以有效解决多进程内存浪费问题。但由于每个线程都拥有自己独立的堆栈，需要占用一定的内存空间，而且操作系统内核在切换线程时也要切换线程上下文。所以在大并发量时，多线程结构无法做到强大的伸缩性<br></p>\n<p><strong>异步I/O</strong><br></p>\n<p>1、一个任务在执行的过程中大部分时间都在等待 I/O 操作，单进程单线程模型会导致别的任务无法并行执行<br><br>2、充分利用操作系统提供的异步 I/O 支持，就可以用单进程单线程模型来执行多任务，这种模型称为事件驱动模型<br><br>3、在单核CPU上采用单进程模型可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效<br></p>\n<p><strong>事件驱动模型</strong><br></p>\n<p>1、事件驱动模型是为了解决高并发（如Node，Nginx)<br><br>2、操作系统在调度时较少的切换上下文，没有线程同步等问题<br><br>3、所有处理都在单线程上进行，所以影响性能的点都在 CPU 的计算能力上，由于不受多进程或多线程模式中资源上线的影响，可伸缩性较强<br></p>\n<p><strong>Node事件驱动模型</strong></p>\n<p>1、每一个 I/O 工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用<br></p>\n<p><img src=\"/images/event.png\"><br></p>\n<p>2、Node 在启动进程中会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，直到事件队列全部执行完毕，node应用就会终<br><br>3、Node 对于堵塞 I/O 使用线程池来在操作，通过取其中一个子线程线程来执行复杂任务，而不占用主循环线程。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作，这样就防止堵塞 I/O 占用空闲资源，这就是所谓的非阻塞式 I/O<br></p>\n<p><img src=\"/images/event-loop.png\"><br></p>\n<p><strong>事件队列调度（通过回调函数将任务添加事件队列中）</strong><br><br>1、内置的事件和事件监听器（http、server的一些事件）<br><br>2、异步堵塞 I/O 库(db处理、fs处理等)<br><br>3、定时器setTimeout、setInterval<br><br>4、全局对象process的.nextTick()API<br><br>5、自定义的事件和监听器<br></p>\n<p><strong>内置事件(举例)</strong><br></p>\n<pre><code>// 引入 events 模块\nlet events = require(&#39;events&#39;);\n\n// 创建事件对象\nlet eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nlet connectHandler = function connected() {\n   // 开始触发事件 \n   eventEmitter.emit(&#39;start&#39;);\n}\n\n// 绑定事件处理程序\neventEmitter.on(&#39;connection&#39;, connectHandler);\neventEmitter.on(&#39;start&#39;, function(){});\n\n// 触发事件处理程序\neventEmitter.emit(&#39;connection&#39;);\n\nconsole.log(&quot;程序执行完毕。&quot;);</code></pre><p>以上是Node 事件驱动模型的基本概念。在下篇进程文章中会介绍在 Node 中怎样创建多进程架构，也会在<strong>node高级系列-v8与异步I/O</strong>中详细介绍 Node的异步 I/O <br></p>\n<h2 id=\"更多方法参考\"><a href=\"#更多方法参考\" class=\"headerlink\" title=\"更多方法参考\"></a>更多方法参考<br></h2><p><a href=\"http://nodejs.cn/api/events.html\" target=\"_blank\" rel=\"noopener\">Node Api events 事件模块 </a></p>\n"},{"title":"Error 异常模块","date":"2019-04-14T15:05:11.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n错误处理是所有应用程序的重要组成部分。要抛出异常，请使用 JavaScript 的 throw  关键字。在 JavaScript 中，通常使用 Error 对象和消息来表示错误<br/>\n\n**捕获异常try/catch**<br/>\n```\n  function fun () {\n    throw new Error(\"error!\");\n  }\n  try {\n    fun();\n  } catch (e) {\n    console.log(e.message);\n  }\n```\n\n**finally关键字**<br/>\n\ncatch部分只有在抛出错误时才执行。finally部分仍然执行，尽管在try部分中抛出了任何错误<br/>\n\n```\ntry { \n  throw new Error(\"throw error\"); \n} catch (e) { \n  console.log(e.message); \n} finally { \n  console.log(\"不论抛出什么错误，我依然会执行\"); \n} \n```\n\n\n\n\n","source":"_posts/node/error.md","raw":"---\ntitle: Error 异常模块\ndate:  2019-04-14 23:05:11\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\n错误处理是所有应用程序的重要组成部分。要抛出异常，请使用 JavaScript 的 throw  关键字。在 JavaScript 中，通常使用 Error 对象和消息来表示错误<br/>\n\n**捕获异常try/catch**<br/>\n```\n  function fun () {\n    throw new Error(\"error!\");\n  }\n  try {\n    fun();\n  } catch (e) {\n    console.log(e.message);\n  }\n```\n\n**finally关键字**<br/>\n\ncatch部分只有在抛出错误时才执行。finally部分仍然执行，尽管在try部分中抛出了任何错误<br/>\n\n```\ntry { \n  throw new Error(\"throw error\"); \n} catch (e) { \n  console.log(e.message); \n} finally { \n  console.log(\"不论抛出什么错误，我依然会执行\"); \n} \n```\n\n\n\n\n","slug":"node/error","published":1,"updated":"2019-10-15T01:29:42.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osl003db0u6i42te42w","content":"<p>错误处理是所有应用程序的重要组成部分。要抛出异常，请使用 JavaScript 的 throw  关键字。在 JavaScript 中，通常使用 Error 对象和消息来表示错误<br></p>\n<p><strong>捕获异常try/catch</strong><br></p>\n<pre><code>  function fun () {\n    throw new Error(&quot;error!&quot;);\n  }\n  try {\n    fun();\n  } catch (e) {\n    console.log(e.message);\n  }</code></pre><p><strong>finally关键字</strong><br></p>\n<p>catch部分只有在抛出错误时才执行。finally部分仍然执行，尽管在try部分中抛出了任何错误<br></p>\n<pre><code>try { \n  throw new Error(&quot;throw error&quot;); \n} catch (e) { \n  console.log(e.message); \n} finally { \n  console.log(&quot;不论抛出什么错误，我依然会执行&quot;); \n} </code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>错误处理是所有应用程序的重要组成部分。要抛出异常，请使用 JavaScript 的 throw  关键字。在 JavaScript 中，通常使用 Error 对象和消息来表示错误<br></p>\n<p><strong>捕获异常try/catch</strong><br></p>\n<pre><code>  function fun () {\n    throw new Error(&quot;error!&quot;);\n  }\n  try {\n    fun();\n  } catch (e) {\n    console.log(e.message);\n  }</code></pre><p><strong>finally关键字</strong><br></p>\n<p>catch部分只有在抛出错误时才执行。finally部分仍然执行，尽管在try部分中抛出了任何错误<br></p>\n<pre><code>try { \n  throw new Error(&quot;throw error&quot;); \n} catch (e) { \n  console.log(e.message); \n} finally { \n  console.log(&quot;不论抛出什么错误，我依然会执行&quot;); \n} </code></pre>"},{"title":"fs 文件操作","date":"2019-04-01T12:16:15.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n在 node 中文件交互是非常重要的，例如文件的打开、读取、写入文件、以及与其交互等等，这其中围绕着异步模式和同步模式读取的话题。下面就 node 的 fs 文件操作模举例说明<br/>\n\n### fs使用特点\n1、同步的版本将阻塞整个进程，直到它们完成（停止所有连接）<br/>\n2、异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回，但是无法保证操作的的正确性和有效的顺序<br/>\n\n### 文件写入<br/>\n\n1. 异步文件写入<br/>\n\n```\n// 引入 fs 模块\nconst fs = require('fs');\n\n/**\n * @description\n * 异步打开文件操作 fs.open\n * 异步写入文件操作 fs.writeFile\n * 异步关闭文件操作 fs.close\n */\nfs.open('file.txt', 'a', (err, fd)=>{\n  if (err) throw err;\n  fs.writeFile(fd, \"node是很有意思的语言！\", (err)=>{\n    if (err) throw err;\n    console.log('写入文件成功')\n    fs.close(fd, (err)=>{\n      if (err) throw err;\n      console.log('文件以保存并关闭')\n    })\n  })\n})\n```\n2. 同步写入方式<br/>\n```\n// 引入模块 \nconst fs = require('fs');\n\n// 打开文件 同步\nvar fd=fs.openSync('file.txt', 'w');\n\n// 写入内容\nfs.writeFileSync(fd,\"node是很有意思的语言!\"); \n\n// 保存并关闭\nfs.closeSync(fd);\n```\n\n\n### 读写操作<br/>\n\n1. 文件读写操作<br/>\n\n```\n// 引入模块\nconst fs = require('fs');\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n */\nfs.readFile('source/file.txt','utf8',(err,data)=>{\n  if (err) throw err;\n  console.log(data); //data 默认读取的是二进制 使用toString() 方法转换成\n})\n```\n\n2. 图片读写操作<br/>\n\n```\n// 引入模块\nconst fs = require('fs');\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n */\nfs.readFile(\"source/a.jpg\",(err,data) => {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile('b.jpg', data, (err) => {\n    if (err) throw err;\n    console.log('写入成功！')\n  })\n});\n```\n\n3. 视频读写操作<br/>\n\n```\n// 引入模块\nlet fs= require('fs');\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n * 创建文件读取流 fs.createReadStream\n * 创建文件写入流 fs.createWriteStream\n * 创建管道 fileStream.pipe\n * fs.readFile() 函数会缓冲整个文件。 \n * 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。\n */\n\n// 方式一\nfs.readFile('source/a.mp4', (err, data) => {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile('b.mp4', data, (err) => {\n    if (err) throw err;\n    console.log('写入成功！');\n  });\n});\n\n// 方式二\nlet rs = fs.createReadStream('source/a.mp4');\nlet ws = fs.createWriteStream('new.mp4');\nre.pipe(ws);\n```\n\n4. 使用同步文件流写入操作<br/>\n```\n// 引入模块\nlet fs= require('fs');\n\n// 建立通道\nlet ws = fs.createWriteStream('file.txt')\n\n// 打开通道\nws.once('open', () => {\n    console.log('通道打开');\n})\n\nws.once('close', () => {\n    console.log('通道关闭');\n})\n\n// 写入内容\nws.write('node开始');\nws.write('node1');\nws.write('node2');\nws.write('node结束');\n```\n\n<a href=\"https://nodejs.org/docs/latest-v9.x/api/fs.html\">其他方法请参考 Node Api </a><br/>\n\n\n","source":"_posts/node/fs.md","raw":"---\ntitle: fs 文件操作\ndate: 2019-04-1 20:16:15\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\n\n在 node 中文件交互是非常重要的，例如文件的打开、读取、写入文件、以及与其交互等等，这其中围绕着异步模式和同步模式读取的话题。下面就 node 的 fs 文件操作模举例说明<br/>\n\n### fs使用特点\n1、同步的版本将阻塞整个进程，直到它们完成（停止所有连接）<br/>\n2、异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回，但是无法保证操作的的正确性和有效的顺序<br/>\n\n### 文件写入<br/>\n\n1. 异步文件写入<br/>\n\n```\n// 引入 fs 模块\nconst fs = require('fs');\n\n/**\n * @description\n * 异步打开文件操作 fs.open\n * 异步写入文件操作 fs.writeFile\n * 异步关闭文件操作 fs.close\n */\nfs.open('file.txt', 'a', (err, fd)=>{\n  if (err) throw err;\n  fs.writeFile(fd, \"node是很有意思的语言！\", (err)=>{\n    if (err) throw err;\n    console.log('写入文件成功')\n    fs.close(fd, (err)=>{\n      if (err) throw err;\n      console.log('文件以保存并关闭')\n    })\n  })\n})\n```\n2. 同步写入方式<br/>\n```\n// 引入模块 \nconst fs = require('fs');\n\n// 打开文件 同步\nvar fd=fs.openSync('file.txt', 'w');\n\n// 写入内容\nfs.writeFileSync(fd,\"node是很有意思的语言!\"); \n\n// 保存并关闭\nfs.closeSync(fd);\n```\n\n\n### 读写操作<br/>\n\n1. 文件读写操作<br/>\n\n```\n// 引入模块\nconst fs = require('fs');\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n */\nfs.readFile('source/file.txt','utf8',(err,data)=>{\n  if (err) throw err;\n  console.log(data); //data 默认读取的是二进制 使用toString() 方法转换成\n})\n```\n\n2. 图片读写操作<br/>\n\n```\n// 引入模块\nconst fs = require('fs');\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n */\nfs.readFile(\"source/a.jpg\",(err,data) => {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile('b.jpg', data, (err) => {\n    if (err) throw err;\n    console.log('写入成功！')\n  })\n});\n```\n\n3. 视频读写操作<br/>\n\n```\n// 引入模块\nlet fs= require('fs');\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n * 创建文件读取流 fs.createReadStream\n * 创建文件写入流 fs.createWriteStream\n * 创建管道 fileStream.pipe\n * fs.readFile() 函数会缓冲整个文件。 \n * 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。\n */\n\n// 方式一\nfs.readFile('source/a.mp4', (err, data) => {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile('b.mp4', data, (err) => {\n    if (err) throw err;\n    console.log('写入成功！');\n  });\n});\n\n// 方式二\nlet rs = fs.createReadStream('source/a.mp4');\nlet ws = fs.createWriteStream('new.mp4');\nre.pipe(ws);\n```\n\n4. 使用同步文件流写入操作<br/>\n```\n// 引入模块\nlet fs= require('fs');\n\n// 建立通道\nlet ws = fs.createWriteStream('file.txt')\n\n// 打开通道\nws.once('open', () => {\n    console.log('通道打开');\n})\n\nws.once('close', () => {\n    console.log('通道关闭');\n})\n\n// 写入内容\nws.write('node开始');\nws.write('node1');\nws.write('node2');\nws.write('node结束');\n```\n\n<a href=\"https://nodejs.org/docs/latest-v9.x/api/fs.html\">其他方法请参考 Node Api </a><br/>\n\n\n","slug":"node/fs","published":1,"updated":"2019-10-15T01:29:42.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osn003eb0u6rz4jtir2","content":"<p>在 node 中文件交互是非常重要的，例如文件的打开、读取、写入文件、以及与其交互等等，这其中围绕着异步模式和同步模式读取的话题。下面就 node 的 fs 文件操作模举例说明<br></p>\n<h3 id=\"fs使用特点\"><a href=\"#fs使用特点\" class=\"headerlink\" title=\"fs使用特点\"></a>fs使用特点</h3><p>1、同步的版本将阻塞整个进程，直到它们完成（停止所有连接）<br><br>2、异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回，但是无法保证操作的的正确性和有效的顺序<br></p>\n<h3 id=\"文件写入\"><a href=\"#文件写入\" class=\"headerlink\" title=\"文件写入\"></a>文件写入<br></h3><ol>\n<li>异步文件写入<br></li>\n</ol>\n<pre><code>// 引入 fs 模块\nconst fs = require(&#39;fs&#39;);\n\n/**\n * @description\n * 异步打开文件操作 fs.open\n * 异步写入文件操作 fs.writeFile\n * 异步关闭文件操作 fs.close\n */\nfs.open(&#39;file.txt&#39;, &#39;a&#39;, (err, fd)=&gt;{\n  if (err) throw err;\n  fs.writeFile(fd, &quot;node是很有意思的语言！&quot;, (err)=&gt;{\n    if (err) throw err;\n    console.log(&#39;写入文件成功&#39;)\n    fs.close(fd, (err)=&gt;{\n      if (err) throw err;\n      console.log(&#39;文件以保存并关闭&#39;)\n    })\n  })\n})</code></pre><ol start=\"2\">\n<li>同步写入方式<br><pre><code>// 引入模块 \nconst fs = require(&#39;fs&#39;);\n</code></pre></li>\n</ol>\n<p>// 打开文件 同步<br>var fd=fs.openSync(‘file.txt’, ‘w’);</p>\n<p>// 写入内容<br>fs.writeFileSync(fd,”node是很有意思的语言!”); </p>\n<p>// 保存并关闭<br>fs.closeSync(fd);</p>\n<pre><code>\n\n### 读写操作&lt;br/&gt;\n\n1. 文件读写操作&lt;br/&gt;\n</code></pre><p>// 引入模块<br>const fs = require(‘fs’);</p>\n<p>/**</p>\n<ul>\n<li>@description</li>\n<li>异步读取文件 fs.readFile</li>\n<li>/<br>fs.readFile(‘source/file.txt’,’utf8’,(err,data)=&gt;{<br>if (err) throw err;<br>console.log(data); //data 默认读取的是二进制 使用toString() 方法转换成<br>})<pre><code></code></pre></li>\n</ul>\n<ol start=\"2\">\n<li>图片读写操作<br></li>\n</ol>\n<pre><code>// 引入模块\nconst fs = require(&#39;fs&#39;);\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n */\nfs.readFile(&quot;source/a.jpg&quot;,(err,data) =&gt; {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile(&#39;b.jpg&#39;, data, (err) =&gt; {\n    if (err) throw err;\n    console.log(&#39;写入成功！&#39;)\n  })\n});</code></pre><ol start=\"3\">\n<li>视频读写操作<br></li>\n</ol>\n<pre><code>// 引入模块\nlet fs= require(&#39;fs&#39;);\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n * 创建文件读取流 fs.createReadStream\n * 创建文件写入流 fs.createWriteStream\n * 创建管道 fileStream.pipe\n * fs.readFile() 函数会缓冲整个文件。 \n * 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。\n */\n\n// 方式一\nfs.readFile(&#39;source/a.mp4&#39;, (err, data) =&gt; {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile(&#39;b.mp4&#39;, data, (err) =&gt; {\n    if (err) throw err;\n    console.log(&#39;写入成功！&#39;);\n  });\n});\n\n// 方式二\nlet rs = fs.createReadStream(&#39;source/a.mp4&#39;);\nlet ws = fs.createWriteStream(&#39;new.mp4&#39;);\nre.pipe(ws);</code></pre><ol start=\"4\">\n<li>使用同步文件流写入操作<br><pre><code>// 引入模块\nlet fs= require(&#39;fs&#39;);\n</code></pre></li>\n</ol>\n<p>// 建立通道<br>let ws = fs.createWriteStream(‘file.txt’)</p>\n<p>// 打开通道<br>ws.once(‘open’, () =&gt; {<br>    console.log(‘通道打开’);<br>})</p>\n<p>ws.once(‘close’, () =&gt; {<br>    console.log(‘通道关闭’);<br>})</p>\n<p>// 写入内容<br>ws.write(‘node开始’);<br>ws.write(‘node1’);<br>ws.write(‘node2’);<br>ws.write(‘node结束’);</p>\n<pre><code>\n&lt;a href=&quot;https://nodejs.org/docs/latest-v9.x/api/fs.html&quot;&gt;其他方法请参考 Node Api &lt;/a&gt;&lt;br/&gt;\n\n</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在 node 中文件交互是非常重要的，例如文件的打开、读取、写入文件、以及与其交互等等，这其中围绕着异步模式和同步模式读取的话题。下面就 node 的 fs 文件操作模举例说明<br></p>\n<h3 id=\"fs使用特点\"><a href=\"#fs使用特点\" class=\"headerlink\" title=\"fs使用特点\"></a>fs使用特点</h3><p>1、同步的版本将阻塞整个进程，直到它们完成（停止所有连接）<br><br>2、异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回，但是无法保证操作的的正确性和有效的顺序<br></p>\n<h3 id=\"文件写入\"><a href=\"#文件写入\" class=\"headerlink\" title=\"文件写入\"></a>文件写入<br></h3><ol>\n<li>异步文件写入<br></li>\n</ol>\n<pre><code>// 引入 fs 模块\nconst fs = require(&#39;fs&#39;);\n\n/**\n * @description\n * 异步打开文件操作 fs.open\n * 异步写入文件操作 fs.writeFile\n * 异步关闭文件操作 fs.close\n */\nfs.open(&#39;file.txt&#39;, &#39;a&#39;, (err, fd)=&gt;{\n  if (err) throw err;\n  fs.writeFile(fd, &quot;node是很有意思的语言！&quot;, (err)=&gt;{\n    if (err) throw err;\n    console.log(&#39;写入文件成功&#39;)\n    fs.close(fd, (err)=&gt;{\n      if (err) throw err;\n      console.log(&#39;文件以保存并关闭&#39;)\n    })\n  })\n})</code></pre><ol start=\"2\">\n<li>同步写入方式<br><pre><code>// 引入模块 \nconst fs = require(&#39;fs&#39;);\n</code></pre></li>\n</ol>\n<p>// 打开文件 同步<br>var fd=fs.openSync(‘file.txt’, ‘w’);</p>\n<p>// 写入内容<br>fs.writeFileSync(fd,”node是很有意思的语言!”); </p>\n<p>// 保存并关闭<br>fs.closeSync(fd);</p>\n<pre><code>\n\n### 读写操作&lt;br/&gt;\n\n1. 文件读写操作&lt;br/&gt;\n</code></pre><p>// 引入模块<br>const fs = require(‘fs’);</p>\n<p>/**</p>\n<ul>\n<li>@description</li>\n<li>异步读取文件 fs.readFile</li>\n<li>/<br>fs.readFile(‘source/file.txt’,’utf8’,(err,data)=&gt;{<br>if (err) throw err;<br>console.log(data); //data 默认读取的是二进制 使用toString() 方法转换成<br>})<pre><code></code></pre></li>\n</ul>\n<ol start=\"2\">\n<li>图片读写操作<br></li>\n</ol>\n<pre><code>// 引入模块\nconst fs = require(&#39;fs&#39;);\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n */\nfs.readFile(&quot;source/a.jpg&quot;,(err,data) =&gt; {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile(&#39;b.jpg&#39;, data, (err) =&gt; {\n    if (err) throw err;\n    console.log(&#39;写入成功！&#39;)\n  })\n});</code></pre><ol start=\"3\">\n<li>视频读写操作<br></li>\n</ol>\n<pre><code>// 引入模块\nlet fs= require(&#39;fs&#39;);\n\n/**\n * @description\n * 异步读取文件 fs.readFile\n * 异步写入文件 fs.writeFile\n * 创建文件读取流 fs.createReadStream\n * 创建文件写入流 fs.createWriteStream\n * 创建管道 fileStream.pipe\n * fs.readFile() 函数会缓冲整个文件。 \n * 为了最小化内存成本，尽可能通过 fs.createReadStream() 进行流式传输。\n */\n\n// 方式一\nfs.readFile(&#39;source/a.mp4&#39;, (err, data) =&gt; {\n  if (err) throw err;\n  // 文件写入\n  fs.writeFile(&#39;b.mp4&#39;, data, (err) =&gt; {\n    if (err) throw err;\n    console.log(&#39;写入成功！&#39;);\n  });\n});\n\n// 方式二\nlet rs = fs.createReadStream(&#39;source/a.mp4&#39;);\nlet ws = fs.createWriteStream(&#39;new.mp4&#39;);\nre.pipe(ws);</code></pre><ol start=\"4\">\n<li>使用同步文件流写入操作<br><pre><code>// 引入模块\nlet fs= require(&#39;fs&#39;);\n</code></pre></li>\n</ol>\n<p>// 建立通道<br>let ws = fs.createWriteStream(‘file.txt’)</p>\n<p>// 打开通道<br>ws.once(‘open’, () =&gt; {<br>    console.log(‘通道打开’);<br>})</p>\n<p>ws.once(‘close’, () =&gt; {<br>    console.log(‘通道关闭’);<br>})</p>\n<p>// 写入内容<br>ws.write(‘node开始’);<br>ws.write(‘node1’);<br>ws.write(‘node2’);<br>ws.write(‘node结束’);</p>\n<pre><code>\n&lt;a href=&quot;https://nodejs.org/docs/latest-v9.x/api/fs.html&quot;&gt;其他方法请参考 Node Api &lt;/a&gt;&lt;br/&gt;\n\n</code></pre>"},{"title":"module 模块机制","date":"2019-04-05T11:16:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。前端模块化组件化也是在这几年逐渐的流行，在 web2.0 发展过程如下<br/>\n\n\n<image src=\"/images/module.png\" width=\"300\"></image><br/>\n\n### CommonJS 规范<br/>\n\nCommonJS（<a href=\"http://www.commonjs.org\">http://www.commonjs.org</a>）规范的出现解决了JavaScript 没有模块系统，标准库等等问题，而 Node.js 自身实现了 require 作为其引入模块的方法，同时 NPM 也基于 CommonJS 定义的包规范，实现了依赖管理和模块自动安装等功能。下图展现Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系<br/>\n\n<image src=\"/images/commonjs.png\" width=\"550\"></image><br/>\n\n### CommonJS 模块\n1、模块引用 require 关键字 <br/>\n```\nconst math = require('math'); \n```\n2、模块定义导出 exports 关键字<br/>\n```\nexports.area = function (r) {\n    return Math.PI * r * r;\n};\n\n```\n3、模块标识<br/>\n模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径，每个模块都有独立的空间。防止虑变量污染。<br/>\n\n### Node 模块实现<br/>\n\n1、引入模块三个步骤(分为核心模块和文件模块)<br/>\n```\n(1) 路径分析\n(2) 文件定位\n(3) 编译执行\n```\n核心模块和文件模块的区别在于加载的时机，核心模块在 Node 进程启动时被直接加载到内存中比文件模块省略了文件定位和编译执行过程<br/>\n\n\n### Node 模块载入策略<br/>\n\n1、不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先，以减少二次引入时的开销<br/>\n2、模块引用的过程由于标识符不同在路径分析和文件定位中有一定的差异<br/>\n```\n// 路径分析\n核心模块，如http、fs、path等(加载最快)\n\n.或..开始的相对路径文件模块(慢于核心模块)\n\n以/开始的绝对路径文件模块(慢于核心模块)\n\n自定义模块（最慢-由于沿路径向上逐级递归，直到根目录下的node_modules目录，层级越多越耗时\n\n// 文件定位\n由于其扩展名不同 Node 会按 .js、.json、.node 的次序补、足扩展名，依次尝试\n\n调用fs模块同步阻塞式地判断文件是否存在\n\n如果文件不是 .js 可以在加载的时候写上文件的扩展名，可以加快文件定位速度，\n\n配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷\n```\n3、模块编译\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n} \n\n对于不同的文件扩展名，其载入方法也有所不同\n\n.js 文件\n  通过fs模块同步读取文件后编译执行。在编译过程中进行了头尾包装。在头部添加了\n  (function (exports, require, module, __filename, __dirname) {\n    \\n，在尾部添加了\\n\n  });。\n  通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的\n  function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），\n  以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n\n.node 文件。用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。\n  Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows\n  和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装\n\n.json 文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。\n\n\n其余扩展名文件。它们都被当做.js文件载入。\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。\n```\n\n\n### Node 核心模块的编译、引入、加载过程<br/>\n\n**模块调用栈**<br/>\n\n1、C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。<br/>\n2、JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要<br/>\n\n<image src=\"/images/module-p.png\" width=\"350\"></image><br/>\n\n\n**核心模块调用流程**<br/>\n\n1、 JavaScript 核心模块编译过程<br/>\n  - 转存为转存为C/C++代码（Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，生成node_natives.h头文件，以字符串的形式存储在 node 的命令空间中）<br/>\n  - 启动 node 进程 JavaScript 代码直接加载进内存中<br/>\n  - 编译 JavaScript 核心模块（lib目录下的所有模块文件也没有定义require、module、exports这些变量。上面说过在引入 JavaScript 核心模块过程进行头尾包装，才可以执行exports对象）<br/>\n\n  ```\n  // node_natives.h 头文件代码\n  namespace node {\n    const char node_native[] = { 47, 47, ..};\n    const char dgram_native[] = { 47, 47, ..};\n    const char console_native[] = { 47, 47, ..};\n    const char buffer_native[] = { 47, 47, ..};\n    const char querystring_native[] = { 47, 47, ..};\n    const char punycode_native[] = { 47, 42, ..};\n    ...\n    struct _native {\n      const char* name;\n      const char* source;\n      size_t source_len;\n    };\n    static const struct _native natives[] = {\n      { \"node\", node_native, sizeof(node_native)-1 },\n      { \"dgram\", dgram_native, sizeof(dgram_native)-1 },\n      ...\n    };\n  }\n\n  // JavaScript 核心模块通过process.binding('natives')取出，编译成功的模块缓存到 NativeModule._cache 对象上，文件模块则缓存到 Module._cache 对象上\n  function NativeModule(id) {\n    this.filename = id + '.js';\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n  }\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {}; \n  ```\n\n2、 C/C++核心模块的编译过程<br/>\n   - 定义内建模块内部结构\n   - 通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br/>\n   - node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中<br/>\n   - Node 通过 get_builtin_module() 方法从 node_module_list 数组中取出这些模块<br/>\n  ```\n  // 内建模块的内部结构定义\n  struct node_module_struct {\n    int version;\n    void *dso_handle;\n    const char *filename;\n    void (*register_func) (v8::Handle<v8::Object> target);\n    const char *modname;\n  };\n\n  // 挂载为结构的register_func成员\n  #define NODE_MODULE(modname, regfunc) \n    extern \"C\" { \n      NODE_MODULE_EXPORT node::node_module_struct modname ## _module = \n      { \n        NODE_STANDARD_MODULE_STUFF, \n        regfunc, \n        NODE_STRINGIFY(modname) \n      }; \n    } \n  ```\n\n3、核心模块的引入流程<br/>\n如 os 原生模块的引入流程<br/>\n<image src=\"/images/module-os.png\" width=\"350\"></image><br/>\n\n通过以上我们大致了解了 Node 中模块的编译、加载、引入流程。当然还有核心模块的编写，在这里就不过多的阐述了。更多请参考朴灵老师编著的《深入浅出 node》，相信会有更多的收获。<br/>\n\n","source":"_posts/node/module.md","raw":"---\ntitle:  module 模块机制\ndate: 2019-04-05 19:16:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\n模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。前端模块化组件化也是在这几年逐渐的流行，在 web2.0 发展过程如下<br/>\n\n\n<image src=\"/images/module.png\" width=\"300\"></image><br/>\n\n### CommonJS 规范<br/>\n\nCommonJS（<a href=\"http://www.commonjs.org\">http://www.commonjs.org</a>）规范的出现解决了JavaScript 没有模块系统，标准库等等问题，而 Node.js 自身实现了 require 作为其引入模块的方法，同时 NPM 也基于 CommonJS 定义的包规范，实现了依赖管理和模块自动安装等功能。下图展现Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系<br/>\n\n<image src=\"/images/commonjs.png\" width=\"550\"></image><br/>\n\n### CommonJS 模块\n1、模块引用 require 关键字 <br/>\n```\nconst math = require('math'); \n```\n2、模块定义导出 exports 关键字<br/>\n```\nexports.area = function (r) {\n    return Math.PI * r * r;\n};\n\n```\n3、模块标识<br/>\n模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径，每个模块都有独立的空间。防止虑变量污染。<br/>\n\n### Node 模块实现<br/>\n\n1、引入模块三个步骤(分为核心模块和文件模块)<br/>\n```\n(1) 路径分析\n(2) 文件定位\n(3) 编译执行\n```\n核心模块和文件模块的区别在于加载的时机，核心模块在 Node 进程启动时被直接加载到内存中比文件模块省略了文件定位和编译执行过程<br/>\n\n\n### Node 模块载入策略<br/>\n\n1、不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先，以减少二次引入时的开销<br/>\n2、模块引用的过程由于标识符不同在路径分析和文件定位中有一定的差异<br/>\n```\n// 路径分析\n核心模块，如http、fs、path等(加载最快)\n\n.或..开始的相对路径文件模块(慢于核心模块)\n\n以/开始的绝对路径文件模块(慢于核心模块)\n\n自定义模块（最慢-由于沿路径向上逐级递归，直到根目录下的node_modules目录，层级越多越耗时\n\n// 文件定位\n由于其扩展名不同 Node 会按 .js、.json、.node 的次序补、足扩展名，依次尝试\n\n调用fs模块同步阻塞式地判断文件是否存在\n\n如果文件不是 .js 可以在加载的时候写上文件的扩展名，可以加快文件定位速度，\n\n配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷\n```\n3、模块编译\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n} \n\n对于不同的文件扩展名，其载入方法也有所不同\n\n.js 文件\n  通过fs模块同步读取文件后编译执行。在编译过程中进行了头尾包装。在头部添加了\n  (function (exports, require, module, __filename, __dirname) {\n    \\n，在尾部添加了\\n\n  });。\n  通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的\n  function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），\n  以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n\n.node 文件。用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。\n  Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows\n  和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装\n\n.json 文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。\n\n\n其余扩展名文件。它们都被当做.js文件载入。\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。\n```\n\n\n### Node 核心模块的编译、引入、加载过程<br/>\n\n**模块调用栈**<br/>\n\n1、C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。<br/>\n2、JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要<br/>\n\n<image src=\"/images/module-p.png\" width=\"350\"></image><br/>\n\n\n**核心模块调用流程**<br/>\n\n1、 JavaScript 核心模块编译过程<br/>\n  - 转存为转存为C/C++代码（Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，生成node_natives.h头文件，以字符串的形式存储在 node 的命令空间中）<br/>\n  - 启动 node 进程 JavaScript 代码直接加载进内存中<br/>\n  - 编译 JavaScript 核心模块（lib目录下的所有模块文件也没有定义require、module、exports这些变量。上面说过在引入 JavaScript 核心模块过程进行头尾包装，才可以执行exports对象）<br/>\n\n  ```\n  // node_natives.h 头文件代码\n  namespace node {\n    const char node_native[] = { 47, 47, ..};\n    const char dgram_native[] = { 47, 47, ..};\n    const char console_native[] = { 47, 47, ..};\n    const char buffer_native[] = { 47, 47, ..};\n    const char querystring_native[] = { 47, 47, ..};\n    const char punycode_native[] = { 47, 42, ..};\n    ...\n    struct _native {\n      const char* name;\n      const char* source;\n      size_t source_len;\n    };\n    static const struct _native natives[] = {\n      { \"node\", node_native, sizeof(node_native)-1 },\n      { \"dgram\", dgram_native, sizeof(dgram_native)-1 },\n      ...\n    };\n  }\n\n  // JavaScript 核心模块通过process.binding('natives')取出，编译成功的模块缓存到 NativeModule._cache 对象上，文件模块则缓存到 Module._cache 对象上\n  function NativeModule(id) {\n    this.filename = id + '.js';\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n  }\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {}; \n  ```\n\n2、 C/C++核心模块的编译过程<br/>\n   - 定义内建模块内部结构\n   - 通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br/>\n   - node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中<br/>\n   - Node 通过 get_builtin_module() 方法从 node_module_list 数组中取出这些模块<br/>\n  ```\n  // 内建模块的内部结构定义\n  struct node_module_struct {\n    int version;\n    void *dso_handle;\n    const char *filename;\n    void (*register_func) (v8::Handle<v8::Object> target);\n    const char *modname;\n  };\n\n  // 挂载为结构的register_func成员\n  #define NODE_MODULE(modname, regfunc) \n    extern \"C\" { \n      NODE_MODULE_EXPORT node::node_module_struct modname ## _module = \n      { \n        NODE_STANDARD_MODULE_STUFF, \n        regfunc, \n        NODE_STRINGIFY(modname) \n      }; \n    } \n  ```\n\n3、核心模块的引入流程<br/>\n如 os 原生模块的引入流程<br/>\n<image src=\"/images/module-os.png\" width=\"350\"></image><br/>\n\n通过以上我们大致了解了 Node 中模块的编译、加载、引入流程。当然还有核心模块的编写，在这里就不过多的阐述了。更多请参考朴灵老师编著的《深入浅出 node》，相信会有更多的收获。<br/>\n\n","slug":"node/module","published":1,"updated":"2019-10-15T01:29:42.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osp003jb0u6s5aimczx","content":"<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。前端模块化组件化也是在这几年逐渐的流行，在 web2.0 发展过程如下<br></p>\n<p><image src=\"/images/module.png\" width=\"300\"></image><br></p>\n<h3 id=\"CommonJS-规范\"><a href=\"#CommonJS-规范\" class=\"headerlink\" title=\"CommonJS 规范\"></a>CommonJS 规范<br></h3><p>CommonJS（<a href=\"http://www.commonjs.org\" target=\"_blank\" rel=\"noopener\">http://www.commonjs.org</a>）规范的出现解决了JavaScript 没有模块系统，标准库等等问题，而 Node.js 自身实现了 require 作为其引入模块的方法，同时 NPM 也基于 CommonJS 定义的包规范，实现了依赖管理和模块自动安装等功能。下图展现Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系<br></p>\n<p><image src=\"/images/commonjs.png\" width=\"550\"></image><br></p>\n<h3 id=\"CommonJS-模块\"><a href=\"#CommonJS-模块\" class=\"headerlink\" title=\"CommonJS 模块\"></a>CommonJS 模块</h3><p>1、模块引用 require 关键字 <br></p>\n<pre><code>const math = require(&#39;math&#39;); </code></pre><p>2、模块定义导出 exports 关键字<br></p>\n<pre><code>exports.area = function (r) {\n    return Math.PI * r * r;\n};\n</code></pre><p>3、模块标识<br><br>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径，每个模块都有独立的空间。防止虑变量污染。<br></p>\n<h3 id=\"Node-模块实现\"><a href=\"#Node-模块实现\" class=\"headerlink\" title=\"Node 模块实现\"></a>Node 模块实现<br></h3><p>1、引入模块三个步骤(分为核心模块和文件模块)<br></p>\n<pre><code>(1) 路径分析\n(2) 文件定位\n(3) 编译执行</code></pre><p>核心模块和文件模块的区别在于加载的时机，核心模块在 Node 进程启动时被直接加载到内存中比文件模块省略了文件定位和编译执行过程<br></p>\n<h3 id=\"Node-模块载入策略\"><a href=\"#Node-模块载入策略\" class=\"headerlink\" title=\"Node 模块载入策略\"></a>Node 模块载入策略<br></h3><p>1、不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先，以减少二次引入时的开销<br><br>2、模块引用的过程由于标识符不同在路径分析和文件定位中有一定的差异<br></p>\n<pre><code>// 路径分析\n核心模块，如http、fs、path等(加载最快)\n\n.或..开始的相对路径文件模块(慢于核心模块)\n\n以/开始的绝对路径文件模块(慢于核心模块)\n\n自定义模块（最慢-由于沿路径向上逐级递归，直到根目录下的node_modules目录，层级越多越耗时\n\n// 文件定位\n由于其扩展名不同 Node 会按 .js、.json、.node 的次序补、足扩展名，依次尝试\n\n调用fs模块同步阻塞式地判断文件是否存在\n\n如果文件不是 .js 可以在加载的时候写上文件的扩展名，可以加快文件定位速度，\n\n配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷</code></pre><p>3、模块编译</p>\n<pre><code>function Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent &amp;&amp; parent.children) {\n    parent.children.push(this);\n  }\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n} \n\n对于不同的文件扩展名，其载入方法也有所不同\n\n.js 文件\n  通过fs模块同步读取文件后编译执行。在编译过程中进行了头尾包装。在头部添加了\n  (function (exports, require, module, __filename, __dirname) {\n    \\n，在尾部添加了\\n\n  });。\n  通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的\n  function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），\n  以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n\n.node 文件。用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。\n  Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows\n  和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装\n\n.json 文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。\n\n\n其余扩展名文件。它们都被当做.js文件载入。\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</code></pre><h3 id=\"Node-核心模块的编译、引入、加载过程\"><a href=\"#Node-核心模块的编译、引入、加载过程\" class=\"headerlink\" title=\"Node 核心模块的编译、引入、加载过程\"></a>Node 核心模块的编译、引入、加载过程<br></h3><p><strong>模块调用栈</strong><br></p>\n<p>1、C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。<br><br>2、JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要<br></p>\n<p><image src=\"/images/module-p.png\" width=\"350\"></image><br></p>\n<p><strong>核心模块调用流程</strong><br></p>\n<p>1、 JavaScript 核心模块编译过程<br></p>\n<ul>\n<li><p>转存为转存为C/C++代码（Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，生成node_natives.h头文件，以字符串的形式存储在 node 的命令空间中）<br></p>\n</li>\n<li><p>启动 node 进程 JavaScript 代码直接加载进内存中<br></p>\n</li>\n<li><p>编译 JavaScript 核心模块（lib目录下的所有模块文件也没有定义require、module、exports这些变量。上面说过在引入 JavaScript 核心模块过程进行头尾包装，才可以执行exports对象）<br></p>\n<pre><code>// node_natives.h 头文件代码\nnamespace node {\nconst char node_native[] = { 47, 47, ..};\nconst char dgram_native[] = { 47, 47, ..};\nconst char console_native[] = { 47, 47, ..};\nconst char buffer_native[] = { 47, 47, ..};\nconst char querystring_native[] = { 47, 47, ..};\nconst char punycode_native[] = { 47, 42, ..};\n...\nstruct _native {\n  const char* name;\n  const char* source;\n  size_t source_len;\n};\nstatic const struct _native natives[] = {\n  { &quot;node&quot;, node_native, sizeof(node_native)-1 },\n  { &quot;dgram&quot;, dgram_native, sizeof(dgram_native)-1 },\n  ...\n};\n}\n\n// JavaScript 核心模块通过process.binding(&#39;natives&#39;)取出，编译成功的模块缓存到 NativeModule._cache 对象上，文件模块则缓存到 Module._cache 对象上\nfunction NativeModule(id) {\nthis.filename = id + &#39;.js&#39;;\nthis.id = id;\nthis.exports = {};\nthis.loaded = false;\n}\nNativeModule._source = process.binding(&#39;natives&#39;);\nNativeModule._cache = {}; </code></pre></li>\n</ul>\n<p>2、 C/C++核心模块的编译过程<br></p>\n<ul>\n<li><p>定义内建模块内部结构</p>\n</li>\n<li><p>通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br></p>\n</li>\n<li><p>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中<br></p>\n</li>\n<li><p>Node 通过 get_builtin_module() 方法从 node_module_list 数组中取出这些模块<br></p>\n<pre><code>// 内建模块的内部结构定义\nstruct node_module_struct {\nint version;\nvoid *dso_handle;\nconst char *filename;\nvoid (*register_func) (v8::Handle&lt;v8::Object&gt; target);\nconst char *modname;\n};\n\n// 挂载为结构的register_func成员\n#define NODE_MODULE(modname, regfunc) \nextern &quot;C&quot; { \n NODE_MODULE_EXPORT node::node_module_struct modname ## _module = \n { \n   NODE_STANDARD_MODULE_STUFF, \n   regfunc, \n   NODE_STRINGIFY(modname) \n }; \n} </code></pre></li>\n</ul>\n<p>3、核心模块的引入流程<br><br>如 os 原生模块的引入流程<br><br><image src=\"/images/module-os.png\" width=\"350\"></image><br></p>\n<p>通过以上我们大致了解了 Node 中模块的编译、加载、引入流程。当然还有核心模块的编写，在这里就不过多的阐述了。更多请参考朴灵老师编著的《深入浅出 node》，相信会有更多的收获。<br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。前端模块化组件化也是在这几年逐渐的流行，在 web2.0 发展过程如下<br></p>\n<p><image src=\"/images/module.png\" width=\"300\"></image><br></p>\n<h3 id=\"CommonJS-规范\"><a href=\"#CommonJS-规范\" class=\"headerlink\" title=\"CommonJS 规范\"></a>CommonJS 规范<br></h3><p>CommonJS（<a href=\"http://www.commonjs.org\" target=\"_blank\" rel=\"noopener\">http://www.commonjs.org</a>）规范的出现解决了JavaScript 没有模块系统，标准库等等问题，而 Node.js 自身实现了 require 作为其引入模块的方法，同时 NPM 也基于 CommonJS 定义的包规范，实现了依赖管理和模块自动安装等功能。下图展现Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系<br></p>\n<p><image src=\"/images/commonjs.png\" width=\"550\"></image><br></p>\n<h3 id=\"CommonJS-模块\"><a href=\"#CommonJS-模块\" class=\"headerlink\" title=\"CommonJS 模块\"></a>CommonJS 模块</h3><p>1、模块引用 require 关键字 <br></p>\n<pre><code>const math = require(&#39;math&#39;); </code></pre><p>2、模块定义导出 exports 关键字<br></p>\n<pre><code>exports.area = function (r) {\n    return Math.PI * r * r;\n};\n</code></pre><p>3、模块标识<br><br>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径，每个模块都有独立的空间。防止虑变量污染。<br></p>\n<h3 id=\"Node-模块实现\"><a href=\"#Node-模块实现\" class=\"headerlink\" title=\"Node 模块实现\"></a>Node 模块实现<br></h3><p>1、引入模块三个步骤(分为核心模块和文件模块)<br></p>\n<pre><code>(1) 路径分析\n(2) 文件定位\n(3) 编译执行</code></pre><p>核心模块和文件模块的区别在于加载的时机，核心模块在 Node 进程启动时被直接加载到内存中比文件模块省略了文件定位和编译执行过程<br></p>\n<h3 id=\"Node-模块载入策略\"><a href=\"#Node-模块载入策略\" class=\"headerlink\" title=\"Node 模块载入策略\"></a>Node 模块载入策略<br></h3><p>1、不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先，以减少二次引入时的开销<br><br>2、模块引用的过程由于标识符不同在路径分析和文件定位中有一定的差异<br></p>\n<pre><code>// 路径分析\n核心模块，如http、fs、path等(加载最快)\n\n.或..开始的相对路径文件模块(慢于核心模块)\n\n以/开始的绝对路径文件模块(慢于核心模块)\n\n自定义模块（最慢-由于沿路径向上逐级递归，直到根目录下的node_modules目录，层级越多越耗时\n\n// 文件定位\n由于其扩展名不同 Node 会按 .js、.json、.node 的次序补、足扩展名，依次尝试\n\n调用fs模块同步阻塞式地判断文件是否存在\n\n如果文件不是 .js 可以在加载的时候写上文件的扩展名，可以加快文件定位速度，\n\n配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的缺陷</code></pre><p>3、模块编译</p>\n<pre><code>function Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent &amp;&amp; parent.children) {\n    parent.children.push(this);\n  }\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n} \n\n对于不同的文件扩展名，其载入方法也有所不同\n\n.js 文件\n  通过fs模块同步读取文件后编译执行。在编译过程中进行了头尾包装。在头部添加了\n  (function (exports, require, module, __filename, __dirname) {\n    \\n，在尾部添加了\\n\n  });。\n  通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的\n  function对象。最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），\n  以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n\n.node 文件。用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。\n  Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows\n  和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装\n\n.json 文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。\n\n\n其余扩展名文件。它们都被当做.js文件载入。\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</code></pre><h3 id=\"Node-核心模块的编译、引入、加载过程\"><a href=\"#Node-核心模块的编译、引入、加载过程\" class=\"headerlink\" title=\"Node 核心模块的编译、引入、加载过程\"></a>Node 核心模块的编译、引入、加载过程<br></h3><p><strong>模块调用栈</strong><br></p>\n<p>1、C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。<br><br>2、JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要<br></p>\n<p><image src=\"/images/module-p.png\" width=\"350\"></image><br></p>\n<p><strong>核心模块调用流程</strong><br></p>\n<p>1、 JavaScript 核心模块编译过程<br></p>\n<ul>\n<li><p>转存为转存为C/C++代码（Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，生成node_natives.h头文件，以字符串的形式存储在 node 的命令空间中）<br></p>\n</li>\n<li><p>启动 node 进程 JavaScript 代码直接加载进内存中<br></p>\n</li>\n<li><p>编译 JavaScript 核心模块（lib目录下的所有模块文件也没有定义require、module、exports这些变量。上面说过在引入 JavaScript 核心模块过程进行头尾包装，才可以执行exports对象）<br></p>\n<pre><code>// node_natives.h 头文件代码\nnamespace node {\nconst char node_native[] = { 47, 47, ..};\nconst char dgram_native[] = { 47, 47, ..};\nconst char console_native[] = { 47, 47, ..};\nconst char buffer_native[] = { 47, 47, ..};\nconst char querystring_native[] = { 47, 47, ..};\nconst char punycode_native[] = { 47, 42, ..};\n...\nstruct _native {\n  const char* name;\n  const char* source;\n  size_t source_len;\n};\nstatic const struct _native natives[] = {\n  { &quot;node&quot;, node_native, sizeof(node_native)-1 },\n  { &quot;dgram&quot;, dgram_native, sizeof(dgram_native)-1 },\n  ...\n};\n}\n\n// JavaScript 核心模块通过process.binding(&#39;natives&#39;)取出，编译成功的模块缓存到 NativeModule._cache 对象上，文件模块则缓存到 Module._cache 对象上\nfunction NativeModule(id) {\nthis.filename = id + &#39;.js&#39;;\nthis.id = id;\nthis.exports = {};\nthis.loaded = false;\n}\nNativeModule._source = process.binding(&#39;natives&#39;);\nNativeModule._cache = {}; </code></pre></li>\n</ul>\n<p>2、 C/C++核心模块的编译过程<br></p>\n<ul>\n<li><p>定义内建模块内部结构</p>\n</li>\n<li><p>通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员<br></p>\n</li>\n<li><p>node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中<br></p>\n</li>\n<li><p>Node 通过 get_builtin_module() 方法从 node_module_list 数组中取出这些模块<br></p>\n<pre><code>// 内建模块的内部结构定义\nstruct node_module_struct {\nint version;\nvoid *dso_handle;\nconst char *filename;\nvoid (*register_func) (v8::Handle&lt;v8::Object&gt; target);\nconst char *modname;\n};\n\n// 挂载为结构的register_func成员\n#define NODE_MODULE(modname, regfunc) \nextern &quot;C&quot; { \n NODE_MODULE_EXPORT node::node_module_struct modname ## _module = \n { \n   NODE_STANDARD_MODULE_STUFF, \n   regfunc, \n   NODE_STRINGIFY(modname) \n }; \n} </code></pre></li>\n</ul>\n<p>3、核心模块的引入流程<br><br>如 os 原生模块的引入流程<br><br><image src=\"/images/module-os.png\" width=\"350\"></image><br></p>\n<p>通过以上我们大致了解了 Node 中模块的编译、加载、引入流程。当然还有核心模块的编写，在这里就不过多的阐述了。更多请参考朴灵老师编著的《深入浅出 node》，相信会有更多的收获。<br></p>\n"},{"title":"path 路径操作","date":"2019-04-02T12:16:15.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\npath 模块提供用于处理文件路径和目录路径的实用工具<br/>\n\n### path使用特点\n\npath 模块的默认操作因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， path 模块将假定正在使用 Windows 风格的路径。<br/>\n\n### 获取路径\tpath.dirname(p) <br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出 /demo/js/test.js\nconsole.log(path.dirname('/demo/js/test.js'));\n\n```\n\n### 获取文件名 path.basename(p) <br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n/ 输出：test.js\nconsole.log( path.basename('/demo/js/test.js') );\n\n// 输出：test\nconsole.log( path.basename('/demo/js/test/') );\n\n// 输出：test\nconsole.log( path.basename('/demo/js/test') );\n```\n\n### 获取文件扩展名 path.extname(p) <br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出 .js\nconsole.log(path.extname('/demo/js/test.js'));\n```\n\n### 拼接文件路径 path.join([...paths])<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// /demo/js/test.js\nconsole.log(path.join('/demo', 'js', 'test.js'));\n```\n\n### 获取的绝对路径/文件名 path.reslove([from ...], to)<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove(''));\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove('.'));\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve('/foo/bar', './baz') );\n\n// 输出 /baz/file\nconsole.log(path.resolve('/foo/bar', '/baz/file/');)\n```\n\n### 获取路径字符串的对象 path.parse(p)<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\npath.parse('/home/user/dir/file.txt');\n\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' }\n\n```\n\n### 获取规范化路径 path.normalize(p)<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出 '/foo/bar/baz/asdf'\npath.normalize('/foo/bar//baz/asdf/quux/..');\n```\n\n\n\n<a href=\"https://nodejs.org/docs/latest-v9.x/api/path.html\">其他方法请参考 Node Api </a><br/>\n\n\n","source":"_posts/node/path.md","raw":"---\ntitle: path 路径操作\ndate: 2019-04-2 20:16:15\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\npath 模块提供用于处理文件路径和目录路径的实用工具<br/>\n\n### path使用特点\n\npath 模块的默认操作因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， path 模块将假定正在使用 Windows 风格的路径。<br/>\n\n### 获取路径\tpath.dirname(p) <br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出 /demo/js/test.js\nconsole.log(path.dirname('/demo/js/test.js'));\n\n```\n\n### 获取文件名 path.basename(p) <br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n/ 输出：test.js\nconsole.log( path.basename('/demo/js/test.js') );\n\n// 输出：test\nconsole.log( path.basename('/demo/js/test/') );\n\n// 输出：test\nconsole.log( path.basename('/demo/js/test') );\n```\n\n### 获取文件扩展名 path.extname(p) <br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出 .js\nconsole.log(path.extname('/demo/js/test.js'));\n```\n\n### 拼接文件路径 path.join([...paths])<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// /demo/js/test.js\nconsole.log(path.join('/demo', 'js', 'test.js'));\n```\n\n### 获取的绝对路径/文件名 path.reslove([from ...], to)<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove(''));\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove('.'));\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve('/foo/bar', './baz') );\n\n// 输出 /baz/file\nconsole.log(path.resolve('/foo/bar', '/baz/file/');)\n```\n\n### 获取路径字符串的对象 path.parse(p)<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\npath.parse('/home/user/dir/file.txt');\n\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' }\n\n```\n\n### 获取规范化路径 path.normalize(p)<br/>\n```\n// 引入 path 模块\nconst path = require('path');\n\n// 输出 '/foo/bar/baz/asdf'\npath.normalize('/foo/bar//baz/asdf/quux/..');\n```\n\n\n\n<a href=\"https://nodejs.org/docs/latest-v9.x/api/path.html\">其他方法请参考 Node Api </a><br/>\n\n\n","slug":"node/path","published":1,"updated":"2019-10-15T01:29:42.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osq003kb0u6b24v69dj","content":"<p>path 模块提供用于处理文件路径和目录路径的实用工具<br></p>\n<h3 id=\"path使用特点\"><a href=\"#path使用特点\" class=\"headerlink\" title=\"path使用特点\"></a>path使用特点</h3><p>path 模块的默认操作因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， path 模块将假定正在使用 Windows 风格的路径。<br></p>\n<h3 id=\"获取路径-path-dirname-p\"><a href=\"#获取路径-path-dirname-p\" class=\"headerlink\" title=\"获取路径    path.dirname(p) \"></a>获取路径    path.dirname(p) <br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出 /demo/js/test.js\nconsole.log(path.dirname(&#39;/demo/js/test.js&#39;));\n</code></pre><h3 id=\"获取文件名-path-basename-p\"><a href=\"#获取文件名-path-basename-p\" class=\"headerlink\" title=\"获取文件名 path.basename(p) \"></a>获取文件名 path.basename(p) <br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n/ 输出：test.js\nconsole.log( path.basename(&#39;/demo/js/test.js&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/demo/js/test/&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/demo/js/test&#39;) );</code></pre><h3 id=\"获取文件扩展名-path-extname-p\"><a href=\"#获取文件扩展名-path-extname-p\" class=\"headerlink\" title=\"获取文件扩展名 path.extname(p) \"></a>获取文件扩展名 path.extname(p) <br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出 .js\nconsole.log(path.extname(&#39;/demo/js/test.js&#39;));</code></pre><h3 id=\"拼接文件路径-path-join-…paths\"><a href=\"#拼接文件路径-path-join-…paths\" class=\"headerlink\" title=\"拼接文件路径 path.join([…paths])\"></a>拼接文件路径 path.join([…paths])<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// /demo/js/test.js\nconsole.log(path.join(&#39;/demo&#39;, &#39;js&#39;, &#39;test.js&#39;));</code></pre><h3 id=\"获取的绝对路径-文件名-path-reslove-from-…-to\"><a href=\"#获取的绝对路径-文件名-path-reslove-from-…-to\" class=\"headerlink\" title=\"获取的绝对路径/文件名 path.reslove([from …], to)\"></a>获取的绝对路径/文件名 path.reslove([from …], to)<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove(&#39;&#39;));\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove(&#39;.&#39;));\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;) );\n\n// 输出 /baz/file\nconsole.log(path.resolve(&#39;/foo/bar&#39;, &#39;/baz/file/&#39;);)</code></pre><h3 id=\"获取路径字符串的对象-path-parse-p\"><a href=\"#获取路径字符串的对象-path-parse-p\" class=\"headerlink\" title=\"获取路径字符串的对象 path.parse(p)\"></a>获取路径字符串的对象 path.parse(p)<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\npath.parse(&#39;/home/user/dir/file.txt&#39;);\n\n// 返回:\n// { root: &#39;/&#39;,\n//   dir: &#39;/home/user/dir&#39;,\n//   base: &#39;file.txt&#39;,\n//   ext: &#39;.txt&#39;,\n//   name: &#39;file&#39; }\n</code></pre><h3 id=\"获取规范化路径-path-normalize-p\"><a href=\"#获取规范化路径-path-normalize-p\" class=\"headerlink\" title=\"获取规范化路径 path.normalize(p)\"></a>获取规范化路径 path.normalize(p)<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出 &#39;/foo/bar/baz/asdf&#39;\npath.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;);</code></pre><p><a href=\"https://nodejs.org/docs/latest-v9.x/api/path.html\" target=\"_blank\" rel=\"noopener\">其他方法请参考 Node Api </a><br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>path 模块提供用于处理文件路径和目录路径的实用工具<br></p>\n<h3 id=\"path使用特点\"><a href=\"#path使用特点\" class=\"headerlink\" title=\"path使用特点\"></a>path使用特点</h3><p>path 模块的默认操作因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， path 模块将假定正在使用 Windows 风格的路径。<br></p>\n<h3 id=\"获取路径-path-dirname-p\"><a href=\"#获取路径-path-dirname-p\" class=\"headerlink\" title=\"获取路径    path.dirname(p) \"></a>获取路径    path.dirname(p) <br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出 /demo/js/test.js\nconsole.log(path.dirname(&#39;/demo/js/test.js&#39;));\n</code></pre><h3 id=\"获取文件名-path-basename-p\"><a href=\"#获取文件名-path-basename-p\" class=\"headerlink\" title=\"获取文件名 path.basename(p) \"></a>获取文件名 path.basename(p) <br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n/ 输出：test.js\nconsole.log( path.basename(&#39;/demo/js/test.js&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/demo/js/test/&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/demo/js/test&#39;) );</code></pre><h3 id=\"获取文件扩展名-path-extname-p\"><a href=\"#获取文件扩展名-path-extname-p\" class=\"headerlink\" title=\"获取文件扩展名 path.extname(p) \"></a>获取文件扩展名 path.extname(p) <br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出 .js\nconsole.log(path.extname(&#39;/demo/js/test.js&#39;));</code></pre><h3 id=\"拼接文件路径-path-join-…paths\"><a href=\"#拼接文件路径-path-join-…paths\" class=\"headerlink\" title=\"拼接文件路径 path.join([…paths])\"></a>拼接文件路径 path.join([…paths])<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// /demo/js/test.js\nconsole.log(path.join(&#39;/demo&#39;, &#39;js&#39;, &#39;test.js&#39;));</code></pre><h3 id=\"获取的绝对路径-文件名-path-reslove-from-…-to\"><a href=\"#获取的绝对路径-文件名-path-reslove-from-…-to\" class=\"headerlink\" title=\"获取的绝对路径/文件名 path.reslove([from …], to)\"></a>获取的绝对路径/文件名 path.reslove([from …], to)<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove(&#39;&#39;));\n\n// 输出当前项目的绝对路径\nconsole.log(path.reslove(&#39;.&#39;));\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;) );\n\n// 输出 /baz/file\nconsole.log(path.resolve(&#39;/foo/bar&#39;, &#39;/baz/file/&#39;);)</code></pre><h3 id=\"获取路径字符串的对象-path-parse-p\"><a href=\"#获取路径字符串的对象-path-parse-p\" class=\"headerlink\" title=\"获取路径字符串的对象 path.parse(p)\"></a>获取路径字符串的对象 path.parse(p)<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\npath.parse(&#39;/home/user/dir/file.txt&#39;);\n\n// 返回:\n// { root: &#39;/&#39;,\n//   dir: &#39;/home/user/dir&#39;,\n//   base: &#39;file.txt&#39;,\n//   ext: &#39;.txt&#39;,\n//   name: &#39;file&#39; }\n</code></pre><h3 id=\"获取规范化路径-path-normalize-p\"><a href=\"#获取规范化路径-path-normalize-p\" class=\"headerlink\" title=\"获取规范化路径 path.normalize(p)\"></a>获取规范化路径 path.normalize(p)<br></h3><pre><code>// 引入 path 模块\nconst path = require(&#39;path&#39;);\n\n// 输出 &#39;/foo/bar/baz/asdf&#39;\npath.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;);</code></pre><p><a href=\"https://nodejs.org/docs/latest-v9.x/api/path.html\" target=\"_blank\" rel=\"noopener\">其他方法请参考 Node Api </a><br></p>\n"},{"title":"process进程","date":"2019-04-12T12:35:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\nprocess 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()<br/>\n\n上文中提到过事件队列调度可以通过process的.nextTick()来实现<br/>\n\n上述文章中说到过 Node 是单进程单线程架构，对多核使用不足，所以启动多进程。每个进程一个 CPU 以此实现多核 CPU 的利用<br/>\n\n**Master-Worker模式（主从模式）**\n\n主从模式主要用于在分布式架构中并行处理业务的模式，具备良好的可伸缩性和稳定性，主进程（master）负责和管理工作进程（worker），工作进程（worker）负责具体的业务逻辑<br/>\n\n<img src=\"/images/master-worker.png\"><br/>\n\n```\n/**\n * 创建工作进程\n * worker.js\n */\n\n// 引入核心模块http\nlet http = require('http');\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type' : 'text/plain'});\n  res.end('Hello World !')\n})\n\n// 指定域名\nlet domain = '127.0.0.1';\n\n// 随机创建端口\nlet port = Math.round((1 + Math.random()) * 1000);\n\n// 监听启动服务\nserver.listen(port, domain)\n```\n\n```\n/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require('child_process');\n\n引入核心模块os，得到cpu数量\nlet cpus = require('os').cpus();\n\n// 根据cpu数量取复制对应的 node 的进程数量\nfor (let i = 0; i < cpus.length; i++) {\n  childProcess.fork('./worker.js')\n}\n\n```\n\n\n**进程间通信**<br/>\n\n说起进程通信，其实我们都熟悉浏览器的 Javascript 主线程与 UI 渲染，共用一个线程。两个是互斥关系，当 UI 渲染时Js引擎线程暂时挂起。所以为了解决这个问题 HTML5 提出WebWork API 主线程与工作线程之间通过onmessage()和postMessage()进行通讯，使 JS 阻塞较为严重的计算不影响主线程上的UI渲染<br/>\n\n在 node 中为了实现父子进程通讯，父子之间将会创建IPC通道，通过IPC通道，父子进程才能通过message和send()传递函数<br/>\n\nIPC原理创建实现示意图<br/>\n\n<img src=\"/images/ipc.png\"><br/>\n\n\nIPC通道创建、连接<br/>\n\n1、父进程在实际创建子进程之前，首先创建IPC通道并监听，然后在创建子进程<br/>\n2、通过环境变量（NODE_CHAMMEL_FD）通知子进程 IPC 通道的文件描述符<br/>\n3、子进程启动过程中通过文件描述符连接已经存在的 IPC 通道<br/>\n4、建立连接后就可以在内核中完成双向通信，不经过网络层<br/>\n5、在 Node 中，IPC 被抽象成为 Stream 对象，调用 send（）发送数据，通过 message 事件接收数据<br/>\n\n<img src=\"/images/ipc-create.png\"><br/>\n\n```\n/**\n * 创建父线程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require('child_process');\n\n// 复制进程\nlet n = childProcess.fork(__dirname + '/worker.js');\n\n// 监听message\nn.on('messge', function (m) {\n  console.log(m)\n})\n\n// 发送数据\nn.send({hello: ''world});\n```\n\n```\n/**\n * 创建子线程\n * worker.js\n */\n\n// 监听message\nprocess.on('message', function (m) {\n  console.log(m)\n});\n// 发送数据\nprocess.send({foo: 'bar'});\n```\n\n**句柄传递**<br/>\n\n通过上述我们简单的了解到进程之间通信原理，但是我们想要通过监听一个端口，主进程将所有的请求交由子进程处理，上述通信远远不够的，所以可以通过 **Node句柄传递** 来实现<br/>\n\n主进程将请求发送给工作进程<br/>\n\n<img src=\"/images/process-send.png\"><br/>\n\n主进程发送完句柄并关闭监听<br/>\n\n<img src=\"/images/process-on.png\"><br/>\n\n```\n/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet cp = require('child_process');\n\n// 复制进程\nlet child1 = cp.fork(__dirname + '/worker.js');\nlet child2 = cp.fork(__dirname + '/worker.js');\n\n// 打开服务使用得服务对象发送数据\nlet server = require('net').createServer();\nserver.listen(1337 ,function () {\n  child1.send('server', server);\n  child2.send('server', server);\n  \n  // 主进程发送完成句柄关闭监听\n  server.close();\n});\n```\n\n```\n/**\n * 创建子进程\n * worker.js\n */\n \n// 引入核心模块http\nlet http = require('http');\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type' : 'text/plain'});\n  res.end('pid is' + process.pid)\n});\n\n// 子进程监听端口\nprocess.on('message', function (m, tcp) {\n  if (m === 'server') {\n    tcp.on('connection', function (socket) {\n      server.emit('connection', socket);\n    });\n  }\n}};\n\n```\n\n通过上述几个例子我们基本基本了解 Node 的进程。当然还有很多需要在事件中摸索例如集群的稳定，包括自动重启，负载均衡，状态共享等等。当然创建 Node 集群也可以用cluster模块，实现起来更轻松方便<br/>\n\n\n## 更多方法参考<br/>\n<a href='http://nodejs.cn/api/process.html'>Node Api process</a><br/>\n<a href='http://nodejs.cn/api/child_process.html'>Node Api child_process</a><br/>\n<a href='http://nodejs.cn/api/cluster.html'>Node Api cluster</a><br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/node/process.md","raw":"---\ntitle: process进程 \ndate: 2019-04-12 20:35:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\nprocess 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()<br/>\n\n上文中提到过事件队列调度可以通过process的.nextTick()来实现<br/>\n\n上述文章中说到过 Node 是单进程单线程架构，对多核使用不足，所以启动多进程。每个进程一个 CPU 以此实现多核 CPU 的利用<br/>\n\n**Master-Worker模式（主从模式）**\n\n主从模式主要用于在分布式架构中并行处理业务的模式，具备良好的可伸缩性和稳定性，主进程（master）负责和管理工作进程（worker），工作进程（worker）负责具体的业务逻辑<br/>\n\n<img src=\"/images/master-worker.png\"><br/>\n\n```\n/**\n * 创建工作进程\n * worker.js\n */\n\n// 引入核心模块http\nlet http = require('http');\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type' : 'text/plain'});\n  res.end('Hello World !')\n})\n\n// 指定域名\nlet domain = '127.0.0.1';\n\n// 随机创建端口\nlet port = Math.round((1 + Math.random()) * 1000);\n\n// 监听启动服务\nserver.listen(port, domain)\n```\n\n```\n/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require('child_process');\n\n引入核心模块os，得到cpu数量\nlet cpus = require('os').cpus();\n\n// 根据cpu数量取复制对应的 node 的进程数量\nfor (let i = 0; i < cpus.length; i++) {\n  childProcess.fork('./worker.js')\n}\n\n```\n\n\n**进程间通信**<br/>\n\n说起进程通信，其实我们都熟悉浏览器的 Javascript 主线程与 UI 渲染，共用一个线程。两个是互斥关系，当 UI 渲染时Js引擎线程暂时挂起。所以为了解决这个问题 HTML5 提出WebWork API 主线程与工作线程之间通过onmessage()和postMessage()进行通讯，使 JS 阻塞较为严重的计算不影响主线程上的UI渲染<br/>\n\n在 node 中为了实现父子进程通讯，父子之间将会创建IPC通道，通过IPC通道，父子进程才能通过message和send()传递函数<br/>\n\nIPC原理创建实现示意图<br/>\n\n<img src=\"/images/ipc.png\"><br/>\n\n\nIPC通道创建、连接<br/>\n\n1、父进程在实际创建子进程之前，首先创建IPC通道并监听，然后在创建子进程<br/>\n2、通过环境变量（NODE_CHAMMEL_FD）通知子进程 IPC 通道的文件描述符<br/>\n3、子进程启动过程中通过文件描述符连接已经存在的 IPC 通道<br/>\n4、建立连接后就可以在内核中完成双向通信，不经过网络层<br/>\n5、在 Node 中，IPC 被抽象成为 Stream 对象，调用 send（）发送数据，通过 message 事件接收数据<br/>\n\n<img src=\"/images/ipc-create.png\"><br/>\n\n```\n/**\n * 创建父线程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require('child_process');\n\n// 复制进程\nlet n = childProcess.fork(__dirname + '/worker.js');\n\n// 监听message\nn.on('messge', function (m) {\n  console.log(m)\n})\n\n// 发送数据\nn.send({hello: ''world});\n```\n\n```\n/**\n * 创建子线程\n * worker.js\n */\n\n// 监听message\nprocess.on('message', function (m) {\n  console.log(m)\n});\n// 发送数据\nprocess.send({foo: 'bar'});\n```\n\n**句柄传递**<br/>\n\n通过上述我们简单的了解到进程之间通信原理，但是我们想要通过监听一个端口，主进程将所有的请求交由子进程处理，上述通信远远不够的，所以可以通过 **Node句柄传递** 来实现<br/>\n\n主进程将请求发送给工作进程<br/>\n\n<img src=\"/images/process-send.png\"><br/>\n\n主进程发送完句柄并关闭监听<br/>\n\n<img src=\"/images/process-on.png\"><br/>\n\n```\n/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet cp = require('child_process');\n\n// 复制进程\nlet child1 = cp.fork(__dirname + '/worker.js');\nlet child2 = cp.fork(__dirname + '/worker.js');\n\n// 打开服务使用得服务对象发送数据\nlet server = require('net').createServer();\nserver.listen(1337 ,function () {\n  child1.send('server', server);\n  child2.send('server', server);\n  \n  // 主进程发送完成句柄关闭监听\n  server.close();\n});\n```\n\n```\n/**\n * 创建子进程\n * worker.js\n */\n \n// 引入核心模块http\nlet http = require('http');\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type' : 'text/plain'});\n  res.end('pid is' + process.pid)\n});\n\n// 子进程监听端口\nprocess.on('message', function (m, tcp) {\n  if (m === 'server') {\n    tcp.on('connection', function (socket) {\n      server.emit('connection', socket);\n    });\n  }\n}};\n\n```\n\n通过上述几个例子我们基本基本了解 Node 的进程。当然还有很多需要在事件中摸索例如集群的稳定，包括自动重启，负载均衡，状态共享等等。当然创建 Node 集群也可以用cluster模块，实现起来更轻松方便<br/>\n\n\n## 更多方法参考<br/>\n<a href='http://nodejs.cn/api/process.html'>Node Api process</a><br/>\n<a href='http://nodejs.cn/api/child_process.html'>Node Api child_process</a><br/>\n<a href='http://nodejs.cn/api/cluster.html'>Node Api cluster</a><br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"node/process","published":1,"updated":"2019-10-15T01:29:42.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ost003pb0u67j1ruk40","content":"<p>process 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()<br></p>\n<p>上文中提到过事件队列调度可以通过process的.nextTick()来实现<br></p>\n<p>上述文章中说到过 Node 是单进程单线程架构，对多核使用不足，所以启动多进程。每个进程一个 CPU 以此实现多核 CPU 的利用<br></p>\n<p><strong>Master-Worker模式（主从模式）</strong></p>\n<p>主从模式主要用于在分布式架构中并行处理业务的模式，具备良好的可伸缩性和稳定性，主进程（master）负责和管理工作进程（worker），工作进程（worker）负责具体的业务逻辑<br></p>\n<p><img src=\"/images/master-worker.png\"><br></p>\n<pre><code>/**\n * 创建工作进程\n * worker.js\n */\n\n// 引入核心模块http\nlet http = require(&#39;http&#39;);\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});\n  res.end(&#39;Hello World !&#39;)\n})\n\n// 指定域名\nlet domain = &#39;127.0.0.1&#39;;\n\n// 随机创建端口\nlet port = Math.round((1 + Math.random()) * 1000);\n\n// 监听启动服务\nserver.listen(port, domain)</code></pre><pre><code>/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require(&#39;child_process&#39;);\n\n引入核心模块os，得到cpu数量\nlet cpus = require(&#39;os&#39;).cpus();\n\n// 根据cpu数量取复制对应的 node 的进程数量\nfor (let i = 0; i &lt; cpus.length; i++) {\n  childProcess.fork(&#39;./worker.js&#39;)\n}\n</code></pre><p><strong>进程间通信</strong><br></p>\n<p>说起进程通信，其实我们都熟悉浏览器的 Javascript 主线程与 UI 渲染，共用一个线程。两个是互斥关系，当 UI 渲染时Js引擎线程暂时挂起。所以为了解决这个问题 HTML5 提出WebWork API 主线程与工作线程之间通过onmessage()和postMessage()进行通讯，使 JS 阻塞较为严重的计算不影响主线程上的UI渲染<br></p>\n<p>在 node 中为了实现父子进程通讯，父子之间将会创建IPC通道，通过IPC通道，父子进程才能通过message和send()传递函数<br></p>\n<p>IPC原理创建实现示意图<br></p>\n<p><img src=\"/images/ipc.png\"><br></p>\n<p>IPC通道创建、连接<br></p>\n<p>1、父进程在实际创建子进程之前，首先创建IPC通道并监听，然后在创建子进程<br><br>2、通过环境变量（NODE_CHAMMEL_FD）通知子进程 IPC 通道的文件描述符<br><br>3、子进程启动过程中通过文件描述符连接已经存在的 IPC 通道<br><br>4、建立连接后就可以在内核中完成双向通信，不经过网络层<br><br>5、在 Node 中，IPC 被抽象成为 Stream 对象，调用 send（）发送数据，通过 message 事件接收数据<br></p>\n<p><img src=\"/images/ipc-create.png\"><br></p>\n<pre><code>/**\n * 创建父线程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require(&#39;child_process&#39;);\n\n// 复制进程\nlet n = childProcess.fork(__dirname + &#39;/worker.js&#39;);\n\n// 监听message\nn.on(&#39;messge&#39;, function (m) {\n  console.log(m)\n})\n\n// 发送数据\nn.send({hello: &#39;&#39;world});</code></pre><pre><code>/**\n * 创建子线程\n * worker.js\n */\n\n// 监听message\nprocess.on(&#39;message&#39;, function (m) {\n  console.log(m)\n});\n// 发送数据\nprocess.send({foo: &#39;bar&#39;});</code></pre><p><strong>句柄传递</strong><br></p>\n<p>通过上述我们简单的了解到进程之间通信原理，但是我们想要通过监听一个端口，主进程将所有的请求交由子进程处理，上述通信远远不够的，所以可以通过 <strong>Node句柄传递</strong> 来实现<br></p>\n<p>主进程将请求发送给工作进程<br></p>\n<p><img src=\"/images/process-send.png\"><br></p>\n<p>主进程发送完句柄并关闭监听<br></p>\n<p><img src=\"/images/process-on.png\"><br></p>\n<pre><code>/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet cp = require(&#39;child_process&#39;);\n\n// 复制进程\nlet child1 = cp.fork(__dirname + &#39;/worker.js&#39;);\nlet child2 = cp.fork(__dirname + &#39;/worker.js&#39;);\n\n// 打开服务使用得服务对象发送数据\nlet server = require(&#39;net&#39;).createServer();\nserver.listen(1337 ,function () {\n  child1.send(&#39;server&#39;, server);\n  child2.send(&#39;server&#39;, server);\n\n  // 主进程发送完成句柄关闭监听\n  server.close();\n});</code></pre><pre><code>/**\n * 创建子进程\n * worker.js\n */\n\n// 引入核心模块http\nlet http = require(&#39;http&#39;);\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});\n  res.end(&#39;pid is&#39; + process.pid)\n});\n\n// 子进程监听端口\nprocess.on(&#39;message&#39;, function (m, tcp) {\n  if (m === &#39;server&#39;) {\n    tcp.on(&#39;connection&#39;, function (socket) {\n      server.emit(&#39;connection&#39;, socket);\n    });\n  }\n}};\n</code></pre><p>通过上述几个例子我们基本基本了解 Node 的进程。当然还有很多需要在事件中摸索例如集群的稳定，包括自动重启，负载均衡，状态共享等等。当然创建 Node 集群也可以用cluster模块，实现起来更轻松方便<br></p>\n<h2 id=\"更多方法参考\"><a href=\"#更多方法参考\" class=\"headerlink\" title=\"更多方法参考\"></a>更多方法参考<br></h2><p><a href=\"http://nodejs.cn/api/process.html\" target=\"_blank\" rel=\"noopener\">Node Api process</a><br><br><a href=\"http://nodejs.cn/api/child_process.html\" target=\"_blank\" rel=\"noopener\">Node Api child_process</a><br><br><a href=\"http://nodejs.cn/api/cluster.html\" target=\"_blank\" rel=\"noopener\">Node Api cluster</a><br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>process 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()<br></p>\n<p>上文中提到过事件队列调度可以通过process的.nextTick()来实现<br></p>\n<p>上述文章中说到过 Node 是单进程单线程架构，对多核使用不足，所以启动多进程。每个进程一个 CPU 以此实现多核 CPU 的利用<br></p>\n<p><strong>Master-Worker模式（主从模式）</strong></p>\n<p>主从模式主要用于在分布式架构中并行处理业务的模式，具备良好的可伸缩性和稳定性，主进程（master）负责和管理工作进程（worker），工作进程（worker）负责具体的业务逻辑<br></p>\n<p><img src=\"/images/master-worker.png\"><br></p>\n<pre><code>/**\n * 创建工作进程\n * worker.js\n */\n\n// 引入核心模块http\nlet http = require(&#39;http&#39;);\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});\n  res.end(&#39;Hello World !&#39;)\n})\n\n// 指定域名\nlet domain = &#39;127.0.0.1&#39;;\n\n// 随机创建端口\nlet port = Math.round((1 + Math.random()) * 1000);\n\n// 监听启动服务\nserver.listen(port, domain)</code></pre><pre><code>/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require(&#39;child_process&#39;);\n\n引入核心模块os，得到cpu数量\nlet cpus = require(&#39;os&#39;).cpus();\n\n// 根据cpu数量取复制对应的 node 的进程数量\nfor (let i = 0; i &lt; cpus.length; i++) {\n  childProcess.fork(&#39;./worker.js&#39;)\n}\n</code></pre><p><strong>进程间通信</strong><br></p>\n<p>说起进程通信，其实我们都熟悉浏览器的 Javascript 主线程与 UI 渲染，共用一个线程。两个是互斥关系，当 UI 渲染时Js引擎线程暂时挂起。所以为了解决这个问题 HTML5 提出WebWork API 主线程与工作线程之间通过onmessage()和postMessage()进行通讯，使 JS 阻塞较为严重的计算不影响主线程上的UI渲染<br></p>\n<p>在 node 中为了实现父子进程通讯，父子之间将会创建IPC通道，通过IPC通道，父子进程才能通过message和send()传递函数<br></p>\n<p>IPC原理创建实现示意图<br></p>\n<p><img src=\"/images/ipc.png\"><br></p>\n<p>IPC通道创建、连接<br></p>\n<p>1、父进程在实际创建子进程之前，首先创建IPC通道并监听，然后在创建子进程<br><br>2、通过环境变量（NODE_CHAMMEL_FD）通知子进程 IPC 通道的文件描述符<br><br>3、子进程启动过程中通过文件描述符连接已经存在的 IPC 通道<br><br>4、建立连接后就可以在内核中完成双向通信，不经过网络层<br><br>5、在 Node 中，IPC 被抽象成为 Stream 对象，调用 send（）发送数据，通过 message 事件接收数据<br></p>\n<p><img src=\"/images/ipc-create.png\"><br></p>\n<pre><code>/**\n * 创建父线程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet childProcess = require(&#39;child_process&#39;);\n\n// 复制进程\nlet n = childProcess.fork(__dirname + &#39;/worker.js&#39;);\n\n// 监听message\nn.on(&#39;messge&#39;, function (m) {\n  console.log(m)\n})\n\n// 发送数据\nn.send({hello: &#39;&#39;world});</code></pre><pre><code>/**\n * 创建子线程\n * worker.js\n */\n\n// 监听message\nprocess.on(&#39;message&#39;, function (m) {\n  console.log(m)\n});\n// 发送数据\nprocess.send({foo: &#39;bar&#39;});</code></pre><p><strong>句柄传递</strong><br></p>\n<p>通过上述我们简单的了解到进程之间通信原理，但是我们想要通过监听一个端口，主进程将所有的请求交由子进程处理，上述通信远远不够的，所以可以通过 <strong>Node句柄传递</strong> 来实现<br></p>\n<p>主进程将请求发送给工作进程<br></p>\n<p><img src=\"/images/process-send.png\"><br></p>\n<p>主进程发送完句柄并关闭监听<br></p>\n<p><img src=\"/images/process-on.png\"><br></p>\n<pre><code>/**\n * 创建主进程\n * master.js\n */\n\n// 引入核心模块child_process 创建子进程\nlet cp = require(&#39;child_process&#39;);\n\n// 复制进程\nlet child1 = cp.fork(__dirname + &#39;/worker.js&#39;);\nlet child2 = cp.fork(__dirname + &#39;/worker.js&#39;);\n\n// 打开服务使用得服务对象发送数据\nlet server = require(&#39;net&#39;).createServer();\nserver.listen(1337 ,function () {\n  child1.send(&#39;server&#39;, server);\n  child2.send(&#39;server&#39;, server);\n\n  // 主进程发送完成句柄关闭监听\n  server.close();\n});</code></pre><pre><code>/**\n * 创建子进程\n * worker.js\n */\n\n// 引入核心模块http\nlet http = require(&#39;http&#39;);\n\n// 创建服务\nlet server = http.createServer(function (req, res) {\n  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});\n  res.end(&#39;pid is&#39; + process.pid)\n});\n\n// 子进程监听端口\nprocess.on(&#39;message&#39;, function (m, tcp) {\n  if (m === &#39;server&#39;) {\n    tcp.on(&#39;connection&#39;, function (socket) {\n      server.emit(&#39;connection&#39;, socket);\n    });\n  }\n}};\n</code></pre><p>通过上述几个例子我们基本基本了解 Node 的进程。当然还有很多需要在事件中摸索例如集群的稳定，包括自动重启，负载均衡，状态共享等等。当然创建 Node 集群也可以用cluster模块，实现起来更轻松方便<br></p>\n<h2 id=\"更多方法参考\"><a href=\"#更多方法参考\" class=\"headerlink\" title=\"更多方法参考\"></a>更多方法参考<br></h2><p><a href=\"http://nodejs.cn/api/process.html\" target=\"_blank\" rel=\"noopener\">Node Api process</a><br><br><a href=\"http://nodejs.cn/api/child_process.html\" target=\"_blank\" rel=\"noopener\">Node Api child_process</a><br><br><a href=\"http://nodejs.cn/api/cluster.html\" target=\"_blank\" rel=\"noopener\">Node Api cluster</a><br></p>\n"},{"title":"querystring 路径操作","date":"2019-04-04T14:17:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\nquerystring 模块提供用于解析和格式化 URL 查询字符串<br/>\n\n### 解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) <br/>\n```\n// 引入模块\nconst querystring = require('querystring');\n\nquerystring.parse('foo=bar&abc=xyz&abc=123')\n\n输出为：\n{\n  foo: 'bar',\n  abc: ['xyz', '123']\n}\n```\n\n默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项：<br/>\n\n```\n// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,{ decodeURIComponent: gbkDecodeURIComponent });\n```\n\n\n### 序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) <br/>\n\n```\n// 引入模块\nconst querystring = require('querystring');\n\n// 输出为 'foo=bar&baz=qux&baz=quux&corge='\nquerystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });\n\n// 输出为 'foo:bar;baz:qux'\nquerystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');\n```\n\n默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项：\n\n```\n// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.stringify({ w: '中文', foo: 'bar' }, null, null,{ encodeURIComponent: gbkEncodeURIComponent })\n```\n\n\n\n<a href=\"https://nodejs.org/docs/latest-v9.x/api/querystring.html\">其他方法请参考 Node Api </a><br/>\n\n","source":"_posts/node/querystring.md","raw":"---\ntitle: querystring 路径操作 \ndate: 2019-04-4 22:17:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\nquerystring 模块提供用于解析和格式化 URL 查询字符串<br/>\n\n### 解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) <br/>\n```\n// 引入模块\nconst querystring = require('querystring');\n\nquerystring.parse('foo=bar&abc=xyz&abc=123')\n\n输出为：\n{\n  foo: 'bar',\n  abc: ['xyz', '123']\n}\n```\n\n默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项：<br/>\n\n```\n// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,{ decodeURIComponent: gbkDecodeURIComponent });\n```\n\n\n### 序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) <br/>\n\n```\n// 引入模块\nconst querystring = require('querystring');\n\n// 输出为 'foo=bar&baz=qux&baz=quux&corge='\nquerystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });\n\n// 输出为 'foo:bar;baz:qux'\nquerystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');\n```\n\n默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项：\n\n```\n// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.stringify({ w: '中文', foo: 'bar' }, null, null,{ encodeURIComponent: gbkEncodeURIComponent })\n```\n\n\n\n<a href=\"https://nodejs.org/docs/latest-v9.x/api/querystring.html\">其他方法请参考 Node Api </a><br/>\n\n","slug":"node/querystring","published":1,"updated":"2019-10-15T01:29:42.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osv003qb0u6gb7ca8dc","content":"<p>querystring 模块提供用于解析和格式化 URL 查询字符串<br></p>\n<h3 id=\"解析-URL-字符串-querystring-parse-str-sep-eq-options\"><a href=\"#解析-URL-字符串-querystring-parse-str-sep-eq-options\" class=\"headerlink\" title=\"解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) \"></a>解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) <br></h3><pre><code>// 引入模块\nconst querystring = require(&#39;querystring&#39;);\n\nquerystring.parse(&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;)\n\n输出为：\n{\n  foo: &#39;bar&#39;,\n  abc: [&#39;xyz&#39;, &#39;123&#39;]\n}</code></pre><p>默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项：<br></p>\n<pre><code>// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null,{ decodeURIComponent: gbkDecodeURIComponent });</code></pre><h3 id=\"序列化-URL-字符串-querystring-stringify-obj-sep-eq-options\"><a href=\"#序列化-URL-字符串-querystring-stringify-obj-sep-eq-options\" class=\"headerlink\" title=\"序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) \"></a>序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) <br></h3><pre><code>// 引入模块\nconst querystring = require(&#39;querystring&#39;);\n\n// 输出为 &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;\nquerystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; });\n\n// 输出为 &#39;foo:bar;baz:qux&#39;\nquerystring.stringify({ foo: &#39;bar&#39;, baz: &#39;qux&#39; }, &#39;;&#39;, &#39;:&#39;);</code></pre><p>默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项：</p>\n<pre><code>// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.stringify({ w: &#39;中文&#39;, foo: &#39;bar&#39; }, null, null,{ encodeURIComponent: gbkEncodeURIComponent })</code></pre><p><a href=\"https://nodejs.org/docs/latest-v9.x/api/querystring.html\" target=\"_blank\" rel=\"noopener\">其他方法请参考 Node Api </a><br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>querystring 模块提供用于解析和格式化 URL 查询字符串<br></p>\n<h3 id=\"解析-URL-字符串-querystring-parse-str-sep-eq-options\"><a href=\"#解析-URL-字符串-querystring-parse-str-sep-eq-options\" class=\"headerlink\" title=\"解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) \"></a>解析 URL 字符串 querystring.parse(str[, sep[, eq[, options]]]) <br></h3><pre><code>// 引入模块\nconst querystring = require(&#39;querystring&#39;);\n\nquerystring.parse(&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;)\n\n输出为：\n{\n  foo: &#39;bar&#39;,\n  abc: [&#39;xyz&#39;, &#39;123&#39;]\n}</code></pre><p>默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 decodeURIComponent 选项：<br></p>\n<pre><code>// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null,{ decodeURIComponent: gbkDecodeURIComponent });</code></pre><h3 id=\"序列化-URL-字符串-querystring-stringify-obj-sep-eq-options\"><a href=\"#序列化-URL-字符串-querystring-stringify-obj-sep-eq-options\" class=\"headerlink\" title=\"序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) \"></a>序列化 URL 字符串 querystring.stringify(obj[, sep[, eq[, options]]]) <br></h3><pre><code>// 引入模块\nconst querystring = require(&#39;querystring&#39;);\n\n// 输出为 &#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;\nquerystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; });\n\n// 输出为 &#39;foo:bar;baz:qux&#39;\nquerystring.stringify({ foo: &#39;bar&#39;, baz: &#39;qux&#39; }, &#39;;&#39;, &#39;:&#39;);</code></pre><p>默认情况下，查询字符串中需要百分比编码的字符将编码为 UTF-8。 如果需要其他编码，则需要指定其他 encodeURIComponent 选项：</p>\n<pre><code>// 假设 gbkEncodeURIComponent 函数已存在。\n\nquerystring.stringify({ w: &#39;中文&#39;, foo: &#39;bar&#39; }, null, null,{ encodeURIComponent: gbkEncodeURIComponent })</code></pre><p><a href=\"https://nodejs.org/docs/latest-v9.x/api/querystring.html\" target=\"_blank\" rel=\"noopener\">其他方法请参考 Node Api </a><br></p>\n"},{"title":"url","date":"2019-03-28T15:28:35.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\nurl模块提供用于URL解析和解析的实用程序<br/>\n\n```\nconst url = require('url');\n```\n\n获取并设置URL的片段部分**url.hash**<br/>\n```\nconst myURL = new URL('https://example.org/foo#bar');\nconsole.log(myURL.hash); //#bar\n\nmyURL.hash = 'baz';\nconsole.log(myURL.href); //https://example.org/foo#baz\n```\n\n获取并设置URL的主机部分**url.host**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo');\nconsole.log(myURL.host);  //example.org:81\nconsole.log(myURL.hostname) //example.org\n```\n\n获取并设置序列化url**url.href**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo');\nconsole.log(myURL.href);  //https://example.org:81/foo\n```\n\n获取并设置URL的路径部分**url.pathname**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.pathname);  // /foo/abc\n```\n\n获取并设置URL的端口部分**url.port  0到65535**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.port);  // 81\n```\n\n获取并设置URL的序列化查询部分**url.search**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.search);  // name=123\n```\n\n获取URLSearchParams表示URL的查询参数的对象**url.serchParams**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.searchParams);  // 123\n```\n\n<a href=\"https://nodejs.org/api/url.html\">更多方法请参考 Node Api </a><br/>\n\n\n\n","source":"_posts/node/url.md","raw":"---\ntitle: url \ndate: 2019-03-28 23:28:35\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\nurl模块提供用于URL解析和解析的实用程序<br/>\n\n```\nconst url = require('url');\n```\n\n获取并设置URL的片段部分**url.hash**<br/>\n```\nconst myURL = new URL('https://example.org/foo#bar');\nconsole.log(myURL.hash); //#bar\n\nmyURL.hash = 'baz';\nconsole.log(myURL.href); //https://example.org/foo#baz\n```\n\n获取并设置URL的主机部分**url.host**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo');\nconsole.log(myURL.host);  //example.org:81\nconsole.log(myURL.hostname) //example.org\n```\n\n获取并设置序列化url**url.href**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo');\nconsole.log(myURL.href);  //https://example.org:81/foo\n```\n\n获取并设置URL的路径部分**url.pathname**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.pathname);  // /foo/abc\n```\n\n获取并设置URL的端口部分**url.port  0到65535**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.port);  // 81\n```\n\n获取并设置URL的序列化查询部分**url.search**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.search);  // name=123\n```\n\n获取URLSearchParams表示URL的查询参数的对象**url.serchParams**<br/>\n```\nconst myURL = new URL('https://example.org:81/foo/abc?name=123');\nconsole.log(myURL.searchParams);  // 123\n```\n\n<a href=\"https://nodejs.org/api/url.html\">更多方法请参考 Node Api </a><br/>\n\n\n\n","slug":"node/url","published":1,"updated":"2019-10-15T01:29:42.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8osx003vb0u6o3ty8qzg","content":"<p>url模块提供用于URL解析和解析的实用程序<br></p>\n<pre><code>const url = require(&#39;url&#39;);</code></pre><p>获取并设置URL的片段部分<strong>url.hash</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org/foo#bar&#39;);\nconsole.log(myURL.hash); //#bar\n\nmyURL.hash = &#39;baz&#39;;\nconsole.log(myURL.href); //https://example.org/foo#baz</code></pre><p>获取并设置URL的主机部分<strong>url.host</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo&#39;);\nconsole.log(myURL.host);  //example.org:81\nconsole.log(myURL.hostname) //example.org</code></pre><p>获取并设置序列化url<strong>url.href</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo&#39;);\nconsole.log(myURL.href);  //https://example.org:81/foo</code></pre><p>获取并设置URL的路径部分<strong>url.pathname</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.pathname);  // /foo/abc</code></pre><p>获取并设置URL的端口部分<strong>url.port  0到65535</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.port);  // 81</code></pre><p>获取并设置URL的序列化查询部分<strong>url.search</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.search);  // name=123</code></pre><p>获取URLSearchParams表示URL的查询参数的对象<strong>url.serchParams</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.searchParams);  // 123</code></pre><p><a href=\"https://nodejs.org/api/url.html\" target=\"_blank\" rel=\"noopener\">更多方法请参考 Node Api </a><br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>url模块提供用于URL解析和解析的实用程序<br></p>\n<pre><code>const url = require(&#39;url&#39;);</code></pre><p>获取并设置URL的片段部分<strong>url.hash</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org/foo#bar&#39;);\nconsole.log(myURL.hash); //#bar\n\nmyURL.hash = &#39;baz&#39;;\nconsole.log(myURL.href); //https://example.org/foo#baz</code></pre><p>获取并设置URL的主机部分<strong>url.host</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo&#39;);\nconsole.log(myURL.host);  //example.org:81\nconsole.log(myURL.hostname) //example.org</code></pre><p>获取并设置序列化url<strong>url.href</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo&#39;);\nconsole.log(myURL.href);  //https://example.org:81/foo</code></pre><p>获取并设置URL的路径部分<strong>url.pathname</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.pathname);  // /foo/abc</code></pre><p>获取并设置URL的端口部分<strong>url.port  0到65535</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.port);  // 81</code></pre><p>获取并设置URL的序列化查询部分<strong>url.search</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.search);  // name=123</code></pre><p>获取URLSearchParams表示URL的查询参数的对象<strong>url.serchParams</strong><br></p>\n<pre><code>const myURL = new URL(&#39;https://example.org:81/foo/abc?name=123&#39;);\nconsole.log(myURL.searchParams);  // 123</code></pre><p><a href=\"https://nodejs.org/api/url.html\" target=\"_blank\" rel=\"noopener\">更多方法请参考 Node Api </a><br></p>\n"},{"title":"PHP 常用方法","date":"2017-01-23T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n此篇文章JS数组方法总结一样纯属是为了熟悉API，不得不承认PHP大法好比JS的原生方法多的很。这里只列出个人认为比较常用的。<br/>\n\n**数组内置函数**<br/>\n\n1. for、foreach循环输出数组元素<br/>\n```\n<?php \n  // for循环\n  for ($i = 0; $i <= 100; $i++) {\n    echo \"$i <br/>\";\n  } \n\n  // foreach 只适用于数组\n  $name = array('zhangsan', 'lisi', 'wangwu');  // 创建数组\n  foreach ($name as $value) {\n    echo \"$value <br/>\";\n  }\n?>\n```\n\n2. count() 获取数组元素的个数 <br/>\n```\n<?php\n  $nameLength = array('zhangsan', 'lisi', 'wangwu');\n  echo count($nameLength); // 3\n?>\n```\n\n3. 输出数组当前的元素的值，如果当前元素为空或者无值则返回FALSE <br/>\n``` \n<?php\n  $name = array('zhangsan', 'lisi', 'wangwu');\n\n  echo current($name); // 返回第一个元素zhangsan \n\n  echo end($name); // 返回最后一个元素wangwu\n\n  echo next($name); // 返回指定元素的下一个元素\n\n  echo prev($name); // 返回指定元素的上一个元素\n\n  echo reset($name); // 把内部指针移动到数组的首个元素zhangsan\n\n?>\n```\n\n4. 对当前数组进行排序<br/>\n```\n  $numbers = array(1, 2, 3, 3, 4, 5, 6, 2);\n\n  // 返回bool\n  sort($numbers);  //对数组进行升序成功则为true 失败则为false\n  rsort($numbers); //对数组进行降序成功则为true 失败则为false\n  array_reverse($array, $preserve); //对原数组按反序排序，返回排序后的数组(2, 6, 5, 4, 3, 3, 2, 1)\n```\n\n5. 合并数组<br/>\n```\n$arr = array(1, 2, 3, 3, 4, 5, 6, 2);\n$arr1 = array(10, 20, 30);\n\narray_merge($arr, $arr1 );\n```\n\n6. 压栈，出栈<br/>\n```\n$name = 'wang';\n$name1  = array('zhang', 'li');\n\narray_push($name1, $name); // 3 返回新数组的长度\n\narray_pop($name1); //li 返回被pop的值。栈为空，返回null\n\narray_shift($name1); //删除第一个元素并返回；\n\narray_unshift(array，val1，val2,...); //将参数按照顺序加入队列中\n```\n\n7. 统计数组中值为出现的次数<br/>\n\n```\n$val = array(1, 2, 3, 3, 4, 3, 3, 1, 1);\nprint_r(array_count_values($val));\n```\n\n8. 过滤数组的元素<br/>\n```\nfunction func ($var) {\n  return($var & 1);\n}\n\n$val = array('a', 'b', 2, 3, 4);\nprint_r(array_filter($val, 'func')); // 3\n```\n\n9. 检查索引是否在数组中<br/>\n```\n$people = array('name'=>'renbo', 'age'=>'28');\n\nif (array_key_exists('name', $people)) {\n  echo 'name存在';\n}\n```\n\n10. 检查数组中是否存在指定的值<br/>\n```\n$val = array('zhangsan', 'lisi', 'wangwu');\nif (in_array('zhangsan', $val)) {\n  echo '存在';\n}\n```\n\n11. 返回当前元素的Key<br/>\n```\n$people = array('name'=>'renbo', 'age'=>'28');\nkey($people); //name\n```\n\n12. 返回当前元素所有的key<br/>\n```\n$people = array('name'=>'renbo','age'=>'28');\nprint_r(array_keys($people)); // name age\n```\n\n**时间内置函数**<br/>\n```\ndate(format[,timestamp])\n\nmktime(hour,minute,second,month,day,year) //省略的参数将以本地日期和时间代替\n\ngetdate([timestamp]) \n``` \n\n**URL处理内置函数**<br/>\n```\nurlencode(str) 返回值字符串中所有的非字母和数字字符变成一个百分号(%) 和一个两位的十六进制数，空格被转换成+,-、_和.不做任何转换\n\nurldecode(str) \n```\n\n\n其实还有好多比如字符串的内置函数、文件操作的内置函数、数据库连接的内置函数等等。其实PHP方法还是比JS多用到的时候查看API即可...<br/>\n","source":"_posts/php/method.md","raw":"---\ntitle: PHP 常用方法\ndate: 2017-01-23 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- PHP\ncategories:\n- PHP\n---\n\n此篇文章JS数组方法总结一样纯属是为了熟悉API，不得不承认PHP大法好比JS的原生方法多的很。这里只列出个人认为比较常用的。<br/>\n\n**数组内置函数**<br/>\n\n1. for、foreach循环输出数组元素<br/>\n```\n<?php \n  // for循环\n  for ($i = 0; $i <= 100; $i++) {\n    echo \"$i <br/>\";\n  } \n\n  // foreach 只适用于数组\n  $name = array('zhangsan', 'lisi', 'wangwu');  // 创建数组\n  foreach ($name as $value) {\n    echo \"$value <br/>\";\n  }\n?>\n```\n\n2. count() 获取数组元素的个数 <br/>\n```\n<?php\n  $nameLength = array('zhangsan', 'lisi', 'wangwu');\n  echo count($nameLength); // 3\n?>\n```\n\n3. 输出数组当前的元素的值，如果当前元素为空或者无值则返回FALSE <br/>\n``` \n<?php\n  $name = array('zhangsan', 'lisi', 'wangwu');\n\n  echo current($name); // 返回第一个元素zhangsan \n\n  echo end($name); // 返回最后一个元素wangwu\n\n  echo next($name); // 返回指定元素的下一个元素\n\n  echo prev($name); // 返回指定元素的上一个元素\n\n  echo reset($name); // 把内部指针移动到数组的首个元素zhangsan\n\n?>\n```\n\n4. 对当前数组进行排序<br/>\n```\n  $numbers = array(1, 2, 3, 3, 4, 5, 6, 2);\n\n  // 返回bool\n  sort($numbers);  //对数组进行升序成功则为true 失败则为false\n  rsort($numbers); //对数组进行降序成功则为true 失败则为false\n  array_reverse($array, $preserve); //对原数组按反序排序，返回排序后的数组(2, 6, 5, 4, 3, 3, 2, 1)\n```\n\n5. 合并数组<br/>\n```\n$arr = array(1, 2, 3, 3, 4, 5, 6, 2);\n$arr1 = array(10, 20, 30);\n\narray_merge($arr, $arr1 );\n```\n\n6. 压栈，出栈<br/>\n```\n$name = 'wang';\n$name1  = array('zhang', 'li');\n\narray_push($name1, $name); // 3 返回新数组的长度\n\narray_pop($name1); //li 返回被pop的值。栈为空，返回null\n\narray_shift($name1); //删除第一个元素并返回；\n\narray_unshift(array，val1，val2,...); //将参数按照顺序加入队列中\n```\n\n7. 统计数组中值为出现的次数<br/>\n\n```\n$val = array(1, 2, 3, 3, 4, 3, 3, 1, 1);\nprint_r(array_count_values($val));\n```\n\n8. 过滤数组的元素<br/>\n```\nfunction func ($var) {\n  return($var & 1);\n}\n\n$val = array('a', 'b', 2, 3, 4);\nprint_r(array_filter($val, 'func')); // 3\n```\n\n9. 检查索引是否在数组中<br/>\n```\n$people = array('name'=>'renbo', 'age'=>'28');\n\nif (array_key_exists('name', $people)) {\n  echo 'name存在';\n}\n```\n\n10. 检查数组中是否存在指定的值<br/>\n```\n$val = array('zhangsan', 'lisi', 'wangwu');\nif (in_array('zhangsan', $val)) {\n  echo '存在';\n}\n```\n\n11. 返回当前元素的Key<br/>\n```\n$people = array('name'=>'renbo', 'age'=>'28');\nkey($people); //name\n```\n\n12. 返回当前元素所有的key<br/>\n```\n$people = array('name'=>'renbo','age'=>'28');\nprint_r(array_keys($people)); // name age\n```\n\n**时间内置函数**<br/>\n```\ndate(format[,timestamp])\n\nmktime(hour,minute,second,month,day,year) //省略的参数将以本地日期和时间代替\n\ngetdate([timestamp]) \n``` \n\n**URL处理内置函数**<br/>\n```\nurlencode(str) 返回值字符串中所有的非字母和数字字符变成一个百分号(%) 和一个两位的十六进制数，空格被转换成+,-、_和.不做任何转换\n\nurldecode(str) \n```\n\n\n其实还有好多比如字符串的内置函数、文件操作的内置函数、数据库连接的内置函数等等。其实PHP方法还是比JS多用到的时候查看API即可...<br/>\n","slug":"php/method","published":1,"updated":"2019-10-15T01:29:42.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ot3003wb0u60zu9ql2w","content":"<p>此篇文章JS数组方法总结一样纯属是为了熟悉API，不得不承认PHP大法好比JS的原生方法多的很。这里只列出个人认为比较常用的。<br></p>\n<p><strong>数组内置函数</strong><br></p>\n<ol>\n<li><p>for、foreach循环输出数组元素<br></p>\n<pre><code>&lt;?php \n// for循环\nfor ($i = 0; $i &lt;= 100; $i++) {\n echo &quot;$i &lt;br/&gt;&quot;;\n} \n\n// foreach 只适用于数组\n$name = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);  // 创建数组\nforeach ($name as $value) {\n echo &quot;$value &lt;br/&gt;&quot;;\n}\n?&gt;</code></pre></li>\n<li><p>count() 获取数组元素的个数 <br></p>\n<pre><code>&lt;?php\n$nameLength = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);\necho count($nameLength); // 3\n?&gt;</code></pre></li>\n<li><p>输出数组当前的元素的值，如果当前元素为空或者无值则返回FALSE <br></p>\n<pre><code>&lt;?php\n$name = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);\n\necho current($name); // 返回第一个元素zhangsan \n\necho end($name); // 返回最后一个元素wangwu\n\necho next($name); // 返回指定元素的下一个元素\n\necho prev($name); // 返回指定元素的上一个元素\n\necho reset($name); // 把内部指针移动到数组的首个元素zhangsan\n</code></pre></li>\n</ol>\n<p>?&gt;</p>\n<pre><code>\n4. 对当前数组进行排序&lt;br/&gt;</code></pre><p>  $numbers = array(1, 2, 3, 3, 4, 5, 6, 2);</p>\n<p>  // 返回bool<br>  sort($numbers);  //对数组进行升序成功则为true 失败则为false<br>  rsort($numbers); //对数组进行降序成功则为true 失败则为false<br>  array_reverse($array, $preserve); //对原数组按反序排序，返回排序后的数组(2, 6, 5, 4, 3, 3, 2, 1)</p>\n<pre><code>\n5. 合并数组&lt;br/&gt;</code></pre><p>$arr = array(1, 2, 3, 3, 4, 5, 6, 2);<br>$arr1 = array(10, 20, 30);</p>\n<p>array_merge($arr, $arr1 );</p>\n<pre><code>\n6. 压栈，出栈&lt;br/&gt;</code></pre><p>$name = ‘wang’;<br>$name1  = array(‘zhang’, ‘li’);</p>\n<p>array_push($name1, $name); // 3 返回新数组的长度</p>\n<p>array_pop($name1); //li 返回被pop的值。栈为空，返回null</p>\n<p>array_shift($name1); //删除第一个元素并返回；</p>\n<p>array_unshift(array，val1，val2,…); //将参数按照顺序加入队列中</p>\n<pre><code>\n7. 统计数组中值为出现的次数&lt;br/&gt;\n</code></pre><p>$val = array(1, 2, 3, 3, 4, 3, 3, 1, 1);<br>print_r(array_count_values($val));</p>\n<pre><code>\n8. 过滤数组的元素&lt;br/&gt;</code></pre><p>function func ($var) {<br>  return($var &amp; 1);<br>}</p>\n<p>$val = array(‘a’, ‘b’, 2, 3, 4);<br>print_r(array_filter($val, ‘func’)); // 3</p>\n<pre><code>\n9. 检查索引是否在数组中&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’, ‘age’=&gt;’28’);</p>\n<p>if (array_key_exists(‘name’, $people)) {<br>  echo ‘name存在’;<br>}</p>\n<pre><code>\n10. 检查数组中是否存在指定的值&lt;br/&gt;</code></pre><p>$val = array(‘zhangsan’, ‘lisi’, ‘wangwu’);<br>if (in_array(‘zhangsan’, $val)) {<br>  echo ‘存在’;<br>}</p>\n<pre><code>\n11. 返回当前元素的Key&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’, ‘age’=&gt;’28’);<br>key($people); //name</p>\n<pre><code>\n12. 返回当前元素所有的key&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’,’age’=&gt;’28’);<br>print_r(array_keys($people)); // name age</p>\n<pre><code>\n**时间内置函数**&lt;br/&gt;</code></pre><p>date(format[,timestamp])</p>\n<p>mktime(hour,minute,second,month,day,year) //省略的参数将以本地日期和时间代替</p>\n<p>getdate([timestamp]) </p>\n<pre><code>\n**URL处理内置函数**&lt;br/&gt;</code></pre><p>urlencode(str) 返回值字符串中所有的非字母和数字字符变成一个百分号(%) 和一个两位的十六进制数，空格被转换成+,-、_和.不做任何转换</p>\n<p>urldecode(str) </p>\n<pre><code>\n\n其实还有好多比如字符串的内置函数、文件操作的内置函数、数据库连接的内置函数等等。其实PHP方法还是比JS多用到的时候查看API即可...&lt;br/&gt;</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>此篇文章JS数组方法总结一样纯属是为了熟悉API，不得不承认PHP大法好比JS的原生方法多的很。这里只列出个人认为比较常用的。<br></p>\n<p><strong>数组内置函数</strong><br></p>\n<ol>\n<li><p>for、foreach循环输出数组元素<br></p>\n<pre><code>&lt;?php \n// for循环\nfor ($i = 0; $i &lt;= 100; $i++) {\n echo &quot;$i &lt;br/&gt;&quot;;\n} \n\n// foreach 只适用于数组\n$name = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);  // 创建数组\nforeach ($name as $value) {\n echo &quot;$value &lt;br/&gt;&quot;;\n}\n?&gt;</code></pre></li>\n<li><p>count() 获取数组元素的个数 <br></p>\n<pre><code>&lt;?php\n$nameLength = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);\necho count($nameLength); // 3\n?&gt;</code></pre></li>\n<li><p>输出数组当前的元素的值，如果当前元素为空或者无值则返回FALSE <br></p>\n<pre><code>&lt;?php\n$name = array(&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;);\n\necho current($name); // 返回第一个元素zhangsan \n\necho end($name); // 返回最后一个元素wangwu\n\necho next($name); // 返回指定元素的下一个元素\n\necho prev($name); // 返回指定元素的上一个元素\n\necho reset($name); // 把内部指针移动到数组的首个元素zhangsan\n</code></pre></li>\n</ol>\n<p>?&gt;</p>\n<pre><code>\n4. 对当前数组进行排序&lt;br/&gt;</code></pre><p>  $numbers = array(1, 2, 3, 3, 4, 5, 6, 2);</p>\n<p>  // 返回bool<br>  sort($numbers);  //对数组进行升序成功则为true 失败则为false<br>  rsort($numbers); //对数组进行降序成功则为true 失败则为false<br>  array_reverse($array, $preserve); //对原数组按反序排序，返回排序后的数组(2, 6, 5, 4, 3, 3, 2, 1)</p>\n<pre><code>\n5. 合并数组&lt;br/&gt;</code></pre><p>$arr = array(1, 2, 3, 3, 4, 5, 6, 2);<br>$arr1 = array(10, 20, 30);</p>\n<p>array_merge($arr, $arr1 );</p>\n<pre><code>\n6. 压栈，出栈&lt;br/&gt;</code></pre><p>$name = ‘wang’;<br>$name1  = array(‘zhang’, ‘li’);</p>\n<p>array_push($name1, $name); // 3 返回新数组的长度</p>\n<p>array_pop($name1); //li 返回被pop的值。栈为空，返回null</p>\n<p>array_shift($name1); //删除第一个元素并返回；</p>\n<p>array_unshift(array，val1，val2,…); //将参数按照顺序加入队列中</p>\n<pre><code>\n7. 统计数组中值为出现的次数&lt;br/&gt;\n</code></pre><p>$val = array(1, 2, 3, 3, 4, 3, 3, 1, 1);<br>print_r(array_count_values($val));</p>\n<pre><code>\n8. 过滤数组的元素&lt;br/&gt;</code></pre><p>function func ($var) {<br>  return($var &amp; 1);<br>}</p>\n<p>$val = array(‘a’, ‘b’, 2, 3, 4);<br>print_r(array_filter($val, ‘func’)); // 3</p>\n<pre><code>\n9. 检查索引是否在数组中&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’, ‘age’=&gt;’28’);</p>\n<p>if (array_key_exists(‘name’, $people)) {<br>  echo ‘name存在’;<br>}</p>\n<pre><code>\n10. 检查数组中是否存在指定的值&lt;br/&gt;</code></pre><p>$val = array(‘zhangsan’, ‘lisi’, ‘wangwu’);<br>if (in_array(‘zhangsan’, $val)) {<br>  echo ‘存在’;<br>}</p>\n<pre><code>\n11. 返回当前元素的Key&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’, ‘age’=&gt;’28’);<br>key($people); //name</p>\n<pre><code>\n12. 返回当前元素所有的key&lt;br/&gt;</code></pre><p>$people = array(‘name’=&gt;’renbo’,’age’=&gt;’28’);<br>print_r(array_keys($people)); // name age</p>\n<pre><code>\n**时间内置函数**&lt;br/&gt;</code></pre><p>date(format[,timestamp])</p>\n<p>mktime(hour,minute,second,month,day,year) //省略的参数将以本地日期和时间代替</p>\n<p>getdate([timestamp]) </p>\n<pre><code>\n**URL处理内置函数**&lt;br/&gt;</code></pre><p>urlencode(str) 返回值字符串中所有的非字母和数字字符变成一个百分号(%) 和一个两位的十六进制数，空格被转换成+,-、_和.不做任何转换</p>\n<p>urldecode(str) </p>\n<pre><code>\n\n其实还有好多比如字符串的内置函数、文件操作的内置函数、数据库连接的内置函数等等。其实PHP方法还是比JS多用到的时候查看API即可...&lt;br/&gt;</code></pre>"},{"title":"语法、变量、数据类型","date":"2017-01-23T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## 基础语法\n\n1. PHP 脚本以 `<?php 开始，以 ?> 结束`<br/>\n2. PHP 文件的默认文件扩展名是 \".php\"<br/>\n3. PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码<br/>\n4. PHP 中的每个代码行都必须以分号结束，否则输出错误<br/>\n```\n<!DOCTYPE html> \n<html> \n<body> \n\n<?php \n  echo \"Hello World!\"; \n?> \n\n</body> \n</html>\n```\n\n## 变量\n\n**PHP 变量规则：**<br/>\n1. 变量以 $ 符号开始，后面跟着变量的名称,$a<br/>\n2. 变量名必须以字母或者下划线字符开始<br/>\n3. 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br/>\n4. 变量名不能包含空格<br/>\n5. 变量名是区分大小写的（$y 和 $Y 是两个不同的变量）<br/>\n6. 由于PHP是弱类型语言所以变量不必声明类型和JS类似 <br/>\n\n**PHP 变量作用域**<br/>\n\n**四种不同的变量作用域**<br/>\n```\nlocal 局部\nglobal 全局\nstatic 局部-静态变量\nparameter 参数\n```\n\n**局部和全局作用域 local global**<br/>\n```\n<?php \n  $age = 20; //全局作用域\n  $name = 'zhangsan';\n  function people () {\n    $isJob  = 'yes'; //局部变量\n    global $name;   //访问全局作用域\n    var_dump($name);  // zhangsan \n  }\n  people()\n?>\n```\n解析：<br/>\n1. $age 是在函数外部定义的变量，拥有全局作用域，但是这里和 JS 的区别是 $age 在people函数中是不可访问的<br/>\n2. $isJob 是在函数内部声明的变量所以是局部变量，只能在函数内部访问<br/>\n3. $name global 是在函数内部**调用**函数外部定义的全局变量,正常情况在函数内部访问函数外部的变量则为NULL<br/>\n\n\n**Static 作用域**<br/>\n```\n<?php\n  function test() {\n    static $a = 0;\n    // static $a = 1 + 2; // 解析错误 参照解析2\n    echo $a;\n    $a++;\n  }\n  test (); //0\n  test (); //1\n  test (); //2\n?>\n```\n解析：<br/>\n1. 静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br/>\n2. 不能对静态变量用表达式的结果赋值，否则会导致解析错误<br/>\n3. static全局变量只初使化一次，下一次依据上一次结果值，上例子中调用三次执行的结果是累加的。<br/>\n4. 在内存的静态存储区中（静态存储区在整个程序运行期间都存在，其他局部变量存储在栈中。<br/>\n\n\n**parameter 参数作用域**<br/>\n\n```\n  function test($a) {\n    echo $a;\n  }\n  test (1); //1\n```\n\n**小结**\n\n1. 定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。\n2. 函数内定义的变量就是局部变量，它的作用域为函数定义范围内。\n3. 函数内访问全局变量需要 global 关键字,如果不使用，则会覆盖全局变量\n\n\n## 数据类型\n\n**php数据类型**\n\nString（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br/>\n\n这里由于和 JS 类似所以不多做解释<br/>\n\n\n","source":"_posts/php/base.md","raw":"---\ntitle: 语法、变量、数据类型\ndate: 2017-01-23 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- PHP\ncategories:\n- PHP\n---\n\n## 基础语法\n\n1. PHP 脚本以 `<?php 开始，以 ?> 结束`<br/>\n2. PHP 文件的默认文件扩展名是 \".php\"<br/>\n3. PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码<br/>\n4. PHP 中的每个代码行都必须以分号结束，否则输出错误<br/>\n```\n<!DOCTYPE html> \n<html> \n<body> \n\n<?php \n  echo \"Hello World!\"; \n?> \n\n</body> \n</html>\n```\n\n## 变量\n\n**PHP 变量规则：**<br/>\n1. 变量以 $ 符号开始，后面跟着变量的名称,$a<br/>\n2. 变量名必须以字母或者下划线字符开始<br/>\n3. 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br/>\n4. 变量名不能包含空格<br/>\n5. 变量名是区分大小写的（$y 和 $Y 是两个不同的变量）<br/>\n6. 由于PHP是弱类型语言所以变量不必声明类型和JS类似 <br/>\n\n**PHP 变量作用域**<br/>\n\n**四种不同的变量作用域**<br/>\n```\nlocal 局部\nglobal 全局\nstatic 局部-静态变量\nparameter 参数\n```\n\n**局部和全局作用域 local global**<br/>\n```\n<?php \n  $age = 20; //全局作用域\n  $name = 'zhangsan';\n  function people () {\n    $isJob  = 'yes'; //局部变量\n    global $name;   //访问全局作用域\n    var_dump($name);  // zhangsan \n  }\n  people()\n?>\n```\n解析：<br/>\n1. $age 是在函数外部定义的变量，拥有全局作用域，但是这里和 JS 的区别是 $age 在people函数中是不可访问的<br/>\n2. $isJob 是在函数内部声明的变量所以是局部变量，只能在函数内部访问<br/>\n3. $name global 是在函数内部**调用**函数外部定义的全局变量,正常情况在函数内部访问函数外部的变量则为NULL<br/>\n\n\n**Static 作用域**<br/>\n```\n<?php\n  function test() {\n    static $a = 0;\n    // static $a = 1 + 2; // 解析错误 参照解析2\n    echo $a;\n    $a++;\n  }\n  test (); //0\n  test (); //1\n  test (); //2\n?>\n```\n解析：<br/>\n1. 静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br/>\n2. 不能对静态变量用表达式的结果赋值，否则会导致解析错误<br/>\n3. static全局变量只初使化一次，下一次依据上一次结果值，上例子中调用三次执行的结果是累加的。<br/>\n4. 在内存的静态存储区中（静态存储区在整个程序运行期间都存在，其他局部变量存储在栈中。<br/>\n\n\n**parameter 参数作用域**<br/>\n\n```\n  function test($a) {\n    echo $a;\n  }\n  test (1); //1\n```\n\n**小结**\n\n1. 定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。\n2. 函数内定义的变量就是局部变量，它的作用域为函数定义范围内。\n3. 函数内访问全局变量需要 global 关键字,如果不使用，则会覆盖全局变量\n\n\n## 数据类型\n\n**php数据类型**\n\nString（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br/>\n\n这里由于和 JS 类似所以不多做解释<br/>\n\n\n","slug":"php/base","published":1,"updated":"2019-10-15T01:29:42.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ot60041b0u60mpp1egk","content":"<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><ol>\n<li>PHP 脚本以 <code>&lt;?php 开始，以 ?&gt; 结束</code><br></li>\n<li>PHP 文件的默认文件扩展名是 “.php”<br></li>\n<li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码<br></li>\n<li>PHP 中的每个代码行都必须以分号结束，否则输出错误<br><pre><code>&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;body&gt; \n</code></pre></li>\n</ol>\n<?php \n  echo \"Hello World!\"; \n?><p> </p>\n \n\n```\n\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p><strong>PHP 变量规则：</strong><br></p>\n<ol>\n<li>变量以 $ 符号开始，后面跟着变量的名称,$a<br></li>\n<li>变量名必须以字母或者下划线字符开始<br></li>\n<li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br></li>\n<li>变量名不能包含空格<br></li>\n<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）<br></li>\n<li>由于PHP是弱类型语言所以变量不必声明类型和JS类似 <br></li>\n</ol>\n<p><strong>PHP 变量作用域</strong><br></p>\n<p><strong>四种不同的变量作用域</strong><br></p>\n<pre><code>local 局部\nglobal 全局\nstatic 局部-静态变量\nparameter 参数</code></pre><p><strong>局部和全局作用域 local global</strong><br></p>\n<pre><code>&lt;?php \n  $age = 20; //全局作用域\n  $name = &#39;zhangsan&#39;;\n  function people () {\n    $isJob  = &#39;yes&#39;; //局部变量\n    global $name;   //访问全局作用域\n    var_dump($name);  // zhangsan \n  }\n  people()\n?&gt;</code></pre><p>解析：<br></p>\n<ol>\n<li>$age 是在函数外部定义的变量，拥有全局作用域，但是这里和 JS 的区别是 $age 在people函数中是不可访问的<br></li>\n<li>$isJob 是在函数内部声明的变量所以是局部变量，只能在函数内部访问<br></li>\n<li>$name global 是在函数内部<strong>调用</strong>函数外部定义的全局变量,正常情况在函数内部访问函数外部的变量则为NULL<br></li>\n</ol>\n<p><strong>Static 作用域</strong><br></p>\n<pre><code>&lt;?php\n  function test() {\n    static $a = 0;\n    // static $a = 1 + 2; // 解析错误 参照解析2\n    echo $a;\n    $a++;\n  }\n  test (); //0\n  test (); //1\n  test (); //2\n?&gt;</code></pre><p>解析：<br></p>\n<ol>\n<li>静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br></li>\n<li>不能对静态变量用表达式的结果赋值，否则会导致解析错误<br></li>\n<li>static全局变量只初使化一次，下一次依据上一次结果值，上例子中调用三次执行的结果是累加的。<br></li>\n<li>在内存的静态存储区中（静态存储区在整个程序运行期间都存在，其他局部变量存储在栈中。<br></li>\n</ol>\n<p><strong>parameter 参数作用域</strong><br></p>\n<pre><code>  function test($a) {\n    echo $a;\n  }\n  test (1); //1</code></pre><p><strong>小结</strong></p>\n<ol>\n<li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li>\n<li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li>\n<li>函数内访问全局变量需要 global 关键字,如果不使用，则会覆盖全局变量</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p><strong>php数据类型</strong></p>\n<p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br></p>\n<p>这里由于和 JS 类似所以不多做解释<br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><ol>\n<li>PHP 脚本以 <code>&lt;?php 开始，以 ?&gt; 结束</code><br></li>\n<li>PHP 文件的默认文件扩展名是 “.php”<br></li>\n<li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码<br></li>\n<li>PHP 中的每个代码行都必须以分号结束，否则输出错误<br><pre><code>&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;body&gt; \n</code></pre></li>\n</ol>\n<?php \n  echo \"Hello World!\"; \n?><p> </p>\n \n\n```\n\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p><strong>PHP 变量规则：</strong><br></p>\n<ol>\n<li>变量以 $ 符号开始，后面跟着变量的名称,$a<br></li>\n<li>变量名必须以字母或者下划线字符开始<br></li>\n<li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br></li>\n<li>变量名不能包含空格<br></li>\n<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）<br></li>\n<li>由于PHP是弱类型语言所以变量不必声明类型和JS类似 <br></li>\n</ol>\n<p><strong>PHP 变量作用域</strong><br></p>\n<p><strong>四种不同的变量作用域</strong><br></p>\n<pre><code>local 局部\nglobal 全局\nstatic 局部-静态变量\nparameter 参数</code></pre><p><strong>局部和全局作用域 local global</strong><br></p>\n<pre><code>&lt;?php \n  $age = 20; //全局作用域\n  $name = &#39;zhangsan&#39;;\n  function people () {\n    $isJob  = &#39;yes&#39;; //局部变量\n    global $name;   //访问全局作用域\n    var_dump($name);  // zhangsan \n  }\n  people()\n?&gt;</code></pre><p>解析：<br></p>\n<ol>\n<li>$age 是在函数外部定义的变量，拥有全局作用域，但是这里和 JS 的区别是 $age 在people函数中是不可访问的<br></li>\n<li>$isJob 是在函数内部声明的变量所以是局部变量，只能在函数内部访问<br></li>\n<li>$name global 是在函数内部<strong>调用</strong>函数外部定义的全局变量,正常情况在函数内部访问函数外部的变量则为NULL<br></li>\n</ol>\n<p><strong>Static 作用域</strong><br></p>\n<pre><code>&lt;?php\n  function test() {\n    static $a = 0;\n    // static $a = 1 + 2; // 解析错误 参照解析2\n    echo $a;\n    $a++;\n  }\n  test (); //0\n  test (); //1\n  test (); //2\n?&gt;</code></pre><p>解析：<br></p>\n<ol>\n<li>静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br></li>\n<li>不能对静态变量用表达式的结果赋值，否则会导致解析错误<br></li>\n<li>static全局变量只初使化一次，下一次依据上一次结果值，上例子中调用三次执行的结果是累加的。<br></li>\n<li>在内存的静态存储区中（静态存储区在整个程序运行期间都存在，其他局部变量存储在栈中。<br></li>\n</ol>\n<p><strong>parameter 参数作用域</strong><br></p>\n<pre><code>  function test($a) {\n    echo $a;\n  }\n  test (1); //1</code></pre><p><strong>小结</strong></p>\n<ol>\n<li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li>\n<li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li>\n<li>函数内访问全局变量需要 global 关键字,如果不使用，则会覆盖全局变量</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p><strong>php数据类型</strong></p>\n<p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br></p>\n<p>这里由于和 JS 类似所以不多做解释<br></p>\n"},{"title":"基本数据类型","date":"2019-05-23T14:28:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n每种语言都会有属于自己的数据类型，ts的基本数据类型基本上是继承了js，但也在基础之上增加了几个不一样的类型\n\n### 布尔型 true／false <br/>\n```\n//在js中声明boolean型的方法和ts中的不同之处\nlet flag = true;\nlet flag: boolean = true;\n```\n\n### float,数值型（在js和ts中数字型都是float）<br/>\n```\n//在js中声明number型的方法和ts中的不同之处\nlet age = 26;\nlet age: number = 26;\n```\n\n### 字符型 String <br/> \n```\n//在js中声明number型的方法和ts中的不同之处\nlet name = 'boren';\nlet name: string = 'boren';\n```\n\n### 数组 Array <br/> \n```\n//在js中声明数组的方法和ts中的不同之处\n//1.js中声明数组的两种方式\nlet city = [];\nlet city = new Array();\n//2.ts中声明数组的两种方式\nlet city: string[] = [];\nlet city:Array<string> = []\n//在ts中声明数组必须提前指定其数据类型，如果其数组中的元素其数据类型不相同，声明的方式会在后面介绍\n```\n\n### 元组 Tuple <br/> \n```\n//可以定义数组中元素不相同的数据类型\nlet people = ['boren',26];//js\nlet people:[string,number];\npeople = ['boren',26];//ts\n```\n\n### 枚举 Enum <br/> \n```\n//js中没有此方法，都是以object或者json的形式去实现枚举的特性如：\nlet school = {\n\n     teacherOne : 'Mars',\n     teacherTwo:'yupeng',\n     teacherThree:'luxuesong'\n\n} \nconsole.log(school.teacherOne)//Mars\n\n在ECMA2015，简称es5中Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\nObject.getOwnPropertyDescriptor（school,‘teacherOne’）\n\n// {\n// value: Mars,\n// writable: true,\n// enumerable: true,\n// configurable: true\n// }\n\n其中这么方法打印出来的对象中key enumerable属性，为可枚举性，在js es5中有三个操作会忽略枚举为 false，for...in、 Object...keys()、 JSON.stringify()；在es6中新增一个方法Object.assign()会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。关于更多js中对枚举属性的支持，在这里就不一一介绍，例如toString()和length等等其枚举属性为false\n//ts中枚举类型的用法\nenum classMember = {chenchao,rongbin,chenhua,liurui,luxuesong};\nlet teacher:classMember = classMember.luxuesong\n\n我们也可以给枚举中的成员进行编号等等，以便于更方便的去找到相应的对象元素\n```\n\n### 通用数据类型 Any<br/>\n```\n这种数据类型个人认为是万能的，它可以在你不知道这个变量为什么数据类型的情况下，并且项目比较急的时候标注为Any，它可以通过编译时的类型检查，有人会说那我所有的类型都写Any，如果你非要这么干，也无妨，那就失去了ts这么语言本身的意义所在，可以用这种方法去解决一个上述声明数组类型时很麻烦的问题\nlet lists: any[] = ['boren',26,'body']; \n\nlet age: any = 26;\nlet name: any = 'boren';\n```\n\n### 空值Void <br/>\n```\n在js中我们其实对void不是那么的陌生，它被认为是一个操作符，这个操作符可以计算表达式但不会返回任何值，在js中常常出现的位置就是在a标签的链接中，我们不想让页面刷新，更不想链接到某些位置只是简简单单的a标签，有时候会调用一个简单的函数，仅此而已，那么我们就会\n<a href=\"javascript:void(0)\" onclick=\"people()\">点我</a>\n\n//在ts中，void类型像是与any类型相反，它表示没有任何类型。\nfunction student(): void{\n   console.log('my name is renbo')\n}\n\n在上述函数中没有返回任何值，所以类型为void，其实void的变量没什么用处和null,undefined一样职能作为数据的类型的判断。\n```\n\n### 永不存在值的类型Never<br/>\n```\n官网解释\nnever is the return type for a function expression or an \narrow function expression that always throws an exception or one that \nnever returns;\nVariables also acquire the type never when narrowed by any type guards that can never be true. \nnever类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\n个人觉得没什么太大用这里就不做深究。\n```\n\n### 类型断言 <br/>\n```\n在ts中类型断言这种方式还是比较有用处的，其相当于js中的类型转换。但是只在编译的时候起作用。并不会改变其数据的本身结构。\nlet city: any = \"beijing\";\n\nlet strLength: number = (city as string).length;\n\n另外一种写法：\nlet city: any = \"beijing\";\n\nlet strLength: number = (<string>city).length;\n```\n<hr/>\n总结：通过以上的介绍相信大家对ts的数据类型已经有了大概的了解，其实相对于js,ts的数据类型并没有做什么变更，只是在声明其数据类型的时候必须明确的指定其相应的数据类型，否则代码编译会报错。虽然 ts的文件是xxx.ts 但由于编译过后和js 没有什么大的不同点，能够很好的运行在浏览器端，其中class、public等等函数及模块编译过后的js能后让你更深入的了解js\n\n\n\n\n\n                \n","source":"_posts/typescript/baseDataType.md","raw":"---\ntitle: 基本数据类型\ndate: 2019-05-23 22:28:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n每种语言都会有属于自己的数据类型，ts的基本数据类型基本上是继承了js，但也在基础之上增加了几个不一样的类型\n\n### 布尔型 true／false <br/>\n```\n//在js中声明boolean型的方法和ts中的不同之处\nlet flag = true;\nlet flag: boolean = true;\n```\n\n### float,数值型（在js和ts中数字型都是float）<br/>\n```\n//在js中声明number型的方法和ts中的不同之处\nlet age = 26;\nlet age: number = 26;\n```\n\n### 字符型 String <br/> \n```\n//在js中声明number型的方法和ts中的不同之处\nlet name = 'boren';\nlet name: string = 'boren';\n```\n\n### 数组 Array <br/> \n```\n//在js中声明数组的方法和ts中的不同之处\n//1.js中声明数组的两种方式\nlet city = [];\nlet city = new Array();\n//2.ts中声明数组的两种方式\nlet city: string[] = [];\nlet city:Array<string> = []\n//在ts中声明数组必须提前指定其数据类型，如果其数组中的元素其数据类型不相同，声明的方式会在后面介绍\n```\n\n### 元组 Tuple <br/> \n```\n//可以定义数组中元素不相同的数据类型\nlet people = ['boren',26];//js\nlet people:[string,number];\npeople = ['boren',26];//ts\n```\n\n### 枚举 Enum <br/> \n```\n//js中没有此方法，都是以object或者json的形式去实现枚举的特性如：\nlet school = {\n\n     teacherOne : 'Mars',\n     teacherTwo:'yupeng',\n     teacherThree:'luxuesong'\n\n} \nconsole.log(school.teacherOne)//Mars\n\n在ECMA2015，简称es5中Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\nObject.getOwnPropertyDescriptor（school,‘teacherOne’）\n\n// {\n// value: Mars,\n// writable: true,\n// enumerable: true,\n// configurable: true\n// }\n\n其中这么方法打印出来的对象中key enumerable属性，为可枚举性，在js es5中有三个操作会忽略枚举为 false，for...in、 Object...keys()、 JSON.stringify()；在es6中新增一个方法Object.assign()会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。关于更多js中对枚举属性的支持，在这里就不一一介绍，例如toString()和length等等其枚举属性为false\n//ts中枚举类型的用法\nenum classMember = {chenchao,rongbin,chenhua,liurui,luxuesong};\nlet teacher:classMember = classMember.luxuesong\n\n我们也可以给枚举中的成员进行编号等等，以便于更方便的去找到相应的对象元素\n```\n\n### 通用数据类型 Any<br/>\n```\n这种数据类型个人认为是万能的，它可以在你不知道这个变量为什么数据类型的情况下，并且项目比较急的时候标注为Any，它可以通过编译时的类型检查，有人会说那我所有的类型都写Any，如果你非要这么干，也无妨，那就失去了ts这么语言本身的意义所在，可以用这种方法去解决一个上述声明数组类型时很麻烦的问题\nlet lists: any[] = ['boren',26,'body']; \n\nlet age: any = 26;\nlet name: any = 'boren';\n```\n\n### 空值Void <br/>\n```\n在js中我们其实对void不是那么的陌生，它被认为是一个操作符，这个操作符可以计算表达式但不会返回任何值，在js中常常出现的位置就是在a标签的链接中，我们不想让页面刷新，更不想链接到某些位置只是简简单单的a标签，有时候会调用一个简单的函数，仅此而已，那么我们就会\n<a href=\"javascript:void(0)\" onclick=\"people()\">点我</a>\n\n//在ts中，void类型像是与any类型相反，它表示没有任何类型。\nfunction student(): void{\n   console.log('my name is renbo')\n}\n\n在上述函数中没有返回任何值，所以类型为void，其实void的变量没什么用处和null,undefined一样职能作为数据的类型的判断。\n```\n\n### 永不存在值的类型Never<br/>\n```\n官网解释\nnever is the return type for a function expression or an \narrow function expression that always throws an exception or one that \nnever returns;\nVariables also acquire the type never when narrowed by any type guards that can never be true. \nnever类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\n个人觉得没什么太大用这里就不做深究。\n```\n\n### 类型断言 <br/>\n```\n在ts中类型断言这种方式还是比较有用处的，其相当于js中的类型转换。但是只在编译的时候起作用。并不会改变其数据的本身结构。\nlet city: any = \"beijing\";\n\nlet strLength: number = (city as string).length;\n\n另外一种写法：\nlet city: any = \"beijing\";\n\nlet strLength: number = (<string>city).length;\n```\n<hr/>\n总结：通过以上的介绍相信大家对ts的数据类型已经有了大概的了解，其实相对于js,ts的数据类型并没有做什么变更，只是在声明其数据类型的时候必须明确的指定其相应的数据类型，否则代码编译会报错。虽然 ts的文件是xxx.ts 但由于编译过后和js 没有什么大的不同点，能够很好的运行在浏览器端，其中class、public等等函数及模块编译过后的js能后让你更深入的了解js\n\n\n\n\n\n                \n","slug":"typescript/baseDataType","published":1,"updated":"2019-10-15T01:29:42.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ot80042b0u6k8qvub2h","content":"<p>每种语言都会有属于自己的数据类型，ts的基本数据类型基本上是继承了js，但也在基础之上增加了几个不一样的类型</p>\n<h3 id=\"布尔型-true／false\"><a href=\"#布尔型-true／false\" class=\"headerlink\" title=\"布尔型 true／false \"></a>布尔型 true／false <br></h3><pre><code>//在js中声明boolean型的方法和ts中的不同之处\nlet flag = true;\nlet flag: boolean = true;</code></pre><h3 id=\"float-数值型（在js和ts中数字型都是float）\"><a href=\"#float-数值型（在js和ts中数字型都是float）\" class=\"headerlink\" title=\"float,数值型（在js和ts中数字型都是float）\"></a>float,数值型（在js和ts中数字型都是float）<br></h3><pre><code>//在js中声明number型的方法和ts中的不同之处\nlet age = 26;\nlet age: number = 26;</code></pre><h3 id=\"字符型-String\"><a href=\"#字符型-String\" class=\"headerlink\" title=\"字符型 String \"></a>字符型 String <br></h3><pre><code>//在js中声明number型的方法和ts中的不同之处\nlet name = &#39;boren&#39;;\nlet name: string = &#39;boren&#39;;</code></pre><h3 id=\"数组-Array\"><a href=\"#数组-Array\" class=\"headerlink\" title=\"数组 Array \"></a>数组 Array <br></h3><pre><code>//在js中声明数组的方法和ts中的不同之处\n//1.js中声明数组的两种方式\nlet city = [];\nlet city = new Array();\n//2.ts中声明数组的两种方式\nlet city: string[] = [];\nlet city:Array&lt;string&gt; = []\n//在ts中声明数组必须提前指定其数据类型，如果其数组中的元素其数据类型不相同，声明的方式会在后面介绍</code></pre><h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple \"></a>元组 Tuple <br></h3><pre><code>//可以定义数组中元素不相同的数据类型\nlet people = [&#39;boren&#39;,26];//js\nlet people:[string,number];\npeople = [&#39;boren&#39;,26];//ts</code></pre><h3 id=\"枚举-Enum\"><a href=\"#枚举-Enum\" class=\"headerlink\" title=\"枚举 Enum \"></a>枚举 Enum <br></h3><pre><code>//js中没有此方法，都是以object或者json的形式去实现枚举的特性如：\nlet school = {\n\n     teacherOne : &#39;Mars&#39;,\n     teacherTwo:&#39;yupeng&#39;,\n     teacherThree:&#39;luxuesong&#39;\n\n} \nconsole.log(school.teacherOne)//Mars\n\n在ECMA2015，简称es5中Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\nObject.getOwnPropertyDescriptor（school,‘teacherOne’）\n\n// {\n// value: Mars,\n// writable: true,\n// enumerable: true,\n// configurable: true\n// }\n\n其中这么方法打印出来的对象中key enumerable属性，为可枚举性，在js es5中有三个操作会忽略枚举为 false，for...in、 Object...keys()、 JSON.stringify()；在es6中新增一个方法Object.assign()会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。关于更多js中对枚举属性的支持，在这里就不一一介绍，例如toString()和length等等其枚举属性为false\n//ts中枚举类型的用法\nenum classMember = {chenchao,rongbin,chenhua,liurui,luxuesong};\nlet teacher:classMember = classMember.luxuesong\n\n我们也可以给枚举中的成员进行编号等等，以便于更方便的去找到相应的对象元素</code></pre><h3 id=\"通用数据类型-Any\"><a href=\"#通用数据类型-Any\" class=\"headerlink\" title=\"通用数据类型 Any\"></a>通用数据类型 Any<br></h3><pre><code>这种数据类型个人认为是万能的，它可以在你不知道这个变量为什么数据类型的情况下，并且项目比较急的时候标注为Any，它可以通过编译时的类型检查，有人会说那我所有的类型都写Any，如果你非要这么干，也无妨，那就失去了ts这么语言本身的意义所在，可以用这种方法去解决一个上述声明数组类型时很麻烦的问题\nlet lists: any[] = [&#39;boren&#39;,26,&#39;body&#39;]; \n\nlet age: any = 26;\nlet name: any = &#39;boren&#39;;</code></pre><h3 id=\"空值Void\"><a href=\"#空值Void\" class=\"headerlink\" title=\"空值Void \"></a>空值Void <br></h3><pre><code>在js中我们其实对void不是那么的陌生，它被认为是一个操作符，这个操作符可以计算表达式但不会返回任何值，在js中常常出现的位置就是在a标签的链接中，我们不想让页面刷新，更不想链接到某些位置只是简简单单的a标签，有时候会调用一个简单的函数，仅此而已，那么我们就会\n&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;people()&quot;&gt;点我&lt;/a&gt;\n\n//在ts中，void类型像是与any类型相反，它表示没有任何类型。\nfunction student(): void{\n   console.log(&#39;my name is renbo&#39;)\n}\n\n在上述函数中没有返回任何值，所以类型为void，其实void的变量没什么用处和null,undefined一样职能作为数据的类型的判断。</code></pre><h3 id=\"永不存在值的类型Never\"><a href=\"#永不存在值的类型Never\" class=\"headerlink\" title=\"永不存在值的类型Never\"></a>永不存在值的类型Never<br></h3><pre><code>官网解释\nnever is the return type for a function expression or an \narrow function expression that always throws an exception or one that \nnever returns;\nVariables also acquire the type never when narrowed by any type guards that can never be true. \nnever类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\n个人觉得没什么太大用这里就不做深究。</code></pre><h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言 \"></a>类型断言 <br></h3><pre><code>在ts中类型断言这种方式还是比较有用处的，其相当于js中的类型转换。但是只在编译的时候起作用。并不会改变其数据的本身结构。\nlet city: any = &quot;beijing&quot;;\n\nlet strLength: number = (city as string).length;\n\n另外一种写法：\nlet city: any = &quot;beijing&quot;;\n\nlet strLength: number = (&lt;string&gt;city).length;</code></pre><hr>\n总结：通过以上的介绍相信大家对ts的数据类型已经有了大概的了解，其实相对于js,ts的数据类型并没有做什么变更，只是在声明其数据类型的时候必须明确的指定其相应的数据类型，否则代码编译会报错。虽然 ts的文件是xxx.ts 但由于编译过后和js 没有什么大的不同点，能够很好的运行在浏览器端，其中class、public等等函数及模块编译过后的js能后让你更深入的了解js\n\n\n\n\n\n\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>每种语言都会有属于自己的数据类型，ts的基本数据类型基本上是继承了js，但也在基础之上增加了几个不一样的类型</p>\n<h3 id=\"布尔型-true／false\"><a href=\"#布尔型-true／false\" class=\"headerlink\" title=\"布尔型 true／false \"></a>布尔型 true／false <br></h3><pre><code>//在js中声明boolean型的方法和ts中的不同之处\nlet flag = true;\nlet flag: boolean = true;</code></pre><h3 id=\"float-数值型（在js和ts中数字型都是float）\"><a href=\"#float-数值型（在js和ts中数字型都是float）\" class=\"headerlink\" title=\"float,数值型（在js和ts中数字型都是float）\"></a>float,数值型（在js和ts中数字型都是float）<br></h3><pre><code>//在js中声明number型的方法和ts中的不同之处\nlet age = 26;\nlet age: number = 26;</code></pre><h3 id=\"字符型-String\"><a href=\"#字符型-String\" class=\"headerlink\" title=\"字符型 String \"></a>字符型 String <br></h3><pre><code>//在js中声明number型的方法和ts中的不同之处\nlet name = &#39;boren&#39;;\nlet name: string = &#39;boren&#39;;</code></pre><h3 id=\"数组-Array\"><a href=\"#数组-Array\" class=\"headerlink\" title=\"数组 Array \"></a>数组 Array <br></h3><pre><code>//在js中声明数组的方法和ts中的不同之处\n//1.js中声明数组的两种方式\nlet city = [];\nlet city = new Array();\n//2.ts中声明数组的两种方式\nlet city: string[] = [];\nlet city:Array&lt;string&gt; = []\n//在ts中声明数组必须提前指定其数据类型，如果其数组中的元素其数据类型不相同，声明的方式会在后面介绍</code></pre><h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple \"></a>元组 Tuple <br></h3><pre><code>//可以定义数组中元素不相同的数据类型\nlet people = [&#39;boren&#39;,26];//js\nlet people:[string,number];\npeople = [&#39;boren&#39;,26];//ts</code></pre><h3 id=\"枚举-Enum\"><a href=\"#枚举-Enum\" class=\"headerlink\" title=\"枚举 Enum \"></a>枚举 Enum <br></h3><pre><code>//js中没有此方法，都是以object或者json的形式去实现枚举的特性如：\nlet school = {\n\n     teacherOne : &#39;Mars&#39;,\n     teacherTwo:&#39;yupeng&#39;,\n     teacherThree:&#39;luxuesong&#39;\n\n} \nconsole.log(school.teacherOne)//Mars\n\n在ECMA2015，简称es5中Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\nObject.getOwnPropertyDescriptor（school,‘teacherOne’）\n\n// {\n// value: Mars,\n// writable: true,\n// enumerable: true,\n// configurable: true\n// }\n\n其中这么方法打印出来的对象中key enumerable属性，为可枚举性，在js es5中有三个操作会忽略枚举为 false，for...in、 Object...keys()、 JSON.stringify()；在es6中新增一个方法Object.assign()会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。关于更多js中对枚举属性的支持，在这里就不一一介绍，例如toString()和length等等其枚举属性为false\n//ts中枚举类型的用法\nenum classMember = {chenchao,rongbin,chenhua,liurui,luxuesong};\nlet teacher:classMember = classMember.luxuesong\n\n我们也可以给枚举中的成员进行编号等等，以便于更方便的去找到相应的对象元素</code></pre><h3 id=\"通用数据类型-Any\"><a href=\"#通用数据类型-Any\" class=\"headerlink\" title=\"通用数据类型 Any\"></a>通用数据类型 Any<br></h3><pre><code>这种数据类型个人认为是万能的，它可以在你不知道这个变量为什么数据类型的情况下，并且项目比较急的时候标注为Any，它可以通过编译时的类型检查，有人会说那我所有的类型都写Any，如果你非要这么干，也无妨，那就失去了ts这么语言本身的意义所在，可以用这种方法去解决一个上述声明数组类型时很麻烦的问题\nlet lists: any[] = [&#39;boren&#39;,26,&#39;body&#39;]; \n\nlet age: any = 26;\nlet name: any = &#39;boren&#39;;</code></pre><h3 id=\"空值Void\"><a href=\"#空值Void\" class=\"headerlink\" title=\"空值Void \"></a>空值Void <br></h3><pre><code>在js中我们其实对void不是那么的陌生，它被认为是一个操作符，这个操作符可以计算表达式但不会返回任何值，在js中常常出现的位置就是在a标签的链接中，我们不想让页面刷新，更不想链接到某些位置只是简简单单的a标签，有时候会调用一个简单的函数，仅此而已，那么我们就会\n&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;people()&quot;&gt;点我&lt;/a&gt;\n\n//在ts中，void类型像是与any类型相反，它表示没有任何类型。\nfunction student(): void{\n   console.log(&#39;my name is renbo&#39;)\n}\n\n在上述函数中没有返回任何值，所以类型为void，其实void的变量没什么用处和null,undefined一样职能作为数据的类型的判断。</code></pre><h3 id=\"永不存在值的类型Never\"><a href=\"#永不存在值的类型Never\" class=\"headerlink\" title=\"永不存在值的类型Never\"></a>永不存在值的类型Never<br></h3><pre><code>官网解释\nnever is the return type for a function expression or an \narrow function expression that always throws an exception or one that \nnever returns;\nVariables also acquire the type never when narrowed by any type guards that can never be true. \nnever类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\n个人觉得没什么太大用这里就不做深究。</code></pre><h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言 \"></a>类型断言 <br></h3><pre><code>在ts中类型断言这种方式还是比较有用处的，其相当于js中的类型转换。但是只在编译的时候起作用。并不会改变其数据的本身结构。\nlet city: any = &quot;beijing&quot;;\n\nlet strLength: number = (city as string).length;\n\n另外一种写法：\nlet city: any = &quot;beijing&quot;;\n\nlet strLength: number = (&lt;string&gt;city).length;</code></pre><hr>\n总结：通过以上的介绍相信大家对ts的数据类型已经有了大概的了解，其实相对于js,ts的数据类型并没有做什么变更，只是在声明其数据类型的时候必须明确的指定其相应的数据类型，否则代码编译会报错。虽然 ts的文件是xxx.ts 但由于编译过后和js 没有什么大的不同点，能够很好的运行在浏览器端，其中class、public等等函数及模块编译过后的js能后让你更深入的了解js\n\n\n\n\n\n\n"},{"title":"类","date":"2019-05-17T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## TS基础系列之-类\n\n在JavaScript 通过构造函数和原型链来实现类和继承。而在 ES6 中，也用语法糖实现了class，下面介绍一下在 ts 中的类。\n\n### 类的概念 <br/><hr/>\n\n类是面向对象程序设计中的概念，是面向对象编程的基础，由于是一种数据类型，而不是数据，所以不存在于内存中。\n\n- 类(Class)：定义了一件事物的抽象特点，包含它的属性和方法\n- 对象（Object）：类的实例，通过 new 生成，类是概念，对象是实体\n- 面向对象（OOP）的三大特性：封装、继承、多态\n- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。\n- 存取器（getter & setter）：用以改变属性的读取和赋值行为\n- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\n### ES6中类的用法 <br/><hr/>\n\n1. **定义属性和方法**\n    ```\n    // 定义类\n    class Parent{\n      // 定义构造函数\n      constructor(name='wang',age='27'){\n        // 定义属性\n        this.name = name;\n        this.age = age;\n      }\n      // 定义方法\n      eat(){\n        console.log(`${this.name} ${this.age} eat food`)\n      }\n    }\n\n    ```\n2. **利用关键字extends 和 super 继承**\n    ```\n    class Child extends Parent{ \n        constructor(name = 'ren',age = '27'){ \n          //继承父类属性\n          super(name, age); \n        } \n          eat(){ \n          //继承父类方法\n            super.eat() \n          } \n      } \n      let child =new Child('xiaoxiami'); \n      child.eat();\n    ```\n3. **存储器getter,setter改变属性和读取**\n\n    ```\n    class People{\n      // 定义构造函数\n      constructor(name){\n        // 定义属性\n        this.name = name;\n      }\n      get name () {\n        return 'renbo';\n      }\n      set name (value) {\n        console.log('setter: ' + value);\n      }\n      // 定义方法\n      eat(){\n        console.log(`${this.name}  eat food`)\n      }\n    }\n    let people = new People('lisi'); // setter: lisi\n    people.name = 'zhangsan'; // setter: zhangsan\n    console.log(people.name); // renbo\n    ```\n4. **静态方法使用static修饰符（由于分配在静态内存空间中，所以不需要实例化，只需要吊影即可）**\n    ```\n    class People{\n      // 定义静态方法\n      static eat(name){\n        console.log(`${name} eat food`)\n      }\n    }\n    console.log(People.eat('renbo')) // renbo eat food\n    ```\n\n### ES7中类的用法 <br/><hr/>\n\n1. **定义属性可以直接在类中定义**\n  ```\n    class People{\n      name = 'zhangsan'\n      constructor () {\n        // \n      }\n    }\n    let people = new People();\n    console.log(npeople.name) // zhangsan\n  ```\n\n2. **定义静态属性**\n```\n  class People{\n   static  name = 'zhangsan'\n    constructor () {\n      // \n    }\n  }\n  console.log(People.name) // zhangsan\n```\n\n### TypeScript 中类的用法 <br/><hr/>\n\n1. **说起 ts 中的类不得不说访问修饰符 public private protected**\n\n- public 说明属性或方法是公有的，在任何地方被访问到，在 ts 中方法和属性默认的是 public\n- private 说明属性或方法是私有的，不能在类的外部访问\n- protected 说明属性或方法是受保护的，和 private 类似，但是 protected 也可以在子类中访问\n\n**public 修饰符**\n\n```\nclass People {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People('renbo');\nconsole.log(people.name); // renbo\n```\n\n**private 修饰符**\n\n```\nclass People {\n  private  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People('renbo');\nconsole.log(people.name); // Property 'name' is private and only accessible within class 'People'.\n\n// 在子类中也不允许访问，只是私有\nclass People {\n  private  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name); // Property 'name' is private and only accessible within class 'People'.\n  }\n}\n```\n\n**protected 修饰符**\n\n```\nclass People {\n  protected  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People('renbo');\nconsole.log(people.name); // Property 'name' is protected and only accessible within class 'People' and its subclasses.ts\n```\n\n**protected 修饰符(子类访问)**\n\n```\nclass People {\n  protected  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name)\n  }\n}\n\nlet people  = new People ('zhangsna')\nlet smilePeople = new SmilePeople('wangwu'); // wangwu\n\n```\n\n2. **抽象类（ abstract 用于定义抽象类以及抽象类中的抽象方法）**\n\n- 抽象类可以作为派生其他类的基类\n- 抽象类中的抽象方法必须被子类实现\n- 抽象类无法直接实例化\n- 与接口不同，抽象类可以包含其成员的实现细节\n\n``` \n// 上述1，2\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat():string\n}\n// 派生类\nclass SmilePeople extends People {\n  static food: string = 'apple'\n  // eat 方法必须在子类中实现\n  public eat ():string {\n    return `my name is ${this.name} I,m eating ${SmilePeople.food}`\n  }\n}\n\nlet smilePeople = new SmilePeople('zhangsan');\nsmilePeople.eat()\n\n// 无法直接实例化\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat ():void\n}\n\nlet people = new People('zhangsan') // Cannot create an instance of an abstract class.\n\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/typescript/class.md","raw":"---\ntitle: 类\ndate: 2019-05-17 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n## TS基础系列之-类\n\n在JavaScript 通过构造函数和原型链来实现类和继承。而在 ES6 中，也用语法糖实现了class，下面介绍一下在 ts 中的类。\n\n### 类的概念 <br/><hr/>\n\n类是面向对象程序设计中的概念，是面向对象编程的基础，由于是一种数据类型，而不是数据，所以不存在于内存中。\n\n- 类(Class)：定义了一件事物的抽象特点，包含它的属性和方法\n- 对象（Object）：类的实例，通过 new 生成，类是概念，对象是实体\n- 面向对象（OOP）的三大特性：封装、继承、多态\n- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。\n- 存取器（getter & setter）：用以改变属性的读取和赋值行为\n- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\n### ES6中类的用法 <br/><hr/>\n\n1. **定义属性和方法**\n    ```\n    // 定义类\n    class Parent{\n      // 定义构造函数\n      constructor(name='wang',age='27'){\n        // 定义属性\n        this.name = name;\n        this.age = age;\n      }\n      // 定义方法\n      eat(){\n        console.log(`${this.name} ${this.age} eat food`)\n      }\n    }\n\n    ```\n2. **利用关键字extends 和 super 继承**\n    ```\n    class Child extends Parent{ \n        constructor(name = 'ren',age = '27'){ \n          //继承父类属性\n          super(name, age); \n        } \n          eat(){ \n          //继承父类方法\n            super.eat() \n          } \n      } \n      let child =new Child('xiaoxiami'); \n      child.eat();\n    ```\n3. **存储器getter,setter改变属性和读取**\n\n    ```\n    class People{\n      // 定义构造函数\n      constructor(name){\n        // 定义属性\n        this.name = name;\n      }\n      get name () {\n        return 'renbo';\n      }\n      set name (value) {\n        console.log('setter: ' + value);\n      }\n      // 定义方法\n      eat(){\n        console.log(`${this.name}  eat food`)\n      }\n    }\n    let people = new People('lisi'); // setter: lisi\n    people.name = 'zhangsan'; // setter: zhangsan\n    console.log(people.name); // renbo\n    ```\n4. **静态方法使用static修饰符（由于分配在静态内存空间中，所以不需要实例化，只需要吊影即可）**\n    ```\n    class People{\n      // 定义静态方法\n      static eat(name){\n        console.log(`${name} eat food`)\n      }\n    }\n    console.log(People.eat('renbo')) // renbo eat food\n    ```\n\n### ES7中类的用法 <br/><hr/>\n\n1. **定义属性可以直接在类中定义**\n  ```\n    class People{\n      name = 'zhangsan'\n      constructor () {\n        // \n      }\n    }\n    let people = new People();\n    console.log(npeople.name) // zhangsan\n  ```\n\n2. **定义静态属性**\n```\n  class People{\n   static  name = 'zhangsan'\n    constructor () {\n      // \n    }\n  }\n  console.log(People.name) // zhangsan\n```\n\n### TypeScript 中类的用法 <br/><hr/>\n\n1. **说起 ts 中的类不得不说访问修饰符 public private protected**\n\n- public 说明属性或方法是公有的，在任何地方被访问到，在 ts 中方法和属性默认的是 public\n- private 说明属性或方法是私有的，不能在类的外部访问\n- protected 说明属性或方法是受保护的，和 private 类似，但是 protected 也可以在子类中访问\n\n**public 修饰符**\n\n```\nclass People {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People('renbo');\nconsole.log(people.name); // renbo\n```\n\n**private 修饰符**\n\n```\nclass People {\n  private  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People('renbo');\nconsole.log(people.name); // Property 'name' is private and only accessible within class 'People'.\n\n// 在子类中也不允许访问，只是私有\nclass People {\n  private  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name); // Property 'name' is private and only accessible within class 'People'.\n  }\n}\n```\n\n**protected 修饰符**\n\n```\nclass People {\n  protected  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People('renbo');\nconsole.log(people.name); // Property 'name' is protected and only accessible within class 'People' and its subclasses.ts\n```\n\n**protected 修饰符(子类访问)**\n\n```\nclass People {\n  protected  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name)\n  }\n}\n\nlet people  = new People ('zhangsna')\nlet smilePeople = new SmilePeople('wangwu'); // wangwu\n\n```\n\n2. **抽象类（ abstract 用于定义抽象类以及抽象类中的抽象方法）**\n\n- 抽象类可以作为派生其他类的基类\n- 抽象类中的抽象方法必须被子类实现\n- 抽象类无法直接实例化\n- 与接口不同，抽象类可以包含其成员的实现细节\n\n``` \n// 上述1，2\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat():string\n}\n// 派生类\nclass SmilePeople extends People {\n  static food: string = 'apple'\n  // eat 方法必须在子类中实现\n  public eat ():string {\n    return `my name is ${this.name} I,m eating ${SmilePeople.food}`\n  }\n}\n\nlet smilePeople = new SmilePeople('zhangsan');\nsmilePeople.eat()\n\n// 无法直接实例化\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat ():void\n}\n\nlet people = new People('zhangsan') // Cannot create an instance of an abstract class.\n\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"typescript/class","published":1,"updated":"2019-10-15T01:29:42.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otc0047b0u6hascztsz","content":"<h2 id=\"TS基础系列之-类\"><a href=\"#TS基础系列之-类\" class=\"headerlink\" title=\"TS基础系列之-类\"></a>TS基础系列之-类</h2><p>在JavaScript 通过构造函数和原型链来实现类和继承。而在 ES6 中，也用语法糖实现了class，下面介绍一下在 ts 中的类。</p>\n<h3 id=\"类的概念\"><a href=\"#类的概念\" class=\"headerlink\" title=\"类的概念 \"></a>类的概念 <br><hr></h3><p>类是面向对象程序设计中的概念，是面向对象编程的基础，由于是一种数据类型，而不是数据，所以不存在于内存中。</p>\n<ul>\n<li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li>\n<li>对象（Object）：类的实例，通过 new 生成，类是概念，对象是实体</li>\n<li>面向对象（OOP）的三大特性：封装、继承、多态</li>\n<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>\n<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。</li>\n<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>\n<li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</li>\n<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li>\n</ul>\n<h3 id=\"ES6中类的用法\"><a href=\"#ES6中类的用法\" class=\"headerlink\" title=\"ES6中类的用法 \"></a>ES6中类的用法 <br><hr></h3><ol>\n<li><p><strong>定义属性和方法</strong></p>\n<pre><code> // 定义类\n class Parent{\n   // 定义构造函数\n   constructor(name=&#39;wang&#39;,age=&#39;27&#39;){\n     // 定义属性\n     this.name = name;\n     this.age = age;\n   }\n   // 定义方法\n   eat(){\n     console.log(`${this.name} ${this.age} eat food`)\n   }\n }\n</code></pre></li>\n<li><p><strong>利用关键字extends 和 super 继承</strong></p>\n<pre><code> class Child extends Parent{ \n     constructor(name = &#39;ren&#39;,age = &#39;27&#39;){ \n       //继承父类属性\n       super(name, age); \n     } \n       eat(){ \n       //继承父类方法\n         super.eat() \n       } \n   } \n   let child =new Child(&#39;xiaoxiami&#39;); \n   child.eat();</code></pre></li>\n<li><p><strong>存储器getter,setter改变属性和读取</strong></p>\n<pre><code> class People{\n   // 定义构造函数\n   constructor(name){\n     // 定义属性\n     this.name = name;\n   }\n   get name () {\n     return &#39;renbo&#39;;\n   }\n   set name (value) {\n     console.log(&#39;setter: &#39; + value);\n   }\n   // 定义方法\n   eat(){\n     console.log(`${this.name}  eat food`)\n   }\n }\n let people = new People(&#39;lisi&#39;); // setter: lisi\n people.name = &#39;zhangsan&#39;; // setter: zhangsan\n console.log(people.name); // renbo</code></pre></li>\n<li><p><strong>静态方法使用static修饰符（由于分配在静态内存空间中，所以不需要实例化，只需要吊影即可）</strong></p>\n<pre><code> class People{\n   // 定义静态方法\n   static eat(name){\n     console.log(`${name} eat food`)\n   }\n }\n console.log(People.eat(&#39;renbo&#39;)) // renbo eat food</code></pre></li>\n</ol>\n<h3 id=\"ES7中类的用法\"><a href=\"#ES7中类的用法\" class=\"headerlink\" title=\"ES7中类的用法 \"></a>ES7中类的用法 <br><hr></h3><ol>\n<li><p><strong>定义属性可以直接在类中定义</strong></p>\n<pre><code> class People{\n   name = &#39;zhangsan&#39;\n   constructor () {\n     // \n   }\n }\n let people = new People();\n console.log(npeople.name) // zhangsan</code></pre></li>\n<li><p><strong>定义静态属性</strong></p>\n<pre><code>class People{\nstatic  name = &#39;zhangsan&#39;\n constructor () {\n   // \n }\n}\nconsole.log(People.name) // zhangsan</code></pre></li>\n</ol>\n<h3 id=\"TypeScript-中类的用法\"><a href=\"#TypeScript-中类的用法\" class=\"headerlink\" title=\"TypeScript 中类的用法 \"></a>TypeScript 中类的用法 <br><hr></h3><ol>\n<li><strong>说起 ts 中的类不得不说访问修饰符 public private protected</strong></li>\n</ol>\n<ul>\n<li>public 说明属性或方法是公有的，在任何地方被访问到，在 ts 中方法和属性默认的是 public</li>\n<li>private 说明属性或方法是私有的，不能在类的外部访问</li>\n<li>protected 说明属性或方法是受保护的，和 private 类似，但是 protected 也可以在子类中访问</li>\n</ul>\n<p><strong>public 修饰符</strong></p>\n<pre><code>class People {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People(&#39;renbo&#39;);\nconsole.log(people.name); // renbo</code></pre><p><strong>private 修饰符</strong></p>\n<pre><code>class People {\n  private  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People(&#39;renbo&#39;);\nconsole.log(people.name); // Property &#39;name&#39; is private and only accessible within class &#39;People&#39;.\n\n// 在子类中也不允许访问，只是私有\nclass People {\n  private  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name); // Property &#39;name&#39; is private and only accessible within class &#39;People&#39;.\n  }\n}</code></pre><p><strong>protected 修饰符</strong></p>\n<pre><code>class People {\n  protected  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People(&#39;renbo&#39;);\nconsole.log(people.name); // Property &#39;name&#39; is protected and only accessible within class &#39;People&#39; and its subclasses.ts</code></pre><p><strong>protected 修饰符(子类访问)</strong></p>\n<pre><code>class People {\n  protected  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name)\n  }\n}\n\nlet people  = new People (&#39;zhangsna&#39;)\nlet smilePeople = new SmilePeople(&#39;wangwu&#39;); // wangwu\n</code></pre><ol start=\"2\">\n<li><strong>抽象类（ abstract 用于定义抽象类以及抽象类中的抽象方法）</strong></li>\n</ol>\n<ul>\n<li>抽象类可以作为派生其他类的基类</li>\n<li>抽象类中的抽象方法必须被子类实现</li>\n<li>抽象类无法直接实例化</li>\n<li>与接口不同，抽象类可以包含其成员的实现细节</li>\n</ul>\n<pre><code>// 上述1，2\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat():string\n}\n// 派生类\nclass SmilePeople extends People {\n  static food: string = &#39;apple&#39;\n  // eat 方法必须在子类中实现\n  public eat ():string {\n    return `my name is ${this.name} I,m eating ${SmilePeople.food}`\n  }\n}\n\nlet smilePeople = new SmilePeople(&#39;zhangsan&#39;);\nsmilePeople.eat()\n\n// 无法直接实例化\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat ():void\n}\n\nlet people = new People(&#39;zhangsan&#39;) // Cannot create an instance of an abstract class.\n</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"TS基础系列之-类\"><a href=\"#TS基础系列之-类\" class=\"headerlink\" title=\"TS基础系列之-类\"></a>TS基础系列之-类</h2><p>在JavaScript 通过构造函数和原型链来实现类和继承。而在 ES6 中，也用语法糖实现了class，下面介绍一下在 ts 中的类。</p>\n<h3 id=\"类的概念\"><a href=\"#类的概念\" class=\"headerlink\" title=\"类的概念 \"></a>类的概念 <br><hr></h3><p>类是面向对象程序设计中的概念，是面向对象编程的基础，由于是一种数据类型，而不是数据，所以不存在于内存中。</p>\n<ul>\n<li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li>\n<li>对象（Object）：类的实例，通过 new 生成，类是概念，对象是实体</li>\n<li>面向对象（OOP）的三大特性：封装、继承、多态</li>\n<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>\n<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。</li>\n<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>\n<li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</li>\n<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li>\n</ul>\n<h3 id=\"ES6中类的用法\"><a href=\"#ES6中类的用法\" class=\"headerlink\" title=\"ES6中类的用法 \"></a>ES6中类的用法 <br><hr></h3><ol>\n<li><p><strong>定义属性和方法</strong></p>\n<pre><code> // 定义类\n class Parent{\n   // 定义构造函数\n   constructor(name=&#39;wang&#39;,age=&#39;27&#39;){\n     // 定义属性\n     this.name = name;\n     this.age = age;\n   }\n   // 定义方法\n   eat(){\n     console.log(`${this.name} ${this.age} eat food`)\n   }\n }\n</code></pre></li>\n<li><p><strong>利用关键字extends 和 super 继承</strong></p>\n<pre><code> class Child extends Parent{ \n     constructor(name = &#39;ren&#39;,age = &#39;27&#39;){ \n       //继承父类属性\n       super(name, age); \n     } \n       eat(){ \n       //继承父类方法\n         super.eat() \n       } \n   } \n   let child =new Child(&#39;xiaoxiami&#39;); \n   child.eat();</code></pre></li>\n<li><p><strong>存储器getter,setter改变属性和读取</strong></p>\n<pre><code> class People{\n   // 定义构造函数\n   constructor(name){\n     // 定义属性\n     this.name = name;\n   }\n   get name () {\n     return &#39;renbo&#39;;\n   }\n   set name (value) {\n     console.log(&#39;setter: &#39; + value);\n   }\n   // 定义方法\n   eat(){\n     console.log(`${this.name}  eat food`)\n   }\n }\n let people = new People(&#39;lisi&#39;); // setter: lisi\n people.name = &#39;zhangsan&#39;; // setter: zhangsan\n console.log(people.name); // renbo</code></pre></li>\n<li><p><strong>静态方法使用static修饰符（由于分配在静态内存空间中，所以不需要实例化，只需要吊影即可）</strong></p>\n<pre><code> class People{\n   // 定义静态方法\n   static eat(name){\n     console.log(`${name} eat food`)\n   }\n }\n console.log(People.eat(&#39;renbo&#39;)) // renbo eat food</code></pre></li>\n</ol>\n<h3 id=\"ES7中类的用法\"><a href=\"#ES7中类的用法\" class=\"headerlink\" title=\"ES7中类的用法 \"></a>ES7中类的用法 <br><hr></h3><ol>\n<li><p><strong>定义属性可以直接在类中定义</strong></p>\n<pre><code> class People{\n   name = &#39;zhangsan&#39;\n   constructor () {\n     // \n   }\n }\n let people = new People();\n console.log(npeople.name) // zhangsan</code></pre></li>\n<li><p><strong>定义静态属性</strong></p>\n<pre><code>class People{\nstatic  name = &#39;zhangsan&#39;\n constructor () {\n   // \n }\n}\nconsole.log(People.name) // zhangsan</code></pre></li>\n</ol>\n<h3 id=\"TypeScript-中类的用法\"><a href=\"#TypeScript-中类的用法\" class=\"headerlink\" title=\"TypeScript 中类的用法 \"></a>TypeScript 中类的用法 <br><hr></h3><ol>\n<li><strong>说起 ts 中的类不得不说访问修饰符 public private protected</strong></li>\n</ol>\n<ul>\n<li>public 说明属性或方法是公有的，在任何地方被访问到，在 ts 中方法和属性默认的是 public</li>\n<li>private 说明属性或方法是私有的，不能在类的外部访问</li>\n<li>protected 说明属性或方法是受保护的，和 private 类似，但是 protected 也可以在子类中访问</li>\n</ul>\n<p><strong>public 修饰符</strong></p>\n<pre><code>class People {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People(&#39;renbo&#39;);\nconsole.log(people.name); // renbo</code></pre><p><strong>private 修饰符</strong></p>\n<pre><code>class People {\n  private  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People(&#39;renbo&#39;);\nconsole.log(people.name); // Property &#39;name&#39; is private and only accessible within class &#39;People&#39;.\n\n// 在子类中也不允许访问，只是私有\nclass People {\n  private  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name); // Property &#39;name&#39; is private and only accessible within class &#39;People&#39;.\n  }\n}</code></pre><p><strong>protected 修饰符</strong></p>\n<pre><code>class People {\n  protected  name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet people = new People(&#39;renbo&#39;);\nconsole.log(people.name); // Property &#39;name&#39; is protected and only accessible within class &#39;People&#39; and its subclasses.ts</code></pre><p><strong>protected 修饰符(子类访问)</strong></p>\n<pre><code>class People {\n  protected  name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass SmilePeople extends People {\n\n  public constructor (name:string) {\n    super(name)\n    console.log(this.name)\n  }\n}\n\nlet people  = new People (&#39;zhangsna&#39;)\nlet smilePeople = new SmilePeople(&#39;wangwu&#39;); // wangwu\n</code></pre><ol start=\"2\">\n<li><strong>抽象类（ abstract 用于定义抽象类以及抽象类中的抽象方法）</strong></li>\n</ol>\n<ul>\n<li>抽象类可以作为派生其他类的基类</li>\n<li>抽象类中的抽象方法必须被子类实现</li>\n<li>抽象类无法直接实例化</li>\n<li>与接口不同，抽象类可以包含其成员的实现细节</li>\n</ul>\n<pre><code>// 上述1，2\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat():string\n}\n// 派生类\nclass SmilePeople extends People {\n  static food: string = &#39;apple&#39;\n  // eat 方法必须在子类中实现\n  public eat ():string {\n    return `my name is ${this.name} I,m eating ${SmilePeople.food}`\n  }\n}\n\nlet smilePeople = new SmilePeople(&#39;zhangsan&#39;);\nsmilePeople.eat()\n\n// 无法直接实例化\nabstract class People {\n  public name:string;\n  public constructor (name:string) {\n    this.name = name;\n  }\n  public abstract eat ():void\n}\n\nlet people = new People(&#39;zhangsan&#39;) // Cannot create an instance of an abstract class.\n</code></pre>"},{"title":"TypeScript编译原理","date":"2019-08-05T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\nTypeScript 编译器源文件位于 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/compiler\">src/compiler </a> 目录下\n\n主要的应用文件\n\n<image src=\"/images/TypeScript 编译原理.png\" />\n\n\n### 编译器的大概工作流\n\n```\nSourceCode（源码） ~~ 扫描器 ~~> Token 流\n```\n\n```\nToken 流 ~~ 解析器 ~~> AST（抽象语法树）\n```\n\n```\nAST ~~ 绑定器 ~~> Symbols（符号）\n```\n\n```\nAST + 符号 ~~ 检查器 ~~> 类型验证\n```\n\n```\nAST + 检查器 ~~ 发射器 ~~> JavaScript 代码\n```\n\n\n\n","source":"_posts/typescript/compilationPrinciple.md","raw":"---\ntitle: TypeScript编译原理\ndate:  2019-08-05 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n\nTypeScript 编译器源文件位于 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/compiler\">src/compiler </a> 目录下\n\n主要的应用文件\n\n<image src=\"/images/TypeScript 编译原理.png\" />\n\n\n### 编译器的大概工作流\n\n```\nSourceCode（源码） ~~ 扫描器 ~~> Token 流\n```\n\n```\nToken 流 ~~ 解析器 ~~> AST（抽象语法树）\n```\n\n```\nAST ~~ 绑定器 ~~> Symbols（符号）\n```\n\n```\nAST + 符号 ~~ 检查器 ~~> 类型验证\n```\n\n```\nAST + 检查器 ~~ 发射器 ~~> JavaScript 代码\n```\n\n\n\n","slug":"typescript/compilationPrinciple","published":1,"updated":"2019-10-15T01:29:42.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ote0048b0u6opgkiztk","content":"<p>TypeScript 编译器源文件位于 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/compiler\" target=\"_blank\" rel=\"noopener\">src/compiler </a> 目录下</p>\n<p>主要的应用文件</p>\n<image src=\"/images/TypeScript 编译原理.png\">\n\n\n<h3 id=\"编译器的大概工作流\"><a href=\"#编译器的大概工作流\" class=\"headerlink\" title=\"编译器的大概工作流\"></a>编译器的大概工作流</h3><pre><code>SourceCode（源码） ~~ 扫描器 ~~&gt; Token 流</code></pre><pre><code>Token 流 ~~ 解析器 ~~&gt; AST（抽象语法树）</code></pre><pre><code>AST ~~ 绑定器 ~~&gt; Symbols（符号）</code></pre><pre><code>AST + 符号 ~~ 检查器 ~~&gt; 类型验证</code></pre><pre><code>AST + 检查器 ~~ 发射器 ~~&gt; JavaScript 代码</code></pre></image>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>TypeScript 编译器源文件位于 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/compiler\" target=\"_blank\" rel=\"noopener\">src/compiler </a> 目录下</p>\n<p>主要的应用文件</p>\n<image src=\"/images/TypeScript 编译原理.png\">\n\n\n<h3 id=\"编译器的大概工作流\"><a href=\"#编译器的大概工作流\" class=\"headerlink\" title=\"编译器的大概工作流\"></a>编译器的大概工作流</h3><pre><code>SourceCode（源码） ~~ 扫描器 ~~&gt; Token 流</code></pre><pre><code>Token 流 ~~ 解析器 ~~&gt; AST（抽象语法树）</code></pre><pre><code>AST ~~ 绑定器 ~~&gt; Symbols（符号）</code></pre><pre><code>AST + 符号 ~~ 检查器 ~~&gt; 类型验证</code></pre><pre><code>AST + 检查器 ~~ 发射器 ~~&gt; JavaScript 代码</code></pre></image>"},{"title":"声明文件","date":"2019-06-20T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## 声明文件\n\n### 识别库的类型\n\n全局库(全局命名空间下能访问)\n\n- 顶级的var语句或function声明\n- 一个或多个赋值语句到window上\n- 假设DOM原始值像document或window是存在的\n\n```\n<script src=\"jquery.js\"></script>\n\nwindow.test = function(){\n    console.log('1111')\n}\n\n```\n\n模块化库（只能工作在模块加载器的环境下）\n\n- 无条件的调用require或define\n- 像import * as a from 'b'; or export c;这样的声明\n- 赋值给exports或module.exports\n \nUMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块\n\n```\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n\n```\n在浏览器环境内也可以这样使用\n\n```\nconsole.log(moment.format());\n```\n\n识别UMD库\n```\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {}))\n```\n\n### 使用依赖\n\n依赖全局库\n```\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n\n依赖模块\n```\nimport * as moment from \"moment\";\n\nfunction getThing(): moment;\n```\n\n依赖UMD库\n```\n// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n\n如果你的模块或UMD库依赖于一个UMD库\n\n不要使用/// <reference指令去声明UMD库的依赖！\n```\nimport * as someLib from 'someLib';\n\n```\n\n### 防止命名冲突\n\n在书写全局声明文件时，使用库定义的全局变量名来声明命名空间类型\n```\ndeclare namespace cats {\n    interface KittySettings { }\n}\n```\n\n\n### 定义全局库模版\n\n模版文件<a href=\"global.d.ts.md\"> global.d.ts </a>定义了myLib库作为例子\n\n### 定义模块化库模版\n\n针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-fun\n\n<a href=\"module.d.ts.md\"> module.d.ts </a> 作为函数调用\n```\nvar x = require(\"foo\");\n// Note: calling 'x' as a function\nvar y = x(42);\n\n```\n\n<a href=\"module-class.d.ts.md\" >module-class.d.ts </a>使用new来构造调用\n```\nvar x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nvar y = new x(\"hello\");\n\n```\n\n如果模块不能被调用或构造，使用<a href=\"module.d.ts.md\"> module.d.ts </a>文件\n\n### 使用库\n\n在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。\n\n```\nnpm install --save @types/lodash\n\nimport * as _ from \"lodash\";\n\n_.padStart(\"Hello TypeScript!\", 20, \" \");\n```\n\n如果npm包没有包含它的声明文件，那就必须下载相应的@types包\n\n大多数类型声明包的名字总是与它们在npm上的包的名字相同，但是有@types/前缀\n\n查找更多typeScript 库请前往 <a href=\"https://aka.ms/types\">https://aka.ms/types</a>\n\n\n\n","source":"_posts/typescript/declareFile.md","raw":"---\ntitle: 声明文件\ndate:  2019-6-20 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n## 声明文件\n\n### 识别库的类型\n\n全局库(全局命名空间下能访问)\n\n- 顶级的var语句或function声明\n- 一个或多个赋值语句到window上\n- 假设DOM原始值像document或window是存在的\n\n```\n<script src=\"jquery.js\"></script>\n\nwindow.test = function(){\n    console.log('1111')\n}\n\n```\n\n模块化库（只能工作在模块加载器的环境下）\n\n- 无条件的调用require或define\n- 像import * as a from 'b'; or export c;这样的声明\n- 赋值给exports或module.exports\n \nUMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块\n\n```\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n\n```\n在浏览器环境内也可以这样使用\n\n```\nconsole.log(moment.format());\n```\n\n识别UMD库\n```\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {}))\n```\n\n### 使用依赖\n\n依赖全局库\n```\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n\n依赖模块\n```\nimport * as moment from \"moment\";\n\nfunction getThing(): moment;\n```\n\n依赖UMD库\n```\n// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n\n如果你的模块或UMD库依赖于一个UMD库\n\n不要使用/// <reference指令去声明UMD库的依赖！\n```\nimport * as someLib from 'someLib';\n\n```\n\n### 防止命名冲突\n\n在书写全局声明文件时，使用库定义的全局变量名来声明命名空间类型\n```\ndeclare namespace cats {\n    interface KittySettings { }\n}\n```\n\n\n### 定义全局库模版\n\n模版文件<a href=\"global.d.ts.md\"> global.d.ts </a>定义了myLib库作为例子\n\n### 定义模块化库模版\n\n针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-fun\n\n<a href=\"module.d.ts.md\"> module.d.ts </a> 作为函数调用\n```\nvar x = require(\"foo\");\n// Note: calling 'x' as a function\nvar y = x(42);\n\n```\n\n<a href=\"module-class.d.ts.md\" >module-class.d.ts </a>使用new来构造调用\n```\nvar x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nvar y = new x(\"hello\");\n\n```\n\n如果模块不能被调用或构造，使用<a href=\"module.d.ts.md\"> module.d.ts </a>文件\n\n### 使用库\n\n在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。\n\n```\nnpm install --save @types/lodash\n\nimport * as _ from \"lodash\";\n\n_.padStart(\"Hello TypeScript!\", 20, \" \");\n```\n\n如果npm包没有包含它的声明文件，那就必须下载相应的@types包\n\n大多数类型声明包的名字总是与它们在npm上的包的名字相同，但是有@types/前缀\n\n查找更多typeScript 库请前往 <a href=\"https://aka.ms/types\">https://aka.ms/types</a>\n\n\n\n","slug":"typescript/declareFile","published":1,"updated":"2019-10-15T01:29:42.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oth004db0u60y4sgcii","content":"<h2 id=\"声明文件\"><a href=\"#声明文件\" class=\"headerlink\" title=\"声明文件\"></a>声明文件</h2><h3 id=\"识别库的类型\"><a href=\"#识别库的类型\" class=\"headerlink\" title=\"识别库的类型\"></a>识别库的类型</h3><p>全局库(全局命名空间下能访问)</p>\n<ul>\n<li>顶级的var语句或function声明</li>\n<li>一个或多个赋值语句到window上</li>\n<li>假设DOM原始值像document或window是存在的</li>\n</ul>\n<pre><code>&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;\n\nwindow.test = function(){\n    console.log(&#39;1111&#39;)\n}\n</code></pre><p>模块化库（只能工作在模块加载器的环境下）</p>\n<ul>\n<li>无条件的调用require或define</li>\n<li>像import * as a from ‘b’; or export c;这样的声明</li>\n<li>赋值给exports或module.exports</li>\n</ul>\n<p>UMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块</p>\n<pre><code>import moment = require(&quot;moment&quot;);\nconsole.log(moment.format());\n</code></pre><p>在浏览器环境内也可以这样使用</p>\n<pre><code>console.log(moment.format());</code></pre><p>识别UMD库</p>\n<pre><code>(function (root, factory) {\n    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {\n        define([&quot;libName&quot;], factory);\n    } else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) {\n        module.exports = factory(require(&quot;libName&quot;));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {}))</code></pre><h3 id=\"使用依赖\"><a href=\"#使用依赖\" class=\"headerlink\" title=\"使用依赖\"></a>使用依赖</h3><p>依赖全局库</p>\n<pre><code>/// &lt;reference types=&quot;someLib&quot; /&gt;\n\nfunction getThing(): someLib.thing;</code></pre><p>依赖模块</p>\n<pre><code>import * as moment from &quot;moment&quot;;\n\nfunction getThing(): moment;</code></pre><p>依赖UMD库</p>\n<pre><code>// &lt;reference types=&quot;moment&quot; /&gt;\n\nfunction getThing(): moment;</code></pre><p>如果你的模块或UMD库依赖于一个UMD库</p>\n<p>不要使用/// &lt;reference指令去声明UMD库的依赖！</p>\n<pre><code>import * as someLib from &#39;someLib&#39;;\n</code></pre><h3 id=\"防止命名冲突\"><a href=\"#防止命名冲突\" class=\"headerlink\" title=\"防止命名冲突\"></a>防止命名冲突</h3><p>在书写全局声明文件时，使用库定义的全局变量名来声明命名空间类型</p>\n<pre><code>declare namespace cats {\n    interface KittySettings { }\n}</code></pre><h3 id=\"定义全局库模版\"><a href=\"#定义全局库模版\" class=\"headerlink\" title=\"定义全局库模版\"></a>定义全局库模版</h3><p>模版文件<a href=\"global.d.ts.md\"> global.d.ts </a>定义了myLib库作为例子</p>\n<h3 id=\"定义模块化库模版\"><a href=\"#定义模块化库模版\" class=\"headerlink\" title=\"定义模块化库模版\"></a>定义模块化库模版</h3><p>针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-fun</p>\n<p><a href=\"module.d.ts.md\"> module.d.ts </a> 作为函数调用</p>\n<pre><code>var x = require(&quot;foo&quot;);\n// Note: calling &#39;x&#39; as a function\nvar y = x(42);\n</code></pre><p><a href=\"module-class.d.ts.md\">module-class.d.ts </a>使用new来构造调用</p>\n<pre><code>var x = require(&quot;bar&quot;);\n// Note: using &#39;new&#39; operator on the imported variable\nvar y = new x(&quot;hello&quot;);\n</code></pre><p>如果模块不能被调用或构造，使用<a href=\"module.d.ts.md\"> module.d.ts </a>文件</p>\n<h3 id=\"使用库\"><a href=\"#使用库\" class=\"headerlink\" title=\"使用库\"></a>使用库</h3><p>在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。</p>\n<pre><code>npm install --save @types/lodash\n\nimport * as _ from &quot;lodash&quot;;\n\n_.padStart(&quot;Hello TypeScript!&quot;, 20, &quot; &quot;);</code></pre><p>如果npm包没有包含它的声明文件，那就必须下载相应的@types包</p>\n<p>大多数类型声明包的名字总是与它们在npm上的包的名字相同，但是有@types/前缀</p>\n<p>查找更多typeScript 库请前往 <a href=\"https://aka.ms/types\" target=\"_blank\" rel=\"noopener\">https://aka.ms/types</a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"声明文件\"><a href=\"#声明文件\" class=\"headerlink\" title=\"声明文件\"></a>声明文件</h2><h3 id=\"识别库的类型\"><a href=\"#识别库的类型\" class=\"headerlink\" title=\"识别库的类型\"></a>识别库的类型</h3><p>全局库(全局命名空间下能访问)</p>\n<ul>\n<li>顶级的var语句或function声明</li>\n<li>一个或多个赋值语句到window上</li>\n<li>假设DOM原始值像document或window是存在的</li>\n</ul>\n<pre><code>&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;\n\nwindow.test = function(){\n    console.log(&#39;1111&#39;)\n}\n</code></pre><p>模块化库（只能工作在模块加载器的环境下）</p>\n<ul>\n<li>无条件的调用require或define</li>\n<li>像import * as a from ‘b’; or export c;这样的声明</li>\n<li>赋值给exports或module.exports</li>\n</ul>\n<p>UMD模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块</p>\n<pre><code>import moment = require(&quot;moment&quot;);\nconsole.log(moment.format());\n</code></pre><p>在浏览器环境内也可以这样使用</p>\n<pre><code>console.log(moment.format());</code></pre><p>识别UMD库</p>\n<pre><code>(function (root, factory) {\n    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {\n        define([&quot;libName&quot;], factory);\n    } else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) {\n        module.exports = factory(require(&quot;libName&quot;));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {}))</code></pre><h3 id=\"使用依赖\"><a href=\"#使用依赖\" class=\"headerlink\" title=\"使用依赖\"></a>使用依赖</h3><p>依赖全局库</p>\n<pre><code>/// &lt;reference types=&quot;someLib&quot; /&gt;\n\nfunction getThing(): someLib.thing;</code></pre><p>依赖模块</p>\n<pre><code>import * as moment from &quot;moment&quot;;\n\nfunction getThing(): moment;</code></pre><p>依赖UMD库</p>\n<pre><code>// &lt;reference types=&quot;moment&quot; /&gt;\n\nfunction getThing(): moment;</code></pre><p>如果你的模块或UMD库依赖于一个UMD库</p>\n<p>不要使用/// &lt;reference指令去声明UMD库的依赖！</p>\n<pre><code>import * as someLib from &#39;someLib&#39;;\n</code></pre><h3 id=\"防止命名冲突\"><a href=\"#防止命名冲突\" class=\"headerlink\" title=\"防止命名冲突\"></a>防止命名冲突</h3><p>在书写全局声明文件时，使用库定义的全局变量名来声明命名空间类型</p>\n<pre><code>declare namespace cats {\n    interface KittySettings { }\n}</code></pre><h3 id=\"定义全局库模版\"><a href=\"#定义全局库模版\" class=\"headerlink\" title=\"定义全局库模版\"></a>定义全局库模版</h3><p>模版文件<a href=\"global.d.ts.md\"> global.d.ts </a>定义了myLib库作为例子</p>\n<h3 id=\"定义模块化库模版\"><a href=\"#定义模块化库模版\" class=\"headerlink\" title=\"定义模块化库模版\"></a>定义模块化库模版</h3><p>针对模块有三种可用的模块， module.d.ts, module-class.d.ts and module-fun</p>\n<p><a href=\"module.d.ts.md\"> module.d.ts </a> 作为函数调用</p>\n<pre><code>var x = require(&quot;foo&quot;);\n// Note: calling &#39;x&#39; as a function\nvar y = x(42);\n</code></pre><p><a href=\"module-class.d.ts.md\">module-class.d.ts </a>使用new来构造调用</p>\n<pre><code>var x = require(&quot;bar&quot;);\n// Note: using &#39;new&#39; operator on the imported variable\nvar y = new x(&quot;hello&quot;);\n</code></pre><p>如果模块不能被调用或构造，使用<a href=\"module.d.ts.md\"> module.d.ts </a>文件</p>\n<h3 id=\"使用库\"><a href=\"#使用库\" class=\"headerlink\" title=\"使用库\"></a>使用库</h3><p>在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。</p>\n<pre><code>npm install --save @types/lodash\n\nimport * as _ from &quot;lodash&quot;;\n\n_.padStart(&quot;Hello TypeScript!&quot;, 20, &quot; &quot;);</code></pre><p>如果npm包没有包含它的声明文件，那就必须下载相应的@types包</p>\n<p>大多数类型声明包的名字总是与它们在npm上的包的名字相同，但是有@types/前缀</p>\n<p>查找更多typeScript 库请前往 <a href=\"https://aka.ms/types\" target=\"_blank\" rel=\"noopener\">https://aka.ms/types</a></p>\n"},{"title":"基础之概述和环境配置","date":"2019-05-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 什么是TypeScript？<br/>\n  ts是一种的开源的编程语言，是由Microsoft主导研发。从工作机制上讲，它就像javaScript的超集。这个语言添加了可选的静态类型和基于类的面向对象编程。2012年首个版本公布\n\n\n### TypeScript的特点?\n  - JavaScript可以使用TypeScript。所有TypeScript代码也都转换为它的JavaScript等效代码\n  - TypeScript支持其他JS库\n  - TypeScript是可移植的。TypeScript可跨浏览器，设备和操作系统的移植\n  - TypeScript与ECMAScript6规范一致\n\n### 为什么要使用TypeScript？<br/>\n  作为前端开发人员我们都知道，从本质上讲，JavaScript是一种自由语言，也叫弱类型的语言，它的语法规则并不是那么严格。正因为如此，我们就更容易犯错，而且，即使是在运行的时候，我们也不能找到所有的错误。鉴于此，TypeScript作为JavaScript的超集，它的语法更严格，我们在编写代码的时候就能够发现大部分错误。不仅如此，按照TypeScript官方的说法，TypeScript使得我们能够以JavaScript的方式实现自己的构思。TypeScript对面向对象的支持也非常完善，它拥有面向对象编程语言的所有特性。如果你想要获取有关TypeScript的更多信息，可以前往TypeScript的官方网站: <a href=\"http://www.typescriptlang.org/\">TypeScript - JavaScript that scales.</a>\n\n### TypeScript的组成部分?\n  - 语言层 - 它包括语法，关键字和类型注释\n  - 编译器层 - TypeScript编译器（TSC）将使用TypeScript编写的指令转换为其等效的JavaScript\n  - 语言服务层 - “语言服务”在核心编译管道周围公开了一个额外的层，它是类似编辑器的应用程序。ts编译核心(core.ts,program.ts,scanner.ts,parser.ts,checker,emitter.ts)<br/>\n<image src=\"images/ts-lang.png\" width=\"350\"></image>\n\n### TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）\n - 下载并安装 node <a href=\"https://nodejs.org/en/\">相关 node 官网</a>\n - 查看 node 是否安装成功，在命令行中执行 `node -v` 如果出现版本号则证明 node 安装成功 \n - 通过 npm 安装 typescript `npm install -g typescript` \n - 创建 filename.ts 文件在文件中书写相应ts代码\n - 执行 `tsc filename.ts` 编译过后默认会在当前目录产生js文件,在页面中引入js文件即可\n - 后续在tsconfig.json 中讨论配置监听属性\n\n\n\n\n\n\n","source":"_posts/typescript/envConfig.md","raw":"---\ntitle: 基础之概述和环境配置\ndate: 2019-05-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n### 什么是TypeScript？<br/>\n  ts是一种的开源的编程语言，是由Microsoft主导研发。从工作机制上讲，它就像javaScript的超集。这个语言添加了可选的静态类型和基于类的面向对象编程。2012年首个版本公布\n\n\n### TypeScript的特点?\n  - JavaScript可以使用TypeScript。所有TypeScript代码也都转换为它的JavaScript等效代码\n  - TypeScript支持其他JS库\n  - TypeScript是可移植的。TypeScript可跨浏览器，设备和操作系统的移植\n  - TypeScript与ECMAScript6规范一致\n\n### 为什么要使用TypeScript？<br/>\n  作为前端开发人员我们都知道，从本质上讲，JavaScript是一种自由语言，也叫弱类型的语言，它的语法规则并不是那么严格。正因为如此，我们就更容易犯错，而且，即使是在运行的时候，我们也不能找到所有的错误。鉴于此，TypeScript作为JavaScript的超集，它的语法更严格，我们在编写代码的时候就能够发现大部分错误。不仅如此，按照TypeScript官方的说法，TypeScript使得我们能够以JavaScript的方式实现自己的构思。TypeScript对面向对象的支持也非常完善，它拥有面向对象编程语言的所有特性。如果你想要获取有关TypeScript的更多信息，可以前往TypeScript的官方网站: <a href=\"http://www.typescriptlang.org/\">TypeScript - JavaScript that scales.</a>\n\n### TypeScript的组成部分?\n  - 语言层 - 它包括语法，关键字和类型注释\n  - 编译器层 - TypeScript编译器（TSC）将使用TypeScript编写的指令转换为其等效的JavaScript\n  - 语言服务层 - “语言服务”在核心编译管道周围公开了一个额外的层，它是类似编辑器的应用程序。ts编译核心(core.ts,program.ts,scanner.ts,parser.ts,checker,emitter.ts)<br/>\n<image src=\"images/ts-lang.png\" width=\"350\"></image>\n\n### TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）\n - 下载并安装 node <a href=\"https://nodejs.org/en/\">相关 node 官网</a>\n - 查看 node 是否安装成功，在命令行中执行 `node -v` 如果出现版本号则证明 node 安装成功 \n - 通过 npm 安装 typescript `npm install -g typescript` \n - 创建 filename.ts 文件在文件中书写相应ts代码\n - 执行 `tsc filename.ts` 编译过后默认会在当前目录产生js文件,在页面中引入js文件即可\n - 后续在tsconfig.json 中讨论配置监听属性\n\n\n\n\n\n\n","slug":"typescript/envConfig","published":1,"updated":"2019-10-15T01:29:42.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oti004eb0u6eh6kaj7w","content":"<h3 id=\"什么是TypeScript？\"><a href=\"#什么是TypeScript？\" class=\"headerlink\" title=\"什么是TypeScript？\"></a>什么是TypeScript？<br></h3><p>  ts是一种的开源的编程语言，是由Microsoft主导研发。从工作机制上讲，它就像javaScript的超集。这个语言添加了可选的静态类型和基于类的面向对象编程。2012年首个版本公布</p>\n<h3 id=\"TypeScript的特点\"><a href=\"#TypeScript的特点\" class=\"headerlink\" title=\"TypeScript的特点?\"></a>TypeScript的特点?</h3><ul>\n<li>JavaScript可以使用TypeScript。所有TypeScript代码也都转换为它的JavaScript等效代码</li>\n<li>TypeScript支持其他JS库</li>\n<li>TypeScript是可移植的。TypeScript可跨浏览器，设备和操作系统的移植</li>\n<li>TypeScript与ECMAScript6规范一致</li>\n</ul>\n<h3 id=\"为什么要使用TypeScript？\"><a href=\"#为什么要使用TypeScript？\" class=\"headerlink\" title=\"为什么要使用TypeScript？\"></a>为什么要使用TypeScript？<br></h3><p>  作为前端开发人员我们都知道，从本质上讲，JavaScript是一种自由语言，也叫弱类型的语言，它的语法规则并不是那么严格。正因为如此，我们就更容易犯错，而且，即使是在运行的时候，我们也不能找到所有的错误。鉴于此，TypeScript作为JavaScript的超集，它的语法更严格，我们在编写代码的时候就能够发现大部分错误。不仅如此，按照TypeScript官方的说法，TypeScript使得我们能够以JavaScript的方式实现自己的构思。TypeScript对面向对象的支持也非常完善，它拥有面向对象编程语言的所有特性。如果你想要获取有关TypeScript的更多信息，可以前往TypeScript的官方网站: <a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript - JavaScript that scales.</a></p>\n<h3 id=\"TypeScript的组成部分\"><a href=\"#TypeScript的组成部分\" class=\"headerlink\" title=\"TypeScript的组成部分?\"></a>TypeScript的组成部分?</h3><ul>\n<li>语言层 - 它包括语法，关键字和类型注释</li>\n<li>编译器层 - TypeScript编译器（TSC）将使用TypeScript编写的指令转换为其等效的JavaScript</li>\n<li>语言服务层 - “语言服务”在核心编译管道周围公开了一个额外的层，它是类似编辑器的应用程序。ts编译核心(core.ts,program.ts,scanner.ts,parser.ts,checker,emitter.ts)<br><br><image src=\"images/ts-lang.png\" width=\"350\"></image></li>\n</ul>\n<h3 id=\"TypeScript-环境配置（本文不讨论-windows-安装过程和-mac-类似）\"><a href=\"#TypeScript-环境配置（本文不讨论-windows-安装过程和-mac-类似）\" class=\"headerlink\" title=\"TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）\"></a>TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）</h3><ul>\n<li>下载并安装 node <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">相关 node 官网</a></li>\n<li>查看 node 是否安装成功，在命令行中执行 <code>node -v</code> 如果出现版本号则证明 node 安装成功 </li>\n<li>通过 npm 安装 typescript <code>npm install -g typescript</code> </li>\n<li>创建 filename.ts 文件在文件中书写相应ts代码</li>\n<li>执行 <code>tsc filename.ts</code> 编译过后默认会在当前目录产生js文件,在页面中引入js文件即可</li>\n<li>后续在tsconfig.json 中讨论配置监听属性</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"什么是TypeScript？\"><a href=\"#什么是TypeScript？\" class=\"headerlink\" title=\"什么是TypeScript？\"></a>什么是TypeScript？<br></h3><p>  ts是一种的开源的编程语言，是由Microsoft主导研发。从工作机制上讲，它就像javaScript的超集。这个语言添加了可选的静态类型和基于类的面向对象编程。2012年首个版本公布</p>\n<h3 id=\"TypeScript的特点\"><a href=\"#TypeScript的特点\" class=\"headerlink\" title=\"TypeScript的特点?\"></a>TypeScript的特点?</h3><ul>\n<li>JavaScript可以使用TypeScript。所有TypeScript代码也都转换为它的JavaScript等效代码</li>\n<li>TypeScript支持其他JS库</li>\n<li>TypeScript是可移植的。TypeScript可跨浏览器，设备和操作系统的移植</li>\n<li>TypeScript与ECMAScript6规范一致</li>\n</ul>\n<h3 id=\"为什么要使用TypeScript？\"><a href=\"#为什么要使用TypeScript？\" class=\"headerlink\" title=\"为什么要使用TypeScript？\"></a>为什么要使用TypeScript？<br></h3><p>  作为前端开发人员我们都知道，从本质上讲，JavaScript是一种自由语言，也叫弱类型的语言，它的语法规则并不是那么严格。正因为如此，我们就更容易犯错，而且，即使是在运行的时候，我们也不能找到所有的错误。鉴于此，TypeScript作为JavaScript的超集，它的语法更严格，我们在编写代码的时候就能够发现大部分错误。不仅如此，按照TypeScript官方的说法，TypeScript使得我们能够以JavaScript的方式实现自己的构思。TypeScript对面向对象的支持也非常完善，它拥有面向对象编程语言的所有特性。如果你想要获取有关TypeScript的更多信息，可以前往TypeScript的官方网站: <a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript - JavaScript that scales.</a></p>\n<h3 id=\"TypeScript的组成部分\"><a href=\"#TypeScript的组成部分\" class=\"headerlink\" title=\"TypeScript的组成部分?\"></a>TypeScript的组成部分?</h3><ul>\n<li>语言层 - 它包括语法，关键字和类型注释</li>\n<li>编译器层 - TypeScript编译器（TSC）将使用TypeScript编写的指令转换为其等效的JavaScript</li>\n<li>语言服务层 - “语言服务”在核心编译管道周围公开了一个额外的层，它是类似编辑器的应用程序。ts编译核心(core.ts,program.ts,scanner.ts,parser.ts,checker,emitter.ts)<br><br><image src=\"images/ts-lang.png\" width=\"350\"></image></li>\n</ul>\n<h3 id=\"TypeScript-环境配置（本文不讨论-windows-安装过程和-mac-类似）\"><a href=\"#TypeScript-环境配置（本文不讨论-windows-安装过程和-mac-类似）\" class=\"headerlink\" title=\"TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）\"></a>TypeScript 环境配置（本文不讨论 windows 安装过程和 mac 类似）</h3><ul>\n<li>下载并安装 node <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">相关 node 官网</a></li>\n<li>查看 node 是否安装成功，在命令行中执行 <code>node -v</code> 如果出现版本号则证明 node 安装成功 </li>\n<li>通过 npm 安装 typescript <code>npm install -g typescript</code> </li>\n<li>创建 filename.ts 文件在文件中书写相应ts代码</li>\n<li>执行 <code>tsc filename.ts</code> 编译过后默认会在当前目录产生js文件,在页面中引入js文件即可</li>\n<li>后续在tsconfig.json 中讨论配置监听属性</li>\n</ul>\n"},{"title":"函数","date":"2019-05-16T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 函数的创建 <br/>\n\n在 ts 中函数创建也氛围两种匿名函数和有命名的函数\n```\n// 有名字的函数\nfunction people () {}\n\n// 匿名函数\nconst people = function () {}\n```\n\n### 函数的参数类型和返回值类型 <br/>\n- 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正\n- 设定了类型之后必须要返回相对应的类型，否则会报错\n- 如果函数没有返回任何值，也必须指定返回值类型为 void而不能留空\n```\n/**\n * \n * @param {*} x number\n * @param {*} y number\n *  return add number \n */\n\nconst add = (x: number, y: number): number => x + y;\n// 书写完整的函数类型\nconst add: (x: number, y: number) => number = (x: number, y: number):number => x + y \n```\n\n### 函数的可选参数和默认参数<br/>\n- 传递给一个函数的参数个数必须与函数期望的参数个数一致，否则会报错\n- 可选参数用`?argname`表示，必须跟在必须参数后面\n- 没有传递参数或传递的值是undefined，这种叫做默认初始化值的参数\n- 所有必须参数**后面**的带默认初始化的参数都是可选的，调用时可省略\n- 带默认值的参数如果出现在必须参数**前面**，用户必须明确的传入 undefined 值来获得默认值\n- 当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）\n\n```\n// 上述1\nconst add: (x: number, y: number) => number = (x: number, y: number):number => x + y \nadd(1, 2) // 3\nadd(1) // 报错\nadd(1,2,3) // 报错\n\n// 上述2\nconst yourName = (firstName: string, lastName?: string): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //ren+bo\nconsole.log(yourName('ren')) // ren+undefined\n\n\n// 上述3\nconst yourName = (firstName: string, lastName?: string): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //ren+bo\nconsole.log(yourName('ren', undefined)) // ren+undefined\n\n//上述4\nconst yourName = (firstName: string, lastName='bo'): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //ren+bo\nconsole.log(yourName('ren')) // ren+bo\n\n// 上述5\nconst yourName = ( lastName='bo', firstName: string): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //bo+ren\nconsole.log(yourName(undefined, 'ren')) // ren+bo\n\n\n// 上述6\nconst people = ( name: string, ...otherProperty: string[]): string => {\n  return name + \" \" + otherProperty.join(\" \");\n}\nconsole.log(people('renbo', '28','170'))  // renbo 28 170 \n```\n\n### 函数的重载 <br/>\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理\n\n```\n// 我们来实现一下通过传入不同的 type 来实现函数的加操作和乘法操作并返回相应的类型\nconst compute = (type: number, ...resetData: number[]):number | string => {\n  if (type === 1 ) {\n    return resetData.reduce((a:number, b:number):number => a + b);\n  } else if (type === 2) {\n    return String(resetData.reduce((a:number, b:number):number => a * b));\n  }\n} \nconsole.log(compute(1, 3, 4, 5, 6)) // 18\nconsole.log(compute(2, 3, 4, 5, 6)) // '360'\n\n// 通过上面的实现唯一的缺点就是不能明确通过type返回的相对应的计算的值和类型\n\nconst compute = (type: number, ...resetData: number[]):number;\nconst compute = (type: number, ...resetData: number[]):string;\nconst compute = (type: number, ...resetData: number[]):number | string => {\n  if (type === 1 ) {\n    return resetData.reduce((a:number, b:number):number => a + b);\n  } else if (type === 2) {\n    return String(resetData.reduce((a:number, b:number):number => a * b));\n  }\n} \nconsole.log(compute(1, 3, 4, 5, 6)) // 18\nconsole.log(compute(2, 3, 4, 5, 6)) // '360'\n\n// 上例中，我们重复定义了多次函数 compute，前几次都是函数定义，最后一次是函数实现。\n```\n\n\n\n\n","source":"_posts/typescript/function.md","raw":"---\ntitle: 函数\ndate:  2019-05-16 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n### 函数的创建 <br/>\n\n在 ts 中函数创建也氛围两种匿名函数和有命名的函数\n```\n// 有名字的函数\nfunction people () {}\n\n// 匿名函数\nconst people = function () {}\n```\n\n### 函数的参数类型和返回值类型 <br/>\n- 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正\n- 设定了类型之后必须要返回相对应的类型，否则会报错\n- 如果函数没有返回任何值，也必须指定返回值类型为 void而不能留空\n```\n/**\n * \n * @param {*} x number\n * @param {*} y number\n *  return add number \n */\n\nconst add = (x: number, y: number): number => x + y;\n// 书写完整的函数类型\nconst add: (x: number, y: number) => number = (x: number, y: number):number => x + y \n```\n\n### 函数的可选参数和默认参数<br/>\n- 传递给一个函数的参数个数必须与函数期望的参数个数一致，否则会报错\n- 可选参数用`?argname`表示，必须跟在必须参数后面\n- 没有传递参数或传递的值是undefined，这种叫做默认初始化值的参数\n- 所有必须参数**后面**的带默认初始化的参数都是可选的，调用时可省略\n- 带默认值的参数如果出现在必须参数**前面**，用户必须明确的传入 undefined 值来获得默认值\n- 当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）\n\n```\n// 上述1\nconst add: (x: number, y: number) => number = (x: number, y: number):number => x + y \nadd(1, 2) // 3\nadd(1) // 报错\nadd(1,2,3) // 报错\n\n// 上述2\nconst yourName = (firstName: string, lastName?: string): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //ren+bo\nconsole.log(yourName('ren')) // ren+undefined\n\n\n// 上述3\nconst yourName = (firstName: string, lastName?: string): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //ren+bo\nconsole.log(yourName('ren', undefined)) // ren+undefined\n\n//上述4\nconst yourName = (firstName: string, lastName='bo'): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //ren+bo\nconsole.log(yourName('ren')) // ren+bo\n\n// 上述5\nconst yourName = ( lastName='bo', firstName: string): string => `${firstName}+${lastName} `;\nconsole.log(yourName('ren', 'bo')) //bo+ren\nconsole.log(yourName(undefined, 'ren')) // ren+bo\n\n\n// 上述6\nconst people = ( name: string, ...otherProperty: string[]): string => {\n  return name + \" \" + otherProperty.join(\" \");\n}\nconsole.log(people('renbo', '28','170'))  // renbo 28 170 \n```\n\n### 函数的重载 <br/>\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理\n\n```\n// 我们来实现一下通过传入不同的 type 来实现函数的加操作和乘法操作并返回相应的类型\nconst compute = (type: number, ...resetData: number[]):number | string => {\n  if (type === 1 ) {\n    return resetData.reduce((a:number, b:number):number => a + b);\n  } else if (type === 2) {\n    return String(resetData.reduce((a:number, b:number):number => a * b));\n  }\n} \nconsole.log(compute(1, 3, 4, 5, 6)) // 18\nconsole.log(compute(2, 3, 4, 5, 6)) // '360'\n\n// 通过上面的实现唯一的缺点就是不能明确通过type返回的相对应的计算的值和类型\n\nconst compute = (type: number, ...resetData: number[]):number;\nconst compute = (type: number, ...resetData: number[]):string;\nconst compute = (type: number, ...resetData: number[]):number | string => {\n  if (type === 1 ) {\n    return resetData.reduce((a:number, b:number):number => a + b);\n  } else if (type === 2) {\n    return String(resetData.reduce((a:number, b:number):number => a * b));\n  }\n} \nconsole.log(compute(1, 3, 4, 5, 6)) // 18\nconsole.log(compute(2, 3, 4, 5, 6)) // '360'\n\n// 上例中，我们重复定义了多次函数 compute，前几次都是函数定义，最后一次是函数实现。\n```\n\n\n\n\n","slug":"typescript/function","published":1,"updated":"2019-10-15T01:29:42.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otl004jb0u69detbx24","content":"<h3 id=\"函数的创建\"><a href=\"#函数的创建\" class=\"headerlink\" title=\"函数的创建 \"></a>函数的创建 <br></h3><p>在 ts 中函数创建也氛围两种匿名函数和有命名的函数</p>\n<pre><code>// 有名字的函数\nfunction people () {}\n\n// 匿名函数\nconst people = function () {}</code></pre><h3 id=\"函数的参数类型和返回值类型\"><a href=\"#函数的参数类型和返回值类型\" class=\"headerlink\" title=\"函数的参数类型和返回值类型 \"></a>函数的参数类型和返回值类型 <br></h3><ul>\n<li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正</li>\n<li>设定了类型之后必须要返回相对应的类型，否则会报错</li>\n<li>如果函数没有返回任何值，也必须指定返回值类型为 void而不能留空<pre><code>/**\n* \n* @param {*} x number\n* @param {*} y number\n*  return add number \n*/\n</code></pre></li>\n</ul>\n<p>const add = (x: number, y: number): number =&gt; x + y;<br>// 书写完整的函数类型<br>const add: (x: number, y: number) =&gt; number = (x: number, y: number):number =&gt; x + y </p>\n<pre><code>\n### 函数的可选参数和默认参数&lt;br/&gt;\n- 传递给一个函数的参数个数必须与函数期望的参数个数一致，否则会报错\n- 可选参数用`?argname`表示，必须跟在必须参数后面\n- 没有传递参数或传递的值是undefined，这种叫做默认初始化值的参数\n- 所有必须参数**后面**的带默认初始化的参数都是可选的，调用时可省略\n- 带默认值的参数如果出现在必须参数**前面**，用户必须明确的传入 undefined 值来获得默认值\n- 当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）\n</code></pre><p>// 上述1<br>const add: (x: number, y: number) =&gt; number = (x: number, y: number):number =&gt; x + y<br>add(1, 2) // 3<br>add(1) // 报错<br>add(1,2,3) // 报错</p>\n<p>// 上述2<br>const yourName = (firstName: string, lastName?: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’)) // ren+undefined</p>\n<p>// 上述3<br>const yourName = (firstName: string, lastName?: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’, undefined)) // ren+undefined</p>\n<p>//上述4<br>const yourName = (firstName: string, lastName=’bo’): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’)) // ren+bo</p>\n<p>// 上述5<br>const yourName = ( lastName=’bo’, firstName: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //bo+ren<br>console.log(yourName(undefined, ‘ren’)) // ren+bo</p>\n<p>// 上述6<br>const people = ( name: string, …otherProperty: string[]): string =&gt; {<br>  return name + “ “ + otherProperty.join(“ “);<br>}<br>console.log(people(‘renbo’, ‘28’,’170’))  // renbo 28 170 </p>\n<pre><code>\n### 函数的重载 &lt;br/&gt;\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理\n</code></pre><p>// 我们来实现一下通过传入不同的 type 来实现函数的加操作和乘法操作并返回相应的类型<br>const compute = (type: number, …resetData: number[]):number | string =&gt; {<br>  if (type === 1 ) {<br>    return resetData.reduce((a:number, b:number):number =&gt; a + b);<br>  } else if (type === 2) {<br>    return String(resetData.reduce((a:number, b:number):number =&gt; a * b));<br>  }<br>}<br>console.log(compute(1, 3, 4, 5, 6)) // 18<br>console.log(compute(2, 3, 4, 5, 6)) // ‘360’</p>\n<p>// 通过上面的实现唯一的缺点就是不能明确通过type返回的相对应的计算的值和类型</p>\n<p>const compute = (type: number, …resetData: number[]):number;<br>const compute = (type: number, …resetData: number[]):string;<br>const compute = (type: number, …resetData: number[]):number | string =&gt; {<br>  if (type === 1 ) {<br>    return resetData.reduce((a:number, b:number):number =&gt; a + b);<br>  } else if (type === 2) {<br>    return String(resetData.reduce((a:number, b:number):number =&gt; a * b));<br>  }<br>}<br>console.log(compute(1, 3, 4, 5, 6)) // 18<br>console.log(compute(2, 3, 4, 5, 6)) // ‘360’</p>\n<p>// 上例中，我们重复定义了多次函数 compute，前几次都是函数定义，最后一次是函数实现。</p>\n<pre><code>\n\n\n</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"函数的创建\"><a href=\"#函数的创建\" class=\"headerlink\" title=\"函数的创建 \"></a>函数的创建 <br></h3><p>在 ts 中函数创建也氛围两种匿名函数和有命名的函数</p>\n<pre><code>// 有名字的函数\nfunction people () {}\n\n// 匿名函数\nconst people = function () {}</code></pre><h3 id=\"函数的参数类型和返回值类型\"><a href=\"#函数的参数类型和返回值类型\" class=\"headerlink\" title=\"函数的参数类型和返回值类型 \"></a>函数的参数类型和返回值类型 <br></h3><ul>\n<li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正</li>\n<li>设定了类型之后必须要返回相对应的类型，否则会报错</li>\n<li>如果函数没有返回任何值，也必须指定返回值类型为 void而不能留空<pre><code>/**\n* \n* @param {*} x number\n* @param {*} y number\n*  return add number \n*/\n</code></pre></li>\n</ul>\n<p>const add = (x: number, y: number): number =&gt; x + y;<br>// 书写完整的函数类型<br>const add: (x: number, y: number) =&gt; number = (x: number, y: number):number =&gt; x + y </p>\n<pre><code>\n### 函数的可选参数和默认参数&lt;br/&gt;\n- 传递给一个函数的参数个数必须与函数期望的参数个数一致，否则会报错\n- 可选参数用`?argname`表示，必须跟在必须参数后面\n- 没有传递参数或传递的值是undefined，这种叫做默认初始化值的参数\n- 所有必须参数**后面**的带默认初始化的参数都是可选的，调用时可省略\n- 带默认值的参数如果出现在必须参数**前面**，用户必须明确的传入 undefined 值来获得默认值\n- 当传入的参数个数不固定时，将所有参数收集到一个变量里和 js 中的 arguments 类似，剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个表达方式为（...）\n</code></pre><p>// 上述1<br>const add: (x: number, y: number) =&gt; number = (x: number, y: number):number =&gt; x + y<br>add(1, 2) // 3<br>add(1) // 报错<br>add(1,2,3) // 报错</p>\n<p>// 上述2<br>const yourName = (firstName: string, lastName?: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’)) // ren+undefined</p>\n<p>// 上述3<br>const yourName = (firstName: string, lastName?: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’, undefined)) // ren+undefined</p>\n<p>//上述4<br>const yourName = (firstName: string, lastName=’bo’): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //ren+bo<br>console.log(yourName(‘ren’)) // ren+bo</p>\n<p>// 上述5<br>const yourName = ( lastName=’bo’, firstName: string): string =&gt; <code>${firstName}+${lastName}</code>;<br>console.log(yourName(‘ren’, ‘bo’)) //bo+ren<br>console.log(yourName(undefined, ‘ren’)) // ren+bo</p>\n<p>// 上述6<br>const people = ( name: string, …otherProperty: string[]): string =&gt; {<br>  return name + “ “ + otherProperty.join(“ “);<br>}<br>console.log(people(‘renbo’, ‘28’,’170’))  // renbo 28 170 </p>\n<pre><code>\n### 函数的重载 &lt;br/&gt;\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理\n</code></pre><p>// 我们来实现一下通过传入不同的 type 来实现函数的加操作和乘法操作并返回相应的类型<br>const compute = (type: number, …resetData: number[]):number | string =&gt; {<br>  if (type === 1 ) {<br>    return resetData.reduce((a:number, b:number):number =&gt; a + b);<br>  } else if (type === 2) {<br>    return String(resetData.reduce((a:number, b:number):number =&gt; a * b));<br>  }<br>}<br>console.log(compute(1, 3, 4, 5, 6)) // 18<br>console.log(compute(2, 3, 4, 5, 6)) // ‘360’</p>\n<p>// 通过上面的实现唯一的缺点就是不能明确通过type返回的相对应的计算的值和类型</p>\n<p>const compute = (type: number, …resetData: number[]):number;<br>const compute = (type: number, …resetData: number[]):string;<br>const compute = (type: number, …resetData: number[]):number | string =&gt; {<br>  if (type === 1 ) {<br>    return resetData.reduce((a:number, b:number):number =&gt; a + b);<br>  } else if (type === 2) {<br>    return String(resetData.reduce((a:number, b:number):number =&gt; a * b));<br>  }<br>}<br>console.log(compute(1, 3, 4, 5, 6)) // 18<br>console.log(compute(2, 3, 4, 5, 6)) // ‘360’</p>\n<p>// 上例中，我们重复定义了多次函数 compute，前几次都是函数定义，最后一次是函数实现。</p>\n<pre><code>\n\n\n</code></pre>"},{"title":"泛型","date":"2019-05-22T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n泛型（Generics）就是不提前指定接口、变量、函数等的类型，在使用的时候再指定类型\n\n### 定义泛型 <br/>\n\n```\n// 定义类型\nfunction identity(arg: number): number {\n  return arg;\n}\n// 定义 any 类型\nfunction identity(arg: any): any {\n  return arg;\n}\n```\n\n如果所有的接口、变量、函数等都用 any 类型，那么写 TS 和写 JS 一样将失去意义，因为你可能像 JS 一样造成许多未知的错误，那么解决这样的问题我们使用一种特殊的变量T，来表示返回的内容。\n\n```\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\n### 调用泛型<br/>\n\n```\nlet output = identity<string>(\"myString\");\n```\n\n### 泛型约束<br/>\n\n在函数内部使用泛型变量的时候，因为不知道它是哪种类型，所以不能随意的操作它的属性或方法\n\n```\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);  // Error: T doesn't have .length\n  return arg;\n}\n```\n由于上面的泛型 T 中不一定包含属性.length, 所以会抛出异常。\n\n这时我们可以创建一个具有单个.length属性的接口，然后我们将使用此接口和extends关键字来表示我们的约束：\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\n```\n\n上面的例子如果在调用的时候传入的参数不符合定义的约束，那么就会抛出异常\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity(5) \n// Argument of type '5' is not assignable to parameter of type 'Lengthwise'\n\n```\n\n相反如果定义了正确的类型\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity([1,2]) // 2\nloggingIdentity({length: 5, value: 1}) // 5\n```\n\n### 泛型接口<br/>\n\n```\n// 定义泛型结构\ninterface CreatePeopleFunc {\n  <T>(name: string, age: T): Array<T>;\n}\n\n// 创建泛型\nlet createPeople:CreatePeopleFunc;\ncreatePeople = function<T>(name: string, age: T): Array<T> {\n  let people: T[] = []\n  let temp:any = {\n    name : name,\n    age: age\n  }\n  people.push(temp)\n  return people\n}\n// 调用函数\ncreatePeople('zhangsan', 28)\n```\n上面例子我们定义了一个泛型，创建了函数，在函数内创建数组并添加了一个元素 name, age\n\n### 泛型类<br/>\n\n泛型类具有与通用接口类似的形状。泛型类<>在类名称后面的尖括号（）中有一个泛型类型参数列表\n\n```\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n\n\n","source":"_posts/typescript/generics.md","raw":"---\ntitle: 泛型\ndate: 2019-05-22 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n泛型（Generics）就是不提前指定接口、变量、函数等的类型，在使用的时候再指定类型\n\n### 定义泛型 <br/>\n\n```\n// 定义类型\nfunction identity(arg: number): number {\n  return arg;\n}\n// 定义 any 类型\nfunction identity(arg: any): any {\n  return arg;\n}\n```\n\n如果所有的接口、变量、函数等都用 any 类型，那么写 TS 和写 JS 一样将失去意义，因为你可能像 JS 一样造成许多未知的错误，那么解决这样的问题我们使用一种特殊的变量T，来表示返回的内容。\n\n```\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\n### 调用泛型<br/>\n\n```\nlet output = identity<string>(\"myString\");\n```\n\n### 泛型约束<br/>\n\n在函数内部使用泛型变量的时候，因为不知道它是哪种类型，所以不能随意的操作它的属性或方法\n\n```\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);  // Error: T doesn't have .length\n  return arg;\n}\n```\n由于上面的泛型 T 中不一定包含属性.length, 所以会抛出异常。\n\n这时我们可以创建一个具有单个.length属性的接口，然后我们将使用此接口和extends关键字来表示我们的约束：\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\n```\n\n上面的例子如果在调用的时候传入的参数不符合定义的约束，那么就会抛出异常\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity(5) \n// Argument of type '5' is not assignable to parameter of type 'Lengthwise'\n\n```\n\n相反如果定义了正确的类型\n```\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity([1,2]) // 2\nloggingIdentity({length: 5, value: 1}) // 5\n```\n\n### 泛型接口<br/>\n\n```\n// 定义泛型结构\ninterface CreatePeopleFunc {\n  <T>(name: string, age: T): Array<T>;\n}\n\n// 创建泛型\nlet createPeople:CreatePeopleFunc;\ncreatePeople = function<T>(name: string, age: T): Array<T> {\n  let people: T[] = []\n  let temp:any = {\n    name : name,\n    age: age\n  }\n  people.push(temp)\n  return people\n}\n// 调用函数\ncreatePeople('zhangsan', 28)\n```\n上面例子我们定义了一个泛型，创建了函数，在函数内创建数组并添加了一个元素 name, age\n\n### 泛型类<br/>\n\n泛型类具有与通用接口类似的形状。泛型类<>在类名称后面的尖括号（）中有一个泛型类型参数列表\n\n```\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n\n\n","slug":"typescript/generics","published":1,"updated":"2019-10-15T01:29:42.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otm004kb0u6tc9aela9","content":"<p>泛型（Generics）就是不提前指定接口、变量、函数等的类型，在使用的时候再指定类型</p>\n<h3 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型 \"></a>定义泛型 <br></h3><pre><code>// 定义类型\nfunction identity(arg: number): number {\n  return arg;\n}\n// 定义 any 类型\nfunction identity(arg: any): any {\n  return arg;\n}</code></pre><p>如果所有的接口、变量、函数等都用 any 类型，那么写 TS 和写 JS 一样将失去意义，因为你可能像 JS 一样造成许多未知的错误，那么解决这样的问题我们使用一种特殊的变量T，来表示返回的内容。</p>\n<pre><code>function identity&lt;T&gt;(arg: T): T {\n  return arg;\n}</code></pre><h3 id=\"调用泛型\"><a href=\"#调用泛型\" class=\"headerlink\" title=\"调用泛型\"></a>调用泛型<br></h3><pre><code>let output = identity&lt;string&gt;(&quot;myString&quot;);</code></pre><h3 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束<br></h3><p>在函数内部使用泛型变量的时候，因为不知道它是哪种类型，所以不能随意的操作它的属性或方法</p>\n<pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {\n  console.log(arg.length);  // Error: T doesn&#39;t have .length\n  return arg;\n}</code></pre><p>由于上面的泛型 T 中不一定包含属性.length, 所以会抛出异常。</p>\n<p>这时我们可以创建一个具有单个.length属性的接口，然后我们将使用此接口和extends关键字来表示我们的约束：</p>\n<pre><code>interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n</code></pre><p>上面的例子如果在调用的时候传入的参数不符合定义的约束，那么就会抛出异常</p>\n<pre><code>interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity(5) \n// Argument of type &#39;5&#39; is not assignable to parameter of type &#39;Lengthwise&#39;\n</code></pre><p>相反如果定义了正确的类型</p>\n<pre><code>interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity([1,2]) // 2\nloggingIdentity({length: 5, value: 1}) // 5</code></pre><h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口<br></h3><pre><code>// 定义泛型结构\ninterface CreatePeopleFunc {\n  &lt;T&gt;(name: string, age: T): Array&lt;T&gt;;\n}\n\n// 创建泛型\nlet createPeople:CreatePeopleFunc;\ncreatePeople = function&lt;T&gt;(name: string, age: T): Array&lt;T&gt; {\n  let people: T[] = []\n  let temp:any = {\n    name : name,\n    age: age\n  }\n  people.push(temp)\n  return people\n}\n// 调用函数\ncreatePeople(&#39;zhangsan&#39;, 28)</code></pre><p>上面例子我们定义了一个泛型，创建了函数，在函数内创建数组并添加了一个元素 name, age</p>\n<h3 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类<br></h3><p>泛型类具有与通用接口类似的形状。泛型类&lt;&gt;在类名称后面的尖括号（）中有一个泛型类型参数列表</p>\n<pre><code>class GenericNumber&lt;T&gt; {\n    zeroValue: T;\n    add: (x: T, y: T) =&gt; T;\n}\n\nlet myGenericNumber = new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>泛型（Generics）就是不提前指定接口、变量、函数等的类型，在使用的时候再指定类型</p>\n<h3 id=\"定义泛型\"><a href=\"#定义泛型\" class=\"headerlink\" title=\"定义泛型 \"></a>定义泛型 <br></h3><pre><code>// 定义类型\nfunction identity(arg: number): number {\n  return arg;\n}\n// 定义 any 类型\nfunction identity(arg: any): any {\n  return arg;\n}</code></pre><p>如果所有的接口、变量、函数等都用 any 类型，那么写 TS 和写 JS 一样将失去意义，因为你可能像 JS 一样造成许多未知的错误，那么解决这样的问题我们使用一种特殊的变量T，来表示返回的内容。</p>\n<pre><code>function identity&lt;T&gt;(arg: T): T {\n  return arg;\n}</code></pre><h3 id=\"调用泛型\"><a href=\"#调用泛型\" class=\"headerlink\" title=\"调用泛型\"></a>调用泛型<br></h3><pre><code>let output = identity&lt;string&gt;(&quot;myString&quot;);</code></pre><h3 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束<br></h3><p>在函数内部使用泛型变量的时候，因为不知道它是哪种类型，所以不能随意的操作它的属性或方法</p>\n<pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {\n  console.log(arg.length);  // Error: T doesn&#39;t have .length\n  return arg;\n}</code></pre><p>由于上面的泛型 T 中不一定包含属性.length, 所以会抛出异常。</p>\n<p>这时我们可以创建一个具有单个.length属性的接口，然后我们将使用此接口和extends关键字来表示我们的约束：</p>\n<pre><code>interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n</code></pre><p>上面的例子如果在调用的时候传入的参数不符合定义的约束，那么就会抛出异常</p>\n<pre><code>interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity(5) \n// Argument of type &#39;5&#39; is not assignable to parameter of type &#39;Lengthwise&#39;\n</code></pre><p>相反如果定义了正确的类型</p>\n<pre><code>interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length); \n  return arg;\n}\n\nloggingIdentity([1,2]) // 2\nloggingIdentity({length: 5, value: 1}) // 5</code></pre><h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口<br></h3><pre><code>// 定义泛型结构\ninterface CreatePeopleFunc {\n  &lt;T&gt;(name: string, age: T): Array&lt;T&gt;;\n}\n\n// 创建泛型\nlet createPeople:CreatePeopleFunc;\ncreatePeople = function&lt;T&gt;(name: string, age: T): Array&lt;T&gt; {\n  let people: T[] = []\n  let temp:any = {\n    name : name,\n    age: age\n  }\n  people.push(temp)\n  return people\n}\n// 调用函数\ncreatePeople(&#39;zhangsan&#39;, 28)</code></pre><p>上面例子我们定义了一个泛型，创建了函数，在函数内创建数组并添加了一个元素 name, age</p>\n<h3 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类<br></h3><p>泛型类具有与通用接口类似的形状。泛型类&lt;&gt;在类名称后面的尖括号（）中有一个泛型类型参数列表</p>\n<pre><code>class GenericNumber&lt;T&gt; {\n    zeroValue: T;\n    add: (x: T, y: T) =&gt; T;\n}\n\nlet myGenericNumber = new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };</code></pre>"},{"title":"global.d.ts","date":"2019-08-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n```\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n    //~ We can write 'myLib.timeout = 50;'\n    let timeout: number;\n\n    //~ We can access 'myLib.version', but not change it\n    const version: string;\n\n    //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n    //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n    class Cat {\n        constructor(n: number);\n\n        //~ We can read 'c.age' from a 'Cat' instance\n        readonly age: number;\n\n        //~ We can invoke 'c.purr()' from a 'Cat' instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write 'const v: myLib.VetID = 42;'\n    //~  or 'const v: myLib.VetID = \"bob\";'\n    type VetID = string | number;\n\n    //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n    function checkCat(c: Cat, s?: VetID);\n}\n```","source":"_posts/typescript/global.d.ts.md","raw":"---\ntitle: global.d.ts\ndate:  2019-8-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n```\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n    //~ We can write 'myLib.timeout = 50;'\n    let timeout: number;\n\n    //~ We can access 'myLib.version', but not change it\n    const version: string;\n\n    //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n    //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n    class Cat {\n        constructor(n: number);\n\n        //~ We can read 'c.age' from a 'Cat' instance\n        readonly age: number;\n\n        //~ We can invoke 'c.purr()' from a 'Cat' instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write 'const v: myLib.VetID = 42;'\n    //~  or 'const v: myLib.VetID = \"bob\";'\n    type VetID = string | number;\n\n    //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n    function checkCat(c: Cat, s?: VetID);\n}\n```","slug":"typescript/global.d.ts","published":1,"updated":"2019-10-15T01:29:42.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otp004pb0u6rxm2ssng","content":"<pre><code>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write &#39;var x: myLib&#39;;\n *~ Be sure this actually makes sense! If it doesn&#39;t, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n    //~ We can write &#39;myLib.timeout = 50;&#39;\n    let timeout: number;\n\n    //~ We can access &#39;myLib.version&#39;, but not change it\n    const version: string;\n\n    //~ There&#39;s some class we can create via &#39;let c = new myLib.Cat(42)&#39;\n    //~ Or reference e.g. &#39;function f(c: myLib.Cat) { ... }\n    class Cat {\n        constructor(n: number);\n\n        //~ We can read &#39;c.age&#39; from a &#39;Cat&#39; instance\n        readonly age: number;\n\n        //~ We can invoke &#39;c.purr()&#39; from a &#39;Cat&#39; instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   &#39;var s: myLib.CatSettings = { weight: 5, name: &quot;Maru&quot; };&#39;\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write &#39;const v: myLib.VetID = 42;&#39;\n    //~  or &#39;const v: myLib.VetID = &quot;bob&quot;;&#39;\n    type VetID = string | number;\n\n    //~ We can invoke &#39;myLib.checkCat(c)&#39; or &#39;myLib.checkCat(c, v);&#39;\n    function checkCat(c: Cat, s?: VetID);\n}</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<pre><code>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write &#39;var x: myLib&#39;;\n *~ Be sure this actually makes sense! If it doesn&#39;t, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n    //~ We can write &#39;myLib.timeout = 50;&#39;\n    let timeout: number;\n\n    //~ We can access &#39;myLib.version&#39;, but not change it\n    const version: string;\n\n    //~ There&#39;s some class we can create via &#39;let c = new myLib.Cat(42)&#39;\n    //~ Or reference e.g. &#39;function f(c: myLib.Cat) { ... }\n    class Cat {\n        constructor(n: number);\n\n        //~ We can read &#39;c.age&#39; from a &#39;Cat&#39; instance\n        readonly age: number;\n\n        //~ We can invoke &#39;c.purr()&#39; from a &#39;Cat&#39; instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   &#39;var s: myLib.CatSettings = { weight: 5, name: &quot;Maru&quot; };&#39;\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write &#39;const v: myLib.VetID = 42;&#39;\n    //~  or &#39;const v: myLib.VetID = &quot;bob&quot;;&#39;\n    type VetID = string | number;\n\n    //~ We can invoke &#39;myLib.checkCat(c)&#39; or &#39;myLib.checkCat(c, v);&#39;\n    function checkCat(c: Cat, s?: VetID);\n}</code></pre>"},{"title":"接口","date":"2019-05-18T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n##\n\n在面向对象语言中接口 (Interfaces) 是对类的行为的抽象，在TypeScript中也常用于定义结构子类型，方便进行类型检查\n\n### 定义一个简单的接口<br/>\n```\ninterface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n  age: 25\n};\n\n```\n\n上面的例子我定义了一个接口 IPeople，并且定义了一个变量 zhangsan，它的类型是 IPerson，zhangsan的数据结构类型必须与 IPeople 一致否则会报错例如下面\n\n```\ninterface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n};\n\nProperty 'age' is missing in type '{ name: string; }' but required in type 'IPeople'\n```\n\n### 可选属性 <br/>\n\n当我们定义接口属性的时候不是必须的那么可选属性就起到了作用\n\n```\ninterface IPeople {\n  name: string;\n  age?: number\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n};\n```\n### 任意属性<br/>\n\n当我们需要定义或增加一些未知的属性，那么任意属性就起到了作用\n\n```\ninterface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: any;\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n  age: 28,\n  gender: 'm'\n};\n```\n上述例子中需要注意的是一旦定义了任意属性，那么可选属性和确定属性的类型必须是它的的类型的子集，否则会报错，例如\n\n```\ninterface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: string;\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n  age: 28,\n  gender: 'm'\n};\n\nType '{ name: string; age: number; gender: string; }' is not assignable to type 'IPeople'.\nProperty 'age' is incompatible with index signature.\nType 'number' is not assignable to type 'string'.\n```\n\n### 只读属性<br/>\n\n当我们需要对象中字段只能在创建的时候被赋值，那么只读属性就起到了作用\n\n```\ninterface IPerson {\n  readonly id: number;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet zhangsan: IPerson = {\n  id: 1,\n  name: 'zhangsan',\n  gender: 'm'\n};\n\nzhangsan.id = 2;\n\nCannot assign to 'id' because it is a read-only property.\n```\n\n### 可以为接口定义函数类型<br/>\n\n```\ninterface IPeople {\n  (name: string, age: number): string;\n}\n\nlet hello: IPeople;\nhello = function(name: string, age: number): string {\n  return `my name is ${name} I,m years old ${age}`\n}\n\nhello('zhangsan', 28) //my name is zhangsan I,m years old 28\n```\n\n\n上面简单的介绍了接口的基本用法，也就是对对象的结构进行性约定，接下来我们来用 Interface 对类的行为进行抽象\n\n### 用类实现接口<br/>\n\n用类实现接口主要应用的场景就是类与类之间有一些公有的功能及特性，要实现高度抽象这也是面向对象的基本。在 TypeScript 中用关键字 implements 去实现。\n\n\n```\n// 定义接口，接口中有一个公共的方法eat\ninterface People{\n  eat(food: string)\n}\n// 实现接口的方法\nclass Boy implements People {\n  constructor () {}\n  eat (food: string): string {\n   return food \n  }\n}\n// 实现接口方法\nclass Girl implements People {\n  constructor () {}\n  eat (food: string):string {\n    return food\n  }\n}\n\nlet boy = new Boy()\nconsole.log(boy.eat('apple'))\n\nlet girl = new Girl()\nconsole.log(girl.eat('banana'))\n\n```\n\n一个类也可以实现多个接口\n```\ninterface Eat{\n  food (food: string)\n}\ninterface Drink{\n  drink()\n}\n// 实现接口的方法\nclass People implements Eat, Drink {\n  constructor () {}\n  food (food: string): string {\n   return food \n  }\n  drink ():string {\n    return `小明跑步中吃${this.food('apple')}是不健康的`\n  }\n}\n\nlet people = new People()\nconsole.log(people.drink())\n```\n\n### 接口的继承<br/>\n\n在 JS ECMA6 中类的继承用 extends 关键字， 那么在 TS 中我们依然同样用这个关键字\n\n```\ninterface Eat {\n  eat ()\n}\n\ninterface People extends Eat {\n  eat()\n  run ()\n}\n\n```\n\n### 混合类型<br/>\n\n混合类型实际上就是在接口中存在多种规则，利用这种规则去实现自己的属性和方法\n\n```\n// 定义规则\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n// 实现规则\nfunction getCounter(): Counter {\n  \n  let counter = <Counter>function (start: number) { \n    console.log(start)\n  };\n\n  counter.interval = 0;\n\n  counter.reset = function () {\n    console.log('reset')\n  };\n\n  return counter;\n}\n\nlet counter = getCounter()\ncounter(20); // 20\ncounter.reset(); // reset \ncounter.interval = 5; // 5\n\n```\n\n","source":"_posts/typescript/interfaces.md","raw":"---\ntitle:  接口\ndate: 2019-05-18 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n##\n\n在面向对象语言中接口 (Interfaces) 是对类的行为的抽象，在TypeScript中也常用于定义结构子类型，方便进行类型检查\n\n### 定义一个简单的接口<br/>\n```\ninterface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n  age: 25\n};\n\n```\n\n上面的例子我定义了一个接口 IPeople，并且定义了一个变量 zhangsan，它的类型是 IPerson，zhangsan的数据结构类型必须与 IPeople 一致否则会报错例如下面\n\n```\ninterface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n};\n\nProperty 'age' is missing in type '{ name: string; }' but required in type 'IPeople'\n```\n\n### 可选属性 <br/>\n\n当我们定义接口属性的时候不是必须的那么可选属性就起到了作用\n\n```\ninterface IPeople {\n  name: string;\n  age?: number\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n};\n```\n### 任意属性<br/>\n\n当我们需要定义或增加一些未知的属性，那么任意属性就起到了作用\n\n```\ninterface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: any;\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n  age: 28,\n  gender: 'm'\n};\n```\n上述例子中需要注意的是一旦定义了任意属性，那么可选属性和确定属性的类型必须是它的的类型的子集，否则会报错，例如\n\n```\ninterface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: string;\n}\n\nlet zhangsan: IPeople = {\n  name: 'zhangsan',\n  age: 28,\n  gender: 'm'\n};\n\nType '{ name: string; age: number; gender: string; }' is not assignable to type 'IPeople'.\nProperty 'age' is incompatible with index signature.\nType 'number' is not assignable to type 'string'.\n```\n\n### 只读属性<br/>\n\n当我们需要对象中字段只能在创建的时候被赋值，那么只读属性就起到了作用\n\n```\ninterface IPerson {\n  readonly id: number;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet zhangsan: IPerson = {\n  id: 1,\n  name: 'zhangsan',\n  gender: 'm'\n};\n\nzhangsan.id = 2;\n\nCannot assign to 'id' because it is a read-only property.\n```\n\n### 可以为接口定义函数类型<br/>\n\n```\ninterface IPeople {\n  (name: string, age: number): string;\n}\n\nlet hello: IPeople;\nhello = function(name: string, age: number): string {\n  return `my name is ${name} I,m years old ${age}`\n}\n\nhello('zhangsan', 28) //my name is zhangsan I,m years old 28\n```\n\n\n上面简单的介绍了接口的基本用法，也就是对对象的结构进行性约定，接下来我们来用 Interface 对类的行为进行抽象\n\n### 用类实现接口<br/>\n\n用类实现接口主要应用的场景就是类与类之间有一些公有的功能及特性，要实现高度抽象这也是面向对象的基本。在 TypeScript 中用关键字 implements 去实现。\n\n\n```\n// 定义接口，接口中有一个公共的方法eat\ninterface People{\n  eat(food: string)\n}\n// 实现接口的方法\nclass Boy implements People {\n  constructor () {}\n  eat (food: string): string {\n   return food \n  }\n}\n// 实现接口方法\nclass Girl implements People {\n  constructor () {}\n  eat (food: string):string {\n    return food\n  }\n}\n\nlet boy = new Boy()\nconsole.log(boy.eat('apple'))\n\nlet girl = new Girl()\nconsole.log(girl.eat('banana'))\n\n```\n\n一个类也可以实现多个接口\n```\ninterface Eat{\n  food (food: string)\n}\ninterface Drink{\n  drink()\n}\n// 实现接口的方法\nclass People implements Eat, Drink {\n  constructor () {}\n  food (food: string): string {\n   return food \n  }\n  drink ():string {\n    return `小明跑步中吃${this.food('apple')}是不健康的`\n  }\n}\n\nlet people = new People()\nconsole.log(people.drink())\n```\n\n### 接口的继承<br/>\n\n在 JS ECMA6 中类的继承用 extends 关键字， 那么在 TS 中我们依然同样用这个关键字\n\n```\ninterface Eat {\n  eat ()\n}\n\ninterface People extends Eat {\n  eat()\n  run ()\n}\n\n```\n\n### 混合类型<br/>\n\n混合类型实际上就是在接口中存在多种规则，利用这种规则去实现自己的属性和方法\n\n```\n// 定义规则\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n// 实现规则\nfunction getCounter(): Counter {\n  \n  let counter = <Counter>function (start: number) { \n    console.log(start)\n  };\n\n  counter.interval = 0;\n\n  counter.reset = function () {\n    console.log('reset')\n  };\n\n  return counter;\n}\n\nlet counter = getCounter()\ncounter(20); // 20\ncounter.reset(); // reset \ncounter.interval = 5; // 5\n\n```\n\n","slug":"typescript/interfaces","published":1,"updated":"2019-10-15T01:29:42.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otr004qb0u6ne0nwoh9","content":"<p>##</p>\n<p>在面向对象语言中接口 (Interfaces) 是对类的行为的抽象，在TypeScript中也常用于定义结构子类型，方便进行类型检查</p>\n<h3 id=\"定义一个简单的接口\"><a href=\"#定义一个简单的接口\" class=\"headerlink\" title=\"定义一个简单的接口\"></a>定义一个简单的接口<br></h3><pre><code>interface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n  age: 25\n};\n</code></pre><p>上面的例子我定义了一个接口 IPeople，并且定义了一个变量 zhangsan，它的类型是 IPerson，zhangsan的数据结构类型必须与 IPeople 一致否则会报错例如下面</p>\n<pre><code>interface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n};\n\nProperty &#39;age&#39; is missing in type &#39;{ name: string; }&#39; but required in type &#39;IPeople&#39;</code></pre><h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性 \"></a>可选属性 <br></h3><p>当我们定义接口属性的时候不是必须的那么可选属性就起到了作用</p>\n<pre><code>interface IPeople {\n  name: string;\n  age?: number\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n};</code></pre><h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性<br></h3><p>当我们需要定义或增加一些未知的属性，那么任意属性就起到了作用</p>\n<pre><code>interface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: any;\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n  age: 28,\n  gender: &#39;m&#39;\n};</code></pre><p>上述例子中需要注意的是一旦定义了任意属性，那么可选属性和确定属性的类型必须是它的的类型的子集，否则会报错，例如</p>\n<pre><code>interface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: string;\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n  age: 28,\n  gender: &#39;m&#39;\n};\n\nType &#39;{ name: string; age: number; gender: string; }&#39; is not assignable to type &#39;IPeople&#39;.\nProperty &#39;age&#39; is incompatible with index signature.\nType &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性<br></h3><p>当我们需要对象中字段只能在创建的时候被赋值，那么只读属性就起到了作用</p>\n<pre><code>interface IPerson {\n  readonly id: number;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet zhangsan: IPerson = {\n  id: 1,\n  name: &#39;zhangsan&#39;,\n  gender: &#39;m&#39;\n};\n\nzhangsan.id = 2;\n\nCannot assign to &#39;id&#39; because it is a read-only property.</code></pre><h3 id=\"可以为接口定义函数类型\"><a href=\"#可以为接口定义函数类型\" class=\"headerlink\" title=\"可以为接口定义函数类型\"></a>可以为接口定义函数类型<br></h3><pre><code>interface IPeople {\n  (name: string, age: number): string;\n}\n\nlet hello: IPeople;\nhello = function(name: string, age: number): string {\n  return `my name is ${name} I,m years old ${age}`\n}\n\nhello(&#39;zhangsan&#39;, 28) //my name is zhangsan I,m years old 28</code></pre><p>上面简单的介绍了接口的基本用法，也就是对对象的结构进行性约定，接下来我们来用 Interface 对类的行为进行抽象</p>\n<h3 id=\"用类实现接口\"><a href=\"#用类实现接口\" class=\"headerlink\" title=\"用类实现接口\"></a>用类实现接口<br></h3><p>用类实现接口主要应用的场景就是类与类之间有一些公有的功能及特性，要实现高度抽象这也是面向对象的基本。在 TypeScript 中用关键字 implements 去实现。</p>\n<pre><code>// 定义接口，接口中有一个公共的方法eat\ninterface People{\n  eat(food: string)\n}\n// 实现接口的方法\nclass Boy implements People {\n  constructor () {}\n  eat (food: string): string {\n   return food \n  }\n}\n// 实现接口方法\nclass Girl implements People {\n  constructor () {}\n  eat (food: string):string {\n    return food\n  }\n}\n\nlet boy = new Boy()\nconsole.log(boy.eat(&#39;apple&#39;))\n\nlet girl = new Girl()\nconsole.log(girl.eat(&#39;banana&#39;))\n</code></pre><p>一个类也可以实现多个接口</p>\n<pre><code>interface Eat{\n  food (food: string)\n}\ninterface Drink{\n  drink()\n}\n// 实现接口的方法\nclass People implements Eat, Drink {\n  constructor () {}\n  food (food: string): string {\n   return food \n  }\n  drink ():string {\n    return `小明跑步中吃${this.food(&#39;apple&#39;)}是不健康的`\n  }\n}\n\nlet people = new People()\nconsole.log(people.drink())</code></pre><h3 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承<br></h3><p>在 JS ECMA6 中类的继承用 extends 关键字， 那么在 TS 中我们依然同样用这个关键字</p>\n<pre><code>interface Eat {\n  eat ()\n}\n\ninterface People extends Eat {\n  eat()\n  run ()\n}\n</code></pre><h3 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型<br></h3><p>混合类型实际上就是在接口中存在多种规则，利用这种规则去实现自己的属性和方法</p>\n<pre><code>// 定义规则\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n// 实现规则\nfunction getCounter(): Counter {\n\n  let counter = &lt;Counter&gt;function (start: number) { \n    console.log(start)\n  };\n\n  counter.interval = 0;\n\n  counter.reset = function () {\n    console.log(&#39;reset&#39;)\n  };\n\n  return counter;\n}\n\nlet counter = getCounter()\ncounter(20); // 20\ncounter.reset(); // reset \ncounter.interval = 5; // 5\n</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>##</p>\n<p>在面向对象语言中接口 (Interfaces) 是对类的行为的抽象，在TypeScript中也常用于定义结构子类型，方便进行类型检查</p>\n<h3 id=\"定义一个简单的接口\"><a href=\"#定义一个简单的接口\" class=\"headerlink\" title=\"定义一个简单的接口\"></a>定义一个简单的接口<br></h3><pre><code>interface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n  age: 25\n};\n</code></pre><p>上面的例子我定义了一个接口 IPeople，并且定义了一个变量 zhangsan，它的类型是 IPerson，zhangsan的数据结构类型必须与 IPeople 一致否则会报错例如下面</p>\n<pre><code>interface IPeople {\n  name: string;\n  age: number\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n};\n\nProperty &#39;age&#39; is missing in type &#39;{ name: string; }&#39; but required in type &#39;IPeople&#39;</code></pre><h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性 \"></a>可选属性 <br></h3><p>当我们定义接口属性的时候不是必须的那么可选属性就起到了作用</p>\n<pre><code>interface IPeople {\n  name: string;\n  age?: number\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n};</code></pre><h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性<br></h3><p>当我们需要定义或增加一些未知的属性，那么任意属性就起到了作用</p>\n<pre><code>interface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: any;\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n  age: 28,\n  gender: &#39;m&#39;\n};</code></pre><p>上述例子中需要注意的是一旦定义了任意属性，那么可选属性和确定属性的类型必须是它的的类型的子集，否则会报错，例如</p>\n<pre><code>interface IPeople {\n  name: string;\n  age?: number\n  [propName: string]: string;\n}\n\nlet zhangsan: IPeople = {\n  name: &#39;zhangsan&#39;,\n  age: 28,\n  gender: &#39;m&#39;\n};\n\nType &#39;{ name: string; age: number; gender: string; }&#39; is not assignable to type &#39;IPeople&#39;.\nProperty &#39;age&#39; is incompatible with index signature.\nType &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性<br></h3><p>当我们需要对象中字段只能在创建的时候被赋值，那么只读属性就起到了作用</p>\n<pre><code>interface IPerson {\n  readonly id: number;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet zhangsan: IPerson = {\n  id: 1,\n  name: &#39;zhangsan&#39;,\n  gender: &#39;m&#39;\n};\n\nzhangsan.id = 2;\n\nCannot assign to &#39;id&#39; because it is a read-only property.</code></pre><h3 id=\"可以为接口定义函数类型\"><a href=\"#可以为接口定义函数类型\" class=\"headerlink\" title=\"可以为接口定义函数类型\"></a>可以为接口定义函数类型<br></h3><pre><code>interface IPeople {\n  (name: string, age: number): string;\n}\n\nlet hello: IPeople;\nhello = function(name: string, age: number): string {\n  return `my name is ${name} I,m years old ${age}`\n}\n\nhello(&#39;zhangsan&#39;, 28) //my name is zhangsan I,m years old 28</code></pre><p>上面简单的介绍了接口的基本用法，也就是对对象的结构进行性约定，接下来我们来用 Interface 对类的行为进行抽象</p>\n<h3 id=\"用类实现接口\"><a href=\"#用类实现接口\" class=\"headerlink\" title=\"用类实现接口\"></a>用类实现接口<br></h3><p>用类实现接口主要应用的场景就是类与类之间有一些公有的功能及特性，要实现高度抽象这也是面向对象的基本。在 TypeScript 中用关键字 implements 去实现。</p>\n<pre><code>// 定义接口，接口中有一个公共的方法eat\ninterface People{\n  eat(food: string)\n}\n// 实现接口的方法\nclass Boy implements People {\n  constructor () {}\n  eat (food: string): string {\n   return food \n  }\n}\n// 实现接口方法\nclass Girl implements People {\n  constructor () {}\n  eat (food: string):string {\n    return food\n  }\n}\n\nlet boy = new Boy()\nconsole.log(boy.eat(&#39;apple&#39;))\n\nlet girl = new Girl()\nconsole.log(girl.eat(&#39;banana&#39;))\n</code></pre><p>一个类也可以实现多个接口</p>\n<pre><code>interface Eat{\n  food (food: string)\n}\ninterface Drink{\n  drink()\n}\n// 实现接口的方法\nclass People implements Eat, Drink {\n  constructor () {}\n  food (food: string): string {\n   return food \n  }\n  drink ():string {\n    return `小明跑步中吃${this.food(&#39;apple&#39;)}是不健康的`\n  }\n}\n\nlet people = new People()\nconsole.log(people.drink())</code></pre><h3 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承<br></h3><p>在 JS ECMA6 中类的继承用 extends 关键字， 那么在 TS 中我们依然同样用这个关键字</p>\n<pre><code>interface Eat {\n  eat ()\n}\n\ninterface People extends Eat {\n  eat()\n  run ()\n}\n</code></pre><h3 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型<br></h3><p>混合类型实际上就是在接口中存在多种规则，利用这种规则去实现自己的属性和方法</p>\n<pre><code>// 定义规则\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n// 实现规则\nfunction getCounter(): Counter {\n\n  let counter = &lt;Counter&gt;function (start: number) { \n    console.log(start)\n  };\n\n  counter.interval = 0;\n\n  counter.reset = function () {\n    console.log(&#39;reset&#39;)\n  };\n\n  return counter;\n}\n\nlet counter = getCounter()\ncounter(20); // 20\ncounter.reset(); // reset \ncounter.interval = 5; // 5\n</code></pre>"},{"title":"Mixinx","date":"2019-07-02T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n 一般情况下，我们已经习惯了用面向对象的继承方式，比如在 JS ES5中用 prototype， 在 ES6 和 TS 中 用extends,然而用 mixinx 也是一种通过可重用组件创建类的方式，来进行混用，混合多个类的方法到一个类上\n\n ### 应用例子\n\n```\n// Disposable Mixin\nclass Disposable {\n    isDisposed!: boolean;\n    dispose() {\n    console.log(this.isDisposed);\n    }\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive!: boolean;\n    activate() {\n       console.log(this.isActive)\n    }\n}\n\n// 没使用 extends 而是使用 implements\nclass SmartObject implements Disposable,Activatable {\n    // Disposable\n    isDisposed: boolean = false;\n    dispose!: () => void;\n    // Activatable\n    isActive: boolean = false;\n    activate!: () => void;\n}\n\n// mixins混入定义的类，完成全部实现部分\napplyMixins(SmartObject, [Disposable, Activatable]);\n\n\n// 创建 applyMixins 混用函数，作用是遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\nlet smartObject = new SmartObject()\n\nsmartObject.dispose() // false\nsmartObject.activate() // false\n\n```\n\n\n\n\n  ","source":"_posts/typescript/mixinx.md","raw":"---\ntitle:  Mixinx\ndate: 2019-7-02 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n 一般情况下，我们已经习惯了用面向对象的继承方式，比如在 JS ES5中用 prototype， 在 ES6 和 TS 中 用extends,然而用 mixinx 也是一种通过可重用组件创建类的方式，来进行混用，混合多个类的方法到一个类上\n\n ### 应用例子\n\n```\n// Disposable Mixin\nclass Disposable {\n    isDisposed!: boolean;\n    dispose() {\n    console.log(this.isDisposed);\n    }\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive!: boolean;\n    activate() {\n       console.log(this.isActive)\n    }\n}\n\n// 没使用 extends 而是使用 implements\nclass SmartObject implements Disposable,Activatable {\n    // Disposable\n    isDisposed: boolean = false;\n    dispose!: () => void;\n    // Activatable\n    isActive: boolean = false;\n    activate!: () => void;\n}\n\n// mixins混入定义的类，完成全部实现部分\napplyMixins(SmartObject, [Disposable, Activatable]);\n\n\n// 创建 applyMixins 混用函数，作用是遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\nlet smartObject = new SmartObject()\n\nsmartObject.dispose() // false\nsmartObject.activate() // false\n\n```\n\n\n\n\n  ","slug":"typescript/mixinx","published":1,"updated":"2019-10-15T01:29:42.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otu004vb0u6mwkt7eug","content":"<p> 一般情况下，我们已经习惯了用面向对象的继承方式，比如在 JS ES5中用 prototype， 在 ES6 和 TS 中 用extends,然而用 mixinx 也是一种通过可重用组件创建类的方式，来进行混用，混合多个类的方法到一个类上</p>\n<h3 id=\"应用例子\"><a href=\"#应用例子\" class=\"headerlink\" title=\"应用例子\"></a>应用例子</h3><pre><code>// Disposable Mixin\nclass Disposable {\n    isDisposed!: boolean;\n    dispose() {\n    console.log(this.isDisposed);\n    }\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive!: boolean;\n    activate() {\n       console.log(this.isActive)\n    }\n}\n\n// 没使用 extends 而是使用 implements\nclass SmartObject implements Disposable,Activatable {\n    // Disposable\n    isDisposed: boolean = false;\n    dispose!: () =&gt; void;\n    // Activatable\n    isActive: boolean = false;\n    activate!: () =&gt; void;\n}\n\n// mixins混入定义的类，完成全部实现部分\napplyMixins(SmartObject, [Disposable, Activatable]);\n\n\n// 创建 applyMixins 混用函数，作用是遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor =&gt; {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\nlet smartObject = new SmartObject()\n\nsmartObject.dispose() // false\nsmartObject.activate() // false\n</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p> 一般情况下，我们已经习惯了用面向对象的继承方式，比如在 JS ES5中用 prototype， 在 ES6 和 TS 中 用extends,然而用 mixinx 也是一种通过可重用组件创建类的方式，来进行混用，混合多个类的方法到一个类上</p>\n<h3 id=\"应用例子\"><a href=\"#应用例子\" class=\"headerlink\" title=\"应用例子\"></a>应用例子</h3><pre><code>// Disposable Mixin\nclass Disposable {\n    isDisposed!: boolean;\n    dispose() {\n    console.log(this.isDisposed);\n    }\n}\n\n// Activatable Mixin\nclass Activatable {\n    isActive!: boolean;\n    activate() {\n       console.log(this.isActive)\n    }\n}\n\n// 没使用 extends 而是使用 implements\nclass SmartObject implements Disposable,Activatable {\n    // Disposable\n    isDisposed: boolean = false;\n    dispose!: () =&gt; void;\n    // Activatable\n    isActive: boolean = false;\n    activate!: () =&gt; void;\n}\n\n// mixins混入定义的类，完成全部实现部分\napplyMixins(SmartObject, [Disposable, Activatable]);\n\n\n// 创建 applyMixins 混用函数，作用是遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor =&gt; {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\nlet smartObject = new SmartObject()\n\nsmartObject.dispose() // false\nsmartObject.activate() // false\n</code></pre>"},{"title":"class.d.ts","date":"2019-08-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note that ES6 modules cannot directly export class objects.\n *~ This file should be imported using the CommonJS-style:\n *~   import x = require('someLibrary');\n *~\n *~ Refer to the documentation to understand common\n *~ workarounds for this limitation of ES6 modules.\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myClassLib;\n\n/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */\nexport = MyClass;\n\n/*~ Write your module's methods and properties in this class */\ndeclare class MyClass {\n    constructor(someParam?: string);\n\n    someProperty: string[];\n\n    myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n */\ndeclare namespace MyClass {\n    export interface MyClassMethodOptions {\n        width?: number;\n        height?: number;\n    }\n}","source":"_posts/typescript/module-class.d.ts.md","raw":"---\ntitle: class.d.ts\ndate:  2019-8-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note that ES6 modules cannot directly export class objects.\n *~ This file should be imported using the CommonJS-style:\n *~   import x = require('someLibrary');\n *~\n *~ Refer to the documentation to understand common\n *~ workarounds for this limitation of ES6 modules.\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myClassLib;\n\n/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */\nexport = MyClass;\n\n/*~ Write your module's methods and properties in this class */\ndeclare class MyClass {\n    constructor(someParam?: string);\n\n    someProperty: string[];\n\n    myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n */\ndeclare namespace MyClass {\n    export interface MyClassMethodOptions {\n        width?: number;\n        height?: number;\n    }\n}","slug":"typescript/module-class.d.ts","published":1,"updated":"2019-10-15T01:29:42.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8otv004wb0u6gx0ceine","content":"<p>// Type definitions for [<del>THE LIBRARY NAME</del>] [<del>OPTIONAL VERSION NUMBER</del>]<br>// Project: [<del>THE PROJECT NAME</del>]<br>// Definitions by: [<del>YOUR NAME</del>] &lt;[<del>A URL FOR YOU</del>]&gt;</p>\n<p>/*~ This is the module template file for class modules.<br> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.<br> *~ For example, if you were writing a file for “super-greeter”, this<br> *~ file should be ‘super-greeter/index.d.ts’<br> */</p>\n<p>/*~ Note that ES6 modules cannot directly export class objects.<br> *~ This file should be imported using the CommonJS-style:<br> *~   import x = require(‘someLibrary’);<br> *~<br> *~ Refer to the documentation to understand common<br> *~ workarounds for this limitation of ES6 modules.<br> */</p>\n<p>/*~ If this module is a UMD module that exposes a global variable ‘myClassLib’ when<br> *~ loaded outside a module loader environment, declare that global here.<br> *~ Otherwise, delete this declaration.<br> */<br>export as namespace myClassLib;</p>\n<p>/*~ This declaration specifies that the class constructor function<br> *~ is the exported object from the file<br> */<br>export = MyClass;</p>\n<p>/*~ Write your module’s methods and properties in this class */<br>declare class MyClass {<br>    constructor(someParam?: string);</p>\n<pre><code>someProperty: string[];\n\nmyMethod(opts: MyClass.MyClassMethodOptions): number;</code></pre><p>}</p>\n<p>/*~ If you want to expose types from your module as well, you can<br> *~ place them in this block.<br> */<br>declare namespace MyClass {<br>    export interface MyClassMethodOptions {<br>        width?: number;<br>        height?: number;<br>    }<br>}</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>// Type definitions for [<del>THE LIBRARY NAME</del>] [<del>OPTIONAL VERSION NUMBER</del>]<br>// Project: [<del>THE PROJECT NAME</del>]<br>// Definitions by: [<del>YOUR NAME</del>] &lt;[<del>A URL FOR YOU</del>]&gt;</p>\n<p>/*~ This is the module template file for class modules.<br> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.<br> *~ For example, if you were writing a file for “super-greeter”, this<br> *~ file should be ‘super-greeter/index.d.ts’<br> */</p>\n<p>/*~ Note that ES6 modules cannot directly export class objects.<br> *~ This file should be imported using the CommonJS-style:<br> *~   import x = require(‘someLibrary’);<br> *~<br> *~ Refer to the documentation to understand common<br> *~ workarounds for this limitation of ES6 modules.<br> */</p>\n<p>/*~ If this module is a UMD module that exposes a global variable ‘myClassLib’ when<br> *~ loaded outside a module loader environment, declare that global here.<br> *~ Otherwise, delete this declaration.<br> */<br>export as namespace myClassLib;</p>\n<p>/*~ This declaration specifies that the class constructor function<br> *~ is the exported object from the file<br> */<br>export = MyClass;</p>\n<p>/*~ Write your module’s methods and properties in this class */<br>declare class MyClass {<br>    constructor(someParam?: string);</p>\n<pre><code>someProperty: string[];\n\nmyMethod(opts: MyClass.MyClassMethodOptions): number;</code></pre><p>}</p>\n<p>/*~ If you want to expose types from your module as well, you can<br> *~ place them in this block.<br> */<br>declare namespace MyClass {<br>    export interface MyClassMethodOptions {<br>        width?: number;<br>        height?: number;<br>    }<br>}</p>\n"},{"title":"module.d.ts","date":"2019-08-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n```\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module has methods, declare them as functions like so.\n */\nexport function myMethod(a: string): string;\nexport function myOtherMethod(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface someType {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n\n/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a 'namespace'.\n */\nexport namespace subProp {\n    /*~ For example, given this definition, someone could write:\n     *~   import { subProp } from 'yourModule';\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from 'yourModule';\n     *~   yourMod.subProp.foo();\n     */\n    export function foo(): void;\n}\n```","source":"_posts/typescript/module.d.ts.md","raw":"---\ntitle: module.d.ts\ndate: 2019-8-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n```\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module has methods, declare them as functions like so.\n */\nexport function myMethod(a: string): string;\nexport function myOtherMethod(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface someType {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n\n/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a 'namespace'.\n */\nexport namespace subProp {\n    /*~ For example, given this definition, someone could write:\n     *~   import { subProp } from 'yourModule';\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from 'yourModule';\n     *~   yourMod.subProp.foo();\n     */\n    export function foo(): void;\n}\n```","slug":"typescript/module.d.ts","published":1,"updated":"2019-10-15T01:29:42.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ou10050b0u6nt7v4t4r","content":"<pre><code>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for &quot;super-greeter&quot;, this\n *~ file should be &#39;super-greeter/index.d.ts&#39;\n */\n\n/*~ If this module is a UMD module that exposes a global variable &#39;myLib&#39; when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module has methods, declare them as functions like so.\n */\nexport function myMethod(a: string): string;\nexport function myOtherMethod(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface someType {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n\n/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a &#39;namespace&#39;.\n */\nexport namespace subProp {\n    /*~ For example, given this definition, someone could write:\n     *~   import { subProp } from &#39;yourModule&#39;;\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from &#39;yourModule&#39;;\n     *~   yourMod.subProp.foo();\n     */\n    export function foo(): void;\n}</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<pre><code>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for &quot;super-greeter&quot;, this\n *~ file should be &#39;super-greeter/index.d.ts&#39;\n */\n\n/*~ If this module is a UMD module that exposes a global variable &#39;myLib&#39; when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module has methods, declare them as functions like so.\n */\nexport function myMethod(a: string): string;\nexport function myOtherMethod(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface someType {\n    name: string;\n    length: number;\n    extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n\n/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a &#39;namespace&#39;.\n */\nexport namespace subProp {\n    /*~ For example, given this definition, someone could write:\n     *~   import { subProp } from &#39;yourModule&#39;;\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from &#39;yourModule&#39;;\n     *~   yourMod.subProp.foo();\n     */\n    export function foo(): void;\n}</code></pre>"},{"title":"function.d.ts","date":"2019-08-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note that ES6 modules cannot directly export callable functions.\n *~ This file should be imported using the CommonJS-style:\n *~   import x = require('someLibrary');\n *~\n *~ Refer to the documentation to understand common\n *~ workarounds for this limitation of ES6 modules.\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myFuncLib;\n\n/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */\nexport = MyFunction;\n\n/*~ This example shows how to have multiple overloads for your function */\ndeclare function MyFunction(name: string): MyFunction.NamedReturnType;\ndeclare function MyFunction(length: number): MyFunction.LengthReturnType;\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n */\ndeclare namespace MyFunction {\n    export interface LengthReturnType {\n        width: number;\n        height: number;\n    }\n    export interface NamedReturnType {\n        firstName: string;\n        lastName: string;\n    }\n\n    /*~ If the module also has properties, declare them here. For example,\n     *~ this declaration says that this code is legal:\n     *~   import f = require('myFuncLibrary');\n     *~   console.log(f.defaultName);\n     */\n    export const defaultName: string;\n    export let defaultLength: number;\n}","source":"_posts/typescript/module-function.d.ts.md","raw":"---\ntitle: function.d.ts\ndate:  2019-8-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note that ES6 modules cannot directly export callable functions.\n *~ This file should be imported using the CommonJS-style:\n *~   import x = require('someLibrary');\n *~\n *~ Refer to the documentation to understand common\n *~ workarounds for this limitation of ES6 modules.\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myFuncLib;\n\n/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */\nexport = MyFunction;\n\n/*~ This example shows how to have multiple overloads for your function */\ndeclare function MyFunction(name: string): MyFunction.NamedReturnType;\ndeclare function MyFunction(length: number): MyFunction.LengthReturnType;\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n */\ndeclare namespace MyFunction {\n    export interface LengthReturnType {\n        width: number;\n        height: number;\n    }\n    export interface NamedReturnType {\n        firstName: string;\n        lastName: string;\n    }\n\n    /*~ If the module also has properties, declare them here. For example,\n     *~ this declaration says that this code is legal:\n     *~   import f = require('myFuncLibrary');\n     *~   console.log(f.defaultName);\n     */\n    export const defaultName: string;\n    export let defaultLength: number;\n}","slug":"typescript/module-function.d.ts","published":1,"updated":"2019-10-15T01:29:42.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ou30052b0u6y6nc2ojl","content":"<p>// Type definitions for [<del>THE LIBRARY NAME</del>] [<del>OPTIONAL VERSION NUMBER</del>]<br>// Project: [<del>THE PROJECT NAME</del>]<br>// Definitions by: [<del>YOUR NAME</del>] &lt;[<del>A URL FOR YOU</del>]&gt;</p>\n<p>/*~ This is the module template file for function modules.<br> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.<br> *~ For example, if you were writing a file for “super-greeter”, this<br> *~ file should be ‘super-greeter/index.d.ts’<br> */</p>\n<p>/*~ Note that ES6 modules cannot directly export callable functions.<br> *~ This file should be imported using the CommonJS-style:<br> *~   import x = require(‘someLibrary’);<br> *~<br> *~ Refer to the documentation to understand common<br> *~ workarounds for this limitation of ES6 modules.<br> */</p>\n<p>/*~ If this module is a UMD module that exposes a global variable ‘myFuncLib’ when<br> *~ loaded outside a module loader environment, declare that global here.<br> *~ Otherwise, delete this declaration.<br> */<br>export as namespace myFuncLib;</p>\n<p>/*~ This declaration specifies that the function<br> *~ is the exported object from the file<br> */<br>export = MyFunction;</p>\n<p>/*~ This example shows how to have multiple overloads for your function */<br>declare function MyFunction(name: string): MyFunction.NamedReturnType;<br>declare function MyFunction(length: number): MyFunction.LengthReturnType;</p>\n<p>/*~ If you want to expose types from your module as well, you can<br> *~ place them in this block. Often you will want to describe the<br> *~ shape of the return type of the function; that type should<br> *~ be declared in here, as this example shows.<br> */<br>declare namespace MyFunction {<br>    export interface LengthReturnType {<br>        width: number;<br>        height: number;<br>    }<br>    export interface NamedReturnType {<br>        firstName: string;<br>        lastName: string;<br>    }</p>\n<pre><code>/*~ If the module also has properties, declare them here. For example,\n *~ this declaration says that this code is legal:\n *~   import f = require(&#39;myFuncLibrary&#39;);\n *~   console.log(f.defaultName);\n */\nexport const defaultName: string;\nexport let defaultLength: number;</code></pre><p>}</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>// Type definitions for [<del>THE LIBRARY NAME</del>] [<del>OPTIONAL VERSION NUMBER</del>]<br>// Project: [<del>THE PROJECT NAME</del>]<br>// Definitions by: [<del>YOUR NAME</del>] &lt;[<del>A URL FOR YOU</del>]&gt;</p>\n<p>/*~ This is the module template file for function modules.<br> *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.<br> *~ For example, if you were writing a file for “super-greeter”, this<br> *~ file should be ‘super-greeter/index.d.ts’<br> */</p>\n<p>/*~ Note that ES6 modules cannot directly export callable functions.<br> *~ This file should be imported using the CommonJS-style:<br> *~   import x = require(‘someLibrary’);<br> *~<br> *~ Refer to the documentation to understand common<br> *~ workarounds for this limitation of ES6 modules.<br> */</p>\n<p>/*~ If this module is a UMD module that exposes a global variable ‘myFuncLib’ when<br> *~ loaded outside a module loader environment, declare that global here.<br> *~ Otherwise, delete this declaration.<br> */<br>export as namespace myFuncLib;</p>\n<p>/*~ This declaration specifies that the function<br> *~ is the exported object from the file<br> */<br>export = MyFunction;</p>\n<p>/*~ This example shows how to have multiple overloads for your function */<br>declare function MyFunction(name: string): MyFunction.NamedReturnType;<br>declare function MyFunction(length: number): MyFunction.LengthReturnType;</p>\n<p>/*~ If you want to expose types from your module as well, you can<br> *~ place them in this block. Often you will want to describe the<br> *~ shape of the return type of the function; that type should<br> *~ be declared in here, as this example shows.<br> */<br>declare namespace MyFunction {<br>    export interface LengthReturnType {<br>        width: number;<br>        height: number;<br>    }<br>    export interface NamedReturnType {<br>        firstName: string;<br>        lastName: string;<br>    }</p>\n<pre><code>/*~ If the module also has properties, declare them here. For example,\n *~ this declaration says that this code is legal:\n *~   import f = require(&#39;myFuncLibrary&#39;);\n *~   console.log(f.defaultName);\n */\nexport const defaultName: string;\nexport let defaultLength: number;</code></pre><p>}</p>\n"},{"title":"模块与命名空间","date":"2019-06-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n在 JS 中 有 module 模块机制，和 TS 类似，在 TS 中内部模块命名空间为关键字namespaces。外部模块现在只是modules\n\n### 使用命名空间 <br/>\n- 命名空间只是全局命名空间中的JavaScript对象\n- 使用 namespace 关键字\n- 跨多个文件，并且可以使用连接--outFile\n- 不使用require关键字\n\n**1.单文件命名空间**\n  ```\n  namespace Validation {\n    export interface StringValidator {\n      isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n  }\n  ```\n**2.多文件命名空间及引入**\n\nValidation.ts\n```\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\nLettersOnlyValidator.ts\n```\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}\n```\nZipCodeValidator.ts\n```\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n```\nTest.ts\n```\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\n  }\n}\n```\n\n涉及多个文件，我们需要确保加载所有已编译的代码。有两种方法可以做到这一点。\n\n1. **--outFile 编译器将根据文件中存在的引用标记自动排序输出文件**\n  ```\n  tsc --outFile sample.js Test.ts\n  ```\n2. **为每一个文件编译一个 JS 文件利用 Script 按照顺序引入**\n  ```\n  <script src=\"Validation.js\" type=\"text/javascript\" />\n  <script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n  <script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n  <script src=\"Test.js\" type=\"text/javascript\" />\n  ```\n\n### 使用模块 <br/>\n- 模块在自己的范围内执行，而不是在全局范围内执行\n- 模块中声明的变量，函数，类等在模块外部不可见,除非使用其中一个export显式导出\n- 模块是声明性的; 模块之间的关系是根据文件级别的导入和导出来指定的\n- 模块文件之间引用用关键字 import 或被 export\n\n**1.使用 export 关键字来导出声明**\n\n单模块导出\n```\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n重命名导出\n```\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };\n```\n导出所有模块\n```\nexport * from \"./StringValidator\";\n\nexport * from \"./ZipCodeValidator\";\n```\n\n**2.使用 import 关键字来导入声明**\n\n从模块导入单个导出\n```\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\n\nlet myValidator = new ZipCodeValidator();\n```\n\n重命名导入\n```\nimport { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();\n```\n\n将整个模块导入单个变量，并使用它来访问模块导出\n```\nimport * as validator from \"./ZipCodeValidator\";\n\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n仅使用这个文件\n```\nimport \"./my-module.js\";\n```\n**3.模块的代码生成**\n\n编译器将为Node.js（CommonJS），require.js（AMD），UMD，SystemJS或ECMAScript 2015本机模块（ES6）模块加载系统生成适当的代码\n\n编译 commonjs 规范\n```\ntsc --module commonjs Test.ts\n```\n\n编译 amd 规范\n```\ntsc --module amd Test.ts\n```\n\n","source":"_posts/typescript/module.md","raw":"---\ntitle:  模块与命名空间\ndate: 2019-6-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n在 JS 中 有 module 模块机制，和 TS 类似，在 TS 中内部模块命名空间为关键字namespaces。外部模块现在只是modules\n\n### 使用命名空间 <br/>\n- 命名空间只是全局命名空间中的JavaScript对象\n- 使用 namespace 关键字\n- 跨多个文件，并且可以使用连接--outFile\n- 不使用require关键字\n\n**1.单文件命名空间**\n  ```\n  namespace Validation {\n    export interface StringValidator {\n      isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n  }\n  ```\n**2.多文件命名空间及引入**\n\nValidation.ts\n```\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\nLettersOnlyValidator.ts\n```\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}\n```\nZipCodeValidator.ts\n```\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n```\nTest.ts\n```\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\n  }\n}\n```\n\n涉及多个文件，我们需要确保加载所有已编译的代码。有两种方法可以做到这一点。\n\n1. **--outFile 编译器将根据文件中存在的引用标记自动排序输出文件**\n  ```\n  tsc --outFile sample.js Test.ts\n  ```\n2. **为每一个文件编译一个 JS 文件利用 Script 按照顺序引入**\n  ```\n  <script src=\"Validation.js\" type=\"text/javascript\" />\n  <script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n  <script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n  <script src=\"Test.js\" type=\"text/javascript\" />\n  ```\n\n### 使用模块 <br/>\n- 模块在自己的范围内执行，而不是在全局范围内执行\n- 模块中声明的变量，函数，类等在模块外部不可见,除非使用其中一个export显式导出\n- 模块是声明性的; 模块之间的关系是根据文件级别的导入和导出来指定的\n- 模块文件之间引用用关键字 import 或被 export\n\n**1.使用 export 关键字来导出声明**\n\n单模块导出\n```\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n重命名导出\n```\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };\n```\n导出所有模块\n```\nexport * from \"./StringValidator\";\n\nexport * from \"./ZipCodeValidator\";\n```\n\n**2.使用 import 关键字来导入声明**\n\n从模块导入单个导出\n```\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\n\nlet myValidator = new ZipCodeValidator();\n```\n\n重命名导入\n```\nimport { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();\n```\n\n将整个模块导入单个变量，并使用它来访问模块导出\n```\nimport * as validator from \"./ZipCodeValidator\";\n\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n仅使用这个文件\n```\nimport \"./my-module.js\";\n```\n**3.模块的代码生成**\n\n编译器将为Node.js（CommonJS），require.js（AMD），UMD，SystemJS或ECMAScript 2015本机模块（ES6）模块加载系统生成适当的代码\n\n编译 commonjs 规范\n```\ntsc --module commonjs Test.ts\n```\n\n编译 amd 规范\n```\ntsc --module amd Test.ts\n```\n\n","slug":"typescript/module","published":1,"updated":"2019-10-15T01:29:42.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ou60056b0u66ksmlfsl","content":"<p>在 JS 中 有 module 模块机制，和 TS 类似，在 TS 中内部模块命名空间为关键字namespaces。外部模块现在只是modules</p>\n<h3 id=\"使用命名空间\"><a href=\"#使用命名空间\" class=\"headerlink\" title=\"使用命名空间 \"></a>使用命名空间 <br></h3><ul>\n<li>命名空间只是全局命名空间中的JavaScript对象</li>\n<li>使用 namespace 关键字</li>\n<li>跨多个文件，并且可以使用连接–outFile</li>\n<li>不使用require关键字</li>\n</ul>\n<p><strong>1.单文件命名空间</strong></p>\n<pre><code>  namespace Validation {\n    export interface StringValidator {\n      isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 &amp;&amp; numberRegexp.test(s);\n        }\n    }\n  }</code></pre><p><strong>2.多文件命名空间及引入</strong></p>\n<p>Validation.ts</p>\n<pre><code>namespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}</code></pre><p>LettersOnlyValidator.ts</p>\n<pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}</code></pre><p>ZipCodeValidator.ts</p>\n<pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 &amp;&amp; numberRegexp.test(s);\n        }\n    }\n}</code></pre><p>Test.ts</p>\n<pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;\n/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;\n/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;\n\n// Some samples to try\nlet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();\nvalidators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`&quot;${ s }&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${ name }`);\n  }\n}</code></pre><p>涉及多个文件，我们需要确保加载所有已编译的代码。有两种方法可以做到这一点。</p>\n<ol>\n<li><strong>–outFile 编译器将根据文件中存在的引用标记自动排序输出文件</strong><pre><code>tsc --outFile sample.js Test.ts</code></pre></li>\n<li><strong>为每一个文件编译一个 JS 文件利用 Script 按照顺序引入</strong><pre><code>&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;\n&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;\n&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;\n&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</code></pre></li>\n</ol>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块 \"></a>使用模块 <br></h3><ul>\n<li>模块在自己的范围内执行，而不是在全局范围内执行</li>\n<li>模块中声明的变量，函数，类等在模块外部不可见,除非使用其中一个export显式导出</li>\n<li>模块是声明性的; 模块之间的关系是根据文件级别的导入和导出来指定的</li>\n<li>模块文件之间引用用关键字 import 或被 export</li>\n</ul>\n<p><strong>1.使用 export 关键字来导出声明</strong></p>\n<p>单模块导出</p>\n<pre><code>export interface StringValidator {\n  isAcceptable(s: string): boolean;\n}</code></pre><p>重命名导出</p>\n<pre><code>class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };</code></pre><p>导出所有模块</p>\n<pre><code>export * from &quot;./StringValidator&quot;;\n\nexport * from &quot;./ZipCodeValidator&quot;;</code></pre><p><strong>2.使用 import 关键字来导入声明</strong></p>\n<p>从模块导入单个导出</p>\n<pre><code>import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;;\n\nlet myValidator = new ZipCodeValidator();</code></pre><p>重命名导入</p>\n<pre><code>import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;;\nlet myValidator = new ZCV();</code></pre><p>将整个模块导入单个变量，并使用它来访问模块导出</p>\n<pre><code>import * as validator from &quot;./ZipCodeValidator&quot;;\n\nlet myValidator = new validator.ZipCodeValidator();</code></pre><p>仅使用这个文件</p>\n<pre><code>import &quot;./my-module.js&quot;;</code></pre><p><strong>3.模块的代码生成</strong></p>\n<p>编译器将为Node.js（CommonJS），require.js（AMD），UMD，SystemJS或ECMAScript 2015本机模块（ES6）模块加载系统生成适当的代码</p>\n<p>编译 commonjs 规范</p>\n<pre><code>tsc --module commonjs Test.ts</code></pre><p>编译 amd 规范</p>\n<pre><code>tsc --module amd Test.ts</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在 JS 中 有 module 模块机制，和 TS 类似，在 TS 中内部模块命名空间为关键字namespaces。外部模块现在只是modules</p>\n<h3 id=\"使用命名空间\"><a href=\"#使用命名空间\" class=\"headerlink\" title=\"使用命名空间 \"></a>使用命名空间 <br></h3><ul>\n<li>命名空间只是全局命名空间中的JavaScript对象</li>\n<li>使用 namespace 关键字</li>\n<li>跨多个文件，并且可以使用连接–outFile</li>\n<li>不使用require关键字</li>\n</ul>\n<p><strong>1.单文件命名空间</strong></p>\n<pre><code>  namespace Validation {\n    export interface StringValidator {\n      isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 &amp;&amp; numberRegexp.test(s);\n        }\n    }\n  }</code></pre><p><strong>2.多文件命名空间及引入</strong></p>\n<p>Validation.ts</p>\n<pre><code>namespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}</code></pre><p>LettersOnlyValidator.ts</p>\n<pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}</code></pre><p>ZipCodeValidator.ts</p>\n<pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 &amp;&amp; numberRegexp.test(s);\n        }\n    }\n}</code></pre><p>Test.ts</p>\n<pre><code>/// &lt;reference path=&quot;Validation.ts&quot; /&gt;\n/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;\n/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;\n\n// Some samples to try\nlet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();\nvalidators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`&quot;${ s }&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${ name }`);\n  }\n}</code></pre><p>涉及多个文件，我们需要确保加载所有已编译的代码。有两种方法可以做到这一点。</p>\n<ol>\n<li><strong>–outFile 编译器将根据文件中存在的引用标记自动排序输出文件</strong><pre><code>tsc --outFile sample.js Test.ts</code></pre></li>\n<li><strong>为每一个文件编译一个 JS 文件利用 Script 按照顺序引入</strong><pre><code>&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;\n&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;\n&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;\n&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</code></pre></li>\n</ol>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块 \"></a>使用模块 <br></h3><ul>\n<li>模块在自己的范围内执行，而不是在全局范围内执行</li>\n<li>模块中声明的变量，函数，类等在模块外部不可见,除非使用其中一个export显式导出</li>\n<li>模块是声明性的; 模块之间的关系是根据文件级别的导入和导出来指定的</li>\n<li>模块文件之间引用用关键字 import 或被 export</li>\n</ul>\n<p><strong>1.使用 export 关键字来导出声明</strong></p>\n<p>单模块导出</p>\n<pre><code>export interface StringValidator {\n  isAcceptable(s: string): boolean;\n}</code></pre><p>重命名导出</p>\n<pre><code>class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };</code></pre><p>导出所有模块</p>\n<pre><code>export * from &quot;./StringValidator&quot;;\n\nexport * from &quot;./ZipCodeValidator&quot;;</code></pre><p><strong>2.使用 import 关键字来导入声明</strong></p>\n<p>从模块导入单个导出</p>\n<pre><code>import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;;\n\nlet myValidator = new ZipCodeValidator();</code></pre><p>重命名导入</p>\n<pre><code>import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;;\nlet myValidator = new ZCV();</code></pre><p>将整个模块导入单个变量，并使用它来访问模块导出</p>\n<pre><code>import * as validator from &quot;./ZipCodeValidator&quot;;\n\nlet myValidator = new validator.ZipCodeValidator();</code></pre><p>仅使用这个文件</p>\n<pre><code>import &quot;./my-module.js&quot;;</code></pre><p><strong>3.模块的代码生成</strong></p>\n<p>编译器将为Node.js（CommonJS），require.js（AMD），UMD，SystemJS或ECMAScript 2015本机模块（ES6）模块加载系统生成适当的代码</p>\n<p>编译 commonjs 规范</p>\n<pre><code>tsc --module commonjs Test.ts</code></pre><p>编译 amd 规范</p>\n<pre><code>tsc --module amd Test.ts</code></pre>"},{"title":"tsconfig.json","date":"2019-07-15T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## \n\n如果一个目录下存在一个tsconfig.json文件，它会把一个文件夹转换为项目，也意味着这个目录是TypeScript项目的根目录\n\n### 使用tsconfig.json\n\n初始化 tsconfig.json 或者手动建立文件tsconfig.json\n```\ntsc --init\n```\n\n如果项目配置了tsconfig.json，那么在进行转换的时候可以在命令行直接输入\n```\ntsc \n```\n编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录\n\n否则就需要在编译时加上文件及目录\n```\ntsc test.ts\n```\n默认在当前目录生成test.js\n\n\n### 编写需要的配置项\n\n下面这个例子是列举了在项目中经常用到的配置，当前根据项目的不同会有区别\n\n```\n{\n\n  \"compileOnSave\": true, //让IDE在保存文件的时候根据tsconfig.json重新生成文件\n  \"compilerOptions\": {\n    \"target\": \"ES5\", // 目标代码类型版本\n    \"outDir\":\"build/\", // 重定向输出目录\n    \"baseUrl\":  \"https://test.file.com\", // 解析非相对模块名的基准目录\n    \"noImplicitAny\":true, // 在表达式和声明上有隐含的'any'类型时报错\n    \"removeComments\":true, //编译 js 的时候，删除掉注释\n    \"preserveConstEnums\":true, // 保留const和enum声明\n    \"experimentalDecorators\": true, // 使用装饰器要开始此选项\n    \"emitDecoratorMetadata\": true, // 在使用reflect-metadata库时候需要添加，给源码里的装饰器声明加上设计类型元数据\n    \"declaration\": true, // 编译时候是否同时产生一份 声明文件\n    \"strict\": true, // 编译时开启严格模式\n    \"sourceMap\": true, // 生成相应的.map文件\n    \"module\": \"commonjs\", //生成哪种模块系统代码\n    \"watch\": true, //会在文件改变时候监视输出文件，重新进行编译\n    \n  },\n  \"include\": [ // 编译时包含的目录及文件\n    \"test.ts\" \n  ],\n  \"exclude\": [ // 编译时排除的目录及文件\n    \"node_modules\", \n    \"dist\",  \n    \"mock\"\n    \"build\"\n  ],\n  \"lib\": [ // 需编译过程中需要引入的库文件的列表，不然编译器识别错误报错\n    \"es2017\",\n    \"dom\"\n  ]\n}\n```\n\n*注意使用\"include\"引入的文件可以使用\"exclude\"属性过滤。 然而，通过 \"files\"属性明确指定的文件不管\"exclude\"如何设置却总是会被包含在内。 如果没有特殊指定， \"exclude\"默认情况下会排除node_modules，bower_components，jspm_packages和outDir目录。*\n\n更多参数请参考官网<a href=\"https://www.tslang.cn/docs/handbook/compiler-options.html\"> tsconfig配置列表 </a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/typescript/tsConfig.md","raw":"---\ntitle: tsconfig.json\ndate:  2019-7-15 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n## \n\n如果一个目录下存在一个tsconfig.json文件，它会把一个文件夹转换为项目，也意味着这个目录是TypeScript项目的根目录\n\n### 使用tsconfig.json\n\n初始化 tsconfig.json 或者手动建立文件tsconfig.json\n```\ntsc --init\n```\n\n如果项目配置了tsconfig.json，那么在进行转换的时候可以在命令行直接输入\n```\ntsc \n```\n编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录\n\n否则就需要在编译时加上文件及目录\n```\ntsc test.ts\n```\n默认在当前目录生成test.js\n\n\n### 编写需要的配置项\n\n下面这个例子是列举了在项目中经常用到的配置，当前根据项目的不同会有区别\n\n```\n{\n\n  \"compileOnSave\": true, //让IDE在保存文件的时候根据tsconfig.json重新生成文件\n  \"compilerOptions\": {\n    \"target\": \"ES5\", // 目标代码类型版本\n    \"outDir\":\"build/\", // 重定向输出目录\n    \"baseUrl\":  \"https://test.file.com\", // 解析非相对模块名的基准目录\n    \"noImplicitAny\":true, // 在表达式和声明上有隐含的'any'类型时报错\n    \"removeComments\":true, //编译 js 的时候，删除掉注释\n    \"preserveConstEnums\":true, // 保留const和enum声明\n    \"experimentalDecorators\": true, // 使用装饰器要开始此选项\n    \"emitDecoratorMetadata\": true, // 在使用reflect-metadata库时候需要添加，给源码里的装饰器声明加上设计类型元数据\n    \"declaration\": true, // 编译时候是否同时产生一份 声明文件\n    \"strict\": true, // 编译时开启严格模式\n    \"sourceMap\": true, // 生成相应的.map文件\n    \"module\": \"commonjs\", //生成哪种模块系统代码\n    \"watch\": true, //会在文件改变时候监视输出文件，重新进行编译\n    \n  },\n  \"include\": [ // 编译时包含的目录及文件\n    \"test.ts\" \n  ],\n  \"exclude\": [ // 编译时排除的目录及文件\n    \"node_modules\", \n    \"dist\",  \n    \"mock\"\n    \"build\"\n  ],\n  \"lib\": [ // 需编译过程中需要引入的库文件的列表，不然编译器识别错误报错\n    \"es2017\",\n    \"dom\"\n  ]\n}\n```\n\n*注意使用\"include\"引入的文件可以使用\"exclude\"属性过滤。 然而，通过 \"files\"属性明确指定的文件不管\"exclude\"如何设置却总是会被包含在内。 如果没有特殊指定， \"exclude\"默认情况下会排除node_modules，bower_components，jspm_packages和outDir目录。*\n\n更多参数请参考官网<a href=\"https://www.tslang.cn/docs/handbook/compiler-options.html\"> tsconfig配置列表 </a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"typescript/tsConfig","published":1,"updated":"2019-10-15T01:29:42.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ou80058b0u6ayo9ztga","content":"<p>## </p>\n<p>如果一个目录下存在一个tsconfig.json文件，它会把一个文件夹转换为项目，也意味着这个目录是TypeScript项目的根目录</p>\n<h3 id=\"使用tsconfig-json\"><a href=\"#使用tsconfig-json\" class=\"headerlink\" title=\"使用tsconfig.json\"></a>使用tsconfig.json</h3><p>初始化 tsconfig.json 或者手动建立文件tsconfig.json</p>\n<pre><code>tsc --init</code></pre><p>如果项目配置了tsconfig.json，那么在进行转换的时候可以在命令行直接输入</p>\n<pre><code>tsc </code></pre><p>编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录</p>\n<p>否则就需要在编译时加上文件及目录</p>\n<pre><code>tsc test.ts</code></pre><p>默认在当前目录生成test.js</p>\n<h3 id=\"编写需要的配置项\"><a href=\"#编写需要的配置项\" class=\"headerlink\" title=\"编写需要的配置项\"></a>编写需要的配置项</h3><p>下面这个例子是列举了在项目中经常用到的配置，当前根据项目的不同会有区别</p>\n<pre><code>{\n\n  &quot;compileOnSave&quot;: true, //让IDE在保存文件的时候根据tsconfig.json重新生成文件\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES5&quot;, // 目标代码类型版本\n    &quot;outDir&quot;:&quot;build/&quot;, // 重定向输出目录\n    &quot;baseUrl&quot;:  &quot;https://test.file.com&quot;, // 解析非相对模块名的基准目录\n    &quot;noImplicitAny&quot;:true, // 在表达式和声明上有隐含的&#39;any&#39;类型时报错\n    &quot;removeComments&quot;:true, //编译 js 的时候，删除掉注释\n    &quot;preserveConstEnums&quot;:true, // 保留const和enum声明\n    &quot;experimentalDecorators&quot;: true, // 使用装饰器要开始此选项\n    &quot;emitDecoratorMetadata&quot;: true, // 在使用reflect-metadata库时候需要添加，给源码里的装饰器声明加上设计类型元数据\n    &quot;declaration&quot;: true, // 编译时候是否同时产生一份 声明文件\n    &quot;strict&quot;: true, // 编译时开启严格模式\n    &quot;sourceMap&quot;: true, // 生成相应的.map文件\n    &quot;module&quot;: &quot;commonjs&quot;, //生成哪种模块系统代码\n    &quot;watch&quot;: true, //会在文件改变时候监视输出文件，重新进行编译\n\n  },\n  &quot;include&quot;: [ // 编译时包含的目录及文件\n    &quot;test.ts&quot; \n  ],\n  &quot;exclude&quot;: [ // 编译时排除的目录及文件\n    &quot;node_modules&quot;, \n    &quot;dist&quot;,  \n    &quot;mock&quot;\n    &quot;build&quot;\n  ],\n  &quot;lib&quot;: [ // 需编译过程中需要引入的库文件的列表，不然编译器识别错误报错\n    &quot;es2017&quot;,\n    &quot;dom&quot;\n  ]\n}</code></pre><p><em>注意使用”include”引入的文件可以使用”exclude”属性过滤。 然而，通过 “files”属性明确指定的文件不管”exclude”如何设置却总是会被包含在内。 如果没有特殊指定， “exclude”默认情况下会排除node_modules，bower_components，jspm_packages和outDir目录。</em></p>\n<p>更多参数请参考官网<a href=\"https://www.tslang.cn/docs/handbook/compiler-options.html\" target=\"_blank\" rel=\"noopener\"> tsconfig配置列表 </a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>## </p>\n<p>如果一个目录下存在一个tsconfig.json文件，它会把一个文件夹转换为项目，也意味着这个目录是TypeScript项目的根目录</p>\n<h3 id=\"使用tsconfig-json\"><a href=\"#使用tsconfig-json\" class=\"headerlink\" title=\"使用tsconfig.json\"></a>使用tsconfig.json</h3><p>初始化 tsconfig.json 或者手动建立文件tsconfig.json</p>\n<pre><code>tsc --init</code></pre><p>如果项目配置了tsconfig.json，那么在进行转换的时候可以在命令行直接输入</p>\n<pre><code>tsc </code></pre><p>编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录</p>\n<p>否则就需要在编译时加上文件及目录</p>\n<pre><code>tsc test.ts</code></pre><p>默认在当前目录生成test.js</p>\n<h3 id=\"编写需要的配置项\"><a href=\"#编写需要的配置项\" class=\"headerlink\" title=\"编写需要的配置项\"></a>编写需要的配置项</h3><p>下面这个例子是列举了在项目中经常用到的配置，当前根据项目的不同会有区别</p>\n<pre><code>{\n\n  &quot;compileOnSave&quot;: true, //让IDE在保存文件的时候根据tsconfig.json重新生成文件\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES5&quot;, // 目标代码类型版本\n    &quot;outDir&quot;:&quot;build/&quot;, // 重定向输出目录\n    &quot;baseUrl&quot;:  &quot;https://test.file.com&quot;, // 解析非相对模块名的基准目录\n    &quot;noImplicitAny&quot;:true, // 在表达式和声明上有隐含的&#39;any&#39;类型时报错\n    &quot;removeComments&quot;:true, //编译 js 的时候，删除掉注释\n    &quot;preserveConstEnums&quot;:true, // 保留const和enum声明\n    &quot;experimentalDecorators&quot;: true, // 使用装饰器要开始此选项\n    &quot;emitDecoratorMetadata&quot;: true, // 在使用reflect-metadata库时候需要添加，给源码里的装饰器声明加上设计类型元数据\n    &quot;declaration&quot;: true, // 编译时候是否同时产生一份 声明文件\n    &quot;strict&quot;: true, // 编译时开启严格模式\n    &quot;sourceMap&quot;: true, // 生成相应的.map文件\n    &quot;module&quot;: &quot;commonjs&quot;, //生成哪种模块系统代码\n    &quot;watch&quot;: true, //会在文件改变时候监视输出文件，重新进行编译\n\n  },\n  &quot;include&quot;: [ // 编译时包含的目录及文件\n    &quot;test.ts&quot; \n  ],\n  &quot;exclude&quot;: [ // 编译时排除的目录及文件\n    &quot;node_modules&quot;, \n    &quot;dist&quot;,  \n    &quot;mock&quot;\n    &quot;build&quot;\n  ],\n  &quot;lib&quot;: [ // 需编译过程中需要引入的库文件的列表，不然编译器识别错误报错\n    &quot;es2017&quot;,\n    &quot;dom&quot;\n  ]\n}</code></pre><p><em>注意使用”include”引入的文件可以使用”exclude”属性过滤。 然而，通过 “files”属性明确指定的文件不管”exclude”如何设置却总是会被包含在内。 如果没有特殊指定， “exclude”默认情况下会排除node_modules，bower_components，jspm_packages和outDir目录。</em></p>\n<p>更多参数请参考官网<a href=\"https://www.tslang.cn/docs/handbook/compiler-options.html\" target=\"_blank\" rel=\"noopener\"> tsconfig配置列表 </a></p>\n"},{"title":"vue 原理之异步组件","date":"2019-09-10T10:06:25.000Z","top":false,"cover":false,"password":null,"toc":false,"mathjax":false,"summary":null,"_content":"\n在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，有三种实现方式\n\n- 普通的异步组件\n\n```js \nVue.component('async-example', function (resolve, reject) {\n   // 这个特殊的 require 语法告诉 webpack\n   // 自动将编译后的代码分割成不同的块，\n   // 这些块将通过 Ajax 请求自动下载。\n   require(['./my-async-component'], resolve)\n})\n```\n\n- Promise 异步组件\n\n```js\nVue.component(\n  'async-webpack-example',\n  // 该 `import` 函数返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n```\n\n- 高级异步组件\n\n```js\nconst AsyncComp = () => ({\n  // 需要加载的组件。应当是一个 Promise\n  component: import('./MyComp.vue'),\n  // 加载中应当渲染的组件\n  loading: LoadingComp,\n  // 出错时渲染的组件\n  error: ErrorComp,\n  // 渲染加载中组件前的等待时间。默认：200ms。\n  delay: 200,\n  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity\n  timeout: 3000\n})\nVue.component('async-example', AsyncComp)\n```\n\n通过上面的例子，我们知道异步组件的注册不再是一个对象，而是一个工厂函数，所以不会执行 Vue.extend 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 createComponent 函数，通过createComponent 方法执行 `Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)`, 它的定义在 `src/core/vdom/helpers/resolve-async-component.js` 中\n\n```js\nexport function resolveAsyncComponent (\n  factory: Function,\n  baseCtor: Class<Component>,\n  context: Component\n): Class<Component> | void {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context)\n  } else {\n    const contexts = factory.contexts = [context]\n    let sync = true\n\n    const forceRender = () => {\n      for (let i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate()\n      }\n    }\n\n    const resolve = once((res: Object | Class<Component>) => {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor)\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender()\n      }\n    })\n\n    const reject = once(reason => {\n      process.env.NODE_ENV !== 'production' && warn(\n        `Failed to resolve async component: ${String(factory)}` +\n        (reason ? `\\nReason: ${reason}` : '')\n      )\n      if (isDef(factory.errorComp)) {\n        factory.error = true\n        forceRender()\n      }\n    })\n\n    const res = factory(resolve, reject)\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject)\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject)\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor)\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor)\n          if (res.delay === 0) {\n            factory.loading = true\n          } else {\n            setTimeout(() => {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true\n                forceRender()\n              }\n            }, res.delay || 200)\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(() => {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? `timeout (${res.timeout}ms)`\n                  : null\n              )\n            }\n          }, res.timeout)\n        }\n      }\n    }\n\n    sync = false\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n```\n\n通过上面代码我们很直观的可以看到异步组件定义了 forceRender、resolve 和 reject 函数来执行异步组件。如果异步组件执行成功就会执行 resolve 函数，再通过 forceUpdate 的逻辑调用渲染 watcher 的 update 方法，让渲染 watcher 对应的回调函数执行，强制触发了组件的重新渲染。因为异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。这样其实异步组件本质是两次渲染。如果失败或者是错误则执行 reject 函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue/vueAsync-component.md","raw":"---\ntitle: vue 原理之异步组件\ndate: 2019-09-10 18:06:25\ntop: false\ncover: false\npassword:\ntoc: false\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，有三种实现方式\n\n- 普通的异步组件\n\n```js \nVue.component('async-example', function (resolve, reject) {\n   // 这个特殊的 require 语法告诉 webpack\n   // 自动将编译后的代码分割成不同的块，\n   // 这些块将通过 Ajax 请求自动下载。\n   require(['./my-async-component'], resolve)\n})\n```\n\n- Promise 异步组件\n\n```js\nVue.component(\n  'async-webpack-example',\n  // 该 `import` 函数返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n```\n\n- 高级异步组件\n\n```js\nconst AsyncComp = () => ({\n  // 需要加载的组件。应当是一个 Promise\n  component: import('./MyComp.vue'),\n  // 加载中应当渲染的组件\n  loading: LoadingComp,\n  // 出错时渲染的组件\n  error: ErrorComp,\n  // 渲染加载中组件前的等待时间。默认：200ms。\n  delay: 200,\n  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity\n  timeout: 3000\n})\nVue.component('async-example', AsyncComp)\n```\n\n通过上面的例子，我们知道异步组件的注册不再是一个对象，而是一个工厂函数，所以不会执行 Vue.extend 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 createComponent 函数，通过createComponent 方法执行 `Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)`, 它的定义在 `src/core/vdom/helpers/resolve-async-component.js` 中\n\n```js\nexport function resolveAsyncComponent (\n  factory: Function,\n  baseCtor: Class<Component>,\n  context: Component\n): Class<Component> | void {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context)\n  } else {\n    const contexts = factory.contexts = [context]\n    let sync = true\n\n    const forceRender = () => {\n      for (let i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate()\n      }\n    }\n\n    const resolve = once((res: Object | Class<Component>) => {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor)\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender()\n      }\n    })\n\n    const reject = once(reason => {\n      process.env.NODE_ENV !== 'production' && warn(\n        `Failed to resolve async component: ${String(factory)}` +\n        (reason ? `\\nReason: ${reason}` : '')\n      )\n      if (isDef(factory.errorComp)) {\n        factory.error = true\n        forceRender()\n      }\n    })\n\n    const res = factory(resolve, reject)\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject)\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject)\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor)\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor)\n          if (res.delay === 0) {\n            factory.loading = true\n          } else {\n            setTimeout(() => {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true\n                forceRender()\n              }\n            }, res.delay || 200)\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(() => {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? `timeout (${res.timeout}ms)`\n                  : null\n              )\n            }\n          }, res.timeout)\n        }\n      }\n    }\n\n    sync = false\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n```\n\n通过上面代码我们很直观的可以看到异步组件定义了 forceRender、resolve 和 reject 函数来执行异步组件。如果异步组件执行成功就会执行 resolve 函数，再通过 forceUpdate 的逻辑调用渲染 watcher 的 update 方法，让渲染 watcher 对应的回调函数执行，强制触发了组件的重新渲染。因为异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。这样其实异步组件本质是两次渲染。如果失败或者是错误则执行 reject 函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue/vueAsync-component","published":1,"updated":"2019-10-15T01:29:42.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oub005cb0u644djvslp","content":"<p>在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，有三种实现方式</p>\n<ul>\n<li>普通的异步组件</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async-example'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\" spellcheck=\"true\">// 这个特殊的 require 语法告诉 webpack</span>\n   <span class=\"token comment\" spellcheck=\"true\">// 自动将编译后的代码分割成不同的块，</span>\n   <span class=\"token comment\" spellcheck=\"true\">// 这些块将通过 Ajax 请求自动下载。</span>\n   <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'./my-async-component'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>Promise 异步组件</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span>\n  <span class=\"token string\">'async-webpack-example'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 该 `import` 函数返回一个 `Promise` 对象。</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./my-async-component'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>高级异步组件</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> AsyncComp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 需要加载的组件。应当是一个 Promise</span>\n  component<span class=\"token punctuation\">:</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./MyComp.vue'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 加载中应当渲染的组件</span>\n  loading<span class=\"token punctuation\">:</span> LoadingComp<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 出错时渲染的组件</span>\n  error<span class=\"token punctuation\">:</span> ErrorComp<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 渲染加载中组件前的等待时间。默认：200ms。</span>\n  delay<span class=\"token punctuation\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span>\n  timeout<span class=\"token punctuation\">:</span> <span class=\"token number\">3000</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async-example'</span><span class=\"token punctuation\">,</span> AsyncComp<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的例子，我们知道异步组件的注册不再是一个对象，而是一个工厂函数，所以不会执行 Vue.extend 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 createComponent 函数，通过createComponent 方法执行 <code>Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</code>, 它的定义在 <code>src/core/vdom/helpers/resolve-async-component.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> resolveAsyncComponent <span class=\"token punctuation\">(</span>\n  factory<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span>\n  baseCtor<span class=\"token punctuation\">:</span> Class<span class=\"token operator\">&lt;</span>Component<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  context<span class=\"token punctuation\">:</span> Component\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Class<span class=\"token operator\">&lt;</span>Component<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>errorComp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">.</span>errorComp\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>resolved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">.</span>resolved\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>loading<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>loadingComp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">.</span>loadingComp\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>contexts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// already pending</span>\n    factory<span class=\"token punctuation\">.</span>contexts<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> contexts <span class=\"token operator\">=</span> factory<span class=\"token punctuation\">.</span>contexts <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>context<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">let</span> sync <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n    <span class=\"token keyword\">const</span> forceRender <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> contexts<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        contexts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">$forceUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">const</span> resolve <span class=\"token operator\">=</span> <span class=\"token function\">once</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">:</span> Object <span class=\"token operator\">|</span> Class<span class=\"token operator\">&lt;</span>Component<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// cache resolved</span>\n      factory<span class=\"token punctuation\">.</span>resolved <span class=\"token operator\">=</span> <span class=\"token function\">ensureCtor</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> baseCtor<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// invoke callbacks only if this is not a synchronous resolve</span>\n      <span class=\"token comment\" spellcheck=\"true\">// (async resolves are shimmed as synchronous during SSR)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>sync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">forceRender</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">const</span> reject <span class=\"token operator\">=</span> <span class=\"token function\">once</span><span class=\"token punctuation\">(</span>reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n        <span class=\"token template-string\"><span class=\"token string\">`Failed to resolve async component: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">String</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span> <span class=\"token operator\">+</span>\n        <span class=\"token punctuation\">(</span>reason <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token string\">`\\nReason: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>reason<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span> <span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>errorComp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        factory<span class=\"token punctuation\">.</span>error <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        <span class=\"token function\">forceRender</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">factory</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isObject</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> res<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// () => Promise</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>resolved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          res<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> res<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        res<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          factory<span class=\"token punctuation\">.</span>errorComp <span class=\"token operator\">=</span> <span class=\"token function\">ensureCtor</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">,</span> baseCtor<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>loading<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          factory<span class=\"token punctuation\">.</span>loadingComp <span class=\"token operator\">=</span> <span class=\"token function\">ensureCtor</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>loading<span class=\"token punctuation\">,</span> baseCtor<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>delay <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            factory<span class=\"token punctuation\">.</span>loading <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>resolved<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                factory<span class=\"token punctuation\">.</span>loading <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n                <span class=\"token function\">forceRender</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">.</span>delay <span class=\"token operator\">||</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">.</span>resolved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>\n                process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span>\n                  <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token string\">`timeout (</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>res<span class=\"token punctuation\">.</span>timeout<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">ms)`</span></span>\n                  <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n              <span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">.</span>timeout<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    sync <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token comment\" spellcheck=\"true\">// return in case resolved synchronously</span>\n    <span class=\"token keyword\">return</span> factory<span class=\"token punctuation\">.</span>loading\n      <span class=\"token operator\">?</span> factory<span class=\"token punctuation\">.</span>loadingComp\n      <span class=\"token punctuation\">:</span> factory<span class=\"token punctuation\">.</span>resolved\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码我们很直观的可以看到异步组件定义了 forceRender、resolve 和 reject 函数来执行异步组件。如果异步组件执行成功就会执行 resolve 函数，再通过 forceUpdate 的逻辑调用渲染 watcher 的 update 方法，让渲染 watcher 对应的回调函数执行，强制触发了组件的重新渲染。因为异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。这样其实异步组件本质是两次渲染。如果失败或者是错误则执行 reject 函数</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，有三种实现方式</p>\n<ul>\n<li>普通的异步组件</li>\n</ul>\n<pre><code class=\"js\">Vue.component(&#39;async-example&#39;, function (resolve, reject) {\n   // 这个特殊的 require 语法告诉 webpack\n   // 自动将编译后的代码分割成不同的块，\n   // 这些块将通过 Ajax 请求自动下载。\n   require([&#39;./my-async-component&#39;], resolve)\n})</code></pre>\n<ul>\n<li>Promise 异步组件</li>\n</ul>\n<pre><code class=\"js\">Vue.component(\n  &#39;async-webpack-example&#39;,\n  // 该 `import` 函数返回一个 `Promise` 对象。\n  () =&gt; import(&#39;./my-async-component&#39;)\n)</code></pre>\n<ul>\n<li>高级异步组件</li>\n</ul>\n<pre><code class=\"js\">const AsyncComp = () =&gt; ({\n  // 需要加载的组件。应当是一个 Promise\n  component: import(&#39;./MyComp.vue&#39;),\n  // 加载中应当渲染的组件\n  loading: LoadingComp,\n  // 出错时渲染的组件\n  error: ErrorComp,\n  // 渲染加载中组件前的等待时间。默认：200ms。\n  delay: 200,\n  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity\n  timeout: 3000\n})\nVue.component(&#39;async-example&#39;, AsyncComp)</code></pre>\n<p>通过上面的例子，我们知道异步组件的注册不再是一个对象，而是一个工厂函数，所以不会执行 Vue.extend 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 createComponent 函数，通过createComponent 方法执行 <code>Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</code>, 它的定义在 <code>src/core/vdom/helpers/resolve-async-component.js</code> 中</p>\n<pre><code class=\"js\">export function resolveAsyncComponent (\n  factory: Function,\n  baseCtor: Class&lt;Component&gt;,\n  context: Component\n): Class&lt;Component&gt; | void {\n  if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context)\n  } else {\n    const contexts = factory.contexts = [context]\n    let sync = true\n\n    const forceRender = () =&gt; {\n      for (let i = 0, l = contexts.length; i &lt; l; i++) {\n        contexts[i].$forceUpdate()\n      }\n    }\n\n    const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor)\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender()\n      }\n    })\n\n    const reject = once(reason =&gt; {\n      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n        `Failed to resolve async component: ${String(factory)}` +\n        (reason ? `\\nReason: ${reason}` : &#39;&#39;)\n      )\n      if (isDef(factory.errorComp)) {\n        factory.error = true\n        forceRender()\n      }\n    })\n\n    const res = factory(resolve, reject)\n\n    if (isObject(res)) {\n      if (typeof res.then === &#39;function&#39;) {\n        // () =&gt; Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject)\n        }\n      } else if (isDef(res.component) &amp;&amp; typeof res.component.then === &#39;function&#39;) {\n        res.component.then(resolve, reject)\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor)\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor)\n          if (res.delay === 0) {\n            factory.loading = true\n          } else {\n            setTimeout(() =&gt; {\n              if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) {\n                factory.loading = true\n                forceRender()\n              }\n            }, res.delay || 200)\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(() =&gt; {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== &#39;production&#39;\n                  ? `timeout (${res.timeout}ms)`\n                  : null\n              )\n            }\n          }, res.timeout)\n        }\n      }\n    }\n\n    sync = false\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}</code></pre>\n<p>通过上面代码我们很直观的可以看到异步组件定义了 forceRender、resolve 和 reject 函数来执行异步组件。如果异步组件执行成功就会执行 resolve 函数，再通过 forceUpdate 的逻辑调用渲染 watcher 的 update 方法，让渲染 watcher 对应的回调函数执行，强制触发了组件的重新渲染。因为异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。这样其实异步组件本质是两次渲染。如果失败或者是错误则执行 reject 函数</p>\n"},{"title":"vue 原理之组件注册","date":"2019-09-08T04:08:25.000Z","top":false,"cover":false,"password":null,"toc":false,"mathjax":false,"summary":null,"_content":"\n在日常开发中我们经常会用到许多自定义的组件，除了内置组件自定义组件用的时候必须注册，否则会提示如下信息\n\n```md\n'Unknown custom element: <xxx> - did you register the component correctly?\n For recursive components, make sure to provide the \"name\" option.'\n```\n\n在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\">官网</a>中提到组件组册的方式分为全局和局部\n\n### 全局注册\n\n```js\nVue.component('my-component-name', {\n  // ... 选项 ...\n})\n```\n\n官方文档中有这样一句话 **全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生** ，那么代码被定义在 `src/core/global-api/assets.js ` 中\n\n```js\nimport { ASSET_TYPES } from 'shared/constants'\nimport { isPlainObject, validateComponentName } from '../util/index'\n\nexport function initAssetRegisters (Vue: GlobalAPI) {\n  // 创建注册的方法\n  ASSET_TYPES.forEach(type => {\n    Vue[type] = function (\n      id: string,\n      definition: Function | Object\n    ): Function | Object | void {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id)\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id\n          definition = this.options._base.extend(definition)\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition }\n        }\n        this.options[type + 's'][id] = definition\n        return definition\n      }\n    }\n  })\n}\n```\n遍历 ASSET_TYPES，得到 type 后挂载到 Vue 上，定义在 `src/shared/constants.js` 中\n\n```js\nexport const ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n]\n```\n\n实际上 vue 是初始化了3个全局函数，那么对于 component 来说是使用 Vue.extend 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 `this.options[type + 's'][id] = definition` 把它挂载到 `Vue.options.components` 上。然后在通过 mergeOptions 进行参数合并，最后在创建 vnode 的时候执行 _createElement 方法，定义在 `src/core/vdom/create-element.js` 中\n```js\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n  // ...\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // ...\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n    // ...\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  // ...\n}\n```\n\n通过 _createElement  方法中的 resolveAsset 拿到这个组件的构造函数，并作为 createComponent 的钩子的参数\n\n```js\nexport function resolveAsset (\n  options: Object,\n  type: string,\n  id: string,\n  warnMissing?: boolean\n): any {\n  // 组件名称必须是字符串\n  if (typeof id !== 'string') {\n    return\n  }\n  const assets = options[type]\n  // 检查本地的注册变量\n  if (hasOwn(assets, id)) return assets[id]\n  const camelizedId = camelize(id)\n  if (hasOwn(assets, camelizedId)) return assets[camelizedId]\n  const PascalCaseId = capitalize(camelizedId)\n  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]\n  // 如果条件都满足那么返回标志，进行 createComponent\n  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    )\n  }\n  return res\n}\n```\n\n上面代码很直观的分析到关于我们关于组件名字的注意事项\n\n- 直接使用 id 拿，如果不存在，则把 id 变成驼峰的形式再拿\n- 如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿\n- 如果仍然拿不到则报错\n\n这样说明了我们在使用 Vue.component(id, definition) 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。那么在在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\">官网</a>中关于组件的命令也写到使用 kebab-case 方式 或者 使用 PascalCase 方式\n\n### 局部注册\n\n```js\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  // ...\n}\n\n```\n\n其实通过上面全局组件的注册，局部组件就很好理解了，也是经过参数合并，通过 resolveAsset 拿到组件的构造函数，并作为createComponent 钩子的参数，区别是局部组件只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。\n\n### Vue.use\n\n我们都知道使用插件的话 vue 提供一个 Vue.use 方法，具体用法见<a href=\"https://cn.vuejs.org/v2/api/#Vue-use\">官网文档</a>  \n\n那么它的原理是什么呢？定义在 `vue/src/core/index.js` 中\n\n```js\n// ...\n\n// 初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n\n// ...\n\n//初始化全局API变量\ninitGlobalAPI(Vue)\n\n// ...\nexport default Vue\n```\n\ninitGlobalAPI 定义在 `/src/core/global-api/index.js`\n\n```js\nexport function initGlobalAPI (Vue: GlobalAPI) {\n  // ...\n  // 初始化use()\n  initUse(Vue)\n  // ...\n}\n```\n\ninitUse(Vue) 定义在 `vue/src/core/global-api/use.js`\n\n```js\nexport function initUse (Vue: GlobalAPI) {\n  Vue.use = function (plugin: Function | Object) {\n    // installedPlugins 存储 install 后的插件\n    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n    if (installedPlugins.indexOf(plugin) > -1) {\n      // 同一个插件只会安装一次\n      return this\n    }\n    // 插件以外的其他参数 Vue.use(MyPlugin, { someOption: true })\n    const args = toArray(arguments, 1)\n    args.unshift(this)\n    if (typeof plugin.install === 'function') {\n      // 如果插件是一个对象，必须提供 install 方法\n      plugin.install.apply(plugin, args)\n    } else if (typeof plugin === 'function') {\n      // 如果插件是一个函数，它会被作为 install 方法\n      plugin.apply(null, args)\n    }\n    // install 之后通过队列储存插件再次安装时匹配判断避免重复安装\n    installedPlugins.push(plugin)\n    return this\n  }\n}\n```\n\n通过上面我们总结到\n\n- Vue.use 对象的原理是使用 install 字段，来进行插件安装\n- Vue.use 调用必须在 new Vue 之前\n- 同一个插件多次使用 Vue.use 只会被运行一次\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue/vueComponentRegister.md","raw":"---\ntitle: vue 原理之组件注册\ndate: 2019-09-08 12:08:25\ntop: false\ncover: false\npassword:\ntoc: false\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n在日常开发中我们经常会用到许多自定义的组件，除了内置组件自定义组件用的时候必须注册，否则会提示如下信息\n\n```md\n'Unknown custom element: <xxx> - did you register the component correctly?\n For recursive components, make sure to provide the \"name\" option.'\n```\n\n在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\">官网</a>中提到组件组册的方式分为全局和局部\n\n### 全局注册\n\n```js\nVue.component('my-component-name', {\n  // ... 选项 ...\n})\n```\n\n官方文档中有这样一句话 **全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生** ，那么代码被定义在 `src/core/global-api/assets.js ` 中\n\n```js\nimport { ASSET_TYPES } from 'shared/constants'\nimport { isPlainObject, validateComponentName } from '../util/index'\n\nexport function initAssetRegisters (Vue: GlobalAPI) {\n  // 创建注册的方法\n  ASSET_TYPES.forEach(type => {\n    Vue[type] = function (\n      id: string,\n      definition: Function | Object\n    ): Function | Object | void {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id)\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id\n          definition = this.options._base.extend(definition)\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition }\n        }\n        this.options[type + 's'][id] = definition\n        return definition\n      }\n    }\n  })\n}\n```\n遍历 ASSET_TYPES，得到 type 后挂载到 Vue 上，定义在 `src/shared/constants.js` 中\n\n```js\nexport const ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n]\n```\n\n实际上 vue 是初始化了3个全局函数，那么对于 component 来说是使用 Vue.extend 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 `this.options[type + 's'][id] = definition` 把它挂载到 `Vue.options.components` 上。然后在通过 mergeOptions 进行参数合并，最后在创建 vnode 的时候执行 _createElement 方法，定义在 `src/core/vdom/create-element.js` 中\n```js\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n  // ...\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // ...\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n    // ...\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  // ...\n}\n```\n\n通过 _createElement  方法中的 resolveAsset 拿到这个组件的构造函数，并作为 createComponent 的钩子的参数\n\n```js\nexport function resolveAsset (\n  options: Object,\n  type: string,\n  id: string,\n  warnMissing?: boolean\n): any {\n  // 组件名称必须是字符串\n  if (typeof id !== 'string') {\n    return\n  }\n  const assets = options[type]\n  // 检查本地的注册变量\n  if (hasOwn(assets, id)) return assets[id]\n  const camelizedId = camelize(id)\n  if (hasOwn(assets, camelizedId)) return assets[camelizedId]\n  const PascalCaseId = capitalize(camelizedId)\n  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]\n  // 如果条件都满足那么返回标志，进行 createComponent\n  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    )\n  }\n  return res\n}\n```\n\n上面代码很直观的分析到关于我们关于组件名字的注意事项\n\n- 直接使用 id 拿，如果不存在，则把 id 变成驼峰的形式再拿\n- 如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿\n- 如果仍然拿不到则报错\n\n这样说明了我们在使用 Vue.component(id, definition) 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。那么在在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\">官网</a>中关于组件的命令也写到使用 kebab-case 方式 或者 使用 PascalCase 方式\n\n### 局部注册\n\n```js\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  // ...\n}\n\n```\n\n其实通过上面全局组件的注册，局部组件就很好理解了，也是经过参数合并，通过 resolveAsset 拿到组件的构造函数，并作为createComponent 钩子的参数，区别是局部组件只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。\n\n### Vue.use\n\n我们都知道使用插件的话 vue 提供一个 Vue.use 方法，具体用法见<a href=\"https://cn.vuejs.org/v2/api/#Vue-use\">官网文档</a>  \n\n那么它的原理是什么呢？定义在 `vue/src/core/index.js` 中\n\n```js\n// ...\n\n// 初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n\n// ...\n\n//初始化全局API变量\ninitGlobalAPI(Vue)\n\n// ...\nexport default Vue\n```\n\ninitGlobalAPI 定义在 `/src/core/global-api/index.js`\n\n```js\nexport function initGlobalAPI (Vue: GlobalAPI) {\n  // ...\n  // 初始化use()\n  initUse(Vue)\n  // ...\n}\n```\n\ninitUse(Vue) 定义在 `vue/src/core/global-api/use.js`\n\n```js\nexport function initUse (Vue: GlobalAPI) {\n  Vue.use = function (plugin: Function | Object) {\n    // installedPlugins 存储 install 后的插件\n    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n    if (installedPlugins.indexOf(plugin) > -1) {\n      // 同一个插件只会安装一次\n      return this\n    }\n    // 插件以外的其他参数 Vue.use(MyPlugin, { someOption: true })\n    const args = toArray(arguments, 1)\n    args.unshift(this)\n    if (typeof plugin.install === 'function') {\n      // 如果插件是一个对象，必须提供 install 方法\n      plugin.install.apply(plugin, args)\n    } else if (typeof plugin === 'function') {\n      // 如果插件是一个函数，它会被作为 install 方法\n      plugin.apply(null, args)\n    }\n    // install 之后通过队列储存插件再次安装时匹配判断避免重复安装\n    installedPlugins.push(plugin)\n    return this\n  }\n}\n```\n\n通过上面我们总结到\n\n- Vue.use 对象的原理是使用 install 字段，来进行插件安装\n- Vue.use 调用必须在 new Vue 之前\n- 同一个插件多次使用 Vue.use 只会被运行一次\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue/vueComponentRegister","published":1,"updated":"2019-10-15T01:29:42.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oud005eb0u6ax7s18ii","content":"<p>在日常开发中我们经常会用到许多自定义的组件，除了内置组件自定义组件用的时候必须注册，否则会提示如下信息</p>\n<pre class=\"line-numbers language-md\"><code class=\"language-md\">'Unknown custom element: <xxx> - did you register the component correctly?\n For recursive components, make sure to provide the \"name\" option.'<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\" target=\"_blank\" rel=\"noopener\">官网</a>中提到组件组册的方式分为全局和局部</p>\n<h3 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my-component-name'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ... 选项 ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>官方文档中有这样一句话 <strong>全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</strong> ，那么代码被定义在 <code>src/core/global-api/assets.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ASSET_TYPES <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'shared/constants'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> isPlainObject<span class=\"token punctuation\">,</span> validateComponentName <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../util/index'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initAssetRegisters <span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">:</span> GlobalAPI<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 创建注册的方法</span>\n  ASSET_TYPES<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    Vue<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>\n      id<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n      definition<span class=\"token punctuation\">:</span> Function <span class=\"token operator\">|</span> Object\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token operator\">|</span> Object <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>definition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">[</span>type <span class=\"token operator\">+</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> type <span class=\"token operator\">===</span> <span class=\"token string\">'component'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">validateComponentName</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'component'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isPlainObject</span><span class=\"token punctuation\">(</span>definition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          definition<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> definition<span class=\"token punctuation\">.</span>name <span class=\"token operator\">||</span> id\n          definition <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>_base<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>definition<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'directive'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> definition <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          definition <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> bind<span class=\"token punctuation\">:</span> definition<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">:</span> definition <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">[</span>type <span class=\"token operator\">+</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> definition\n        <span class=\"token keyword\">return</span> definition\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>遍历 ASSET_TYPES，得到 type 后挂载到 Vue 上，定义在 <code>src/shared/constants.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ASSET_TYPES <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token string\">'component'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'directive'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'filter'</span>\n<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>实际上 vue 是初始化了3个全局函数，那么对于 component 来说是使用 Vue.extend 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 <code>this.options[type + &#39;s&#39;][id] = definition</code> 把它挂载到 <code>Vue.options.components</code> 上。然后在通过 mergeOptions 进行参数合并，最后在创建 vnode 的时候执行 _createElement 方法，定义在 <code>src/core/vdom/create-element.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> _createElement <span class=\"token punctuation\">(</span>\n  context<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n  tag<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Class<span class=\"token operator\">&lt;</span>Component<span class=\"token operator\">></span> <span class=\"token operator\">|</span> Function <span class=\"token operator\">|</span> Object<span class=\"token punctuation\">,</span>\n  data<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> VNodeData<span class=\"token punctuation\">,</span>\n  children<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  normalizationType<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> number\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> VNode <span class=\"token operator\">|</span> Array<span class=\"token operator\">&lt;</span>VNode<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">let</span> vnode<span class=\"token punctuation\">,</span> ns\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> tag <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> Ctor\n    ns <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">&amp;&amp;</span> context<span class=\"token punctuation\">.</span>$vnode<span class=\"token punctuation\">.</span>ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> config<span class=\"token punctuation\">.</span><span class=\"token function\">getTagNamespace</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span><span class=\"token function\">isReservedTag</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>Ctor <span class=\"token operator\">=</span> <span class=\"token function\">resolveAsset</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">,</span> <span class=\"token string\">'components'</span><span class=\"token punctuation\">,</span> tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// component</span>\n      vnode <span class=\"token operator\">=</span> <span class=\"token function\">createComponent</span><span class=\"token punctuation\">(</span>Ctor<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">,</span> tag<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// direct component options / constructor</span>\n    vnode <span class=\"token operator\">=</span> <span class=\"token function\">createComponent</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过 _createElement  方法中的 resolveAsset 拿到这个组件的构造函数，并作为 createComponent 的钩子的参数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> resolveAsset <span class=\"token punctuation\">(</span>\n  options<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">,</span>\n  type<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  id<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  warnMissing<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> any <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 组件名称必须是字符串</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> id <span class=\"token operator\">!==</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> assets <span class=\"token operator\">=</span> options<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 检查本地的注册变量</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasOwn</span><span class=\"token punctuation\">(</span>assets<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> assets<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> camelizedId <span class=\"token operator\">=</span> <span class=\"token function\">camelize</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasOwn</span><span class=\"token punctuation\">(</span>assets<span class=\"token punctuation\">,</span> camelizedId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> assets<span class=\"token punctuation\">[</span>camelizedId<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> PascalCaseId <span class=\"token operator\">=</span> <span class=\"token function\">capitalize</span><span class=\"token punctuation\">(</span>camelizedId<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasOwn</span><span class=\"token punctuation\">(</span>assets<span class=\"token punctuation\">,</span> PascalCaseId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> assets<span class=\"token punctuation\">[</span>PascalCaseId<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果条件都满足那么返回标志，进行 createComponent</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> assets<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> assets<span class=\"token punctuation\">[</span>camelizedId<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> assets<span class=\"token punctuation\">[</span>PascalCaseId<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> warnMissing <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'Failed to resolve '</span> <span class=\"token operator\">+</span> type<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">': '</span> <span class=\"token operator\">+</span> id<span class=\"token punctuation\">,</span>\n      options\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> res\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面代码很直观的分析到关于我们关于组件名字的注意事项</p>\n<ul>\n<li>直接使用 id 拿，如果不存在，则把 id 变成驼峰的形式再拿</li>\n<li>如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿</li>\n<li>如果仍然拿不到则报错</li>\n</ul>\n<p>这样说明了我们在使用 Vue.component(id, definition) 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。那么在在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\" target=\"_blank\" rel=\"noopener\">官网</a>中关于组件的命令也写到使用 kebab-case 方式 或者 使用 PascalCase 方式</p>\n<h3 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> ComponentA <span class=\"token keyword\">from</span> <span class=\"token string\">'./ComponentA.vue'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  components<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    ComponentA\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其实通过上面全局组件的注册，局部组件就很好理解了，也是经过参数合并，通过 resolveAsset 拿到组件的构造函数，并作为createComponent 钩子的参数，区别是局部组件只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。</p>\n<h3 id=\"Vue-use\"><a href=\"#Vue-use\" class=\"headerlink\" title=\"Vue.use\"></a>Vue.use</h3><p>我们都知道使用插件的话 vue 提供一个 Vue.use 方法，具体用法见<a href=\"https://cn.vuejs.org/v2/api/#Vue-use\" target=\"_blank\" rel=\"noopener\">官网文档</a>  </p>\n<p>那么它的原理是什么呢？定义在 <code>vue/src/core/index.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 初始化全局API</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> initGlobalAPI <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./global-api/index'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//初始化全局API变量</span>\n<span class=\"token function\">initGlobalAPI</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Vue<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>initGlobalAPI 定义在 <code>/src/core/global-api/index.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initGlobalAPI <span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">:</span> GlobalAPI<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 初始化use()</span>\n  <span class=\"token function\">initUse</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>initUse(Vue) 定义在 <code>vue/src/core/global-api/use.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initUse <span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">:</span> GlobalAPI<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Vue<span class=\"token punctuation\">.</span>use <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">:</span> Function <span class=\"token operator\">|</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// installedPlugins 存储 install 后的插件</span>\n    <span class=\"token keyword\">const</span> installedPlugins <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_installedPlugins <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_installedPlugins <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>installedPlugins<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 同一个插件只会安装一次</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 插件以外的其他参数 Vue.use(MyPlugin, { someOption: true })</span>\n    <span class=\"token keyword\">const</span> args <span class=\"token operator\">=</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    args<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> plugin<span class=\"token punctuation\">.</span>install <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果插件是一个对象，必须提供 install 方法</span>\n      plugin<span class=\"token punctuation\">.</span>install<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> plugin <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果插件是一个函数，它会被作为 install 方法</span>\n      plugin<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// install 之后通过队列储存插件再次安装时匹配判断避免重复安装</span>\n    installedPlugins<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面我们总结到</p>\n<ul>\n<li>Vue.use 对象的原理是使用 install 字段，来进行插件安装</li>\n<li>Vue.use 调用必须在 new Vue 之前</li>\n<li>同一个插件多次使用 Vue.use 只会被运行一次</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在日常开发中我们经常会用到许多自定义的组件，除了内置组件自定义组件用的时候必须注册，否则会提示如下信息</p>\n<pre><code class=\"md\">&#39;Unknown custom element: &lt;xxx&gt; - did you register the component correctly?\n For recursive components, make sure to provide the &quot;name&quot; option.&#39;</code></pre>\n<p>在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\" target=\"_blank\" rel=\"noopener\">官网</a>中提到组件组册的方式分为全局和局部</p>\n<h3 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h3><pre><code class=\"js\">Vue.component(&#39;my-component-name&#39;, {\n  // ... 选项 ...\n})</code></pre>\n<p>官方文档中有这样一句话 <strong>全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</strong> ，那么代码被定义在 <code>src/core/global-api/assets.js</code> 中</p>\n<pre><code class=\"js\">import { ASSET_TYPES } from &#39;shared/constants&#39;\nimport { isPlainObject, validateComponentName } from &#39;../util/index&#39;\n\nexport function initAssetRegisters (Vue: GlobalAPI) {\n  // 创建注册的方法\n  ASSET_TYPES.forEach(type =&gt; {\n    Vue[type] = function (\n      id: string,\n      definition: Function | Object\n    ): Function | Object | void {\n      if (!definition) {\n        return this.options[type + &#39;s&#39;][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; type === &#39;component&#39;) {\n          validateComponentName(id)\n        }\n        if (type === &#39;component&#39; &amp;&amp; isPlainObject(definition)) {\n          definition.name = definition.name || id\n          definition = this.options._base.extend(definition)\n        }\n        if (type === &#39;directive&#39; &amp;&amp; typeof definition === &#39;function&#39;) {\n          definition = { bind: definition, update: definition }\n        }\n        this.options[type + &#39;s&#39;][id] = definition\n        return definition\n      }\n    }\n  })\n}</code></pre>\n<p>遍历 ASSET_TYPES，得到 type 后挂载到 Vue 上，定义在 <code>src/shared/constants.js</code> 中</p>\n<pre><code class=\"js\">export const ASSET_TYPES = [\n  &#39;component&#39;,\n  &#39;directive&#39;,\n  &#39;filter&#39;\n]</code></pre>\n<p>实际上 vue 是初始化了3个全局函数，那么对于 component 来说是使用 Vue.extend 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 <code>this.options[type + &#39;s&#39;][id] = definition</code> 把它挂载到 <code>Vue.options.components</code> 上。然后在通过 mergeOptions 进行参数合并，最后在创建 vnode 的时候执行 _createElement 方法，定义在 <code>src/core/vdom/create-element.js</code> 中</p>\n<pre><code class=\"js\">export function _createElement (\n  context: Component,\n  tag?: string | Class&lt;Component&gt; | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array&lt;VNode&gt; {\n  // ...\n  let vnode, ns\n  if (typeof tag === &#39;string&#39;) {\n    let Ctor\n    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // ...\n    } else if (isDef(Ctor = resolveAsset(context.$options, &#39;components&#39;, tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n    // ...\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  // ...\n}</code></pre>\n<p>通过 _createElement  方法中的 resolveAsset 拿到这个组件的构造函数，并作为 createComponent 的钩子的参数</p>\n<pre><code class=\"js\">export function resolveAsset (\n  options: Object,\n  type: string,\n  id: string,\n  warnMissing?: boolean\n): any {\n  // 组件名称必须是字符串\n  if (typeof id !== &#39;string&#39;) {\n    return\n  }\n  const assets = options[type]\n  // 检查本地的注册变量\n  if (hasOwn(assets, id)) return assets[id]\n  const camelizedId = camelize(id)\n  if (hasOwn(assets, camelizedId)) return assets[camelizedId]\n  const PascalCaseId = capitalize(camelizedId)\n  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]\n  // 如果条件都满足那么返回标志，进行 createComponent\n  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warnMissing &amp;&amp; !res) {\n    warn(\n      &#39;Failed to resolve &#39; + type.slice(0, -1) + &#39;: &#39; + id,\n      options\n    )\n  }\n  return res\n}</code></pre>\n<p>上面代码很直观的分析到关于我们关于组件名字的注意事项</p>\n<ul>\n<li>直接使用 id 拿，如果不存在，则把 id 变成驼峰的形式再拿</li>\n<li>如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿</li>\n<li>如果仍然拿不到则报错</li>\n</ul>\n<p>这样说明了我们在使用 Vue.component(id, definition) 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。那么在在<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\" target=\"_blank\" rel=\"noopener\">官网</a>中关于组件的命令也写到使用 kebab-case 方式 或者 使用 PascalCase 方式</p>\n<h3 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h3><pre><code class=\"js\">import ComponentA from &#39;./ComponentA.vue&#39;\n\nexport default {\n  components: {\n    ComponentA\n  },\n  // ...\n}\n</code></pre>\n<p>其实通过上面全局组件的注册，局部组件就很好理解了，也是经过参数合并，通过 resolveAsset 拿到组件的构造函数，并作为createComponent 钩子的参数，区别是局部组件只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。</p>\n<h3 id=\"Vue-use\"><a href=\"#Vue-use\" class=\"headerlink\" title=\"Vue.use\"></a>Vue.use</h3><p>我们都知道使用插件的话 vue 提供一个 Vue.use 方法，具体用法见<a href=\"https://cn.vuejs.org/v2/api/#Vue-use\" target=\"_blank\" rel=\"noopener\">官网文档</a>  </p>\n<p>那么它的原理是什么呢？定义在 <code>vue/src/core/index.js</code> 中</p>\n<pre><code class=\"js\">// ...\n\n// 初始化全局API\nimport { initGlobalAPI } from &#39;./global-api/index&#39;\n\n// ...\n\n//初始化全局API变量\ninitGlobalAPI(Vue)\n\n// ...\nexport default Vue</code></pre>\n<p>initGlobalAPI 定义在 <code>/src/core/global-api/index.js</code></p>\n<pre><code class=\"js\">export function initGlobalAPI (Vue: GlobalAPI) {\n  // ...\n  // 初始化use()\n  initUse(Vue)\n  // ...\n}</code></pre>\n<p>initUse(Vue) 定义在 <code>vue/src/core/global-api/use.js</code></p>\n<pre><code class=\"js\">export function initUse (Vue: GlobalAPI) {\n  Vue.use = function (plugin: Function | Object) {\n    // installedPlugins 存储 install 后的插件\n    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n    if (installedPlugins.indexOf(plugin) &gt; -1) {\n      // 同一个插件只会安装一次\n      return this\n    }\n    // 插件以外的其他参数 Vue.use(MyPlugin, { someOption: true })\n    const args = toArray(arguments, 1)\n    args.unshift(this)\n    if (typeof plugin.install === &#39;function&#39;) {\n      // 如果插件是一个对象，必须提供 install 方法\n      plugin.install.apply(plugin, args)\n    } else if (typeof plugin === &#39;function&#39;) {\n      // 如果插件是一个函数，它会被作为 install 方法\n      plugin.apply(null, args)\n    }\n    // install 之后通过队列储存插件再次安装时匹配判断避免重复安装\n    installedPlugins.push(plugin)\n    return this\n  }\n}</code></pre>\n<p>通过上面我们总结到</p>\n<ul>\n<li>Vue.use 对象的原理是使用 install 字段，来进行插件安装</li>\n<li>Vue.use 调用必须在 new Vue 之前</li>\n<li>同一个插件多次使用 Vue.use 只会被运行一次</li>\n</ul>\n"},{"title":"vue 原理之组件化","date":"2019-09-21T02:50:28.000Z","top":false,"cover":false,"password":null,"toc":false,"mathjax":false,"summary":null,"_content":"\n\n> <a href=\"https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/\">生命周期</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/08/vue/vuecomponentregister/\">组件注册</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/10/vue/vueasync-component/\">异步组件</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/12/vue/vuevmodel/\">v-model</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/22/vue/vuekeepalive/\">keep-alive</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/07/vue/vuecomputedwatcher/\">computed 和 watch</a>\n\n","source":"_posts/vue/vueComponents.md","raw":"---\ntitle: vue 原理之组件化\ndate: 2019-09-21 10:50:28\ntop: false\ncover: false\npassword:\ntoc: false\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n\n> <a href=\"https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/\">生命周期</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/08/vue/vuecomponentregister/\">组件注册</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/10/vue/vueasync-component/\">异步组件</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/12/vue/vuevmodel/\">v-model</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/22/vue/vuekeepalive/\">keep-alive</a>\n\n> <a href=\"https://www.studyfe.cn/2019/09/07/vue/vuecomputedwatcher/\">computed 和 watch</a>\n\n","slug":"vue/vueComponents","published":1,"updated":"2019-10-15T01:29:42.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oug005ib0u6g8ane8vh","content":"<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/\">生命周期</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/08/vue/vuecomponentregister/\">组件注册</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/10/vue/vueasync-component/\">异步组件</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/12/vue/vuevmodel/\">v-model</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/22/vue/vuekeepalive/\">keep-alive</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/07/vue/vuecomputedwatcher/\">computed 和 watch</a></p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/21/vue/vuelifecycle/\">生命周期</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/08/vue/vuecomponentregister/\">组件注册</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/10/vue/vueasync-component/\">异步组件</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/12/vue/vuevmodel/\">v-model</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/22/vue/vuekeepalive/\">keep-alive</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.studyfe.cn/2019/09/07/vue/vuecomputedwatcher/\">computed 和 watch</a></p>\n</blockquote>\n"},{"title":"vue 原理之 v-model","date":"2019-09-12T12:20:12.000Z","top":false,"cover":false,"password":null,"toc":false,"mathjax":false,"summary":null,"_content":"\n在日常开发中我们使用 v-model 来实现数据的双向绑定，那么接下来我们通过一张流程图来大概的看看它实现的流程。具体源码解析请参考<a href=\"https://ustbhuangyi.github.io/vue-analysis/extend/v-model.html\">Vue.js 技术揭秘</a>\n<img src=\"/images/vue-vmodel.png\"></img>\n\n\n\n\n\n\n","source":"_posts/vue/vueVModel.md","raw":"---\ntitle: vue 原理之 v-model\ndate: 2019-09-12 20:20:12\ntop: false\ncover: false\npassword:\ntoc: false\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n在日常开发中我们使用 v-model 来实现数据的双向绑定，那么接下来我们通过一张流程图来大概的看看它实现的流程。具体源码解析请参考<a href=\"https://ustbhuangyi.github.io/vue-analysis/extend/v-model.html\">Vue.js 技术揭秘</a>\n<img src=\"/images/vue-vmodel.png\"></img>\n\n\n\n\n\n\n","slug":"vue/vueVModel","published":1,"updated":"2019-10-15T01:29:42.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ouh005kb0u6hsb9qqc8","content":"<p>在日常开发中我们使用 v-model 来实现数据的双向绑定，那么接下来我们通过一张流程图来大概的看看它实现的流程。具体源码解析请参考<a href=\"https://ustbhuangyi.github.io/vue-analysis/extend/v-model.html\" target=\"_blank\" rel=\"noopener\">Vue.js 技术揭秘</a><br><img src=\"/images/vue-vmodel.png\"></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在日常开发中我们使用 v-model 来实现数据的双向绑定，那么接下来我们通过一张流程图来大概的看看它实现的流程。具体源码解析请参考<a href=\"https://ustbhuangyi.github.io/vue-analysis/extend/v-model.html\" target=\"_blank\" rel=\"noopener\">Vue.js 技术揭秘</a><br><img src=\"/images/vue-vmodel.png\"></p>\n"},{"title":"generator 与 async","date":"2019-08-26T08:22:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n### 概述\n在前端中异步编程一直是前端开发的一个痛点，因为 JavaScript 语法的灵活性和特殊性导致前端开发的困难（因为 JavaScript 是单线程，如果没有异步的世界可以想象一下，将无法执行卡死操作）\n\n### 什么是异步编程\n所谓\"异步\"，一个任务不是连续完成的，先执行第一段，然后执行其他任务，等做好了准备，回过头执行第二段\n\n所谓\"同步\"，就是不间断的连续执行一个任务\n\n### 异步编程示例\n我们熟悉的异步编程有很多种例如 `代码的执行任务队列`,`setTimeout`, `setInterval`, `callback`, `promise` 等\n\n回调函数\n\n```js\nfunction Fun(name, callback) {\n  console.log(name)\n  callback && callback()\n}\nfun('renbo',function () {})\n\n再例如数组的操作方法\n\n[1,2,3,4,5].map(function(v,i){\n  return i+':'+v\n})\n\n```\n\nPromise\n\n```js\nvar readFile = require('fs-readfile-promise');\nreadFile(fileA)\n.then(function (data) {\n  console.log(data.toString());\n})\n.then(function () {\n  return readFile(fileB);\n})\n.then(function (data) {\n  console.log(data.toString());\n})\n.catch(function (err) {\n  console.log(err);\n});\n\n```\n\n### Generator概念\n\nES6 提供的一种异步编程解决方案，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n### Generator特征\n- function关键字与函数名之间有一个星号\n- 函数体内部使用yield表达式，定义不同的内部状态\n- 执行函数不会立即执行，只有调用了next方法才会执行\n- 如果函数内部不写 yield 表达式，则此函数就是单纯的暂缓执行函数\n- 每次调用遍历器对象的next方法，返回value和done两个属性的对象\n- value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值\n- done属性是一个布尔值，表示是否遍历结束\n\n```js\nfunction* funGenerator() {\n  yield 'hello';\n  yield 'my name is renbo';\n  return 'ending';\n}\n\nvar fun = funGenerator();\n\nfun.next() // { value: 'hello', done: false }\nfun.next() // { value: 'my name is renbo', done: false }\nfun.next()  // { value: 'ending', done: true }\nfun.next()  // { value: undefined, done: true }\n```\n\n### 控制流管理\n\n回调\n\n```js\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n\n```\n\npromise\n\n```js\nPromise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();\n```\n\nGenerator\n\n```js\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\n```\n\n### 单个异步任务\n\nGenerator + Promise\n\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result);\n}\n\n// 调用\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n    return data.json();\n}).then(function(data){\n    g.next(data);\n});\n```\n\n上述的执行过程调用 gen 会返回遍历器，然后通过遍历器的 next 方法返回 fetch 的 promise 实例`{ value: Promise { <pending> }, done: false }`，通过调用 then 方法执行结果\n\n\n###  多个异步任务\n\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen() {\n  var r1 = yield fetch('https://api.github.com/users/github');\n  var r2 = yield fetch('https://api.github.com/users/github/followers');\n  var r3 = yield fetch('https://api.github.com/users/github/repos');\n\n  console.log([r1.bio, r2[0].login, r3[0].full_name].join('\\n'));\n}\n\n```\n\n获得执行结果\n\n```js\nvar g = gen();\nvar result1 = g.next();\n\nresult1.value.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value;\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    g.next(data)\n});\n\n```\n\n利用递归封装上述执行结果\n\n```js\nfunction run(gen) {\n  var g = gen();\n\n  function next(data) {\n    var result = g.next(data);\n\n    if (result.done) return;\n\n    result.value.then(function(data) {\n        return data.json();\n    }).then(function(data) {\n        next(data);\n    });\n\n  }\n\n  next();\n}\n\nrun(gen);\n```\n\n### 启动器函数 （Generator + Promise）\n\n由于 fetch 方法返回 promise 有 json 方法，所以上述例子成立，如果 yield 直接结合 promise 函数那么就会变成启动器函数。由于 Generator 不能像普通函数一样自动执行和自己暂缓执行的特性，所以增加自执行启动函数，这也是 co 模块的初衷（）\n\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen() {\n  var r1 = yield fetch('https://api.github.com/users/github');\n  var json1 = yield r1.json();\n  var r2 = yield fetch('https://api.github.com/users/github/followers');\n  var json2 = yield r2.json();\n  var r3 = yield fetch('https://api.github.com/users/github/repos');\n  var json3 = yield r3.json();\n\n  console.log([json1.bio, json2[0].login, json3[0].full_name].join('\\n'));\n}\n\nfunction run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value.then(function(data) {\n            next(data);\n        });\n\n    }\n\n    next();\n}\n\nrun(gen);\n\n```\n\n### 启动器函数 （Generator + 回调）\n\n回调函数\n\n```js\nfunction fetchData(url) {\n    return function(cb){\n        setTimeout(function(){\n            cb({status: 200, data: url})\n        }, 1000)\n    }\n}\n```\n\nGenerator函数\n\n```js\nfunction* gen() {\n    var r1 = yield fetchData('https://api.github.com/users/github');\n    var r2 = yield fetchData('https://api.github.com/users/github/followers');\n\n    console.log([r1.data, r2.data].join('\\n'));\n}\n```\n\n获得结果\n\n```js\nvar g = gen();\n\nvar r1 = g.next();\n\nr1.value(function(data) {\n  var r2 = g.next(data);\n  r2.value(function(data) {\n      g.next(data);\n  });\n});\n```\n\n通过上面的示例代码我们观察到回调函数依然解决不了多个 yield 时代码会循环嵌套。还的借助递归\n\n```js\nfunction run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value(next);\n    }\n\n    next();\n}\n\nrun(gen);\n```\n\n### run \n\n通过上面代码可以看出 Generator 函数的自动执行需要一种机制，当异步操作有了结果，才能自动交回执行权\n\n- 回调函数。 将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权\n- Promise对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权\n\n上面两种方法写了一个 run 的启动器函数，那么我们将两种封装在一起，返回了一个 Promise，获得 Generator 函数的返回值，并且捕获错误\n\n``` js\nfunction run(gen) {\n\n    return new Promise(function(resolve, reject) {\n        if (typeof gen == 'function') gen = gen();\n\n        // 如果 gen 不是一个迭代器\n        if (!gen || typeof gen.next !== 'function') return resolve(gen)\n\n        onFulfilled();\n\n        function onFulfilled(res) {\n            var ret;\n            try {\n                ret = gen.next(res);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function onRejected(err) {\n            var ret;\n            try {\n                ret = gen.throw(err);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function next(ret) {\n            if (ret.done) return resolve(ret.value);\n            var value = toPromise(ret.value);\n            if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n            return onRejected(new TypeError('You may only yield a function, promise ' +\n                'but the following object was passed: \"' + String(ret.value) + '\"'));\n        }\n    })\n}\n\nfunction isPromise(obj) {\n    return 'function' == typeof obj.then;\n}\n\nfunction toPromise(obj) {\n    if (isPromise(obj)) return obj;\n    if ('function' == typeof obj) return thunkToPromise(obj);\n    return obj;\n}\n\nfunction thunkToPromise(fn) {\n    return new Promise(function(resolve, reject) {\n        fn(function(err, res) {\n            if (err) return reject(err);\n            resolve(res);\n        });\n    });\n}\n\nmodule.exports = run;\n```\n\n### co\n \nco 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。\n\n如果直接使用 co 模块，这两种不同的例子可以简写为\n\nyield 后是一个 Promise\n\n```js\nvar fetch = require('node-fetch');\nvar co = require('co');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    var r2 = yield fetch('https://api.github.com/users/github/followers');\n    var json2 = yield r2.json();\n    var r3 = yield fetch('https://api.github.com/users/github/repos');\n    var json3 = yield r3.json();\n\n    console.log([json1.bio, json2[0].login, json3[0].full_name].join('\\n'));\n}\n\nco(gen);\n```\n\nyield 后是一个回调函数\n\n```js\n\nvar co = require('co');\n\nfunction fetchData(url) {\n    return function(cb) {\n        setTimeout(function() {\n            cb(null, { status: 200, data: url })\n        }, 1000)\n    }\n}\n\nfunction* gen() {\n    var r1 = yield fetchData('https://api.github.com/users/github');\n    var r2 = yield fetchData('https://api.github.com/users/github/followers');\n\n    console.log([r1.data, r2.data].join('\\n'));\n}\n\nco(gen);\n```\n\n\n### async 有点\n\n async 函数，使得异步操作变得更加方便,它也是 Generator 函数的语法糖。\n\n当使用 Generator 函数的时候\n\n```js\nvar fetch = require('node-fetch');\nvar co = require('co');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    console.log(json1.bio);\n}\n\nco(gen);\n```\n\n当使用 async 时候\n\n```js\nvar fetch = require('node-fetch');\n\nvar fetchData = async function () {\n    var r1 = await fetch('https://api.github.com/users/github');\n    var json1 = await r1.json();\n    console.log(json1.bio);\n};\n\nfetchData();\n```\n\n通过上面观察到代码基本一样，所以 async 的原理就是将 Generator 函数和自动执行器，包装在一个函数里面\n\n```js\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n```\n\nasync 函数返回一个 Promise 对象所以也可以理解为 async 函数是基于 Promise 和 Generator 的一层封装\n随意处理初步流程 async 会比使用 Promise 更优雅\n\n```js\nfunction fetch() {\n  return (\n    fetchData().then(() => {\n      return \"done\"\n    });\n  )\n}\n\nasync function fetch() {\n  await fetchData()\n  return \"done\"\n};\n```\n\n```js\nfunction fetch() {\n  return fetchData().then(data => {\n    if (data.moreData) {\n      return fetchAnotherData(data).then(moreData => {\n        return moreData\n      })\n    } else {\n      return data\n    }\n  });\n}\n\nasync function fetch() {\n  const data = await fetchData()\n  if (data.moreData) {\n    const moreData = await fetchAnotherData(data);\n    return moreData\n  } else {\n    return data\n  }\n}\n```\n\n```js\nfunction fetch() {\n  return (\n    fetchData()\n    .then(value1 => {\n      return fetchMoreData(value1)\n    })\n    .then(value2 => {\n      return fetchMoreData2(value2)\n    })\n  )\n}\n\nasync function fetch() {\n  const value1 = await fetchData()\n  const value2 = await fetchMoreData(value1)\n  return fetchMoreData2(value2)\n};\n```\n\n### async 缺点\n\n- 用try...catch 处理上是原本的优雅代码变得不再优雅\n- 语法的简洁让原本可以并行执行的内容变成了顺序执行，从而影响了性能\n\nawait由于返回 promise 对象，所以结果可能是rejected，所以最好把await命令放在try...catch代码块中\n但是如果想捕获 JSON.parse 中的错误那么就需要再添加一层 try...catch\n\n```js\nasync function fetch() {\n  try {\n    const data = JSON.parse(await fetchData())\n  } catch (err) {\n    console.log(err)\n  }\n};\n```\n\n原本没有依赖关系的两个函数，却只能等待 getList 返回才能执行 getAnotherList，导致请求时间多了一倍\n\n```js\n(async () => {\n  const getList = await getList();\n  const getAnotherList = await getAnotherList();\n})();\n```\n\n将上面的函数改为如下函数可以解决上述问题\n```js\n(async () => {\n  const listPromise = getList();\n  const anotherListPromise = getAnotherList();\n  await listPromise;\n  await anotherListPromise;\n})();\n```\n\n也可以使用 Promse.all\n\n```js\n(async () => {\n  Promise.all([getList(), getAnotherList()]).then(...);\n})();\n```\n\n并发执行 async 函数\n\n\n```js\nasync function handleList() {\n  const listPromise = await getList();\n  // ...\n  await submit(listData);\n}\n\nasync function handleAnotherList() {\n  const anotherListPromise = await getAnotherList()\n  // ...\n  await submit(anotherListData)\n}\n\n// 方法一\n(async () => {\n  const handleListPromise = handleList()\n  const handleAnotherListPromise = handleAnotherList()\n  await handleListPromise\n  await handleAnotherListPromise\n})()\n\n// 方法二\n(async () => {\n  Promise.all([handleList(), handleAnotherList()]).then()\n})()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/Generator-Async.md","raw":"---\ntitle: generator 与 async\ndate: 2019-8-26 16:22:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n\n### 概述\n在前端中异步编程一直是前端开发的一个痛点，因为 JavaScript 语法的灵活性和特殊性导致前端开发的困难（因为 JavaScript 是单线程，如果没有异步的世界可以想象一下，将无法执行卡死操作）\n\n### 什么是异步编程\n所谓\"异步\"，一个任务不是连续完成的，先执行第一段，然后执行其他任务，等做好了准备，回过头执行第二段\n\n所谓\"同步\"，就是不间断的连续执行一个任务\n\n### 异步编程示例\n我们熟悉的异步编程有很多种例如 `代码的执行任务队列`,`setTimeout`, `setInterval`, `callback`, `promise` 等\n\n回调函数\n\n```js\nfunction Fun(name, callback) {\n  console.log(name)\n  callback && callback()\n}\nfun('renbo',function () {})\n\n再例如数组的操作方法\n\n[1,2,3,4,5].map(function(v,i){\n  return i+':'+v\n})\n\n```\n\nPromise\n\n```js\nvar readFile = require('fs-readfile-promise');\nreadFile(fileA)\n.then(function (data) {\n  console.log(data.toString());\n})\n.then(function () {\n  return readFile(fileB);\n})\n.then(function (data) {\n  console.log(data.toString());\n})\n.catch(function (err) {\n  console.log(err);\n});\n\n```\n\n### Generator概念\n\nES6 提供的一种异步编程解决方案，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n### Generator特征\n- function关键字与函数名之间有一个星号\n- 函数体内部使用yield表达式，定义不同的内部状态\n- 执行函数不会立即执行，只有调用了next方法才会执行\n- 如果函数内部不写 yield 表达式，则此函数就是单纯的暂缓执行函数\n- 每次调用遍历器对象的next方法，返回value和done两个属性的对象\n- value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值\n- done属性是一个布尔值，表示是否遍历结束\n\n```js\nfunction* funGenerator() {\n  yield 'hello';\n  yield 'my name is renbo';\n  return 'ending';\n}\n\nvar fun = funGenerator();\n\nfun.next() // { value: 'hello', done: false }\nfun.next() // { value: 'my name is renbo', done: false }\nfun.next()  // { value: 'ending', done: true }\nfun.next()  // { value: undefined, done: true }\n```\n\n### 控制流管理\n\n回调\n\n```js\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n\n```\n\npromise\n\n```js\nPromise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();\n```\n\nGenerator\n\n```js\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\n```\n\n### 单个异步任务\n\nGenerator + Promise\n\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result);\n}\n\n// 调用\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n    return data.json();\n}).then(function(data){\n    g.next(data);\n});\n```\n\n上述的执行过程调用 gen 会返回遍历器，然后通过遍历器的 next 方法返回 fetch 的 promise 实例`{ value: Promise { <pending> }, done: false }`，通过调用 then 方法执行结果\n\n\n###  多个异步任务\n\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen() {\n  var r1 = yield fetch('https://api.github.com/users/github');\n  var r2 = yield fetch('https://api.github.com/users/github/followers');\n  var r3 = yield fetch('https://api.github.com/users/github/repos');\n\n  console.log([r1.bio, r2[0].login, r3[0].full_name].join('\\n'));\n}\n\n```\n\n获得执行结果\n\n```js\nvar g = gen();\nvar result1 = g.next();\n\nresult1.value.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value;\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    g.next(data)\n});\n\n```\n\n利用递归封装上述执行结果\n\n```js\nfunction run(gen) {\n  var g = gen();\n\n  function next(data) {\n    var result = g.next(data);\n\n    if (result.done) return;\n\n    result.value.then(function(data) {\n        return data.json();\n    }).then(function(data) {\n        next(data);\n    });\n\n  }\n\n  next();\n}\n\nrun(gen);\n```\n\n### 启动器函数 （Generator + Promise）\n\n由于 fetch 方法返回 promise 有 json 方法，所以上述例子成立，如果 yield 直接结合 promise 函数那么就会变成启动器函数。由于 Generator 不能像普通函数一样自动执行和自己暂缓执行的特性，所以增加自执行启动函数，这也是 co 模块的初衷（）\n\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen() {\n  var r1 = yield fetch('https://api.github.com/users/github');\n  var json1 = yield r1.json();\n  var r2 = yield fetch('https://api.github.com/users/github/followers');\n  var json2 = yield r2.json();\n  var r3 = yield fetch('https://api.github.com/users/github/repos');\n  var json3 = yield r3.json();\n\n  console.log([json1.bio, json2[0].login, json3[0].full_name].join('\\n'));\n}\n\nfunction run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value.then(function(data) {\n            next(data);\n        });\n\n    }\n\n    next();\n}\n\nrun(gen);\n\n```\n\n### 启动器函数 （Generator + 回调）\n\n回调函数\n\n```js\nfunction fetchData(url) {\n    return function(cb){\n        setTimeout(function(){\n            cb({status: 200, data: url})\n        }, 1000)\n    }\n}\n```\n\nGenerator函数\n\n```js\nfunction* gen() {\n    var r1 = yield fetchData('https://api.github.com/users/github');\n    var r2 = yield fetchData('https://api.github.com/users/github/followers');\n\n    console.log([r1.data, r2.data].join('\\n'));\n}\n```\n\n获得结果\n\n```js\nvar g = gen();\n\nvar r1 = g.next();\n\nr1.value(function(data) {\n  var r2 = g.next(data);\n  r2.value(function(data) {\n      g.next(data);\n  });\n});\n```\n\n通过上面的示例代码我们观察到回调函数依然解决不了多个 yield 时代码会循环嵌套。还的借助递归\n\n```js\nfunction run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value(next);\n    }\n\n    next();\n}\n\nrun(gen);\n```\n\n### run \n\n通过上面代码可以看出 Generator 函数的自动执行需要一种机制，当异步操作有了结果，才能自动交回执行权\n\n- 回调函数。 将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权\n- Promise对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权\n\n上面两种方法写了一个 run 的启动器函数，那么我们将两种封装在一起，返回了一个 Promise，获得 Generator 函数的返回值，并且捕获错误\n\n``` js\nfunction run(gen) {\n\n    return new Promise(function(resolve, reject) {\n        if (typeof gen == 'function') gen = gen();\n\n        // 如果 gen 不是一个迭代器\n        if (!gen || typeof gen.next !== 'function') return resolve(gen)\n\n        onFulfilled();\n\n        function onFulfilled(res) {\n            var ret;\n            try {\n                ret = gen.next(res);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function onRejected(err) {\n            var ret;\n            try {\n                ret = gen.throw(err);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function next(ret) {\n            if (ret.done) return resolve(ret.value);\n            var value = toPromise(ret.value);\n            if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n            return onRejected(new TypeError('You may only yield a function, promise ' +\n                'but the following object was passed: \"' + String(ret.value) + '\"'));\n        }\n    })\n}\n\nfunction isPromise(obj) {\n    return 'function' == typeof obj.then;\n}\n\nfunction toPromise(obj) {\n    if (isPromise(obj)) return obj;\n    if ('function' == typeof obj) return thunkToPromise(obj);\n    return obj;\n}\n\nfunction thunkToPromise(fn) {\n    return new Promise(function(resolve, reject) {\n        fn(function(err, res) {\n            if (err) return reject(err);\n            resolve(res);\n        });\n    });\n}\n\nmodule.exports = run;\n```\n\n### co\n \nco 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。\n\n如果直接使用 co 模块，这两种不同的例子可以简写为\n\nyield 后是一个 Promise\n\n```js\nvar fetch = require('node-fetch');\nvar co = require('co');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    var r2 = yield fetch('https://api.github.com/users/github/followers');\n    var json2 = yield r2.json();\n    var r3 = yield fetch('https://api.github.com/users/github/repos');\n    var json3 = yield r3.json();\n\n    console.log([json1.bio, json2[0].login, json3[0].full_name].join('\\n'));\n}\n\nco(gen);\n```\n\nyield 后是一个回调函数\n\n```js\n\nvar co = require('co');\n\nfunction fetchData(url) {\n    return function(cb) {\n        setTimeout(function() {\n            cb(null, { status: 200, data: url })\n        }, 1000)\n    }\n}\n\nfunction* gen() {\n    var r1 = yield fetchData('https://api.github.com/users/github');\n    var r2 = yield fetchData('https://api.github.com/users/github/followers');\n\n    console.log([r1.data, r2.data].join('\\n'));\n}\n\nco(gen);\n```\n\n\n### async 有点\n\n async 函数，使得异步操作变得更加方便,它也是 Generator 函数的语法糖。\n\n当使用 Generator 函数的时候\n\n```js\nvar fetch = require('node-fetch');\nvar co = require('co');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    console.log(json1.bio);\n}\n\nco(gen);\n```\n\n当使用 async 时候\n\n```js\nvar fetch = require('node-fetch');\n\nvar fetchData = async function () {\n    var r1 = await fetch('https://api.github.com/users/github');\n    var json1 = await r1.json();\n    console.log(json1.bio);\n};\n\nfetchData();\n```\n\n通过上面观察到代码基本一样，所以 async 的原理就是将 Generator 函数和自动执行器，包装在一个函数里面\n\n```js\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n```\n\nasync 函数返回一个 Promise 对象所以也可以理解为 async 函数是基于 Promise 和 Generator 的一层封装\n随意处理初步流程 async 会比使用 Promise 更优雅\n\n```js\nfunction fetch() {\n  return (\n    fetchData().then(() => {\n      return \"done\"\n    });\n  )\n}\n\nasync function fetch() {\n  await fetchData()\n  return \"done\"\n};\n```\n\n```js\nfunction fetch() {\n  return fetchData().then(data => {\n    if (data.moreData) {\n      return fetchAnotherData(data).then(moreData => {\n        return moreData\n      })\n    } else {\n      return data\n    }\n  });\n}\n\nasync function fetch() {\n  const data = await fetchData()\n  if (data.moreData) {\n    const moreData = await fetchAnotherData(data);\n    return moreData\n  } else {\n    return data\n  }\n}\n```\n\n```js\nfunction fetch() {\n  return (\n    fetchData()\n    .then(value1 => {\n      return fetchMoreData(value1)\n    })\n    .then(value2 => {\n      return fetchMoreData2(value2)\n    })\n  )\n}\n\nasync function fetch() {\n  const value1 = await fetchData()\n  const value2 = await fetchMoreData(value1)\n  return fetchMoreData2(value2)\n};\n```\n\n### async 缺点\n\n- 用try...catch 处理上是原本的优雅代码变得不再优雅\n- 语法的简洁让原本可以并行执行的内容变成了顺序执行，从而影响了性能\n\nawait由于返回 promise 对象，所以结果可能是rejected，所以最好把await命令放在try...catch代码块中\n但是如果想捕获 JSON.parse 中的错误那么就需要再添加一层 try...catch\n\n```js\nasync function fetch() {\n  try {\n    const data = JSON.parse(await fetchData())\n  } catch (err) {\n    console.log(err)\n  }\n};\n```\n\n原本没有依赖关系的两个函数，却只能等待 getList 返回才能执行 getAnotherList，导致请求时间多了一倍\n\n```js\n(async () => {\n  const getList = await getList();\n  const getAnotherList = await getAnotherList();\n})();\n```\n\n将上面的函数改为如下函数可以解决上述问题\n```js\n(async () => {\n  const listPromise = getList();\n  const anotherListPromise = getAnotherList();\n  await listPromise;\n  await anotherListPromise;\n})();\n```\n\n也可以使用 Promse.all\n\n```js\n(async () => {\n  Promise.all([getList(), getAnotherList()]).then(...);\n})();\n```\n\n并发执行 async 函数\n\n\n```js\nasync function handleList() {\n  const listPromise = await getList();\n  // ...\n  await submit(listData);\n}\n\nasync function handleAnotherList() {\n  const anotherListPromise = await getAnotherList()\n  // ...\n  await submit(anotherListData)\n}\n\n// 方法一\n(async () => {\n  const handleListPromise = handleList()\n  const handleAnotherListPromise = handleAnotherList()\n  await handleListPromise\n  await handleAnotherListPromise\n})()\n\n// 方法二\n(async () => {\n  Promise.all([handleList(), handleAnotherList()]).then()\n})()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/Generator-Async","published":1,"updated":"2019-10-15T01:29:42.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ow3008gb0u65cfsosrv","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>在前端中异步编程一直是前端开发的一个痛点，因为 JavaScript 语法的灵活性和特殊性导致前端开发的困难（因为 JavaScript 是单线程，如果没有异步的世界可以想象一下，将无法执行卡死操作）</p>\n<h3 id=\"什么是异步编程\"><a href=\"#什么是异步编程\" class=\"headerlink\" title=\"什么是异步编程\"></a>什么是异步编程</h3><p>所谓”异步”，一个任务不是连续完成的，先执行第一段，然后执行其他任务，等做好了准备，回过头执行第二段</p>\n<p>所谓”同步”，就是不间断的连续执行一个任务</p>\n<h3 id=\"异步编程示例\"><a href=\"#异步编程示例\" class=\"headerlink\" title=\"异步编程示例\"></a>异步编程示例</h3><p>我们熟悉的异步编程有很多种例如 <code>代码的执行任务队列</code>,<code>setTimeout</code>, <code>setInterval</code>, <code>callback</code>, <code>promise</code> 等</p>\n<p>回调函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Fun</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n  callback <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token string\">'renbo'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n再例如数组的操作方法\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> i<span class=\"token operator\">+</span><span class=\"token string\">':'</span><span class=\"token operator\">+</span>v\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Promise</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> readFile <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs-readfile-promise'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>fileA<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>fileB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"Generator概念\"><a href=\"#Generator概念\" class=\"headerlink\" title=\"Generator概念\"></a>Generator概念</h3><p>ES6 提供的一种异步编程解决方案，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<h3 id=\"Generator特征\"><a href=\"#Generator特征\" class=\"headerlink\" title=\"Generator特征\"></a>Generator特征</h3><ul>\n<li>function关键字与函数名之间有一个星号</li>\n<li>函数体内部使用yield表达式，定义不同的内部状态</li>\n<li>执行函数不会立即执行，只有调用了next方法才会执行</li>\n<li>如果函数内部不写 yield 表达式，则此函数就是单纯的暂缓执行函数</li>\n<li>每次调用遍历器对象的next方法，返回value和done两个属性的对象</li>\n<li>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值</li>\n<li>done属性是一个布尔值，表示是否遍历结束</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">funGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">yield</span> <span class=\"token string\">'my name is renbo'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'ending'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fun <span class=\"token operator\">=</span> <span class=\"token function\">funGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// { value: 'hello', done: false }</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// { value: 'my name is renbo', done: false }</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// { value: 'ending', done: true }</span>\nfun<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// { value: undefined, done: true }</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"控制流管理\"><a href=\"#控制流管理\" class=\"headerlink\" title=\"控制流管理\"></a>控制流管理</h3><p>回调</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">step1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">step4</span><span class=\"token punctuation\">(</span>value3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Do something with value4</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>promise</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>step1<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>step2<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>step3<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>step4<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Do something with value4</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle any error from step1 through step4</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Generator</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">longRunningTask</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> value2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> value3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> value4 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>value3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> value5 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">step4</span><span class=\"token punctuation\">(</span>value4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Do something with value4</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle any error from step1 through step4</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"单个异步任务\"><a href=\"#单个异步任务\" class=\"headerlink\" title=\"单个异步任务\"></a>单个异步任务</h3><p>Generator + Promise</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> <span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 调用</span>\n<span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nresult<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上述的执行过程调用 gen 会返回遍历器，然后通过遍历器的 next 方法返回 fetch 的 promise 实例<code>{ value: Promise { &lt;pending&gt; }, done: false }</code>，通过调用 then 方法执行结果</p>\n<h3 id=\"多个异步任务\"><a href=\"#多个异步任务\" class=\"headerlink\" title=\"多个异步任务\"></a>多个异步任务</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> r2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/followers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> r3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/repos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">,</span> r2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>login<span class=\"token punctuation\">,</span> r3<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>full_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>获得执行结果</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result1 <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nresult1<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>利用递归封装上述执行结果</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"启动器函数-（Generator-Promise）\"><a href=\"#启动器函数-（Generator-Promise）\" class=\"headerlink\" title=\"启动器函数 （Generator + Promise）\"></a>启动器函数 （Generator + Promise）</h3><p>由于 fetch 方法返回 promise 有 json 方法，所以上述例子成立，如果 yield 直接结合 promise 函数那么就会变成启动器函数。由于 Generator 不能像普通函数一样自动执行和自己暂缓执行的特性，所以增加自执行启动函数，这也是 co 模块的初衷（）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> json1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r1<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> r2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/followers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> json2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r2<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> r3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/repos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> json3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r3<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>json1<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">,</span> json2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>login<span class=\"token punctuation\">,</span> json3<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>full_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n        result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"启动器函数-（Generator-回调）\"><a href=\"#启动器函数-（Generator-回调）\" class=\"headerlink\" title=\"启动器函数 （Generator + 回调）\"></a>启动器函数 （Generator + 回调）</h3><p>回调函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">:</span> url<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Generator函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> r2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/followers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> r2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>获得结果</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nr1<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> r2 <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  r2<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的示例代码我们观察到回调函数依然解决不了多个 yield 时代码会循环嵌套。还的借助递归</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n        result<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>通过上面代码可以看出 Generator 函数的自动执行需要一种机制，当异步操作有了结果，才能自动交回执行权</p>\n<ul>\n<li>回调函数。 将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权</li>\n<li>Promise对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权</li>\n</ul>\n<p>上面两种方法写了一个 run 的启动器函数，那么我们将两种封装在一起，返回了一个 Promise，获得 Generator 函数的返回值，并且捕获错误</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> gen <span class=\"token operator\">==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 如果 gen 不是一个迭代器</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>gen <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span> gen<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span>\n\n        <span class=\"token function\">onFulfilled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">function</span> <span class=\"token function\">onFulfilled</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">var</span> ret<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                ret <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">function</span> <span class=\"token function\">onRejected</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">var</span> ret<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                ret <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> value <span class=\"token operator\">=</span> <span class=\"token function\">toPromise</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isPromise</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>onFulfilled<span class=\"token punctuation\">,</span> onRejected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">onRejected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You may only yield a function, promise '</span> <span class=\"token operator\">+</span>\n                <span class=\"token string\">'but the following object was passed: \"'</span> <span class=\"token operator\">+</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'\"'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">isPromise</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">.</span>then<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">toPromise</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isPromise</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'function'</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">thunkToPromise</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">thunkToPromise</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> run<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h3><p>co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。</p>\n<p>如果直接使用 co 模块，这两种不同的例子可以简写为</p>\n<p>yield 后是一个 Promise</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> json1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r1<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> r2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/followers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> json2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r2<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> r3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/repos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> json3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r3<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>json1<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">,</span> json2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>login<span class=\"token punctuation\">,</span> json3<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>full_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>yield 后是一个回调函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">var</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> status<span class=\"token punctuation\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">:</span> url <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> r2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github/followers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> r2<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"async-有点\"><a href=\"#async-有点\" class=\"headerlink\" title=\"async 有点\"></a>async 有点</h3><p> async 函数，使得异步操作变得更加方便,它也是 Generator 函数的语法糖。</p>\n<p>当使用 Generator 函数的时候</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> json1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> r1<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>json1<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当使用 async 时候</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fetchData <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> r1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> json1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> r1<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>json1<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面观察到代码基本一样，所以 async 的原理就是将 Generator 函数和自动执行器，包装在一个函数里面</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 等同于</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>async 函数返回一个 Promise 对象所以也可以理解为 async 函数是基于 Promise 和 Generator 的一层封装<br>随意处理初步流程 async 会比使用 Promise 更优雅</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">\"done\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"done\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>moreData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">fetchAnotherData</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>moreData <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> moreData\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> data\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>moreData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> moreData <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetchAnotherData</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> moreData\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> data\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>value1 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">fetchMoreData</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>value2 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">fetchMoreData2</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> value1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> value2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetchMoreData</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fetchMoreData2</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"async-缺点\"><a href=\"#async-缺点\" class=\"headerlink\" title=\"async 缺点\"></a>async 缺点</h3><ul>\n<li>用try…catch 处理上是原本的优雅代码变得不再优雅</li>\n<li>语法的简洁让原本可以并行执行的内容变成了顺序执行，从而影响了性能</li>\n</ul>\n<p>await由于返回 promise 对象，所以结果可能是rejected，所以最好把await命令放在try…catch代码块中<br>但是如果想捕获 JSON.parse 中的错误那么就需要再添加一层 try…catch</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>原本没有依赖关系的两个函数，却只能等待 getList 返回才能执行 getAnotherList，导致请求时间多了一倍</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> getList <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> getAnotherList <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将上面的函数改为如下函数可以解决上述问题</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> listPromise <span class=\"token operator\">=</span> <span class=\"token function\">getList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> anotherListPromise <span class=\"token operator\">=</span> <span class=\"token function\">getAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">await</span> listPromise<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">await</span> anotherListPromise<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>也可以使用 Promse.all</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token function\">getList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>并发执行 async 函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">handleList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> listPromise <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>listData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">handleAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> anotherListPromise <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>anotherListData<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法一</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> handleListPromise <span class=\"token operator\">=</span> <span class=\"token function\">handleList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> handleAnotherListPromise <span class=\"token operator\">=</span> <span class=\"token function\">handleAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">await</span> handleListPromise\n  <span class=\"token keyword\">await</span> handleAnotherListPromise\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法二</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token function\">handleList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">handleAnotherList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>在前端中异步编程一直是前端开发的一个痛点，因为 JavaScript 语法的灵活性和特殊性导致前端开发的困难（因为 JavaScript 是单线程，如果没有异步的世界可以想象一下，将无法执行卡死操作）</p>\n<h3 id=\"什么是异步编程\"><a href=\"#什么是异步编程\" class=\"headerlink\" title=\"什么是异步编程\"></a>什么是异步编程</h3><p>所谓”异步”，一个任务不是连续完成的，先执行第一段，然后执行其他任务，等做好了准备，回过头执行第二段</p>\n<p>所谓”同步”，就是不间断的连续执行一个任务</p>\n<h3 id=\"异步编程示例\"><a href=\"#异步编程示例\" class=\"headerlink\" title=\"异步编程示例\"></a>异步编程示例</h3><p>我们熟悉的异步编程有很多种例如 <code>代码的执行任务队列</code>,<code>setTimeout</code>, <code>setInterval</code>, <code>callback</code>, <code>promise</code> 等</p>\n<p>回调函数</p>\n<pre><code class=\"js\">function Fun(name, callback) {\n  console.log(name)\n  callback &amp;&amp; callback()\n}\nfun(&#39;renbo&#39;,function () {})\n\n再例如数组的操作方法\n\n[1,2,3,4,5].map(function(v,i){\n  return i+&#39;:&#39;+v\n})\n</code></pre>\n<p>Promise</p>\n<pre><code class=\"js\">var readFile = require(&#39;fs-readfile-promise&#39;);\nreadFile(fileA)\n.then(function (data) {\n  console.log(data.toString());\n})\n.then(function () {\n  return readFile(fileB);\n})\n.then(function (data) {\n  console.log(data.toString());\n})\n.catch(function (err) {\n  console.log(err);\n});\n</code></pre>\n<h3 id=\"Generator概念\"><a href=\"#Generator概念\" class=\"headerlink\" title=\"Generator概念\"></a>Generator概念</h3><p>ES6 提供的一种异步编程解决方案，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<h3 id=\"Generator特征\"><a href=\"#Generator特征\" class=\"headerlink\" title=\"Generator特征\"></a>Generator特征</h3><ul>\n<li>function关键字与函数名之间有一个星号</li>\n<li>函数体内部使用yield表达式，定义不同的内部状态</li>\n<li>执行函数不会立即执行，只有调用了next方法才会执行</li>\n<li>如果函数内部不写 yield 表达式，则此函数就是单纯的暂缓执行函数</li>\n<li>每次调用遍历器对象的next方法，返回value和done两个属性的对象</li>\n<li>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值</li>\n<li>done属性是一个布尔值，表示是否遍历结束</li>\n</ul>\n<pre><code class=\"js\">function* funGenerator() {\n  yield &#39;hello&#39;;\n  yield &#39;my name is renbo&#39;;\n  return &#39;ending&#39;;\n}\n\nvar fun = funGenerator();\n\nfun.next() // { value: &#39;hello&#39;, done: false }\nfun.next() // { value: &#39;my name is renbo&#39;, done: false }\nfun.next()  // { value: &#39;ending&#39;, done: true }\nfun.next()  // { value: undefined, done: true }</code></pre>\n<h3 id=\"控制流管理\"><a href=\"#控制流管理\" class=\"headerlink\" title=\"控制流管理\"></a>控制流管理</h3><p>回调</p>\n<pre><code class=\"js\">step1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n</code></pre>\n<p>promise</p>\n<pre><code class=\"js\">Promise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();</code></pre>\n<p>Generator</p>\n<pre><code class=\"js\">function* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n</code></pre>\n<h3 id=\"单个异步任务\"><a href=\"#单个异步任务\" class=\"headerlink\" title=\"单个异步任务\"></a>单个异步任务</h3><p>Generator + Promise</p>\n<pre><code class=\"js\">var fetch = require(&#39;node-fetch&#39;);\n\nfunction* gen(){\n  var url = &#39;https://api.github.com/users/github&#39;;\n  var result = yield fetch(url);\n  console.log(result);\n}\n\n// 调用\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n    return data.json();\n}).then(function(data){\n    g.next(data);\n});</code></pre>\n<p>上述的执行过程调用 gen 会返回遍历器，然后通过遍历器的 next 方法返回 fetch 的 promise 实例<code>{ value: Promise { &lt;pending&gt; }, done: false }</code>，通过调用 then 方法执行结果</p>\n<h3 id=\"多个异步任务\"><a href=\"#多个异步任务\" class=\"headerlink\" title=\"多个异步任务\"></a>多个异步任务</h3><pre><code class=\"js\">var fetch = require(&#39;node-fetch&#39;);\n\nfunction* gen() {\n  var r1 = yield fetch(&#39;https://api.github.com/users/github&#39;);\n  var r2 = yield fetch(&#39;https://api.github.com/users/github/followers&#39;);\n  var r3 = yield fetch(&#39;https://api.github.com/users/github/repos&#39;);\n\n  console.log([r1.bio, r2[0].login, r3[0].full_name].join(&#39;\\n&#39;));\n}\n</code></pre>\n<p>获得执行结果</p>\n<pre><code class=\"js\">var g = gen();\nvar result1 = g.next();\n\nresult1.value.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value;\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    g.next(data)\n});\n</code></pre>\n<p>利用递归封装上述执行结果</p>\n<pre><code class=\"js\">function run(gen) {\n  var g = gen();\n\n  function next(data) {\n    var result = g.next(data);\n\n    if (result.done) return;\n\n    result.value.then(function(data) {\n        return data.json();\n    }).then(function(data) {\n        next(data);\n    });\n\n  }\n\n  next();\n}\n\nrun(gen);</code></pre>\n<h3 id=\"启动器函数-（Generator-Promise）\"><a href=\"#启动器函数-（Generator-Promise）\" class=\"headerlink\" title=\"启动器函数 （Generator + Promise）\"></a>启动器函数 （Generator + Promise）</h3><p>由于 fetch 方法返回 promise 有 json 方法，所以上述例子成立，如果 yield 直接结合 promise 函数那么就会变成启动器函数。由于 Generator 不能像普通函数一样自动执行和自己暂缓执行的特性，所以增加自执行启动函数，这也是 co 模块的初衷（）</p>\n<pre><code class=\"js\">var fetch = require(&#39;node-fetch&#39;);\n\nfunction* gen() {\n  var r1 = yield fetch(&#39;https://api.github.com/users/github&#39;);\n  var json1 = yield r1.json();\n  var r2 = yield fetch(&#39;https://api.github.com/users/github/followers&#39;);\n  var json2 = yield r2.json();\n  var r3 = yield fetch(&#39;https://api.github.com/users/github/repos&#39;);\n  var json3 = yield r3.json();\n\n  console.log([json1.bio, json2[0].login, json3[0].full_name].join(&#39;\\n&#39;));\n}\n\nfunction run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value.then(function(data) {\n            next(data);\n        });\n\n    }\n\n    next();\n}\n\nrun(gen);\n</code></pre>\n<h3 id=\"启动器函数-（Generator-回调）\"><a href=\"#启动器函数-（Generator-回调）\" class=\"headerlink\" title=\"启动器函数 （Generator + 回调）\"></a>启动器函数 （Generator + 回调）</h3><p>回调函数</p>\n<pre><code class=\"js\">function fetchData(url) {\n    return function(cb){\n        setTimeout(function(){\n            cb({status: 200, data: url})\n        }, 1000)\n    }\n}</code></pre>\n<p>Generator函数</p>\n<pre><code class=\"js\">function* gen() {\n    var r1 = yield fetchData(&#39;https://api.github.com/users/github&#39;);\n    var r2 = yield fetchData(&#39;https://api.github.com/users/github/followers&#39;);\n\n    console.log([r1.data, r2.data].join(&#39;\\n&#39;));\n}</code></pre>\n<p>获得结果</p>\n<pre><code class=\"js\">var g = gen();\n\nvar r1 = g.next();\n\nr1.value(function(data) {\n  var r2 = g.next(data);\n  r2.value(function(data) {\n      g.next(data);\n  });\n});</code></pre>\n<p>通过上面的示例代码我们观察到回调函数依然解决不了多个 yield 时代码会循环嵌套。还的借助递归</p>\n<pre><code class=\"js\">function run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value(next);\n    }\n\n    next();\n}\n\nrun(gen);</code></pre>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>通过上面代码可以看出 Generator 函数的自动执行需要一种机制，当异步操作有了结果，才能自动交回执行权</p>\n<ul>\n<li>回调函数。 将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权</li>\n<li>Promise对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权</li>\n</ul>\n<p>上面两种方法写了一个 run 的启动器函数，那么我们将两种封装在一起，返回了一个 Promise，获得 Generator 函数的返回值，并且捕获错误</p>\n<pre><code class=\"js\">function run(gen) {\n\n    return new Promise(function(resolve, reject) {\n        if (typeof gen == &#39;function&#39;) gen = gen();\n\n        // 如果 gen 不是一个迭代器\n        if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen)\n\n        onFulfilled();\n\n        function onFulfilled(res) {\n            var ret;\n            try {\n                ret = gen.next(res);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function onRejected(err) {\n            var ret;\n            try {\n                ret = gen.throw(err);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function next(ret) {\n            if (ret.done) return resolve(ret.value);\n            var value = toPromise(ret.value);\n            if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n            return onRejected(new TypeError(&#39;You may only yield a function, promise &#39; +\n                &#39;but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;));\n        }\n    })\n}\n\nfunction isPromise(obj) {\n    return &#39;function&#39; == typeof obj.then;\n}\n\nfunction toPromise(obj) {\n    if (isPromise(obj)) return obj;\n    if (&#39;function&#39; == typeof obj) return thunkToPromise(obj);\n    return obj;\n}\n\nfunction thunkToPromise(fn) {\n    return new Promise(function(resolve, reject) {\n        fn(function(err, res) {\n            if (err) return reject(err);\n            resolve(res);\n        });\n    });\n}\n\nmodule.exports = run;</code></pre>\n<h3 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h3><p>co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。</p>\n<p>如果直接使用 co 模块，这两种不同的例子可以简写为</p>\n<p>yield 后是一个 Promise</p>\n<pre><code class=\"js\">var fetch = require(&#39;node-fetch&#39;);\nvar co = require(&#39;co&#39;);\n\nfunction* gen() {\n    var r1 = yield fetch(&#39;https://api.github.com/users/github&#39;);\n    var json1 = yield r1.json();\n    var r2 = yield fetch(&#39;https://api.github.com/users/github/followers&#39;);\n    var json2 = yield r2.json();\n    var r3 = yield fetch(&#39;https://api.github.com/users/github/repos&#39;);\n    var json3 = yield r3.json();\n\n    console.log([json1.bio, json2[0].login, json3[0].full_name].join(&#39;\\n&#39;));\n}\n\nco(gen);</code></pre>\n<p>yield 后是一个回调函数</p>\n<pre><code class=\"js\">\nvar co = require(&#39;co&#39;);\n\nfunction fetchData(url) {\n    return function(cb) {\n        setTimeout(function() {\n            cb(null, { status: 200, data: url })\n        }, 1000)\n    }\n}\n\nfunction* gen() {\n    var r1 = yield fetchData(&#39;https://api.github.com/users/github&#39;);\n    var r2 = yield fetchData(&#39;https://api.github.com/users/github/followers&#39;);\n\n    console.log([r1.data, r2.data].join(&#39;\\n&#39;));\n}\n\nco(gen);</code></pre>\n<h3 id=\"async-有点\"><a href=\"#async-有点\" class=\"headerlink\" title=\"async 有点\"></a>async 有点</h3><p> async 函数，使得异步操作变得更加方便,它也是 Generator 函数的语法糖。</p>\n<p>当使用 Generator 函数的时候</p>\n<pre><code class=\"js\">var fetch = require(&#39;node-fetch&#39;);\nvar co = require(&#39;co&#39;);\n\nfunction* gen() {\n    var r1 = yield fetch(&#39;https://api.github.com/users/github&#39;);\n    var json1 = yield r1.json();\n    console.log(json1.bio);\n}\n\nco(gen);</code></pre>\n<p>当使用 async 时候</p>\n<pre><code class=\"js\">var fetch = require(&#39;node-fetch&#39;);\n\nvar fetchData = async function () {\n    var r1 = await fetch(&#39;https://api.github.com/users/github&#39;);\n    var json1 = await r1.json();\n    console.log(json1.bio);\n};\n\nfetchData();</code></pre>\n<p>通过上面观察到代码基本一样，所以 async 的原理就是将 Generator 函数和自动执行器，包装在一个函数里面</p>\n<pre><code class=\"js\">async function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}</code></pre>\n<p>async 函数返回一个 Promise 对象所以也可以理解为 async 函数是基于 Promise 和 Generator 的一层封装<br>随意处理初步流程 async 会比使用 Promise 更优雅</p>\n<pre><code class=\"js\">function fetch() {\n  return (\n    fetchData().then(() =&gt; {\n      return &quot;done&quot;\n    });\n  )\n}\n\nasync function fetch() {\n  await fetchData()\n  return &quot;done&quot;\n};</code></pre>\n<pre><code class=\"js\">function fetch() {\n  return fetchData().then(data =&gt; {\n    if (data.moreData) {\n      return fetchAnotherData(data).then(moreData =&gt; {\n        return moreData\n      })\n    } else {\n      return data\n    }\n  });\n}\n\nasync function fetch() {\n  const data = await fetchData()\n  if (data.moreData) {\n    const moreData = await fetchAnotherData(data);\n    return moreData\n  } else {\n    return data\n  }\n}</code></pre>\n<pre><code class=\"js\">function fetch() {\n  return (\n    fetchData()\n    .then(value1 =&gt; {\n      return fetchMoreData(value1)\n    })\n    .then(value2 =&gt; {\n      return fetchMoreData2(value2)\n    })\n  )\n}\n\nasync function fetch() {\n  const value1 = await fetchData()\n  const value2 = await fetchMoreData(value1)\n  return fetchMoreData2(value2)\n};</code></pre>\n<h3 id=\"async-缺点\"><a href=\"#async-缺点\" class=\"headerlink\" title=\"async 缺点\"></a>async 缺点</h3><ul>\n<li>用try…catch 处理上是原本的优雅代码变得不再优雅</li>\n<li>语法的简洁让原本可以并行执行的内容变成了顺序执行，从而影响了性能</li>\n</ul>\n<p>await由于返回 promise 对象，所以结果可能是rejected，所以最好把await命令放在try…catch代码块中<br>但是如果想捕获 JSON.parse 中的错误那么就需要再添加一层 try…catch</p>\n<pre><code class=\"js\">async function fetch() {\n  try {\n    const data = JSON.parse(await fetchData())\n  } catch (err) {\n    console.log(err)\n  }\n};</code></pre>\n<p>原本没有依赖关系的两个函数，却只能等待 getList 返回才能执行 getAnotherList，导致请求时间多了一倍</p>\n<pre><code class=\"js\">(async () =&gt; {\n  const getList = await getList();\n  const getAnotherList = await getAnotherList();\n})();</code></pre>\n<p>将上面的函数改为如下函数可以解决上述问题</p>\n<pre><code class=\"js\">(async () =&gt; {\n  const listPromise = getList();\n  const anotherListPromise = getAnotherList();\n  await listPromise;\n  await anotherListPromise;\n})();</code></pre>\n<p>也可以使用 Promse.all</p>\n<pre><code class=\"js\">(async () =&gt; {\n  Promise.all([getList(), getAnotherList()]).then(...);\n})();</code></pre>\n<p>并发执行 async 函数</p>\n<pre><code class=\"js\">async function handleList() {\n  const listPromise = await getList();\n  // ...\n  await submit(listData);\n}\n\nasync function handleAnotherList() {\n  const anotherListPromise = await getAnotherList()\n  // ...\n  await submit(anotherListData)\n}\n\n// 方法一\n(async () =&gt; {\n  const handleListPromise = handleList()\n  const handleAnotherListPromise = handleAnotherList()\n  await handleListPromise\n  await handleAnotherListPromise\n})()\n\n// 方法二\n(async () =&gt; {\n  Promise.all([handleList(), handleAnotherList()]).then()\n})()</code></pre>\n"},{"title":"函数节流与抖动","date":"2019-05-15T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 浏览器内核\n\n说起函数的节流与抖动这个老生长谈的话题，我们就需要了解一下关于浏览器的知识\n\n浏览器有各种进程，来保证浏览器正常的、流畅的呈现在用户的眼前。例如渲染进程（也就是浏览器的内核）是非常重要的一个进程，其中包含了很多的线程\n\n```\nGUI渲染线程(负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等)\n\nJS引擎线程(JS内核，负责处理JavaScript脚本程序)\n\n事件触发线程(归属于浏览器而不是JS引擎，用来控制事件循环)\n\n定时触发器线程(传说中的setTimeout和setInterval所在的线程)\n\n异步http请求线程(在XMLHttpRequest在连接后是通过浏览器新型一个线程请求)\n```\n\n这里我们大概了解一下着几个概念，关于更过的相关知识会在后续的文章中介绍\n\n\n### 请求过程\n\n我们先来看下面一张来至 W3C 的图\n\n<img src=\"/images/timestamp-diagram.svg\"></img>\n\n\n从图中我们看到处理模型大概分为如下几个阶段\n- DNS 查询\n- TCP 连接\n- HTTP 请求即响应\n- 服务器响应\n- 客户端渲染\n\n这篇文章我们不讨论 Resource Timing 阶段，会在后续文章前端性能的时候重新提起\n\n### 渲染过程\n\n通过第五个阶段客户端渲染简单的回忆一下网页的生成过程，大致分为几个步骤\n\n- HTML解析器解析成DOM 树\n- CSS解析器解析成CSSOM 树\n- 结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)\n- 生成布局（Layout），根据渲染树来布局，以计算每个节点的几何信息\n- 最后一步是绘制（Paint），使用最终渲染树将像素渲染到在屏幕上\n\n\n<img src=\"/images/render-process.jpg\">\n\n通过上面的总结我们解析每一个步骤能更加深入的了解浏览器渲染过程\n\n### HTML 解析器解析过程\n\nHTML 解析器构建 DOM 树，实际上是经过下面几个步骤\n\n```\n字节 -> 字符 -> 令牌 -> 节点对象 -> 对象模型\n\n编码阶段将 HTML 的原始字节数据转换为文件指定编码\n\n令牌阶段根据HTML规范来将字符串转换成各种令牌也就是标签节点\n\n生成节点对象阶段是根据每个令牌转换定义其属性和规则的对象（节点对象）\n\n最后阶段 DOM 树构建完成，整个对象集合就像是一棵树形结构（对象模型）\n```\n\n下面通过代码和图片来解释上面的步骤\n\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <link href=\"style.css\" rel=\"stylesheet\">\n    <title></title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"\"></div>\n  </body>\n</html>\n```\n\n<img src=\"/images/dom-render.jpg\" />\n\n### CSS 解析过程\n\n浏览器获得 CSS 文件的数据后 CSS 解析器根据具体的样式将渲染 CSSDOM 树\n\n<img src=\"/images/css-dom-render.jpg\" />\n\n### 渲染树渲染\n\n构建 两个树之后渲染树出场，浏览器会先从DOM树的根节点开始遍历，对每个可见节点，找到对应的 CSS 样式规则，进行匹配形成构建完成的渲染树\n\n<img src=\"/images/render-tree.jpg\">\n\n\n渲染树构建后浏览器根据节点对象的规则进行flow（布局）阶段，布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置最后生成我们大家知道的浏览器盒模型\n\n\n最后当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，最后渲染到在屏幕上\n\n\n通过上面大致的流程我们知道了浏览器的渲染过程，我们知道网页在生成的时候，至少会渲染一次执行css之后 load 对应 JS 也会进行重新渲染\n\n重新渲染就可能会 reflow + repaint\n\n### 重绘与回流\n\n回流(reflow)： 当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建\n\n重绘(repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘\n\n回流必定会发生重绘，重绘不一定会引发回流\n\n浏览器的reflow + repaint 在我们设置节点样式时频繁出现，对性能是个巨大的消耗，因为回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流，所以我们经常说尽可能的减少重排次数、重排范围，这样就能呈现给用户更改的感官（关于优化手段会在后续的性能优化文章中介绍）\n\n\n根据上面说了这么多，我们来进入文章的主题**防抖和节流**当我们窗口发生改变，浏览器的滚动条执行scroll，输入框校验，搜索请求接口等这些都会使页面频繁重新渲染，加重浏览器的负担，这是我们通过**防抖和节流**的方式减少触发频率，这样就会大大的提高用户体验\n\n### debounce（防抖）\n\n动作发生一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。\n\nhtml \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>防抖</title>\n  <style>\n    #container{\n      width: 100%; \n      height: 500px; \n      background: #000; \n      font-size: 50px;\n      color: #fff;\n      line-height: 500px; \n      text-align: center; \n    }\n  </style>\n</head>\n<body>\n  <div id=\"content\"><div>\n  <script src=\"debounce.js\"></script>\n  <script>\n    var count = 1;\n    var container = document.getElementById('container');\n    function getContent(e) {\n      container.innerHTML = count++;\n    };\n    // container.onmousemove = getContent\n    container.onmousemove = debounce(getContent, 500, true);\n  </script>\n</body>\n</html>\n```\n\ndebounce.js \n\n```js\n@underscore.js\n\nvar debounce = /** @class */ (function () {\n  \n  /**\n   * @desc 函数防抖\n   * @param {*} func 回调函数\n   * @param {*} wait 延迟执行毫秒数\n   * @param {*} immediate  true 表立即执行，false 表非立即执行\n   */\n  function debounce(func, wait, immediate) {\n\n    // 创建一个标记用来存放定时器的返回值\n    var timeout,result;\n    \n    return function () {\n\n      // 指定this 作用域\n      var context = this;\n      // event 对象\n      var args = arguments;\n\n      // 再次执行事件的时候，清除上一个定时器\n      if (timeout) clearTimeout(timeout);\n      \n      if (immediate) {\n        // 如果已经执行过，将不再执行\n        var callNow = !timeout;\n        timeout = setTimeout(function(){\n          timeout = null;\n        }, wait)\n        \n        if (callNow) result = func.apply(context, args)\n      }\n      else {\n        \n        timeout = setTimeout(function(){\n          func.apply(context, args)\n        }, wait);\n      }\n      // func 这个函数，可能有返回值\n      return result;\n    }\n  }\n\n  return debounce;\n  \n}())\n\n```\n\n\n### throttle\n\n动作执行一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新执行\n\n关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器\n\n使用时间戳\n\n当触发事件的时候，取出当前的时间戳，之后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，执行函数并更新当前时间戳，反之就不执行。\n\n```js\nvar throttle = /** @class */ (function () {\n  \n  function throttle(func, wait) {\n    var args;\n    var previous = 0;\n  \n    return function() {\n      var now = +new Date();\n      args = arguments;\n      if (now - previous > wait) {\n        func.apply(this, args);\n        previous = now;\n      }\n    }\n  }\n\n  return throttle\n}())\n```\n\n使用定时器\n\n事件触发的时候，设置一个定时器，如果定时器存在，就不执行，等定时器到指定的时间，清空定时器，执行事件\n\n```js\nfunction throttle(func, wait) {\n  var timeout;\n  var previous = 0;\n\n  return function() {\n    context = this;\n    args = arguments;\n    if (!timeout) {\n      timeout = setTimeout(function(){\n        timeout = null;\n        func.apply(context, args)\n      }, wait)\n    }\n  }\n}\n```\n\n对比两种实现方式\n\n- 第一种会立刻执行，第二种会在设定的时间后第一次执行\n- 第一种停止触发后不会再执行，第二种停止触发后依然会再执行一次\n\n现在我们要结合上面两种方式实现一个开始触发立刻执行，停止触发的时候还能再执行一次\n\n```js\n@underscore.js\n\nvar throttle = /** @class */ (function () {\n\n  /**\n   * throttle 节流\n   * @param {*} func  回调函数\n   * @param {*} wait  执行时间间隔\n   * @param {*} options  如果想忽略开始函数的的调用，传入{leading: false}\n   *                     如果想忽略结尾函数的调用，传入{trailing: false}\n   *                     两者不能共存，否则函数不能执行\n   */\n  function throttle(func, wait, options) {\n\n    var timeout, context, args;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      previous = options.leading === false ? 0 : new Date().getTime();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = new Date().getTime();\n      \n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing，没有就开启一个定时器\n        timeout = setTimeout(later, remaining);\n      }\n    };\n    return throttled;\n}\n\n  return throttle\n}())\n```\n\n调用例子\n```js\nontainer.onmousemove = throttle(getContent, 1000);\ncontainer.onmousemove = throttle(getContent, 1000, {\n  leading: false\n});\ncontainer.onmousemove = throttle(getContent, 1000, {\n  trailing: false\n});\n```\n\n### 总结\n\n上面的就是函数的节流与抖动的全部，我们在面试和工作中会经常的遇到。这也是性能优化的一种方案。当然还有很多版本比如多 promise 版本的就不再这里叙述了，有兴趣的可以找找技术论坛\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/debounce.md","raw":"---\ntitle: 函数节流与抖动\ndate: 2019-5-15 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n### 浏览器内核\n\n说起函数的节流与抖动这个老生长谈的话题，我们就需要了解一下关于浏览器的知识\n\n浏览器有各种进程，来保证浏览器正常的、流畅的呈现在用户的眼前。例如渲染进程（也就是浏览器的内核）是非常重要的一个进程，其中包含了很多的线程\n\n```\nGUI渲染线程(负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等)\n\nJS引擎线程(JS内核，负责处理JavaScript脚本程序)\n\n事件触发线程(归属于浏览器而不是JS引擎，用来控制事件循环)\n\n定时触发器线程(传说中的setTimeout和setInterval所在的线程)\n\n异步http请求线程(在XMLHttpRequest在连接后是通过浏览器新型一个线程请求)\n```\n\n这里我们大概了解一下着几个概念，关于更过的相关知识会在后续的文章中介绍\n\n\n### 请求过程\n\n我们先来看下面一张来至 W3C 的图\n\n<img src=\"/images/timestamp-diagram.svg\"></img>\n\n\n从图中我们看到处理模型大概分为如下几个阶段\n- DNS 查询\n- TCP 连接\n- HTTP 请求即响应\n- 服务器响应\n- 客户端渲染\n\n这篇文章我们不讨论 Resource Timing 阶段，会在后续文章前端性能的时候重新提起\n\n### 渲染过程\n\n通过第五个阶段客户端渲染简单的回忆一下网页的生成过程，大致分为几个步骤\n\n- HTML解析器解析成DOM 树\n- CSS解析器解析成CSSOM 树\n- 结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)\n- 生成布局（Layout），根据渲染树来布局，以计算每个节点的几何信息\n- 最后一步是绘制（Paint），使用最终渲染树将像素渲染到在屏幕上\n\n\n<img src=\"/images/render-process.jpg\">\n\n通过上面的总结我们解析每一个步骤能更加深入的了解浏览器渲染过程\n\n### HTML 解析器解析过程\n\nHTML 解析器构建 DOM 树，实际上是经过下面几个步骤\n\n```\n字节 -> 字符 -> 令牌 -> 节点对象 -> 对象模型\n\n编码阶段将 HTML 的原始字节数据转换为文件指定编码\n\n令牌阶段根据HTML规范来将字符串转换成各种令牌也就是标签节点\n\n生成节点对象阶段是根据每个令牌转换定义其属性和规则的对象（节点对象）\n\n最后阶段 DOM 树构建完成，整个对象集合就像是一棵树形结构（对象模型）\n```\n\n下面通过代码和图片来解释上面的步骤\n\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <link href=\"style.css\" rel=\"stylesheet\">\n    <title></title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"\"></div>\n  </body>\n</html>\n```\n\n<img src=\"/images/dom-render.jpg\" />\n\n### CSS 解析过程\n\n浏览器获得 CSS 文件的数据后 CSS 解析器根据具体的样式将渲染 CSSDOM 树\n\n<img src=\"/images/css-dom-render.jpg\" />\n\n### 渲染树渲染\n\n构建 两个树之后渲染树出场，浏览器会先从DOM树的根节点开始遍历，对每个可见节点，找到对应的 CSS 样式规则，进行匹配形成构建完成的渲染树\n\n<img src=\"/images/render-tree.jpg\">\n\n\n渲染树构建后浏览器根据节点对象的规则进行flow（布局）阶段，布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置最后生成我们大家知道的浏览器盒模型\n\n\n最后当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，最后渲染到在屏幕上\n\n\n通过上面大致的流程我们知道了浏览器的渲染过程，我们知道网页在生成的时候，至少会渲染一次执行css之后 load 对应 JS 也会进行重新渲染\n\n重新渲染就可能会 reflow + repaint\n\n### 重绘与回流\n\n回流(reflow)： 当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建\n\n重绘(repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘\n\n回流必定会发生重绘，重绘不一定会引发回流\n\n浏览器的reflow + repaint 在我们设置节点样式时频繁出现，对性能是个巨大的消耗，因为回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流，所以我们经常说尽可能的减少重排次数、重排范围，这样就能呈现给用户更改的感官（关于优化手段会在后续的性能优化文章中介绍）\n\n\n根据上面说了这么多，我们来进入文章的主题**防抖和节流**当我们窗口发生改变，浏览器的滚动条执行scroll，输入框校验，搜索请求接口等这些都会使页面频繁重新渲染，加重浏览器的负担，这是我们通过**防抖和节流**的方式减少触发频率，这样就会大大的提高用户体验\n\n### debounce（防抖）\n\n动作发生一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。\n\nhtml \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>防抖</title>\n  <style>\n    #container{\n      width: 100%; \n      height: 500px; \n      background: #000; \n      font-size: 50px;\n      color: #fff;\n      line-height: 500px; \n      text-align: center; \n    }\n  </style>\n</head>\n<body>\n  <div id=\"content\"><div>\n  <script src=\"debounce.js\"></script>\n  <script>\n    var count = 1;\n    var container = document.getElementById('container');\n    function getContent(e) {\n      container.innerHTML = count++;\n    };\n    // container.onmousemove = getContent\n    container.onmousemove = debounce(getContent, 500, true);\n  </script>\n</body>\n</html>\n```\n\ndebounce.js \n\n```js\n@underscore.js\n\nvar debounce = /** @class */ (function () {\n  \n  /**\n   * @desc 函数防抖\n   * @param {*} func 回调函数\n   * @param {*} wait 延迟执行毫秒数\n   * @param {*} immediate  true 表立即执行，false 表非立即执行\n   */\n  function debounce(func, wait, immediate) {\n\n    // 创建一个标记用来存放定时器的返回值\n    var timeout,result;\n    \n    return function () {\n\n      // 指定this 作用域\n      var context = this;\n      // event 对象\n      var args = arguments;\n\n      // 再次执行事件的时候，清除上一个定时器\n      if (timeout) clearTimeout(timeout);\n      \n      if (immediate) {\n        // 如果已经执行过，将不再执行\n        var callNow = !timeout;\n        timeout = setTimeout(function(){\n          timeout = null;\n        }, wait)\n        \n        if (callNow) result = func.apply(context, args)\n      }\n      else {\n        \n        timeout = setTimeout(function(){\n          func.apply(context, args)\n        }, wait);\n      }\n      // func 这个函数，可能有返回值\n      return result;\n    }\n  }\n\n  return debounce;\n  \n}())\n\n```\n\n\n### throttle\n\n动作执行一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新执行\n\n关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器\n\n使用时间戳\n\n当触发事件的时候，取出当前的时间戳，之后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，执行函数并更新当前时间戳，反之就不执行。\n\n```js\nvar throttle = /** @class */ (function () {\n  \n  function throttle(func, wait) {\n    var args;\n    var previous = 0;\n  \n    return function() {\n      var now = +new Date();\n      args = arguments;\n      if (now - previous > wait) {\n        func.apply(this, args);\n        previous = now;\n      }\n    }\n  }\n\n  return throttle\n}())\n```\n\n使用定时器\n\n事件触发的时候，设置一个定时器，如果定时器存在，就不执行，等定时器到指定的时间，清空定时器，执行事件\n\n```js\nfunction throttle(func, wait) {\n  var timeout;\n  var previous = 0;\n\n  return function() {\n    context = this;\n    args = arguments;\n    if (!timeout) {\n      timeout = setTimeout(function(){\n        timeout = null;\n        func.apply(context, args)\n      }, wait)\n    }\n  }\n}\n```\n\n对比两种实现方式\n\n- 第一种会立刻执行，第二种会在设定的时间后第一次执行\n- 第一种停止触发后不会再执行，第二种停止触发后依然会再执行一次\n\n现在我们要结合上面两种方式实现一个开始触发立刻执行，停止触发的时候还能再执行一次\n\n```js\n@underscore.js\n\nvar throttle = /** @class */ (function () {\n\n  /**\n   * throttle 节流\n   * @param {*} func  回调函数\n   * @param {*} wait  执行时间间隔\n   * @param {*} options  如果想忽略开始函数的的调用，传入{leading: false}\n   *                     如果想忽略结尾函数的调用，传入{trailing: false}\n   *                     两者不能共存，否则函数不能执行\n   */\n  function throttle(func, wait, options) {\n\n    var timeout, context, args;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      previous = options.leading === false ? 0 : new Date().getTime();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = new Date().getTime();\n      \n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing，没有就开启一个定时器\n        timeout = setTimeout(later, remaining);\n      }\n    };\n    return throttled;\n}\n\n  return throttle\n}())\n```\n\n调用例子\n```js\nontainer.onmousemove = throttle(getContent, 1000);\ncontainer.onmousemove = throttle(getContent, 1000, {\n  leading: false\n});\ncontainer.onmousemove = throttle(getContent, 1000, {\n  trailing: false\n});\n```\n\n### 总结\n\n上面的就是函数的节流与抖动的全部，我们在面试和工作中会经常的遇到。这也是性能优化的一种方案。当然还有很多版本比如多 promise 版本的就不再这里叙述了，有兴趣的可以找找技术论坛\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/debounce","published":1,"updated":"2019-10-15T01:29:42.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ow4008hb0u6y7l8au2s","content":"<h3 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h3><p>说起函数的节流与抖动这个老生长谈的话题，我们就需要了解一下关于浏览器的知识</p>\n<p>浏览器有各种进程，来保证浏览器正常的、流畅的呈现在用户的眼前。例如渲染进程（也就是浏览器的内核）是非常重要的一个进程，其中包含了很多的线程</p>\n<pre><code>GUI渲染线程(负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等)\n\nJS引擎线程(JS内核，负责处理JavaScript脚本程序)\n\n事件触发线程(归属于浏览器而不是JS引擎，用来控制事件循环)\n\n定时触发器线程(传说中的setTimeout和setInterval所在的线程)\n\n异步http请求线程(在XMLHttpRequest在连接后是通过浏览器新型一个线程请求)</code></pre><p>这里我们大概了解一下着几个概念，关于更过的相关知识会在后续的文章中介绍</p>\n<h3 id=\"请求过程\"><a href=\"#请求过程\" class=\"headerlink\" title=\"请求过程\"></a>请求过程</h3><p>我们先来看下面一张来至 W3C 的图</p>\n<p><img src=\"/images/timestamp-diagram.svg\"></p>\n<p>从图中我们看到处理模型大概分为如下几个阶段</p>\n<ul>\n<li>DNS 查询</li>\n<li>TCP 连接</li>\n<li>HTTP 请求即响应</li>\n<li>服务器响应</li>\n<li>客户端渲染</li>\n</ul>\n<p>这篇文章我们不讨论 Resource Timing 阶段，会在后续文章前端性能的时候重新提起</p>\n<h3 id=\"渲染过程\"><a href=\"#渲染过程\" class=\"headerlink\" title=\"渲染过程\"></a>渲染过程</h3><p>通过第五个阶段客户端渲染简单的回忆一下网页的生成过程，大致分为几个步骤</p>\n<ul>\n<li>HTML解析器解析成DOM 树</li>\n<li>CSS解析器解析成CSSOM 树</li>\n<li>结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)</li>\n<li>生成布局（Layout），根据渲染树来布局，以计算每个节点的几何信息</li>\n<li>最后一步是绘制（Paint），使用最终渲染树将像素渲染到在屏幕上</li>\n</ul>\n<img src=\"/images/render-process.jpg\">\n\n<p>通过上面的总结我们解析每一个步骤能更加深入的了解浏览器渲染过程</p>\n<h3 id=\"HTML-解析器解析过程\"><a href=\"#HTML-解析器解析过程\" class=\"headerlink\" title=\"HTML 解析器解析过程\"></a>HTML 解析器解析过程</h3><p>HTML 解析器构建 DOM 树，实际上是经过下面几个步骤</p>\n<pre><code>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型\n\n编码阶段将 HTML 的原始字节数据转换为文件指定编码\n\n令牌阶段根据HTML规范来将字符串转换成各种令牌也就是标签节点\n\n生成节点对象阶段是根据每个令牌转换定义其属性和规则的对象（节点对象）\n\n最后阶段 DOM 树构建完成，整个对象集合就像是一棵树形结构（对象模型）</code></pre><p>下面通过代码和图片来解释上面的步骤</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>width<span class=\"token punctuation\">=</span>device-width,initial-scale<span class=\"token punctuation\">=</span>1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>style.css<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>stylesheet<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Hello <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span>web performance<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span> students!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<img src=\"/images/dom-render.jpg\">\n\n<h3 id=\"CSS-解析过程\"><a href=\"#CSS-解析过程\" class=\"headerlink\" title=\"CSS 解析过程\"></a>CSS 解析过程</h3><p>浏览器获得 CSS 文件的数据后 CSS 解析器根据具体的样式将渲染 CSSDOM 树</p>\n<img src=\"/images/css-dom-render.jpg\">\n\n<h3 id=\"渲染树渲染\"><a href=\"#渲染树渲染\" class=\"headerlink\" title=\"渲染树渲染\"></a>渲染树渲染</h3><p>构建 两个树之后渲染树出场，浏览器会先从DOM树的根节点开始遍历，对每个可见节点，找到对应的 CSS 样式规则，进行匹配形成构建完成的渲染树</p>\n<img src=\"/images/render-tree.jpg\">\n\n\n<p>渲染树构建后浏览器根据节点对象的规则进行flow（布局）阶段，布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置最后生成我们大家知道的浏览器盒模型</p>\n<p>最后当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，最后渲染到在屏幕上</p>\n<p>通过上面大致的流程我们知道了浏览器的渲染过程，我们知道网页在生成的时候，至少会渲染一次执行css之后 load 对应 JS 也会进行重新渲染</p>\n<p>重新渲染就可能会 reflow + repaint</p>\n<h3 id=\"重绘与回流\"><a href=\"#重绘与回流\" class=\"headerlink\" title=\"重绘与回流\"></a>重绘与回流</h3><p>回流(reflow)： 当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建</p>\n<p>重绘(repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘</p>\n<p>回流必定会发生重绘，重绘不一定会引发回流</p>\n<p>浏览器的reflow + repaint 在我们设置节点样式时频繁出现，对性能是个巨大的消耗，因为回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流，所以我们经常说尽可能的减少重排次数、重排范围，这样就能呈现给用户更改的感官（关于优化手段会在后续的性能优化文章中介绍）</p>\n<p>根据上面说了这么多，我们来进入文章的主题<strong>防抖和节流</strong>当我们窗口发生改变，浏览器的滚动条执行scroll，输入框校验，搜索请求接口等这些都会使页面频繁重新渲染，加重浏览器的负担，这是我们通过<strong>防抖和节流</strong>的方式减少触发频率，这样就会大大的提高用户体验</p>\n<h3 id=\"debounce（防抖）\"><a href=\"#debounce（防抖）\" class=\"headerlink\" title=\"debounce（防抖）\"></a>debounce（防抖）</h3><p>动作发生一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。</p>\n<p>html </p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>X-UA-Compatible<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>ie<span class=\"token punctuation\">=</span>edge<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>防抖<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token selector\"><span class=\"token id\">#container</span></span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100%</span><span class=\"token punctuation\">;</span> \n      <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">500</span>px<span class=\"token punctuation\">;</span> \n      <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#000</span><span class=\"token punctuation\">;</span> \n      <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n      <span class=\"token property\">color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n      <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">500</span>px<span class=\"token punctuation\">;</span> \n      <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>content<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>debounce.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    <span class=\"token keyword\">var</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> container <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getContent</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      container<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// container.onmousemove = getContent</span>\n    container<span class=\"token punctuation\">.</span>onmousemove <span class=\"token operator\">=</span> <span class=\"token function\">debounce</span><span class=\"token punctuation\">(</span>getContent<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>debounce.js </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">@underscore<span class=\"token punctuation\">.</span>js\n\n<span class=\"token keyword\">var</span> debounce <span class=\"token operator\">=</span> <span class=\"token comment\" spellcheck=\"true\">/** @class */</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * @desc 函数防抖\n   * @param {*} func 回调函数\n   * @param {*} wait 延迟执行毫秒数\n   * @param {*} immediate  true 表立即执行，false 表非立即执行\n   */</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">debounce</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">,</span> immediate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建一个标记用来存放定时器的返回值</span>\n    <span class=\"token keyword\">var</span> timeout<span class=\"token punctuation\">,</span>result<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 指定this 作用域</span>\n      <span class=\"token keyword\">var</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// event 对象</span>\n      <span class=\"token keyword\">var</span> args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 再次执行事件的时候，清除上一个定时器</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>immediate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果已经执行过，将不再执行</span>\n        <span class=\"token keyword\">var</span> callNow <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>timeout<span class=\"token punctuation\">;</span>\n        timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          timeout <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>callNow<span class=\"token punctuation\">)</span> result <span class=\"token operator\">=</span> func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\n        timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// func 这个函数，可能有返回值</span>\n      <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> debounce<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"throttle\"></a>throttle</h3><p>动作执行一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新执行</p>\n<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器</p>\n<p>使用时间戳</p>\n<p>当触发事件的时候，取出当前的时间戳，之后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，执行函数并更新当前时间戳，反之就不执行。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> throttle <span class=\"token operator\">=</span> <span class=\"token comment\" spellcheck=\"true\">/** @class */</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> args<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> previous <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> now <span class=\"token operator\">=</span> <span class=\"token operator\">+</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>now <span class=\"token operator\">-</span> previous <span class=\"token operator\">></span> wait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        previous <span class=\"token operator\">=</span> now<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> throttle\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用定时器</p>\n<p>事件触发的时候，设置一个定时器，如果定时器存在，就不执行，等定时器到指定的时间，清空定时器，执行事件</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> timeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> previous <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        timeout <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对比两种实现方式</p>\n<ul>\n<li>第一种会立刻执行，第二种会在设定的时间后第一次执行</li>\n<li>第一种停止触发后不会再执行，第二种停止触发后依然会再执行一次</li>\n</ul>\n<p>现在我们要结合上面两种方式实现一个开始触发立刻执行，停止触发的时候还能再执行一次</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">@underscore<span class=\"token punctuation\">.</span>js\n\n<span class=\"token keyword\">var</span> throttle <span class=\"token operator\">=</span> <span class=\"token comment\" spellcheck=\"true\">/** @class */</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * throttle 节流\n   * @param {*} func  回调函数\n   * @param {*} wait  执行时间间隔\n   * @param {*} options  如果想忽略开始函数的的调用，传入{leading: false}\n   *                     如果想忽略结尾函数的调用，传入{trailing: false}\n   *                     两者不能共存，否则函数不能执行\n   */</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">var</span> timeout<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> previous <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">)</span> options <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">var</span> later <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果设置了 leading，就将 previous 设为 0</span>\n      previous <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>leading <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>timeout<span class=\"token punctuation\">)</span> context <span class=\"token operator\">=</span> args <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">var</span> throttled <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> now <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>previous <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>leading <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> previous <span class=\"token operator\">=</span> now<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 计算剩余时间</span>\n      <span class=\"token keyword\">var</span> remaining <span class=\"token operator\">=</span> wait <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>now <span class=\"token operator\">-</span> previous<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n      args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>remaining <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> remaining <span class=\"token operator\">></span> wait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果存在定时器就清理掉否则会调用二次回调</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          timeout <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        previous <span class=\"token operator\">=</span> now<span class=\"token punctuation\">;</span>\n        func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>timeout<span class=\"token punctuation\">)</span> context <span class=\"token operator\">=</span> args <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>timeout <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>trailing <span class=\"token operator\">!==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 判断是否设置了定时器和 trailing，没有就开启一个定时器</span>\n        timeout <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>later<span class=\"token punctuation\">,</span> remaining<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> throttled<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> throttle\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>调用例子</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">ontainer<span class=\"token punctuation\">.</span>onmousemove <span class=\"token operator\">=</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>getContent<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncontainer<span class=\"token punctuation\">.</span>onmousemove <span class=\"token operator\">=</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>getContent<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  leading<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncontainer<span class=\"token punctuation\">.</span>onmousemove <span class=\"token operator\">=</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>getContent<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  trailing<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面的就是函数的节流与抖动的全部，我们在面试和工作中会经常的遇到。这也是性能优化的一种方案。当然还有很多版本比如多 promise 版本的就不再这里叙述了，有兴趣的可以找找技术论坛</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h3><p>说起函数的节流与抖动这个老生长谈的话题，我们就需要了解一下关于浏览器的知识</p>\n<p>浏览器有各种进程，来保证浏览器正常的、流畅的呈现在用户的眼前。例如渲染进程（也就是浏览器的内核）是非常重要的一个进程，其中包含了很多的线程</p>\n<pre><code>GUI渲染线程(负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等)\n\nJS引擎线程(JS内核，负责处理JavaScript脚本程序)\n\n事件触发线程(归属于浏览器而不是JS引擎，用来控制事件循环)\n\n定时触发器线程(传说中的setTimeout和setInterval所在的线程)\n\n异步http请求线程(在XMLHttpRequest在连接后是通过浏览器新型一个线程请求)</code></pre><p>这里我们大概了解一下着几个概念，关于更过的相关知识会在后续的文章中介绍</p>\n<h3 id=\"请求过程\"><a href=\"#请求过程\" class=\"headerlink\" title=\"请求过程\"></a>请求过程</h3><p>我们先来看下面一张来至 W3C 的图</p>\n<p><img src=\"/images/timestamp-diagram.svg\"></p>\n<p>从图中我们看到处理模型大概分为如下几个阶段</p>\n<ul>\n<li>DNS 查询</li>\n<li>TCP 连接</li>\n<li>HTTP 请求即响应</li>\n<li>服务器响应</li>\n<li>客户端渲染</li>\n</ul>\n<p>这篇文章我们不讨论 Resource Timing 阶段，会在后续文章前端性能的时候重新提起</p>\n<h3 id=\"渲染过程\"><a href=\"#渲染过程\" class=\"headerlink\" title=\"渲染过程\"></a>渲染过程</h3><p>通过第五个阶段客户端渲染简单的回忆一下网页的生成过程，大致分为几个步骤</p>\n<ul>\n<li>HTML解析器解析成DOM 树</li>\n<li>CSS解析器解析成CSSOM 树</li>\n<li>结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)</li>\n<li>生成布局（Layout），根据渲染树来布局，以计算每个节点的几何信息</li>\n<li>最后一步是绘制（Paint），使用最终渲染树将像素渲染到在屏幕上</li>\n</ul>\n<img src=\"/images/render-process.jpg\">\n\n<p>通过上面的总结我们解析每一个步骤能更加深入的了解浏览器渲染过程</p>\n<h3 id=\"HTML-解析器解析过程\"><a href=\"#HTML-解析器解析过程\" class=\"headerlink\" title=\"HTML 解析器解析过程\"></a>HTML 解析器解析过程</h3><p>HTML 解析器构建 DOM 树，实际上是经过下面几个步骤</p>\n<pre><code>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型\n\n编码阶段将 HTML 的原始字节数据转换为文件指定编码\n\n令牌阶段根据HTML规范来将字符串转换成各种令牌也就是标签节点\n\n生成节点对象阶段是根据每个令牌转换定义其属性和规则的对象（节点对象）\n\n最后阶段 DOM 树构建完成，整个对象集合就像是一棵树形结构（对象模型）</code></pre><p>下面通过代码和图片来解释上面的步骤</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;title&gt;&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<img src=\"/images/dom-render.jpg\">\n\n<h3 id=\"CSS-解析过程\"><a href=\"#CSS-解析过程\" class=\"headerlink\" title=\"CSS 解析过程\"></a>CSS 解析过程</h3><p>浏览器获得 CSS 文件的数据后 CSS 解析器根据具体的样式将渲染 CSSDOM 树</p>\n<img src=\"/images/css-dom-render.jpg\">\n\n<h3 id=\"渲染树渲染\"><a href=\"#渲染树渲染\" class=\"headerlink\" title=\"渲染树渲染\"></a>渲染树渲染</h3><p>构建 两个树之后渲染树出场，浏览器会先从DOM树的根节点开始遍历，对每个可见节点，找到对应的 CSS 样式规则，进行匹配形成构建完成的渲染树</p>\n<img src=\"/images/render-tree.jpg\">\n\n\n<p>渲染树构建后浏览器根据节点对象的规则进行flow（布局）阶段，布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置最后生成我们大家知道的浏览器盒模型</p>\n<p>最后当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，最后渲染到在屏幕上</p>\n<p>通过上面大致的流程我们知道了浏览器的渲染过程，我们知道网页在生成的时候，至少会渲染一次执行css之后 load 对应 JS 也会进行重新渲染</p>\n<p>重新渲染就可能会 reflow + repaint</p>\n<h3 id=\"重绘与回流\"><a href=\"#重绘与回流\" class=\"headerlink\" title=\"重绘与回流\"></a>重绘与回流</h3><p>回流(reflow)： 当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建</p>\n<p>重绘(repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘</p>\n<p>回流必定会发生重绘，重绘不一定会引发回流</p>\n<p>浏览器的reflow + repaint 在我们设置节点样式时频繁出现，对性能是个巨大的消耗，因为回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流，所以我们经常说尽可能的减少重排次数、重排范围，这样就能呈现给用户更改的感官（关于优化手段会在后续的性能优化文章中介绍）</p>\n<p>根据上面说了这么多，我们来进入文章的主题<strong>防抖和节流</strong>当我们窗口发生改变，浏览器的滚动条执行scroll，输入框校验，搜索请求接口等这些都会使页面频繁重新渲染，加重浏览器的负担，这是我们通过<strong>防抖和节流</strong>的方式减少触发频率，这样就会大大的提高用户体验</p>\n<h3 id=\"debounce（防抖）\"><a href=\"#debounce（防抖）\" class=\"headerlink\" title=\"debounce（防抖）\"></a>debounce（防抖）</h3><p>动作发生一定时间后触发事件，在这段时间内，如果该动作又发生，则重新等待一定时间再触发事件。</p>\n<p>html </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;防抖&lt;/title&gt;\n  &lt;style&gt;\n    #container{\n      width: 100%; \n      height: 500px; \n      background: #000; \n      font-size: 50px;\n      color: #fff;\n      line-height: 500px; \n      text-align: center; \n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;content&quot;&gt;&lt;div&gt;\n  &lt;script src=&quot;debounce.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    var count = 1;\n    var container = document.getElementById(&#39;container&#39;);\n    function getContent(e) {\n      container.innerHTML = count++;\n    };\n    // container.onmousemove = getContent\n    container.onmousemove = debounce(getContent, 500, true);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>debounce.js </p>\n<pre><code class=\"js\">@underscore.js\n\nvar debounce = /** @class */ (function () {\n\n  /**\n   * @desc 函数防抖\n   * @param {*} func 回调函数\n   * @param {*} wait 延迟执行毫秒数\n   * @param {*} immediate  true 表立即执行，false 表非立即执行\n   */\n  function debounce(func, wait, immediate) {\n\n    // 创建一个标记用来存放定时器的返回值\n    var timeout,result;\n\n    return function () {\n\n      // 指定this 作用域\n      var context = this;\n      // event 对象\n      var args = arguments;\n\n      // 再次执行事件的时候，清除上一个定时器\n      if (timeout) clearTimeout(timeout);\n\n      if (immediate) {\n        // 如果已经执行过，将不再执行\n        var callNow = !timeout;\n        timeout = setTimeout(function(){\n          timeout = null;\n        }, wait)\n\n        if (callNow) result = func.apply(context, args)\n      }\n      else {\n\n        timeout = setTimeout(function(){\n          func.apply(context, args)\n        }, wait);\n      }\n      // func 这个函数，可能有返回值\n      return result;\n    }\n  }\n\n  return debounce;\n\n}())\n</code></pre>\n<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"throttle\"></a>throttle</h3><p>动作执行一段时间后触发事件，在这段时间内，如果动作又发生，则无视该动作，直到事件执行完后，才能重新执行</p>\n<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器</p>\n<p>使用时间戳</p>\n<p>当触发事件的时候，取出当前的时间戳，之后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，执行函数并更新当前时间戳，反之就不执行。</p>\n<pre><code class=\"js\">var throttle = /** @class */ (function () {\n\n  function throttle(func, wait) {\n    var args;\n    var previous = 0;\n\n    return function() {\n      var now = +new Date();\n      args = arguments;\n      if (now - previous &gt; wait) {\n        func.apply(this, args);\n        previous = now;\n      }\n    }\n  }\n\n  return throttle\n}())</code></pre>\n<p>使用定时器</p>\n<p>事件触发的时候，设置一个定时器，如果定时器存在，就不执行，等定时器到指定的时间，清空定时器，执行事件</p>\n<pre><code class=\"js\">function throttle(func, wait) {\n  var timeout;\n  var previous = 0;\n\n  return function() {\n    context = this;\n    args = arguments;\n    if (!timeout) {\n      timeout = setTimeout(function(){\n        timeout = null;\n        func.apply(context, args)\n      }, wait)\n    }\n  }\n}</code></pre>\n<p>对比两种实现方式</p>\n<ul>\n<li>第一种会立刻执行，第二种会在设定的时间后第一次执行</li>\n<li>第一种停止触发后不会再执行，第二种停止触发后依然会再执行一次</li>\n</ul>\n<p>现在我们要结合上面两种方式实现一个开始触发立刻执行，停止触发的时候还能再执行一次</p>\n<pre><code class=\"js\">@underscore.js\n\nvar throttle = /** @class */ (function () {\n\n  /**\n   * throttle 节流\n   * @param {*} func  回调函数\n   * @param {*} wait  执行时间间隔\n   * @param {*} options  如果想忽略开始函数的的调用，传入{leading: false}\n   *                     如果想忽略结尾函数的调用，传入{trailing: false}\n   *                     两者不能共存，否则函数不能执行\n   */\n  function throttle(func, wait, options) {\n\n    var timeout, context, args;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      previous = options.leading === false ? 0 : new Date().getTime();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = new Date().getTime();\n\n      if (!previous &amp;&amp; options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining &lt;= 0 || remaining &gt; wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout &amp;&amp; options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing，没有就开启一个定时器\n        timeout = setTimeout(later, remaining);\n      }\n    };\n    return throttled;\n}\n\n  return throttle\n}())</code></pre>\n<p>调用例子</p>\n<pre><code class=\"js\">ontainer.onmousemove = throttle(getContent, 1000);\ncontainer.onmousemove = throttle(getContent, 1000, {\n  leading: false\n});\ncontainer.onmousemove = throttle(getContent, 1000, {\n  trailing: false\n});</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上面的就是函数的节流与抖动的全部，我们在面试和工作中会经常的遇到。这也是性能优化的一种方案。当然还有很多版本比如多 promise 版本的就不再这里叙述了，有兴趣的可以找找技术论坛</p>\n"},{"title":"promise","date":"2019-06-11T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n本篇文章主要是实现 Promise 的原理, 具体 API 用法不在本文中做介绍。可以查看阮一峰老师的 <a href=\"http://es6.ruanyifeng.com/#docs/promise\">ES6 Promise教程</a><br/>\n\n实现 Promise 首先要知道它的执行特点<br/>\n\n1. Promise 是一个构造函数，接受函数作为参数(resolve(),reject()) \n2. Promise 对象有三种状态 pending(进行中), fulfilled(成功), rejected(失败)\n3. Promise 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve() \n4. Promise 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()\n5. Promise 状态无法中途取消，一旦建立立即执行，会一直保持这个结果，这时也叫 resolved(已定型状态)\n6. Promise 状态改变时 then 方法支持多次链式调用 \n7. Promise 如果不设置回调函数内部会抛异常\n\n\n### 定义构造函数 \n \n构造函数 Promise 必须接受函数作为参数\n\n1. 定义构造函数\n2. 判断一个参数是否为函数\n\n```js\n/**\n * 封装判断参数是够是函数\n */\nfunction isFunction(fn) {\n  return Object.prototype.toString.call(fn) === '[object Function]';\n}\n\n/**\n * 定义构造函数\n * @param {*} fn \n */\nfunction Promise(fn) {\n  if (!isFunction(fn)) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n}\n```\n\n### 定义 resolve \n\n在内部定义 resolve 方法作为参数传到 fn 中，fn 调用成功后会调用 resolve 方法，之后在执行 then 中注册的回调函数\n\n```js\n/**\n * 定义构造函数\n * @param {*} fn \n */\nfunction Promise(fn) {\n  // 判断是否是函数\n  var _isFunction = Object.prototype.toString.call(fn) === '[object Function]';\n\n  // 如果不是函数抛出异常\n  if (!_isFunction) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n  \n  // 定义回调状态\n  var __callback\n  this.then = function (status) {\n    __callback = status\n  }\n  // 定义 resolve 函数传入成功的数据\n  function resolve (data) {\n    __callback(data)\n  }\n  fn(resolve)\n}\n```\n\n调用例子\n\n```js\nfunction request () {\n  return new Promise(function(resolve){\n    if (true) {\n      setTimeout(function() {\n        resolve(\"renbo\");\n      }, 0);\n    }\n  })\n}\n\nrequest().then(function(data){\n  console.log(data)\n  console.log('success')\n})\n\n// 输出\nrenbo\nsuccess\n```\n\n上面的例子我们已经简单的实现了 promise 的基础回调，接下来我们完成链式语法调用以及then队列管理\n\n### 链式语法及队列管理\n\n```js\nfunction Promise (fn) {\n  \n  var _isFunction = Object.prototype.toString.call(fn) === '[object Function]';\n\n  if (!_isFunction) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n  \n  var _this = this,\n      _value = null;\n      _this._resolves = [];\n\n  this.then = function (status) {\n    _this._resolves.push(status);\n    return this;\n  }\n\n  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾\n  function resolve (val) {\n     setTimeout(function() {\n      _this._resolves.forEach(function (callback) {\n        _value = val\n        callback(_value)\n      })\n    },0);\n  }\n\n  fn (resolve)\n}\n```\n\n\n###  加入状态并串行Promise\n\nPromise 对象有三种状态 <br/>\n1. pending(进行中) 立即执行\n2. 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve('fulfilled') \n3. 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject('rejected')\n\n`promsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变`\n\n我们加入上面的状态并串行Promise\n\n```js\nfunction Promise (fn) {\n  \n  function _isFunction (func) {\n    return Object.prototype.toString.call(func) === '[object Function]';\n  }\n  if (!_isFunction(fn)) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n  \n  var _this = this,\n      _val = null;\n      _this._resolves = [];\n      _this._status = 'PENDING';\n      \n  this.then = function (onFulfilled) {\n    return new Promise(function (resolve) {\n      // handle 函数对上一个 promise 的 then 中回调进行了处理，并且调用当前的 promise 中的 resolve 方法。\n      function handle(_val) {\n        var ret = _isFunction(onFulfilled) && onFulfilled(_val) || _val\n        // 如果是⼀一个 promise 对象，就会调⽤ then 方法，形成一个嵌套\n        if (ret && _isFunction(ret['then'])) {\n          ret.then(function (value) {\n            resolve(value);\n          })\n        } else {\n          resolve(ret)\n        }\n      }\n      if (_this._status === 'PENDING') {\n       _this._resolves.push(handle);\n      } else if(promise._status === 'FULFILLED'){\n        handle(value);\n      }       \n    })\n  }\n\n  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾\n  function resolve (val) {\n     setTimeout(function() {\n       _this.status = \"FULFILLED\";\n      _this._resolves.forEach(function (callback) {\n        _val = val\n        callback(_val)\n      })\n    },0);\n  }\n\n  fn (resolve)\n}\n```\n\n### 错误处理reject\n\n在异步操作中，操作可能失败，执行失败的回调函数，上面已经说到从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()\n\n```js\nfunction Promise(fn) {\n\n  /**\n   * 工具函数判断是否是 function\n   * @param {*} func \n   */\n  function _isFunction(func) {\n    return Object.prototype.toString.call(func) === '[object Function]';\n  }\n  if (!_isFunction(fn)) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n\n\n  var _this = this;\n  _this._value;\n  _this._reason;\n  _this._resolves = [];\n  _this._rejects = [];\n  _this._status = \"PENDING\";\n\n  /**\n   * promise then回调\n   * @onFulfilled 执行成功状态的处理函数\n   * @onRejected 执行失败状态处理函数\n   */\n  this.then = function (onFulfilled, onRejected) {\n    return new Promise(function (resolve, reject) {\n\n      /**\n       * 对上一个 promise 的 then 中回调进行了处理\n       * 并且调用当前的 promise 中的 resolve 方法\n       */\n      function handle(value) {\n        var ret = _isFunction(onFulfilled) && onFulfilled(value) || value\n        if (ret && _isFunction(ret['then'])) {\n          ret.then(\n            function (value) {\n              resolve(value);\n            },\n            function (reason) {\n              reject(reason);\n            }\n          )\n        } else {\n          resolve(ret)\n        }\n      }\n\n      /**\n       * 错误处理回调函数\n       */\n      function errback(reason) {\n        reason = _isFunction(onRejected) && onRejected(reason) || reason;\n        reject(reason);\n      }\n\n      /**\n       * 根据当前异步状态执行操作\n       */\n      var config = {\n        'PENDING': function () {\n          _this._resolves.push(handle);\n          _this._rejects.push(errback);\n        },\n        'FULFILLED': function () {\n          handle(value);\n        },\n        'REJECTED': function () {\n          errback(_this._reason);\n        }\n      }\n      \n      config[_this._status]()\n    })\n  }\n\n  /**\n   * 成功的回调函数\n   * setTimeout作用是将resolve \n   * 执行回调的逻辑放置到 JS 任务队列列末尾\n   * 防止then执行在resolve之前\n   * @FULFILLED 状态\n   * @param {*} value \n   */\n  function resolve(value) {\n    setTimeout(function () {\n      _this.status = \"FULFILLED\"\n      _this._resolves.forEach(function (callback) {\n       _this._value = callback(value)\n      })\n    }, 0)\n  }\n\n  /**\n   * 错误处理回调函数\n   * @REJECTED 状态\n   * @param {*} value \n   */\n  function reject(value) {\n    setTimeout(function () {\n      _this._status = \"REJECTED\"\n      _this._rejects.forEach(function (callback) {\n        _this._reason = callback(value);\n      })\n    }, 0)\n  }\n\n  fn(resolve, reject)\n}\n```\n\n### 实现Promise.all\n\n实现Promise.all函数\n\n```js\n/**\n * Promise.all\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n */\nPromise.all = function(promiseArr) {\n\n  if (!Array.isArray(promiseArr)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n  // 返回 promise 实例\n  return new Promise(function (resolve, reject) {\n    let done = gen(promiseArr.length, resolve);\n    promiseArr.forEach(function (promise, index) {\n      promise.then(function (value) {\n        done(index, value)\n      },reject)\n    })\n  })\n}\n\nfunction gen(length, resolve) {\n  let count = 0;\n  let result = [];\n  return function(i, value) {\n    result[i] = value;\n    if (++count === length) {\n      resolve(result);\n    }\n  }\n}\n```\n\n\n### 实现Promise.race\n\n实现Promise.race函数\n\n```js\n/**\n * Promise.race\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n */\n\nPromise.race = function(promiseArr) {\n\n  if (!Array.isArray(promiseArr)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n  // 返回 promise 实例\n  return new Promise(function(resolve, reject){\n    promiseArr.forEach(function (promise, index) {\n      promise.then(resolve,reject)\n    })\n  })\n}\n\n```\n\n### 实现 catch <br/>\n\n\n实现 catch \n```js\n/**\n * 链式写法中可以捕获前面then中发送的异常\n */\n\nfunction Promise () {\n  var _this = this\n  ...\n  \n  this.catch = function (onRejected) {\n    return _this.then(null, onRejected);\n  }\n}\n \n```\n\n\n### 代码封装\n经过上面的几个步骤我们基本实现了 promise 的几个重要特性，下面我们将代码整理一下\n\n\n```js\n/*\n * @Description: promise \n * @Author: renbo\n * @Date: 2019-08-12 15:13:40\n * @LastEditTime: 2019-08-15 10:34:44\n */\n\nvar Promise = /** @class */ (function () {\n\n  function Promise (fn) {\n\n    var _this = this;\n    _this._status = 'PENDING';\n    _this._value = undefined;\n    _this._reason = undefined;\n    //存储状态\n    _this._resolves = [];\n    _this._rejects = [];\n\n    // 异常处理\n    if (!(typeof fn === 'function' )) {\n      throw new TypeError('Promise must accept a function as a parameter');\n    }\n    if(!(this instanceof Promise)) return new Promise(fn);\n\n    \n   function resolve(value) {\n      //由於apply參數是數組\n      _this.final.apply(_this,['FULFILLED'].concat([value]));\n    }\n\n    function reject(reason){\n      _this.final.apply(_this,['REJECTED'].concat([reason]));\n    }\n    \n    fn(resolve,reject);\n  }\n\n  /**\n   * 用于resolve 和 reject \n   * 异步调用，保证then是先执行的\n   * @param {*} status \n   * @param {*} value \n   */\n  Promise.prototype.final = function (status,value) {\n    var _this = this, fn, st;\n    if(_this._status !== 'PENDING') return;\n\n    setTimeout(function(){\n      _this._status = status;\n      st = _this._status === 'FULFILLED'\n      queue = _this[st ? '_resolves' : '_rejects'];\n\n      while(fn = queue.shift()) {\n        value = fn.call(_this, value) || value;\n      }\n\n      _this[st ? '_value' : '_reason'] = value;\n      _this['_resolves'] = _this['_rejects'] = undefined;\n    });\n  }\n\n  /**\n   * then \n   * @params onFulfilled\n   * @params onRejected\n   */\n  Promise.prototype.then = function (onFulfilled,onRejected) {\n    var _this = this;\n    // 每次返回一个promise，保证是可thenable的\n    return new Promise(function(resolve,reject){\n        \n      function handle(value) {\n        // 這一步很關鍵，只有這樣才可以將值傳遞給下一個resolve\n        var ret = typeof onFulfilled === 'function' && onFulfilled(value) || value;\n\n        //判断是不是promise 对象\n        if (ret && typeof ret ['then'] == 'function') {\n            ret.then(function(value) {\n                resolve(value);\n            }, function(reason) {\n                reject(reason);\n            });\n        } else {\n          resolve(ret);\n        }\n      }\n\n      function errback(reason){\n        reason = typeof onRejected === 'function' && onRejected(reason) || reason;\n        reject(reason);\n      }\n\n      // 根据当前异步状态执行操作\n      var config = {\n        'PENDING': function () {\n          _this._resolves.push(handle);\n          _this._rejects.push(errback);\n        },\n        'FULFILLED': function () {\n          handle(value);\n        },\n        'REJECTED': function () {\n          errback(_this._reason);\n        }\n      }\n      \n      config[_this._status]()\n    });\n  }\n\n\n  /**\n   * 链式写法中可以捕获前面then中发送的异常\n   */\n  Promise.prototype.catch = function(onRejected){\n    return this.then(undefined, onRejected)\n  }\n\n\n  /**\n   * Promise.race\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n   */\n\n  Promise.race = function(promiseArr) {\n\n    if (!Array.isArray(promiseArr)) {\n      throw new TypeError('You must pass an array to all.');\n    }\n    // 返回 promise 实例\n    return new Promise(function(resolve, reject){\n      promiseArr.forEach(function (promise, index) {\n        promise.then(resolve,reject)\n      })\n    })\n  }\n\n\n  /**\n   * Promise.all\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n   */\n  Promise.all = function(promiseArr) {\n\n    if (!Array.isArray(promiseArr)) {\n      throw new TypeError('You must pass an array to all.');\n    }\n    // 返回 promise 实例\n    return new Promise(function (resolve, reject) {\n      let done = gen(promiseArr.length, resolve);\n      promiseArr.forEach(function (promise, index) {\n        promise.then(function (value) {\n          done(index, value)\n        },reject)\n      })\n    })\n\n    // 判断 promise 状态是否全部 resolve\n    function gen(length, resolve) {\n      let count = 0;\n      let result = [];\n      return function(i, value) {\n        result[i] = value;\n        if (++count === length) {\n          resolve(result);\n        }\n      }\n    }\n  }\n\n  Promise.resolve = function(arg){\n    return new Promise(function(resolve,reject){\n        resolve(arg)\n    })\n  }\n\n  Promise.reject = function(arg){\n    return Promise(function(resolve,reject){\n      reject(arg)\n    })\n  }\n\n  return Promise;\n}())\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/promise.md","raw":"---\ntitle: promise\ndate: 2019-6-11 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n本篇文章主要是实现 Promise 的原理, 具体 API 用法不在本文中做介绍。可以查看阮一峰老师的 <a href=\"http://es6.ruanyifeng.com/#docs/promise\">ES6 Promise教程</a><br/>\n\n实现 Promise 首先要知道它的执行特点<br/>\n\n1. Promise 是一个构造函数，接受函数作为参数(resolve(),reject()) \n2. Promise 对象有三种状态 pending(进行中), fulfilled(成功), rejected(失败)\n3. Promise 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve() \n4. Promise 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()\n5. Promise 状态无法中途取消，一旦建立立即执行，会一直保持这个结果，这时也叫 resolved(已定型状态)\n6. Promise 状态改变时 then 方法支持多次链式调用 \n7. Promise 如果不设置回调函数内部会抛异常\n\n\n### 定义构造函数 \n \n构造函数 Promise 必须接受函数作为参数\n\n1. 定义构造函数\n2. 判断一个参数是否为函数\n\n```js\n/**\n * 封装判断参数是够是函数\n */\nfunction isFunction(fn) {\n  return Object.prototype.toString.call(fn) === '[object Function]';\n}\n\n/**\n * 定义构造函数\n * @param {*} fn \n */\nfunction Promise(fn) {\n  if (!isFunction(fn)) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n}\n```\n\n### 定义 resolve \n\n在内部定义 resolve 方法作为参数传到 fn 中，fn 调用成功后会调用 resolve 方法，之后在执行 then 中注册的回调函数\n\n```js\n/**\n * 定义构造函数\n * @param {*} fn \n */\nfunction Promise(fn) {\n  // 判断是否是函数\n  var _isFunction = Object.prototype.toString.call(fn) === '[object Function]';\n\n  // 如果不是函数抛出异常\n  if (!_isFunction) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n  \n  // 定义回调状态\n  var __callback\n  this.then = function (status) {\n    __callback = status\n  }\n  // 定义 resolve 函数传入成功的数据\n  function resolve (data) {\n    __callback(data)\n  }\n  fn(resolve)\n}\n```\n\n调用例子\n\n```js\nfunction request () {\n  return new Promise(function(resolve){\n    if (true) {\n      setTimeout(function() {\n        resolve(\"renbo\");\n      }, 0);\n    }\n  })\n}\n\nrequest().then(function(data){\n  console.log(data)\n  console.log('success')\n})\n\n// 输出\nrenbo\nsuccess\n```\n\n上面的例子我们已经简单的实现了 promise 的基础回调，接下来我们完成链式语法调用以及then队列管理\n\n### 链式语法及队列管理\n\n```js\nfunction Promise (fn) {\n  \n  var _isFunction = Object.prototype.toString.call(fn) === '[object Function]';\n\n  if (!_isFunction) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n  \n  var _this = this,\n      _value = null;\n      _this._resolves = [];\n\n  this.then = function (status) {\n    _this._resolves.push(status);\n    return this;\n  }\n\n  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾\n  function resolve (val) {\n     setTimeout(function() {\n      _this._resolves.forEach(function (callback) {\n        _value = val\n        callback(_value)\n      })\n    },0);\n  }\n\n  fn (resolve)\n}\n```\n\n\n###  加入状态并串行Promise\n\nPromise 对象有三种状态 <br/>\n1. pending(进行中) 立即执行\n2. 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve('fulfilled') \n3. 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject('rejected')\n\n`promsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变`\n\n我们加入上面的状态并串行Promise\n\n```js\nfunction Promise (fn) {\n  \n  function _isFunction (func) {\n    return Object.prototype.toString.call(func) === '[object Function]';\n  }\n  if (!_isFunction(fn)) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n  \n  var _this = this,\n      _val = null;\n      _this._resolves = [];\n      _this._status = 'PENDING';\n      \n  this.then = function (onFulfilled) {\n    return new Promise(function (resolve) {\n      // handle 函数对上一个 promise 的 then 中回调进行了处理，并且调用当前的 promise 中的 resolve 方法。\n      function handle(_val) {\n        var ret = _isFunction(onFulfilled) && onFulfilled(_val) || _val\n        // 如果是⼀一个 promise 对象，就会调⽤ then 方法，形成一个嵌套\n        if (ret && _isFunction(ret['then'])) {\n          ret.then(function (value) {\n            resolve(value);\n          })\n        } else {\n          resolve(ret)\n        }\n      }\n      if (_this._status === 'PENDING') {\n       _this._resolves.push(handle);\n      } else if(promise._status === 'FULFILLED'){\n        handle(value);\n      }       \n    })\n  }\n\n  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾\n  function resolve (val) {\n     setTimeout(function() {\n       _this.status = \"FULFILLED\";\n      _this._resolves.forEach(function (callback) {\n        _val = val\n        callback(_val)\n      })\n    },0);\n  }\n\n  fn (resolve)\n}\n```\n\n### 错误处理reject\n\n在异步操作中，操作可能失败，执行失败的回调函数，上面已经说到从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()\n\n```js\nfunction Promise(fn) {\n\n  /**\n   * 工具函数判断是否是 function\n   * @param {*} func \n   */\n  function _isFunction(func) {\n    return Object.prototype.toString.call(func) === '[object Function]';\n  }\n  if (!_isFunction(fn)) {\n    throw new Error('Promise must accept a function as a parameter')\n  }\n\n\n  var _this = this;\n  _this._value;\n  _this._reason;\n  _this._resolves = [];\n  _this._rejects = [];\n  _this._status = \"PENDING\";\n\n  /**\n   * promise then回调\n   * @onFulfilled 执行成功状态的处理函数\n   * @onRejected 执行失败状态处理函数\n   */\n  this.then = function (onFulfilled, onRejected) {\n    return new Promise(function (resolve, reject) {\n\n      /**\n       * 对上一个 promise 的 then 中回调进行了处理\n       * 并且调用当前的 promise 中的 resolve 方法\n       */\n      function handle(value) {\n        var ret = _isFunction(onFulfilled) && onFulfilled(value) || value\n        if (ret && _isFunction(ret['then'])) {\n          ret.then(\n            function (value) {\n              resolve(value);\n            },\n            function (reason) {\n              reject(reason);\n            }\n          )\n        } else {\n          resolve(ret)\n        }\n      }\n\n      /**\n       * 错误处理回调函数\n       */\n      function errback(reason) {\n        reason = _isFunction(onRejected) && onRejected(reason) || reason;\n        reject(reason);\n      }\n\n      /**\n       * 根据当前异步状态执行操作\n       */\n      var config = {\n        'PENDING': function () {\n          _this._resolves.push(handle);\n          _this._rejects.push(errback);\n        },\n        'FULFILLED': function () {\n          handle(value);\n        },\n        'REJECTED': function () {\n          errback(_this._reason);\n        }\n      }\n      \n      config[_this._status]()\n    })\n  }\n\n  /**\n   * 成功的回调函数\n   * setTimeout作用是将resolve \n   * 执行回调的逻辑放置到 JS 任务队列列末尾\n   * 防止then执行在resolve之前\n   * @FULFILLED 状态\n   * @param {*} value \n   */\n  function resolve(value) {\n    setTimeout(function () {\n      _this.status = \"FULFILLED\"\n      _this._resolves.forEach(function (callback) {\n       _this._value = callback(value)\n      })\n    }, 0)\n  }\n\n  /**\n   * 错误处理回调函数\n   * @REJECTED 状态\n   * @param {*} value \n   */\n  function reject(value) {\n    setTimeout(function () {\n      _this._status = \"REJECTED\"\n      _this._rejects.forEach(function (callback) {\n        _this._reason = callback(value);\n      })\n    }, 0)\n  }\n\n  fn(resolve, reject)\n}\n```\n\n### 实现Promise.all\n\n实现Promise.all函数\n\n```js\n/**\n * Promise.all\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n */\nPromise.all = function(promiseArr) {\n\n  if (!Array.isArray(promiseArr)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n  // 返回 promise 实例\n  return new Promise(function (resolve, reject) {\n    let done = gen(promiseArr.length, resolve);\n    promiseArr.forEach(function (promise, index) {\n      promise.then(function (value) {\n        done(index, value)\n      },reject)\n    })\n  })\n}\n\nfunction gen(length, resolve) {\n  let count = 0;\n  let result = [];\n  return function(i, value) {\n    result[i] = value;\n    if (++count === length) {\n      resolve(result);\n    }\n  }\n}\n```\n\n\n### 实现Promise.race\n\n实现Promise.race函数\n\n```js\n/**\n * Promise.race\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n */\n\nPromise.race = function(promiseArr) {\n\n  if (!Array.isArray(promiseArr)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n  // 返回 promise 实例\n  return new Promise(function(resolve, reject){\n    promiseArr.forEach(function (promise, index) {\n      promise.then(resolve,reject)\n    })\n  })\n}\n\n```\n\n### 实现 catch <br/>\n\n\n实现 catch \n```js\n/**\n * 链式写法中可以捕获前面then中发送的异常\n */\n\nfunction Promise () {\n  var _this = this\n  ...\n  \n  this.catch = function (onRejected) {\n    return _this.then(null, onRejected);\n  }\n}\n \n```\n\n\n### 代码封装\n经过上面的几个步骤我们基本实现了 promise 的几个重要特性，下面我们将代码整理一下\n\n\n```js\n/*\n * @Description: promise \n * @Author: renbo\n * @Date: 2019-08-12 15:13:40\n * @LastEditTime: 2019-08-15 10:34:44\n */\n\nvar Promise = /** @class */ (function () {\n\n  function Promise (fn) {\n\n    var _this = this;\n    _this._status = 'PENDING';\n    _this._value = undefined;\n    _this._reason = undefined;\n    //存储状态\n    _this._resolves = [];\n    _this._rejects = [];\n\n    // 异常处理\n    if (!(typeof fn === 'function' )) {\n      throw new TypeError('Promise must accept a function as a parameter');\n    }\n    if(!(this instanceof Promise)) return new Promise(fn);\n\n    \n   function resolve(value) {\n      //由於apply參數是數組\n      _this.final.apply(_this,['FULFILLED'].concat([value]));\n    }\n\n    function reject(reason){\n      _this.final.apply(_this,['REJECTED'].concat([reason]));\n    }\n    \n    fn(resolve,reject);\n  }\n\n  /**\n   * 用于resolve 和 reject \n   * 异步调用，保证then是先执行的\n   * @param {*} status \n   * @param {*} value \n   */\n  Promise.prototype.final = function (status,value) {\n    var _this = this, fn, st;\n    if(_this._status !== 'PENDING') return;\n\n    setTimeout(function(){\n      _this._status = status;\n      st = _this._status === 'FULFILLED'\n      queue = _this[st ? '_resolves' : '_rejects'];\n\n      while(fn = queue.shift()) {\n        value = fn.call(_this, value) || value;\n      }\n\n      _this[st ? '_value' : '_reason'] = value;\n      _this['_resolves'] = _this['_rejects'] = undefined;\n    });\n  }\n\n  /**\n   * then \n   * @params onFulfilled\n   * @params onRejected\n   */\n  Promise.prototype.then = function (onFulfilled,onRejected) {\n    var _this = this;\n    // 每次返回一个promise，保证是可thenable的\n    return new Promise(function(resolve,reject){\n        \n      function handle(value) {\n        // 這一步很關鍵，只有這樣才可以將值傳遞給下一個resolve\n        var ret = typeof onFulfilled === 'function' && onFulfilled(value) || value;\n\n        //判断是不是promise 对象\n        if (ret && typeof ret ['then'] == 'function') {\n            ret.then(function(value) {\n                resolve(value);\n            }, function(reason) {\n                reject(reason);\n            });\n        } else {\n          resolve(ret);\n        }\n      }\n\n      function errback(reason){\n        reason = typeof onRejected === 'function' && onRejected(reason) || reason;\n        reject(reason);\n      }\n\n      // 根据当前异步状态执行操作\n      var config = {\n        'PENDING': function () {\n          _this._resolves.push(handle);\n          _this._rejects.push(errback);\n        },\n        'FULFILLED': function () {\n          handle(value);\n        },\n        'REJECTED': function () {\n          errback(_this._reason);\n        }\n      }\n      \n      config[_this._status]()\n    });\n  }\n\n\n  /**\n   * 链式写法中可以捕获前面then中发送的异常\n   */\n  Promise.prototype.catch = function(onRejected){\n    return this.then(undefined, onRejected)\n  }\n\n\n  /**\n   * Promise.race\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n   */\n\n  Promise.race = function(promiseArr) {\n\n    if (!Array.isArray(promiseArr)) {\n      throw new TypeError('You must pass an array to all.');\n    }\n    // 返回 promise 实例\n    return new Promise(function(resolve, reject){\n      promiseArr.forEach(function (promise, index) {\n        promise.then(resolve,reject)\n      })\n    })\n  }\n\n\n  /**\n   * Promise.all\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n   */\n  Promise.all = function(promiseArr) {\n\n    if (!Array.isArray(promiseArr)) {\n      throw new TypeError('You must pass an array to all.');\n    }\n    // 返回 promise 实例\n    return new Promise(function (resolve, reject) {\n      let done = gen(promiseArr.length, resolve);\n      promiseArr.forEach(function (promise, index) {\n        promise.then(function (value) {\n          done(index, value)\n        },reject)\n      })\n    })\n\n    // 判断 promise 状态是否全部 resolve\n    function gen(length, resolve) {\n      let count = 0;\n      let result = [];\n      return function(i, value) {\n        result[i] = value;\n        if (++count === length) {\n          resolve(result);\n        }\n      }\n    }\n  }\n\n  Promise.resolve = function(arg){\n    return new Promise(function(resolve,reject){\n        resolve(arg)\n    })\n  }\n\n  Promise.reject = function(arg){\n    return Promise(function(resolve,reject){\n      reject(arg)\n    })\n  }\n\n  return Promise;\n}())\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"javascript/promise","published":1,"updated":"2019-10-15T01:29:42.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ow6008jb0u6a8wavkli","content":"<p>本篇文章主要是实现 Promise 的原理, 具体 API 用法不在本文中做介绍。可以查看阮一峰老师的 <a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">ES6 Promise教程</a><br></p>\n<p>实现 Promise 首先要知道它的执行特点<br></p>\n<ol>\n<li>Promise 是一个构造函数，接受函数作为参数(resolve(),reject()) </li>\n<li>Promise 对象有三种状态 pending(进行中), fulfilled(成功), rejected(失败)</li>\n<li>Promise 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve() </li>\n<li>Promise 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()</li>\n<li>Promise 状态无法中途取消，一旦建立立即执行，会一直保持这个结果，这时也叫 resolved(已定型状态)</li>\n<li>Promise 状态改变时 then 方法支持多次链式调用 </li>\n<li>Promise 如果不设置回调函数内部会抛异常</li>\n</ol>\n<h3 id=\"定义构造函数\"><a href=\"#定义构造函数\" class=\"headerlink\" title=\"定义构造函数\"></a>定义构造函数</h3><p>构造函数 Promise 必须接受函数作为参数</p>\n<ol>\n<li>定义构造函数</li>\n<li>判断一个参数是否为函数</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 封装判断参数是够是函数\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">isFunction</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Function]'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 定义构造函数\n * @param {*} fn \n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Promise</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isFunction</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise must accept a function as a parameter'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"定义-resolve\"><a href=\"#定义-resolve\" class=\"headerlink\" title=\"定义 resolve\"></a>定义 resolve</h3><p>在内部定义 resolve 方法作为参数传到 fn 中，fn 调用成功后会调用 resolve 方法，之后在执行 then 中注册的回调函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 定义构造函数\n * @param {*} fn \n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Promise</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 判断是否是函数</span>\n  <span class=\"token keyword\">var</span> _isFunction <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Function]'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 如果不是函数抛出异常</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>_isFunction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise must accept a function as a parameter'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 定义回调状态</span>\n  <span class=\"token keyword\">var</span> __callback\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    __callback <span class=\"token operator\">=</span> status\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 定义 resolve 函数传入成功的数据</span>\n  <span class=\"token keyword\">function</span> resolve <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">__callback</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>调用例子</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> request <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"renbo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'success'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 输出</span>\nrenbo\nsuccess<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的例子我们已经简单的实现了 promise 的基础回调，接下来我们完成链式语法调用以及then队列管理</p>\n<h3 id=\"链式语法及队列管理\"><a href=\"#链式语法及队列管理\" class=\"headerlink\" title=\"链式语法及队列管理\"></a>链式语法及队列管理</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Promise <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">var</span> _isFunction <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Function]'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>_isFunction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise must accept a function as a parameter'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>\n      _value <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      _this<span class=\"token punctuation\">.</span>_resolves <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾</span>\n  <span class=\"token keyword\">function</span> resolve <span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _value <span class=\"token operator\">=</span> val\n        <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>_value<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  fn <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"加入状态并串行Promise\"><a href=\"#加入状态并串行Promise\" class=\"headerlink\" title=\"加入状态并串行Promise\"></a>加入状态并串行Promise</h3><p>Promise 对象有三种状态 <br></p>\n<ol>\n<li>pending(进行中) 立即执行</li>\n<li>从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve(‘fulfilled’) </li>\n<li>从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject(‘rejected’)</li>\n</ol>\n<p><code>promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变</code></p>\n<p>我们加入上面的状态并串行Promise</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Promise <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">function</span> _isFunction <span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Function]'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise must accept a function as a parameter'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>\n      _val <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      _this<span class=\"token punctuation\">.</span>_resolves <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      _this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">=</span> <span class=\"token string\">'PENDING'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>onFulfilled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// handle 函数对上一个 promise 的 then 中回调进行了处理，并且调用当前的 promise 中的 resolve 方法。</span>\n      <span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>_val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>onFulfilled<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onFulfilled</span><span class=\"token punctuation\">(</span>_val<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> _val\n        <span class=\"token comment\" spellcheck=\"true\">// 如果是⼀一个 promise 对象，就会调⽤ then 方法，形成一个嵌套</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">[</span><span class=\"token string\">'then'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          ret<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">===</span> <span class=\"token string\">'PENDING'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>handle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">===</span> <span class=\"token string\">'FULFILLED'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>       \n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾</span>\n  <span class=\"token keyword\">function</span> resolve <span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       _this<span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> <span class=\"token string\">\"FULFILLED\"</span><span class=\"token punctuation\">;</span>\n      _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _val <span class=\"token operator\">=</span> val\n        <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>_val<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  fn <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"错误处理reject\"><a href=\"#错误处理reject\" class=\"headerlink\" title=\"错误处理reject\"></a>错误处理reject</h3><p>在异步操作中，操作可能失败，执行失败的回调函数，上面已经说到从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Promise</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * 工具函数判断是否是 function\n   * @param {*} func \n   */</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Function]'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise must accept a function as a parameter'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  _this<span class=\"token punctuation\">.</span>_value<span class=\"token punctuation\">;</span>\n  _this<span class=\"token punctuation\">.</span>_reason<span class=\"token punctuation\">;</span>\n  _this<span class=\"token punctuation\">.</span>_resolves <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  _this<span class=\"token punctuation\">.</span>_rejects <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  _this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">=</span> <span class=\"token string\">\"PENDING\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * promise then回调\n   * @onFulfilled 执行成功状态的处理函数\n   * @onRejected 执行失败状态处理函数\n   */</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>onFulfilled<span class=\"token punctuation\">,</span> onRejected<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">/**\n       * 对上一个 promise 的 then 中回调进行了处理\n       * 并且调用当前的 promise 中的 resolve 方法\n       */</span>\n      <span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>onFulfilled<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onFulfilled</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> value\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">[</span><span class=\"token string\">'then'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          ret<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\n            <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">/**\n       * 错误处理回调函数\n       */</span>\n      <span class=\"token keyword\">function</span> <span class=\"token function\">errback</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        reason <span class=\"token operator\">=</span> <span class=\"token function\">_isFunction</span><span class=\"token punctuation\">(</span>onRejected<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onRejected</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> reason<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">/**\n       * 根据当前异步状态执行操作\n       */</span>\n      <span class=\"token keyword\">var</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'PENDING'</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>handle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          _this<span class=\"token punctuation\">.</span>_rejects<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>errback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'FULFILLED'</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'REJECTED'</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">errback</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">.</span>_reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      config<span class=\"token punctuation\">[</span>_this<span class=\"token punctuation\">.</span>_status<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * 成功的回调函数\n   * setTimeout作用是将resolve \n   * 执行回调的逻辑放置到 JS 任务队列列末尾\n   * 防止then执行在resolve之前\n   * @FULFILLED 状态\n   * @param {*} value \n   */</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      _this<span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> <span class=\"token string\">\"FULFILLED\"</span>\n      _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       _this<span class=\"token punctuation\">.</span>_value <span class=\"token operator\">=</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * 错误处理回调函数\n   * @REJECTED 状态\n   * @param {*} value \n   */</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      _this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">=</span> <span class=\"token string\">\"REJECTED\"</span>\n      _this<span class=\"token punctuation\">.</span>_rejects<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _this<span class=\"token punctuation\">.</span>_reason <span class=\"token operator\">=</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"实现Promise-all\"><a href=\"#实现Promise-all\" class=\"headerlink\" title=\"实现Promise.all\"></a>实现Promise.all</h3><p>实现Promise.all函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Promise.all\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n */</span>\nPromise<span class=\"token punctuation\">.</span>all <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You must pass an array to all.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 返回 promise 实例</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> done <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    promiseArr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">done</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count <span class=\"token operator\">===</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"实现Promise-race\"><a href=\"#实现Promise-race\" class=\"headerlink\" title=\"实现Promise.race\"></a>实现Promise.race</h3><p>实现Promise.race函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Promise.race\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n */</span>\n\nPromise<span class=\"token punctuation\">.</span>race <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You must pass an array to all.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 返回 promise 实例</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    promiseArr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch \"></a>实现 catch <br></h3><p>实现 catch </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 链式写法中可以捕获前面then中发送的异常\n */</span>\n\n<span class=\"token keyword\">function</span> Promise <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n  <span class=\"token operator\">...</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>onRejected<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> _this<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> onRejected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"代码封装\"><a href=\"#代码封装\" class=\"headerlink\" title=\"代码封装\"></a>代码封装</h3><p>经过上面的几个步骤我们基本实现了 promise 的几个重要特性，下面我们将代码整理一下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/*\n * @Description: promise \n * @Author: renbo\n * @Date: 2019-08-12 15:13:40\n * @LastEditTime: 2019-08-15 10:34:44\n */</span>\n\n<span class=\"token keyword\">var</span> Promise <span class=\"token operator\">=</span> <span class=\"token comment\" spellcheck=\"true\">/** @class */</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">function</span> Promise <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    _this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">=</span> <span class=\"token string\">'PENDING'</span><span class=\"token punctuation\">;</span>\n    _this<span class=\"token punctuation\">.</span>_value <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n    _this<span class=\"token punctuation\">.</span>_reason <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//存储状态</span>\n    _this<span class=\"token punctuation\">.</span>_resolves <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    _this<span class=\"token punctuation\">.</span>_rejects <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 异常处理</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> fn <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise must accept a function as a parameter'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n   <span class=\"token keyword\">function</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">//由於apply參數是數組</span>\n      _this<span class=\"token punctuation\">.</span>final<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'FULFILLED'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      _this<span class=\"token punctuation\">.</span>final<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'REJECTED'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>reason<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * 用于resolve 和 reject \n   * 异步调用，保证then是先执行的\n   * @param {*} status \n   * @param {*} value \n   */</span>\n  Promise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>final <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> st<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">!==</span> <span class=\"token string\">'PENDING'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      _this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">=</span> status<span class=\"token punctuation\">;</span>\n      st <span class=\"token operator\">=</span> _this<span class=\"token punctuation\">.</span>_status <span class=\"token operator\">===</span> <span class=\"token string\">'FULFILLED'</span>\n      queue <span class=\"token operator\">=</span> _this<span class=\"token punctuation\">[</span>st <span class=\"token operator\">?</span> <span class=\"token string\">'_resolves'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'_rejects'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fn <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        value <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> value<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      _this<span class=\"token punctuation\">[</span>st <span class=\"token operator\">?</span> <span class=\"token string\">'_value'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'_reason'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n      _this<span class=\"token punctuation\">[</span><span class=\"token string\">'_resolves'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> _this<span class=\"token punctuation\">[</span><span class=\"token string\">'_rejects'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * then \n   * @params onFulfilled\n   * @params onRejected\n   */</span>\n  Promise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>onFulfilled<span class=\"token punctuation\">,</span>onRejected<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 每次返回一个promise，保证是可thenable的</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">function</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 這一步很關鍵，只有這樣才可以將值傳遞給下一個resolve</span>\n        <span class=\"token keyword\">var</span> ret <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> onFulfilled <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onFulfilled</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> value<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//判断是不是promise 对象</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ret <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> ret <span class=\"token punctuation\">[</span><span class=\"token string\">'then'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ret<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">function</span> <span class=\"token function\">errback</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        reason <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> onRejected <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onRejected</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> reason<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 根据当前异步状态执行操作</span>\n      <span class=\"token keyword\">var</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'PENDING'</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _this<span class=\"token punctuation\">.</span>_resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>handle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          _this<span class=\"token punctuation\">.</span>_rejects<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>errback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'FULFILLED'</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">'REJECTED'</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">errback</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">.</span>_reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      config<span class=\"token punctuation\">[</span>_this<span class=\"token punctuation\">.</span>_status<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * 链式写法中可以捕获前面then中发送的异常\n   */</span>\n  Promise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>onRejected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>undefined<span class=\"token punctuation\">,</span> onRejected<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Promise.race\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n   */</span>\n\n  Promise<span class=\"token punctuation\">.</span>race <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You must pass an array to all.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 返回 promise 实例</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      promiseArr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Promise.all\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n   */</span>\n  Promise<span class=\"token punctuation\">.</span>all <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You must pass an array to all.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 返回 promise 实例</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> done <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span>promiseArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      promiseArr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">done</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 判断 promise 状态是否全部 resolve</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count <span class=\"token operator\">===</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  Promise<span class=\"token punctuation\">.</span>resolve <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  Promise<span class=\"token punctuation\">.</span>reject <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>本篇文章主要是实现 Promise 的原理, 具体 API 用法不在本文中做介绍。可以查看阮一峰老师的 <a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">ES6 Promise教程</a><br></p>\n<p>实现 Promise 首先要知道它的执行特点<br></p>\n<ol>\n<li>Promise 是一个构造函数，接受函数作为参数(resolve(),reject()) </li>\n<li>Promise 对象有三种状态 pending(进行中), fulfilled(成功), rejected(失败)</li>\n<li>Promise 从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve() </li>\n<li>Promise 从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()</li>\n<li>Promise 状态无法中途取消，一旦建立立即执行，会一直保持这个结果，这时也叫 resolved(已定型状态)</li>\n<li>Promise 状态改变时 then 方法支持多次链式调用 </li>\n<li>Promise 如果不设置回调函数内部会抛异常</li>\n</ol>\n<h3 id=\"定义构造函数\"><a href=\"#定义构造函数\" class=\"headerlink\" title=\"定义构造函数\"></a>定义构造函数</h3><p>构造函数 Promise 必须接受函数作为参数</p>\n<ol>\n<li>定义构造函数</li>\n<li>判断一个参数是否为函数</li>\n</ol>\n<pre><code class=\"js\">/**\n * 封装判断参数是够是函数\n */\nfunction isFunction(fn) {\n  return Object.prototype.toString.call(fn) === &#39;[object Function]&#39;;\n}\n\n/**\n * 定义构造函数\n * @param {*} fn \n */\nfunction Promise(fn) {\n  if (!isFunction(fn)) {\n    throw new Error(&#39;Promise must accept a function as a parameter&#39;)\n  }\n}</code></pre>\n<h3 id=\"定义-resolve\"><a href=\"#定义-resolve\" class=\"headerlink\" title=\"定义 resolve\"></a>定义 resolve</h3><p>在内部定义 resolve 方法作为参数传到 fn 中，fn 调用成功后会调用 resolve 方法，之后在执行 then 中注册的回调函数</p>\n<pre><code class=\"js\">/**\n * 定义构造函数\n * @param {*} fn \n */\nfunction Promise(fn) {\n  // 判断是否是函数\n  var _isFunction = Object.prototype.toString.call(fn) === &#39;[object Function]&#39;;\n\n  // 如果不是函数抛出异常\n  if (!_isFunction) {\n    throw new Error(&#39;Promise must accept a function as a parameter&#39;)\n  }\n\n  // 定义回调状态\n  var __callback\n  this.then = function (status) {\n    __callback = status\n  }\n  // 定义 resolve 函数传入成功的数据\n  function resolve (data) {\n    __callback(data)\n  }\n  fn(resolve)\n}</code></pre>\n<p>调用例子</p>\n<pre><code class=\"js\">function request () {\n  return new Promise(function(resolve){\n    if (true) {\n      setTimeout(function() {\n        resolve(&quot;renbo&quot;);\n      }, 0);\n    }\n  })\n}\n\nrequest().then(function(data){\n  console.log(data)\n  console.log(&#39;success&#39;)\n})\n\n// 输出\nrenbo\nsuccess</code></pre>\n<p>上面的例子我们已经简单的实现了 promise 的基础回调，接下来我们完成链式语法调用以及then队列管理</p>\n<h3 id=\"链式语法及队列管理\"><a href=\"#链式语法及队列管理\" class=\"headerlink\" title=\"链式语法及队列管理\"></a>链式语法及队列管理</h3><pre><code class=\"js\">function Promise (fn) {\n\n  var _isFunction = Object.prototype.toString.call(fn) === &#39;[object Function]&#39;;\n\n  if (!_isFunction) {\n    throw new Error(&#39;Promise must accept a function as a parameter&#39;)\n  }\n\n  var _this = this,\n      _value = null;\n      _this._resolves = [];\n\n  this.then = function (status) {\n    _this._resolves.push(status);\n    return this;\n  }\n\n  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾\n  function resolve (val) {\n     setTimeout(function() {\n      _this._resolves.forEach(function (callback) {\n        _value = val\n        callback(_value)\n      })\n    },0);\n  }\n\n  fn (resolve)\n}</code></pre>\n<h3 id=\"加入状态并串行Promise\"><a href=\"#加入状态并串行Promise\" class=\"headerlink\" title=\"加入状态并串行Promise\"></a>加入状态并串行Promise</h3><p>Promise 对象有三种状态 <br></p>\n<ol>\n<li>pending(进行中) 立即执行</li>\n<li>从 pending 变为 fulfilled 过程是成功的过程可以执行回调函数 resolve(‘fulfilled’) </li>\n<li>从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject(‘rejected’)</li>\n</ol>\n<p><code>promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变</code></p>\n<p>我们加入上面的状态并串行Promise</p>\n<pre><code class=\"js\">function Promise (fn) {\n\n  function _isFunction (func) {\n    return Object.prototype.toString.call(func) === &#39;[object Function]&#39;;\n  }\n  if (!_isFunction(fn)) {\n    throw new Error(&#39;Promise must accept a function as a parameter&#39;)\n  }\n\n  var _this = this,\n      _val = null;\n      _this._resolves = [];\n      _this._status = &#39;PENDING&#39;;\n\n  this.then = function (onFulfilled) {\n    return new Promise(function (resolve) {\n      // handle 函数对上一个 promise 的 then 中回调进行了处理，并且调用当前的 promise 中的 resolve 方法。\n      function handle(_val) {\n        var ret = _isFunction(onFulfilled) &amp;&amp; onFulfilled(_val) || _val\n        // 如果是⼀一个 promise 对象，就会调⽤ then 方法，形成一个嵌套\n        if (ret &amp;&amp; _isFunction(ret[&#39;then&#39;])) {\n          ret.then(function (value) {\n            resolve(value);\n          })\n        } else {\n          resolve(ret)\n        }\n      }\n      if (_this._status === &#39;PENDING&#39;) {\n       _this._resolves.push(handle);\n      } else if(promise._status === &#39;FULFILLED&#39;){\n        handle(value);\n      }       \n    })\n  }\n\n  // 将 resolve 中执行回调的逻辑放置到 JS 任务队列列末尾\n  function resolve (val) {\n     setTimeout(function() {\n       _this.status = &quot;FULFILLED&quot;;\n      _this._resolves.forEach(function (callback) {\n        _val = val\n        callback(_val)\n      })\n    },0);\n  }\n\n  fn (resolve)\n}</code></pre>\n<h3 id=\"错误处理reject\"><a href=\"#错误处理reject\" class=\"headerlink\" title=\"错误处理reject\"></a>错误处理reject</h3><p>在异步操作中，操作可能失败，执行失败的回调函数，上面已经说到从 pending 变为 rejected 过程是失败的过程可以执行回调函数 reject()</p>\n<pre><code class=\"js\">function Promise(fn) {\n\n  /**\n   * 工具函数判断是否是 function\n   * @param {*} func \n   */\n  function _isFunction(func) {\n    return Object.prototype.toString.call(func) === &#39;[object Function]&#39;;\n  }\n  if (!_isFunction(fn)) {\n    throw new Error(&#39;Promise must accept a function as a parameter&#39;)\n  }\n\n\n  var _this = this;\n  _this._value;\n  _this._reason;\n  _this._resolves = [];\n  _this._rejects = [];\n  _this._status = &quot;PENDING&quot;;\n\n  /**\n   * promise then回调\n   * @onFulfilled 执行成功状态的处理函数\n   * @onRejected 执行失败状态处理函数\n   */\n  this.then = function (onFulfilled, onRejected) {\n    return new Promise(function (resolve, reject) {\n\n      /**\n       * 对上一个 promise 的 then 中回调进行了处理\n       * 并且调用当前的 promise 中的 resolve 方法\n       */\n      function handle(value) {\n        var ret = _isFunction(onFulfilled) &amp;&amp; onFulfilled(value) || value\n        if (ret &amp;&amp; _isFunction(ret[&#39;then&#39;])) {\n          ret.then(\n            function (value) {\n              resolve(value);\n            },\n            function (reason) {\n              reject(reason);\n            }\n          )\n        } else {\n          resolve(ret)\n        }\n      }\n\n      /**\n       * 错误处理回调函数\n       */\n      function errback(reason) {\n        reason = _isFunction(onRejected) &amp;&amp; onRejected(reason) || reason;\n        reject(reason);\n      }\n\n      /**\n       * 根据当前异步状态执行操作\n       */\n      var config = {\n        &#39;PENDING&#39;: function () {\n          _this._resolves.push(handle);\n          _this._rejects.push(errback);\n        },\n        &#39;FULFILLED&#39;: function () {\n          handle(value);\n        },\n        &#39;REJECTED&#39;: function () {\n          errback(_this._reason);\n        }\n      }\n\n      config[_this._status]()\n    })\n  }\n\n  /**\n   * 成功的回调函数\n   * setTimeout作用是将resolve \n   * 执行回调的逻辑放置到 JS 任务队列列末尾\n   * 防止then执行在resolve之前\n   * @FULFILLED 状态\n   * @param {*} value \n   */\n  function resolve(value) {\n    setTimeout(function () {\n      _this.status = &quot;FULFILLED&quot;\n      _this._resolves.forEach(function (callback) {\n       _this._value = callback(value)\n      })\n    }, 0)\n  }\n\n  /**\n   * 错误处理回调函数\n   * @REJECTED 状态\n   * @param {*} value \n   */\n  function reject(value) {\n    setTimeout(function () {\n      _this._status = &quot;REJECTED&quot;\n      _this._rejects.forEach(function (callback) {\n        _this._reason = callback(value);\n      })\n    }, 0)\n  }\n\n  fn(resolve, reject)\n}</code></pre>\n<h3 id=\"实现Promise-all\"><a href=\"#实现Promise-all\" class=\"headerlink\" title=\"实现Promise.all\"></a>实现Promise.all</h3><p>实现Promise.all函数</p>\n<pre><code class=\"js\">/**\n * Promise.all\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n */\nPromise.all = function(promiseArr) {\n\n  if (!Array.isArray(promiseArr)) {\n    throw new TypeError(&#39;You must pass an array to all.&#39;);\n  }\n  // 返回 promise 实例\n  return new Promise(function (resolve, reject) {\n    let done = gen(promiseArr.length, resolve);\n    promiseArr.forEach(function (promise, index) {\n      promise.then(function (value) {\n        done(index, value)\n      },reject)\n    })\n  })\n}\n\nfunction gen(length, resolve) {\n  let count = 0;\n  let result = [];\n  return function(i, value) {\n    result[i] = value;\n    if (++count === length) {\n      resolve(result);\n    }\n  }\n}</code></pre>\n<h3 id=\"实现Promise-race\"><a href=\"#实现Promise-race\" class=\"headerlink\" title=\"实现Promise.race\"></a>实现Promise.race</h3><p>实现Promise.race函数</p>\n<pre><code class=\"js\">/**\n * Promise.race\n * 接收一个元素为 Promise 对象的数组作为参数\n * 返回一个Promise实例\n * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n */\n\nPromise.race = function(promiseArr) {\n\n  if (!Array.isArray(promiseArr)) {\n    throw new TypeError(&#39;You must pass an array to all.&#39;);\n  }\n  // 返回 promise 实例\n  return new Promise(function(resolve, reject){\n    promiseArr.forEach(function (promise, index) {\n      promise.then(resolve,reject)\n    })\n  })\n}\n</code></pre>\n<h3 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch \"></a>实现 catch <br></h3><p>实现 catch </p>\n<pre><code class=\"js\">/**\n * 链式写法中可以捕获前面then中发送的异常\n */\n\nfunction Promise () {\n  var _this = this\n  ...\n\n  this.catch = function (onRejected) {\n    return _this.then(null, onRejected);\n  }\n}\n</code></pre>\n<h3 id=\"代码封装\"><a href=\"#代码封装\" class=\"headerlink\" title=\"代码封装\"></a>代码封装</h3><p>经过上面的几个步骤我们基本实现了 promise 的几个重要特性，下面我们将代码整理一下</p>\n<pre><code class=\"js\">/*\n * @Description: promise \n * @Author: renbo\n * @Date: 2019-08-12 15:13:40\n * @LastEditTime: 2019-08-15 10:34:44\n */\n\nvar Promise = /** @class */ (function () {\n\n  function Promise (fn) {\n\n    var _this = this;\n    _this._status = &#39;PENDING&#39;;\n    _this._value = undefined;\n    _this._reason = undefined;\n    //存储状态\n    _this._resolves = [];\n    _this._rejects = [];\n\n    // 异常处理\n    if (!(typeof fn === &#39;function&#39; )) {\n      throw new TypeError(&#39;Promise must accept a function as a parameter&#39;);\n    }\n    if(!(this instanceof Promise)) return new Promise(fn);\n\n\n   function resolve(value) {\n      //由於apply參數是數組\n      _this.final.apply(_this,[&#39;FULFILLED&#39;].concat([value]));\n    }\n\n    function reject(reason){\n      _this.final.apply(_this,[&#39;REJECTED&#39;].concat([reason]));\n    }\n\n    fn(resolve,reject);\n  }\n\n  /**\n   * 用于resolve 和 reject \n   * 异步调用，保证then是先执行的\n   * @param {*} status \n   * @param {*} value \n   */\n  Promise.prototype.final = function (status,value) {\n    var _this = this, fn, st;\n    if(_this._status !== &#39;PENDING&#39;) return;\n\n    setTimeout(function(){\n      _this._status = status;\n      st = _this._status === &#39;FULFILLED&#39;\n      queue = _this[st ? &#39;_resolves&#39; : &#39;_rejects&#39;];\n\n      while(fn = queue.shift()) {\n        value = fn.call(_this, value) || value;\n      }\n\n      _this[st ? &#39;_value&#39; : &#39;_reason&#39;] = value;\n      _this[&#39;_resolves&#39;] = _this[&#39;_rejects&#39;] = undefined;\n    });\n  }\n\n  /**\n   * then \n   * @params onFulfilled\n   * @params onRejected\n   */\n  Promise.prototype.then = function (onFulfilled,onRejected) {\n    var _this = this;\n    // 每次返回一个promise，保证是可thenable的\n    return new Promise(function(resolve,reject){\n\n      function handle(value) {\n        // 這一步很關鍵，只有這樣才可以將值傳遞給下一個resolve\n        var ret = typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(value) || value;\n\n        //判断是不是promise 对象\n        if (ret &amp;&amp; typeof ret [&#39;then&#39;] == &#39;function&#39;) {\n            ret.then(function(value) {\n                resolve(value);\n            }, function(reason) {\n                reject(reason);\n            });\n        } else {\n          resolve(ret);\n        }\n      }\n\n      function errback(reason){\n        reason = typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(reason) || reason;\n        reject(reason);\n      }\n\n      // 根据当前异步状态执行操作\n      var config = {\n        &#39;PENDING&#39;: function () {\n          _this._resolves.push(handle);\n          _this._rejects.push(errback);\n        },\n        &#39;FULFILLED&#39;: function () {\n          handle(value);\n        },\n        &#39;REJECTED&#39;: function () {\n          errback(_this._reason);\n        }\n      }\n\n      config[_this._status]()\n    });\n  }\n\n\n  /**\n   * 链式写法中可以捕获前面then中发送的异常\n   */\n  Promise.prototype.catch = function(onRejected){\n    return this.then(undefined, onRejected)\n  }\n\n\n  /**\n   * Promise.race\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 只要该数组中的任意一个 Promise 对象的状态发⽣变化(无论是 resolve 还是 reject)该⽅法都会返回\n   */\n\n  Promise.race = function(promiseArr) {\n\n    if (!Array.isArray(promiseArr)) {\n      throw new TypeError(&#39;You must pass an array to all.&#39;);\n    }\n    // 返回 promise 实例\n    return new Promise(function(resolve, reject){\n      promiseArr.forEach(function (promise, index) {\n        promise.then(resolve,reject)\n      })\n    })\n  }\n\n\n  /**\n   * Promise.all\n   * 接收一个元素为 Promise 对象的数组作为参数\n   * 返回一个Promise实例\n   * 当这个数组里的所有promise对象都变为resolve状态的时候，才会返回\n   */\n  Promise.all = function(promiseArr) {\n\n    if (!Array.isArray(promiseArr)) {\n      throw new TypeError(&#39;You must pass an array to all.&#39;);\n    }\n    // 返回 promise 实例\n    return new Promise(function (resolve, reject) {\n      let done = gen(promiseArr.length, resolve);\n      promiseArr.forEach(function (promise, index) {\n        promise.then(function (value) {\n          done(index, value)\n        },reject)\n      })\n    })\n\n    // 判断 promise 状态是否全部 resolve\n    function gen(length, resolve) {\n      let count = 0;\n      let result = [];\n      return function(i, value) {\n        result[i] = value;\n        if (++count === length) {\n          resolve(result);\n        }\n      }\n    }\n  }\n\n  Promise.resolve = function(arg){\n    return new Promise(function(resolve,reject){\n        resolve(arg)\n    })\n  }\n\n  Promise.reject = function(arg){\n    return Promise(function(resolve,reject){\n      reject(arg)\n    })\n  }\n\n  return Promise;\n}())</code></pre>\n"},{"title":"tcp udp http","date":"2019-03-23T14:33:25.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n### 构建TCP服务<br/>\n tcp全名为传输控制协议，在OSI模型中属于传输层协议如下图<br/>\n <image src=/images/tcp.png' width=\"300px\"></image><br/>\n\n tcp是面向连接的协议，特点是在传输之前需要3次握手形成会话如下图<br/>\n <image src=/images/ack.png' width=\"300px\"></image><br/>\n\n  第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认<br/>\n  第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br/>\n  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br/>\n\n  当然tcp也会有四次挥手，在这里就不具体说明了<br/>\n\n### 创建TCP服务端<br/>\n1、创建TCP服务端接受网络请求<br/>\n1.1服务器事件<br/>\n\n```\nvar net = require('net');\nvar server = net.createServer(function(socket) {\n  // 开始新连接\n  socket.on('data', function(data) {\n    socket.write('hello');\n  })\n\n  // 断开连接\n  socket.on('end', function() {\n    console.log('断开连接');\n  }) \n})\n\nserver.listen(8124, function() {\n  console.log('server start listen port 8124 !');\n});\n```\n通过上面代码创建为服务器事件，它是一个**EventEmitter**实例，自定义事件有一下几种<br/>\n- listening 绑定的端口\n- connection 连接到服务器时出发此事件\n- close 服务器关闭时触发\n- error 服务器发生异常时触发<br/>\n\n1.2连接事件<br/>\n\n```\nvar net = require('net');\nvar client = net.connect({ port: 8124 }, function () {\n  console.log('client connected !');\n  client.write('hello');\n})\n\nclient.on('data', function (data) {\n  conosle.log(data);\n  client.end();\n})\n\nclient.on('end', function () {\n  console.log('此连接结束');\n})\n```\n通过上面代码创建连接事件，服务器可以同时与多个客户端保持连接，对于每个连接其实都是**Stream**对象，它用于服务器端和客户端之间的通讯，自定义事件如下<br/>\n- data 当一端调用write()发送数据时，另一端会触发data，事件传递的数据是write()发送的数据\n- end 当连接中的任意一端发送**FIN** 数据时，触发此事件\n- drain 当一端调用write()发送数据时，触发此事件\n- close 当所有连接完全关闭时触发\n- error 服务器发生异常时触发\n- timeout 连接超时时触发\n\n**node中 TCP默认开启Nagle算法（优化网络数据包）此算法由于要求缓冲数据达到一定数量或一定时间后才发送，所以可能会造成延迟发送**\n\n### 构建UDP服务<br/>\nUDP用户数据包协议，和TCP一样属于网络传输层<br/>\n\n### 创建UDP服务端<br/>\n```\nvar dgram = require('dgram');\n// 创建server对象\nvar server  = dgram.createSocket('udp4');\n// 接到消息时，触发该事件，携带的数据为消息buffer和远程地址信息对象\nserver.on('message' function (msg, rinfo) {\n  console.log(msg)\n  console.log(rinfo)\n});\n// 绑定端口之后启动监听时间\nserver.on('listening', function () {\n  var address = server.address();\n  console.log(address);\n});\n// 绑定端口\nserver.bind(41234);\n\n```\n### 创建UDP客户端<br/>\n```\nvar dgram = require('dgram');\n\nvar message = new Buffer('hello');\nvar client = dgram.createSocket('udp4');\nclient.send(message, 0, message.length, 41234, 'localhost', function (err, bytes) {\n  client.close();\n})\n```\n\n### 构建HTTP服务<br/>\n\nHTTP是超文本传输协议，是构建在TCP之上的，属于应用层协议，在HTTP的两端是服务端和浏览器也就是B/S模式<br/>\n\n### HTTP报文<br/>\n我们可以在命令行利用curl -v http://localhost:8080/ 来模拟请求，产生如下报文信息<br/>\n\n第一部分其实就是标准的TCP3次握手过程<br/>\n```\n* About to connect() to localhost (127.0.0.1) port 8080 (#0)\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n```\n\n第二部分在握手完成之后，客户端向服务端发送的请求报文<br/>\n```\n> GET / HTTP/1.1\n> Host: 127.0.0.1:8080\n> User-Agent: curl/7.54.0\n> Accept: */*\n>\n```\n\n第三部分是服务端处理结束后，向客户端发送的响应内容包括响应头和响应体<br/>\n```\n< HTTP/1.1 200 OK\n< X-Powered-By: Express\n< Accept-Ranges: bytes\n< Content-Type: text/html; charset=UTF-8\n< Content-Length: 820\n< ETag: W/\"334-dKswJvgc24O5QPXd939SLJD+BhM\"\n< Date: Thu, 11 Apr 2019 10:33:03 GMT\n< Connection: keep-alive\n<\nhello\n```\n\n第四部分是结束此会话<br/>\n```\n* Connection #0 to host 127.0.0.1 left intact\n* Closing connection #0\n```\n\n通过上面的信息中我们可以看出虽然是基于 TCP，但是本身确实基于请求响应式的，一问一答模式并不是会话模式。<br/>\n\n### HTTP模块<br/>\n\nnode http 模块承继 tcp 服务器（ net 模块）它能够与多个客户端保持连接，采用事件驱动，不会为每个连接创建额外的线程或进程。占用内存低，所以能实现高并发，tcp 服务以connection进行服务，http以request进行服务。node http 模块将connection和request进行封装<br/>\n<image src=/images/request.png' width=\"400px\"></image><br/>\n\nhttp模块将所有读写抽象为ServerRequest和ServerResponse对象<br/>\n<image src=/images/http.png' width=\"400px\"></image><br/>\n```\nfunction (req, res) {\n  res.writeHead(200, {'Content-Type' : 'text/plain'});\n  res.end('Hello Word');\n}\n```\n\n### HTTP代理<br/>\n\nhttp 提供的 ClientRequest 是基于 tcp 层实现的，在keepalive情况下，一个底层会话能够连接多个请求。<br/>\nhttp 模块包含一个默认的客户端代理对象http.globalAgent<br/>\n通过 ClientRequest 对象对用一个服务器发起的 http 最多可以创建5个连接，实际上是一个连接池。如果 http 客户端同时对一个服务器发起超过5个请求，其实也只有5个处于并发状态。<br/>\n<image src=/images/http代理.png' width=\"400px\"></image><br/>\n```\n// 可以通过http.Agent修改连接数量，但连接数量过大会影响服务器性能\nvar agent = new http.Agent({\n  maxSockets: 10\n})\nvar option = {\n  hostname: '127.0.0.1',\n  port: 1334,\n  path: '/',\n  method: 'GET',\n  agent: agent\n}\n```\n\n### 构建 WebSocket 服务<br/>\nWebsocket 协议解决了服务器与客户端全双工通信的问题,也就是客户端和服务端之间的长连接<br/>\n\n### WebSocket协议解析<br/>\n\nWebSocket协议主要分为两个部分第一部分 http **握手**连接，第二部分协议升级为 WebSocket 进行**数据传输**<br/>\n<image src=/images/websocket.png' width=\"400px\"></image><br/>\n\n\n\n### TCP UDP HTTP WebSocket区别\n1. TCP UDP HTTP WebSocket都是协议，而TCP/IP是不同协议的组合 <br/>\n2. Socket的本质是API，只不过是对TCP/IP协议族的抽象或者说封装<br/>\n3. 从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议<br/>\n\n**1.TCP和UDP**<br/>\n\nTCP是面向连接的传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至<br/>\nUDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至<br/>\n\n**2.HTTP**<br/>\n\nHTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。\n而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作<br/>\n\n**3.WebSocket**<br/>\n\nWebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化<br/>\n\n\n**4.HTTP、WebSocket与TCP的关系**<br/>\n\nHTTP通信过程是客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯<br/>\nHTTP和WebSocket虽都是基于TCP协议<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/node/http.md","raw":"---\ntitle:  tcp udp http\ndate: 2019-03-23 22:33:25\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- Node\ncategories:\n- Node\n---\n\n### 构建TCP服务<br/>\n tcp全名为传输控制协议，在OSI模型中属于传输层协议如下图<br/>\n <image src=/images/tcp.png' width=\"300px\"></image><br/>\n\n tcp是面向连接的协议，特点是在传输之前需要3次握手形成会话如下图<br/>\n <image src=/images/ack.png' width=\"300px\"></image><br/>\n\n  第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认<br/>\n  第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br/>\n  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br/>\n\n  当然tcp也会有四次挥手，在这里就不具体说明了<br/>\n\n### 创建TCP服务端<br/>\n1、创建TCP服务端接受网络请求<br/>\n1.1服务器事件<br/>\n\n```\nvar net = require('net');\nvar server = net.createServer(function(socket) {\n  // 开始新连接\n  socket.on('data', function(data) {\n    socket.write('hello');\n  })\n\n  // 断开连接\n  socket.on('end', function() {\n    console.log('断开连接');\n  }) \n})\n\nserver.listen(8124, function() {\n  console.log('server start listen port 8124 !');\n});\n```\n通过上面代码创建为服务器事件，它是一个**EventEmitter**实例，自定义事件有一下几种<br/>\n- listening 绑定的端口\n- connection 连接到服务器时出发此事件\n- close 服务器关闭时触发\n- error 服务器发生异常时触发<br/>\n\n1.2连接事件<br/>\n\n```\nvar net = require('net');\nvar client = net.connect({ port: 8124 }, function () {\n  console.log('client connected !');\n  client.write('hello');\n})\n\nclient.on('data', function (data) {\n  conosle.log(data);\n  client.end();\n})\n\nclient.on('end', function () {\n  console.log('此连接结束');\n})\n```\n通过上面代码创建连接事件，服务器可以同时与多个客户端保持连接，对于每个连接其实都是**Stream**对象，它用于服务器端和客户端之间的通讯，自定义事件如下<br/>\n- data 当一端调用write()发送数据时，另一端会触发data，事件传递的数据是write()发送的数据\n- end 当连接中的任意一端发送**FIN** 数据时，触发此事件\n- drain 当一端调用write()发送数据时，触发此事件\n- close 当所有连接完全关闭时触发\n- error 服务器发生异常时触发\n- timeout 连接超时时触发\n\n**node中 TCP默认开启Nagle算法（优化网络数据包）此算法由于要求缓冲数据达到一定数量或一定时间后才发送，所以可能会造成延迟发送**\n\n### 构建UDP服务<br/>\nUDP用户数据包协议，和TCP一样属于网络传输层<br/>\n\n### 创建UDP服务端<br/>\n```\nvar dgram = require('dgram');\n// 创建server对象\nvar server  = dgram.createSocket('udp4');\n// 接到消息时，触发该事件，携带的数据为消息buffer和远程地址信息对象\nserver.on('message' function (msg, rinfo) {\n  console.log(msg)\n  console.log(rinfo)\n});\n// 绑定端口之后启动监听时间\nserver.on('listening', function () {\n  var address = server.address();\n  console.log(address);\n});\n// 绑定端口\nserver.bind(41234);\n\n```\n### 创建UDP客户端<br/>\n```\nvar dgram = require('dgram');\n\nvar message = new Buffer('hello');\nvar client = dgram.createSocket('udp4');\nclient.send(message, 0, message.length, 41234, 'localhost', function (err, bytes) {\n  client.close();\n})\n```\n\n### 构建HTTP服务<br/>\n\nHTTP是超文本传输协议，是构建在TCP之上的，属于应用层协议，在HTTP的两端是服务端和浏览器也就是B/S模式<br/>\n\n### HTTP报文<br/>\n我们可以在命令行利用curl -v http://localhost:8080/ 来模拟请求，产生如下报文信息<br/>\n\n第一部分其实就是标准的TCP3次握手过程<br/>\n```\n* About to connect() to localhost (127.0.0.1) port 8080 (#0)\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n```\n\n第二部分在握手完成之后，客户端向服务端发送的请求报文<br/>\n```\n> GET / HTTP/1.1\n> Host: 127.0.0.1:8080\n> User-Agent: curl/7.54.0\n> Accept: */*\n>\n```\n\n第三部分是服务端处理结束后，向客户端发送的响应内容包括响应头和响应体<br/>\n```\n< HTTP/1.1 200 OK\n< X-Powered-By: Express\n< Accept-Ranges: bytes\n< Content-Type: text/html; charset=UTF-8\n< Content-Length: 820\n< ETag: W/\"334-dKswJvgc24O5QPXd939SLJD+BhM\"\n< Date: Thu, 11 Apr 2019 10:33:03 GMT\n< Connection: keep-alive\n<\nhello\n```\n\n第四部分是结束此会话<br/>\n```\n* Connection #0 to host 127.0.0.1 left intact\n* Closing connection #0\n```\n\n通过上面的信息中我们可以看出虽然是基于 TCP，但是本身确实基于请求响应式的，一问一答模式并不是会话模式。<br/>\n\n### HTTP模块<br/>\n\nnode http 模块承继 tcp 服务器（ net 模块）它能够与多个客户端保持连接，采用事件驱动，不会为每个连接创建额外的线程或进程。占用内存低，所以能实现高并发，tcp 服务以connection进行服务，http以request进行服务。node http 模块将connection和request进行封装<br/>\n<image src=/images/request.png' width=\"400px\"></image><br/>\n\nhttp模块将所有读写抽象为ServerRequest和ServerResponse对象<br/>\n<image src=/images/http.png' width=\"400px\"></image><br/>\n```\nfunction (req, res) {\n  res.writeHead(200, {'Content-Type' : 'text/plain'});\n  res.end('Hello Word');\n}\n```\n\n### HTTP代理<br/>\n\nhttp 提供的 ClientRequest 是基于 tcp 层实现的，在keepalive情况下，一个底层会话能够连接多个请求。<br/>\nhttp 模块包含一个默认的客户端代理对象http.globalAgent<br/>\n通过 ClientRequest 对象对用一个服务器发起的 http 最多可以创建5个连接，实际上是一个连接池。如果 http 客户端同时对一个服务器发起超过5个请求，其实也只有5个处于并发状态。<br/>\n<image src=/images/http代理.png' width=\"400px\"></image><br/>\n```\n// 可以通过http.Agent修改连接数量，但连接数量过大会影响服务器性能\nvar agent = new http.Agent({\n  maxSockets: 10\n})\nvar option = {\n  hostname: '127.0.0.1',\n  port: 1334,\n  path: '/',\n  method: 'GET',\n  agent: agent\n}\n```\n\n### 构建 WebSocket 服务<br/>\nWebsocket 协议解决了服务器与客户端全双工通信的问题,也就是客户端和服务端之间的长连接<br/>\n\n### WebSocket协议解析<br/>\n\nWebSocket协议主要分为两个部分第一部分 http **握手**连接，第二部分协议升级为 WebSocket 进行**数据传输**<br/>\n<image src=/images/websocket.png' width=\"400px\"></image><br/>\n\n\n\n### TCP UDP HTTP WebSocket区别\n1. TCP UDP HTTP WebSocket都是协议，而TCP/IP是不同协议的组合 <br/>\n2. Socket的本质是API，只不过是对TCP/IP协议族的抽象或者说封装<br/>\n3. 从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议<br/>\n\n**1.TCP和UDP**<br/>\n\nTCP是面向连接的传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至<br/>\nUDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至<br/>\n\n**2.HTTP**<br/>\n\nHTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。\n而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作<br/>\n\n**3.WebSocket**<br/>\n\nWebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化<br/>\n\n\n**4.HTTP、WebSocket与TCP的关系**<br/>\n\nHTTP通信过程是客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯<br/>\nHTTP和WebSocket虽都是基于TCP协议<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"node/http","published":1,"updated":"2019-10-15T01:29:42.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ow7008lb0u66j7f4bq9","content":"<h3 id=\"构建TCP服务\"><a href=\"#构建TCP服务\" class=\"headerlink\" title=\"构建TCP服务\"></a>构建TCP服务<br></h3><p> tcp全名为传输控制协议，在OSI模型中属于传输层协议如下图<br><br> &lt;image src=/images/tcp.png’ width=”300px”&gt;<br></p>\n<p> tcp是面向连接的协议，特点是在传输之前需要3次握手形成会话如下图<br><br> &lt;image src=/images/ack.png’ width=”300px”&gt;<br></p>\n<p>  第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认<br><br>  第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br><br>  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br></p>\n<p>  当然tcp也会有四次挥手，在这里就不具体说明了<br></p>\n<h3 id=\"创建TCP服务端\"><a href=\"#创建TCP服务端\" class=\"headerlink\" title=\"创建TCP服务端\"></a>创建TCP服务端<br></h3><p>1、创建TCP服务端接受网络请求<br><br>1.1服务器事件<br></p>\n<pre><code>var net = require(&#39;net&#39;);\nvar server = net.createServer(function(socket) {\n  // 开始新连接\n  socket.on(&#39;data&#39;, function(data) {\n    socket.write(&#39;hello&#39;);\n  })\n\n  // 断开连接\n  socket.on(&#39;end&#39;, function() {\n    console.log(&#39;断开连接&#39;);\n  }) \n})\n\nserver.listen(8124, function() {\n  console.log(&#39;server start listen port 8124 !&#39;);\n});</code></pre><p>通过上面代码创建为服务器事件，它是一个<strong>EventEmitter</strong>实例，自定义事件有一下几种<br></p>\n<ul>\n<li>listening 绑定的端口</li>\n<li>connection 连接到服务器时出发此事件</li>\n<li>close 服务器关闭时触发</li>\n<li>error 服务器发生异常时触发<br></li>\n</ul>\n<p>1.2连接事件<br></p>\n<pre><code>var net = require(&#39;net&#39;);\nvar client = net.connect({ port: 8124 }, function () {\n  console.log(&#39;client connected !&#39;);\n  client.write(&#39;hello&#39;);\n})\n\nclient.on(&#39;data&#39;, function (data) {\n  conosle.log(data);\n  client.end();\n})\n\nclient.on(&#39;end&#39;, function () {\n  console.log(&#39;此连接结束&#39;);\n})</code></pre><p>通过上面代码创建连接事件，服务器可以同时与多个客户端保持连接，对于每个连接其实都是<strong>Stream</strong>对象，它用于服务器端和客户端之间的通讯，自定义事件如下<br></p>\n<ul>\n<li>data 当一端调用write()发送数据时，另一端会触发data，事件传递的数据是write()发送的数据</li>\n<li>end 当连接中的任意一端发送<strong>FIN</strong> 数据时，触发此事件</li>\n<li>drain 当一端调用write()发送数据时，触发此事件</li>\n<li>close 当所有连接完全关闭时触发</li>\n<li>error 服务器发生异常时触发</li>\n<li>timeout 连接超时时触发</li>\n</ul>\n<p><strong>node中 TCP默认开启Nagle算法（优化网络数据包）此算法由于要求缓冲数据达到一定数量或一定时间后才发送，所以可能会造成延迟发送</strong></p>\n<h3 id=\"构建UDP服务\"><a href=\"#构建UDP服务\" class=\"headerlink\" title=\"构建UDP服务\"></a>构建UDP服务<br></h3><p>UDP用户数据包协议，和TCP一样属于网络传输层<br></p>\n<h3 id=\"创建UDP服务端\"><a href=\"#创建UDP服务端\" class=\"headerlink\" title=\"创建UDP服务端\"></a>创建UDP服务端<br></h3><pre><code>var dgram = require(&#39;dgram&#39;);\n// 创建server对象\nvar server  = dgram.createSocket(&#39;udp4&#39;);\n// 接到消息时，触发该事件，携带的数据为消息buffer和远程地址信息对象\nserver.on(&#39;message&#39; function (msg, rinfo) {\n  console.log(msg)\n  console.log(rinfo)\n});\n// 绑定端口之后启动监听时间\nserver.on(&#39;listening&#39;, function () {\n  var address = server.address();\n  console.log(address);\n});\n// 绑定端口\nserver.bind(41234);\n</code></pre><h3 id=\"创建UDP客户端\"><a href=\"#创建UDP客户端\" class=\"headerlink\" title=\"创建UDP客户端\"></a>创建UDP客户端<br></h3><pre><code>var dgram = require(&#39;dgram&#39;);\n\nvar message = new Buffer(&#39;hello&#39;);\nvar client = dgram.createSocket(&#39;udp4&#39;);\nclient.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) {\n  client.close();\n})</code></pre><h3 id=\"构建HTTP服务\"><a href=\"#构建HTTP服务\" class=\"headerlink\" title=\"构建HTTP服务\"></a>构建HTTP服务<br></h3><p>HTTP是超文本传输协议，是构建在TCP之上的，属于应用层协议，在HTTP的两端是服务端和浏览器也就是B/S模式<br></p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文<br></h3><p>我们可以在命令行利用curl -v <a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/</a> 来模拟请求，产生如下报文信息<br></p>\n<p>第一部分其实就是标准的TCP3次握手过程<br></p>\n<pre><code>* About to connect() to localhost (127.0.0.1) port 8080 (#0)\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to localhost (127.0.0.1) port 8080 (#0)</code></pre><p>第二部分在握手完成之后，客户端向服务端发送的请求报文<br></p>\n<pre><code>&gt; GET / HTTP/1.1\n&gt; Host: 127.0.0.1:8080\n&gt; User-Agent: curl/7.54.0\n&gt; Accept: */*\n&gt;</code></pre><p>第三部分是服务端处理结束后，向客户端发送的响应内容包括响应头和响应体<br></p>\n<pre><code>&lt; HTTP/1.1 200 OK\n&lt; X-Powered-By: Express\n&lt; Accept-Ranges: bytes\n&lt; Content-Type: text/html; charset=UTF-8\n&lt; Content-Length: 820\n&lt; ETag: W/&quot;334-dKswJvgc24O5QPXd939SLJD+BhM&quot;\n&lt; Date: Thu, 11 Apr 2019 10:33:03 GMT\n&lt; Connection: keep-alive\n&lt;\nhello</code></pre><p>第四部分是结束此会话<br></p>\n<pre><code>* Connection #0 to host 127.0.0.1 left intact\n* Closing connection #0</code></pre><p>通过上面的信息中我们可以看出虽然是基于 TCP，但是本身确实基于请求响应式的，一问一答模式并不是会话模式。<br></p>\n<h3 id=\"HTTP模块\"><a href=\"#HTTP模块\" class=\"headerlink\" title=\"HTTP模块\"></a>HTTP模块<br></h3><p>node http 模块承继 tcp 服务器（ net 模块）它能够与多个客户端保持连接，采用事件驱动，不会为每个连接创建额外的线程或进程。占用内存低，所以能实现高并发，tcp 服务以connection进行服务，http以request进行服务。node http 模块将connection和request进行封装<br><br>&lt;image src=/images/request.png’ width=”400px”&gt;<br></p>\n<p>http模块将所有读写抽象为ServerRequest和ServerResponse对象<br><br>&lt;image src=/images/http.png’ width=”400px”&gt;<br></p>\n<pre><code>function (req, res) {\n  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});\n  res.end(&#39;Hello Word&#39;);\n}</code></pre><h3 id=\"HTTP代理\"><a href=\"#HTTP代理\" class=\"headerlink\" title=\"HTTP代理\"></a>HTTP代理<br></h3><p>http 提供的 ClientRequest 是基于 tcp 层实现的，在keepalive情况下，一个底层会话能够连接多个请求。<br><br>http 模块包含一个默认的客户端代理对象http.globalAgent<br><br>通过 ClientRequest 对象对用一个服务器发起的 http 最多可以创建5个连接，实际上是一个连接池。如果 http 客户端同时对一个服务器发起超过5个请求，其实也只有5个处于并发状态。<br><br>&lt;image src=/images/http代理.png’ width=”400px”&gt;<br></p>\n<pre><code>// 可以通过http.Agent修改连接数量，但连接数量过大会影响服务器性能\nvar agent = new http.Agent({\n  maxSockets: 10\n})\nvar option = {\n  hostname: &#39;127.0.0.1&#39;,\n  port: 1334,\n  path: &#39;/&#39;,\n  method: &#39;GET&#39;,\n  agent: agent\n}</code></pre><h3 id=\"构建-WebSocket-服务\"><a href=\"#构建-WebSocket-服务\" class=\"headerlink\" title=\"构建 WebSocket 服务\"></a>构建 WebSocket 服务<br></h3><p>Websocket 协议解决了服务器与客户端全双工通信的问题,也就是客户端和服务端之间的长连接<br></p>\n<h3 id=\"WebSocket协议解析\"><a href=\"#WebSocket协议解析\" class=\"headerlink\" title=\"WebSocket协议解析\"></a>WebSocket协议解析<br></h3><p>WebSocket协议主要分为两个部分第一部分 http <strong>握手</strong>连接，第二部分协议升级为 WebSocket 进行<strong>数据传输</strong><br><br>&lt;image src=/images/websocket.png’ width=”400px”&gt;<br></p>\n<h3 id=\"TCP-UDP-HTTP-WebSocket区别\"><a href=\"#TCP-UDP-HTTP-WebSocket区别\" class=\"headerlink\" title=\"TCP UDP HTTP WebSocket区别\"></a>TCP UDP HTTP WebSocket区别</h3><ol>\n<li>TCP UDP HTTP WebSocket都是协议，而TCP/IP是不同协议的组合 <br></li>\n<li>Socket的本质是API，只不过是对TCP/IP协议族的抽象或者说封装<br></li>\n<li>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议<br></li>\n</ol>\n<p><strong>1.TCP和UDP</strong><br></p>\n<p>TCP是面向连接的传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至<br><br>UDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至<br></p>\n<p><strong>2.HTTP</strong><br></p>\n<p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。<br>而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作<br></p>\n<p><strong>3.WebSocket</strong><br></p>\n<p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化<br></p>\n<p><strong>4.HTTP、WebSocket与TCP的关系</strong><br></p>\n<p>HTTP通信过程是客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯<br><br>HTTP和WebSocket虽都是基于TCP协议<br></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"构建TCP服务\"><a href=\"#构建TCP服务\" class=\"headerlink\" title=\"构建TCP服务\"></a>构建TCP服务<br></h3><p> tcp全名为传输控制协议，在OSI模型中属于传输层协议如下图<br><br> &lt;image src=/images/tcp.png’ width=”300px”&gt;<br></p>\n<p> tcp是面向连接的协议，特点是在传输之前需要3次握手形成会话如下图<br><br> &lt;image src=/images/ack.png’ width=”300px”&gt;<br></p>\n<p>  第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认<br><br>  第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br><br>  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br></p>\n<p>  当然tcp也会有四次挥手，在这里就不具体说明了<br></p>\n<h3 id=\"创建TCP服务端\"><a href=\"#创建TCP服务端\" class=\"headerlink\" title=\"创建TCP服务端\"></a>创建TCP服务端<br></h3><p>1、创建TCP服务端接受网络请求<br><br>1.1服务器事件<br></p>\n<pre><code>var net = require(&#39;net&#39;);\nvar server = net.createServer(function(socket) {\n  // 开始新连接\n  socket.on(&#39;data&#39;, function(data) {\n    socket.write(&#39;hello&#39;);\n  })\n\n  // 断开连接\n  socket.on(&#39;end&#39;, function() {\n    console.log(&#39;断开连接&#39;);\n  }) \n})\n\nserver.listen(8124, function() {\n  console.log(&#39;server start listen port 8124 !&#39;);\n});</code></pre><p>通过上面代码创建为服务器事件，它是一个<strong>EventEmitter</strong>实例，自定义事件有一下几种<br></p>\n<ul>\n<li>listening 绑定的端口</li>\n<li>connection 连接到服务器时出发此事件</li>\n<li>close 服务器关闭时触发</li>\n<li>error 服务器发生异常时触发<br></li>\n</ul>\n<p>1.2连接事件<br></p>\n<pre><code>var net = require(&#39;net&#39;);\nvar client = net.connect({ port: 8124 }, function () {\n  console.log(&#39;client connected !&#39;);\n  client.write(&#39;hello&#39;);\n})\n\nclient.on(&#39;data&#39;, function (data) {\n  conosle.log(data);\n  client.end();\n})\n\nclient.on(&#39;end&#39;, function () {\n  console.log(&#39;此连接结束&#39;);\n})</code></pre><p>通过上面代码创建连接事件，服务器可以同时与多个客户端保持连接，对于每个连接其实都是<strong>Stream</strong>对象，它用于服务器端和客户端之间的通讯，自定义事件如下<br></p>\n<ul>\n<li>data 当一端调用write()发送数据时，另一端会触发data，事件传递的数据是write()发送的数据</li>\n<li>end 当连接中的任意一端发送<strong>FIN</strong> 数据时，触发此事件</li>\n<li>drain 当一端调用write()发送数据时，触发此事件</li>\n<li>close 当所有连接完全关闭时触发</li>\n<li>error 服务器发生异常时触发</li>\n<li>timeout 连接超时时触发</li>\n</ul>\n<p><strong>node中 TCP默认开启Nagle算法（优化网络数据包）此算法由于要求缓冲数据达到一定数量或一定时间后才发送，所以可能会造成延迟发送</strong></p>\n<h3 id=\"构建UDP服务\"><a href=\"#构建UDP服务\" class=\"headerlink\" title=\"构建UDP服务\"></a>构建UDP服务<br></h3><p>UDP用户数据包协议，和TCP一样属于网络传输层<br></p>\n<h3 id=\"创建UDP服务端\"><a href=\"#创建UDP服务端\" class=\"headerlink\" title=\"创建UDP服务端\"></a>创建UDP服务端<br></h3><pre><code>var dgram = require(&#39;dgram&#39;);\n// 创建server对象\nvar server  = dgram.createSocket(&#39;udp4&#39;);\n// 接到消息时，触发该事件，携带的数据为消息buffer和远程地址信息对象\nserver.on(&#39;message&#39; function (msg, rinfo) {\n  console.log(msg)\n  console.log(rinfo)\n});\n// 绑定端口之后启动监听时间\nserver.on(&#39;listening&#39;, function () {\n  var address = server.address();\n  console.log(address);\n});\n// 绑定端口\nserver.bind(41234);\n</code></pre><h3 id=\"创建UDP客户端\"><a href=\"#创建UDP客户端\" class=\"headerlink\" title=\"创建UDP客户端\"></a>创建UDP客户端<br></h3><pre><code>var dgram = require(&#39;dgram&#39;);\n\nvar message = new Buffer(&#39;hello&#39;);\nvar client = dgram.createSocket(&#39;udp4&#39;);\nclient.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) {\n  client.close();\n})</code></pre><h3 id=\"构建HTTP服务\"><a href=\"#构建HTTP服务\" class=\"headerlink\" title=\"构建HTTP服务\"></a>构建HTTP服务<br></h3><p>HTTP是超文本传输协议，是构建在TCP之上的，属于应用层协议，在HTTP的两端是服务端和浏览器也就是B/S模式<br></p>\n<h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文<br></h3><p>我们可以在命令行利用curl -v <a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/</a> 来模拟请求，产生如下报文信息<br></p>\n<p>第一部分其实就是标准的TCP3次握手过程<br></p>\n<pre><code>* About to connect() to localhost (127.0.0.1) port 8080 (#0)\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to localhost (127.0.0.1) port 8080 (#0)</code></pre><p>第二部分在握手完成之后，客户端向服务端发送的请求报文<br></p>\n<pre><code>&gt; GET / HTTP/1.1\n&gt; Host: 127.0.0.1:8080\n&gt; User-Agent: curl/7.54.0\n&gt; Accept: */*\n&gt;</code></pre><p>第三部分是服务端处理结束后，向客户端发送的响应内容包括响应头和响应体<br></p>\n<pre><code>&lt; HTTP/1.1 200 OK\n&lt; X-Powered-By: Express\n&lt; Accept-Ranges: bytes\n&lt; Content-Type: text/html; charset=UTF-8\n&lt; Content-Length: 820\n&lt; ETag: W/&quot;334-dKswJvgc24O5QPXd939SLJD+BhM&quot;\n&lt; Date: Thu, 11 Apr 2019 10:33:03 GMT\n&lt; Connection: keep-alive\n&lt;\nhello</code></pre><p>第四部分是结束此会话<br></p>\n<pre><code>* Connection #0 to host 127.0.0.1 left intact\n* Closing connection #0</code></pre><p>通过上面的信息中我们可以看出虽然是基于 TCP，但是本身确实基于请求响应式的，一问一答模式并不是会话模式。<br></p>\n<h3 id=\"HTTP模块\"><a href=\"#HTTP模块\" class=\"headerlink\" title=\"HTTP模块\"></a>HTTP模块<br></h3><p>node http 模块承继 tcp 服务器（ net 模块）它能够与多个客户端保持连接，采用事件驱动，不会为每个连接创建额外的线程或进程。占用内存低，所以能实现高并发，tcp 服务以connection进行服务，http以request进行服务。node http 模块将connection和request进行封装<br><br>&lt;image src=/images/request.png’ width=”400px”&gt;<br></p>\n<p>http模块将所有读写抽象为ServerRequest和ServerResponse对象<br><br>&lt;image src=/images/http.png’ width=”400px”&gt;<br></p>\n<pre><code>function (req, res) {\n  res.writeHead(200, {&#39;Content-Type&#39; : &#39;text/plain&#39;});\n  res.end(&#39;Hello Word&#39;);\n}</code></pre><h3 id=\"HTTP代理\"><a href=\"#HTTP代理\" class=\"headerlink\" title=\"HTTP代理\"></a>HTTP代理<br></h3><p>http 提供的 ClientRequest 是基于 tcp 层实现的，在keepalive情况下，一个底层会话能够连接多个请求。<br><br>http 模块包含一个默认的客户端代理对象http.globalAgent<br><br>通过 ClientRequest 对象对用一个服务器发起的 http 最多可以创建5个连接，实际上是一个连接池。如果 http 客户端同时对一个服务器发起超过5个请求，其实也只有5个处于并发状态。<br><br>&lt;image src=/images/http代理.png’ width=”400px”&gt;<br></p>\n<pre><code>// 可以通过http.Agent修改连接数量，但连接数量过大会影响服务器性能\nvar agent = new http.Agent({\n  maxSockets: 10\n})\nvar option = {\n  hostname: &#39;127.0.0.1&#39;,\n  port: 1334,\n  path: &#39;/&#39;,\n  method: &#39;GET&#39;,\n  agent: agent\n}</code></pre><h3 id=\"构建-WebSocket-服务\"><a href=\"#构建-WebSocket-服务\" class=\"headerlink\" title=\"构建 WebSocket 服务\"></a>构建 WebSocket 服务<br></h3><p>Websocket 协议解决了服务器与客户端全双工通信的问题,也就是客户端和服务端之间的长连接<br></p>\n<h3 id=\"WebSocket协议解析\"><a href=\"#WebSocket协议解析\" class=\"headerlink\" title=\"WebSocket协议解析\"></a>WebSocket协议解析<br></h3><p>WebSocket协议主要分为两个部分第一部分 http <strong>握手</strong>连接，第二部分协议升级为 WebSocket 进行<strong>数据传输</strong><br><br>&lt;image src=/images/websocket.png’ width=”400px”&gt;<br></p>\n<h3 id=\"TCP-UDP-HTTP-WebSocket区别\"><a href=\"#TCP-UDP-HTTP-WebSocket区别\" class=\"headerlink\" title=\"TCP UDP HTTP WebSocket区别\"></a>TCP UDP HTTP WebSocket区别</h3><ol>\n<li>TCP UDP HTTP WebSocket都是协议，而TCP/IP是不同协议的组合 <br></li>\n<li>Socket的本质是API，只不过是对TCP/IP协议族的抽象或者说封装<br></li>\n<li>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议<br></li>\n</ol>\n<p><strong>1.TCP和UDP</strong><br></p>\n<p>TCP是面向连接的传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至<br><br>UDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至<br></p>\n<p><strong>2.HTTP</strong><br></p>\n<p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。<br>而HTTP/1.1中的keep-alive所保持的长连接则是为了优化每次HTTP请求中TCP连接三次握手的麻烦和资源开销，只建立一次TCP连接，多次的在这个通道上完成请求/响应操作<br></p>\n<p><strong>3.WebSocket</strong><br></p>\n<p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化<br></p>\n<p><strong>4.HTTP、WebSocket与TCP的关系</strong><br></p>\n<p>HTTP通信过程是客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯<br><br>HTTP和WebSocket虽都是基于TCP协议<br></p>\n"},{"title":"PHP 面向对象","date":"2017-01-23T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n**面向对象基础概念**<br/>\nObject Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数<br/>\n\n**对象的主要三个特性**<br/>\n对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为<br/>\n对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型<br/>\n对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同<br/>\n\n比如 People(人) 是一个抽象类，我们可以具体到男人和女人，男人和女人就是具体的对象，他们有名字属性，可以写，可以学习说话等行为状态。\n\n**面向对象内容**<br/>\n```\n类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作\n\n对象 − 是类的实例\n\n成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性\n\n成员函数 − 定义在类的内部，可用于访问对象的数据\n\n继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容\n\n父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类\n\n子类 − 一个类继承其他类称为子类，也可称为派生类\n\n多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性\n\n重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法\n\n抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关\n\n封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内\n\n构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中\n\n析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做\"清理善后\" 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）\n```\n\n## 代码解析上述概念\n\n**PHP中类的定义**<br/>\n```\n  <?php\n    class People {\n      // 公有成员属性\n      public $name = 'zhangsan';\n      public $age = 28;\n      // 公有成员函数方法\n      public function sayName () {\n        //业务逻辑 \n      }\n    }\n  ?>\n\n```\n**PHP中对象的创建**<br/>\n```\n  class People {\n    // 公有成员属性\n    public $name = 'zhangsan';\n    public $age = 28;\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo $this->name;\n    }\n  }\n  // 通过new操作符创建对象\n  $body = new People();\n  // 成员对象的调用\n  $body->study();\n```\n**PHP中构造函数**<br/>\n构造函数是一种特殊的方法。主要用来在创建对象时初始化对象和JS中构造函数中的constructor相似<br/>\n```\n  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct( $name, $age ) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n  }\n  // 通过new操作符创建zhangsan对象\n  $zhangsan = new People('zhangsan', 28);\n  $zhangsan->sayName();\n\n  // 通过new操作符创建lisi对象\n  $lisi = new People('lisi', 26);\n  $lisi->sayName();\n```\n**PHP中析构函数**<br/>\n析构函数 (destructor) 与构造函数相反，当对象结束其生命周期时，系统自动执行析构函数，常用场景例如连接数据库在__construct中,处理完数据断开连接在__destruct方法中<br/>\n```\n  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct ($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n    // 析构函数用于销毁某些变量、对象，操作等\n    function __destruct () {\n      $this->name = '';\n      return true;\n    }\n  }\n  // 通过new操作符创建lisi对象\n  $lisi = new People('lisi', 26);\n\n  var_dump($lisi);\n  echo '<br/>';\n\n  if ($lisi->__destruct()) {\n    echo '销毁成功 <br/>';\n    var_dump($lisi);\n  }\n```\n\n**PHP中继承实现**<br/>\nPHP 使用关键字 extends 来继承一个类<br/>\n```\n  // 父类\n  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n  }\n  // 子类\n  class Boy extends People {\n\n    function getParentProperty () {\n      var_dump($this);\n    }\n\n  }\n  $lisi = new People('lisi', 26);\n  $boy = new Boy('wangwu',28);\n  $boy->getParentProperty();\n  // 子类调用父类方法\n  $boy->sayName();\n```\n**PHP中方法重写**\n```\n  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n  }\n  // 子类\n  class Boy extends People {\n    // 重写父类方法\n    public function sayName () {\n      echo (\"my name is &nbsp;\" .$this->name);\n      return $this->name;\n    }\n  }\n  $lisi = new People('lisi', 26);\n  $boy = new Boy('wangwu',28);\n  // 重写方法\n  $boy->sayName();\n```\n**PHP中访问的控制**<br/>\nPHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的<br/>\n\npublic & var（公有）：公有的类成员可以在任何地方被访问<br/>\n\nprotected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问<br/>\n\nprivate（私有）：私有的类成员则只能被其定义所在的类访问<br/>\n\n```\n  /**\n   * 基类\n   * Define People\n   */\n  class People \n  {\n    // 声明一个公有的构造函数\n    public function __construct () {}\n\n    // 声明一个共有的方法\n    public function sayName () \n    {\n      echo 'sayname</br>';\n    }\n\n    // 声明一个受保护的方法\n    protected function swim () \n    {\n      echo 'swim</br>';\n    }\n\n    // 声明一个私有方法\n    private function study () \n    {\n      echo 'study';\n    }\n    \n    // 不加关键字默认公有方法\n    function getFun () {\n      $this->sayName();\n      $this->swim();\n      $this->study();\n    }\n  }\n  $people = new People();\n  // 正常运行输出sayname\n  $people->sayName();\n  // 产生错误\n  $people->swim();\n  // 产生错误\n  $people->study();\n  // 公有，受保护，私有都可以执行\n  $people->getFun(); \n\n  /**\n   * 子类\n   * Define Boy\n   */\n\n  class Boy extends People\n  {\n    function getFun2 ()\n    {\n      $this->sayName();\n      $this->swim();\n      // 这行会产生一个错误\n      $this->study(); \n    }\n  }\n  $body = new Boy();\n  // 这行能被正常执行\n  $body ->sayName();\n  // 公有的和受保护的都可执行，但私有的不行\n  $body->getFun2(); \n```\n\n**PHP中抽象类**<br/>\n利用关键字abstract声明抽象\n\n如果类中有一个方法被是声明为抽象，那么这个类也必须声明为抽象<br/>\n\n抽象方法只声明了调用方式（参数），不能定义其具体的功能实现（相当于没有函数体），子类通过继承实现抽象方法，且不能被实例化<br/>\n\n继承一个抽象类，子类必须定义父类中的所有抽象方法并且必须要和父类的声明访问级别保持一致或者更宽松<br/>\n\n```\n  /**\n   * 定义抽象类People\n   */\n  abstract class People \n  {\n\n    abstract protected function eat();\n    abstract protected function sleep();\n    abstract protected function study();\n    public function runing() \n    {\n      echo '跑啊跑！</br>';\n    }\n  }\n\n  /**\n   * 实现抽象类\n   */\n  class Zhangsan extends People\n  {\n    protected function eat()\n    {\n      echo 'eat </br>';\n      return 'eat';\n    }\n\n    protected function sleep()\n    {\n      echo 'sleep </br>';\n      return 'sleep';\n    }\n\n    protected function study()\n    {\n      echo 'study </br>';\n      return 'study';\n    }\n\n    public function getFunc () \n    {\n      $this->eat();\n      $this->sleep();\n      $this->study();\n    }\n  }\n  // 调用子类\n  $zhangsan = new Zhangsan;\n  $zhangsan->runing(); //跑啊跑！\n  $zhangsan->getFunc(); // eat sleep study\n```\n\n场景：在很多类里面很多的方法都是在重复。这里就可以去用抽象类，当然也可以重写一个类，每个公共类实例化实例化一次，调用相同的方法。但是abstract可以省去实例化的步骤，而且可以重载这个方法,这样不是更方便简单嘛<br/>\n**PHP中接口的使用**<br/>\ninterface主要对类名，类所拥有的方法，以及所传参数起约束和规范作用，和abstract类似。在多人协同开发项目时起重要作用<br/>\n```\n// 定义接口类\ninterface People  \n{\n  public eat () {};\n}\n// 实现接口类\nclass Apple implements People{\n public function eat ()\n {\n   echo '我吃的苹果';\n }\n}\n\n$apple = new Apple();\n$apple->eat(); \n```\n\n参数约束，如果参数名字不一样会报错<br/>\n```\n// 定义接口类\ninterface People  \n{\n  public function eat($color);\n}\n\n// 实现接口类Apple\nclass Apple implements People\n{\n public function eat($color)\n {\n    echo(\"我吃的$color 🍎<br/>\");\n }\n}\n\n// 实现接口类Grape\nclass Grape implements People\n{\n  public function eat($color)\n  {\n    echo(\"我吃的$color 🍇\");\n  }\n}\n\n$apple = new Apple();\n$apple->eat('红'); \n\n$grape = new Grape();\n$grape->eat('紫'); \n```\n\n接口继承<br/>\n```\n  // 定义People接口类\n  interface People  \n  {  \n    public function eat();  \n  }\n\n  // 继承People接口类\n  interface Boy extends People  \n  {  \n    public function drink();  \n  }\n\n  // 接口方法实现\n  class Behavior implements Boy  \n  {  \n    public function eat()  \n    {  \n        echo \"吃东西<br>\";  \n    }  \n    \n    public function drink()  \n    {  \n      echo \"喝饮料<br>\";  \n    }  \n  }         \n  Behavior::eat();      \n  Behavior::drink();\n\n```\n**总结抽象类和接口**<br/>\n抽象类就是一个类的服务提供商，拥有众多服务<br/>\n\n接口类就是一个类的规范，子类必须完成它指定方法<br/>\n\n它们的区别：<br/>\n\n抽象类继承用extends,接口继承用implements<br/>\n\n抽象类能多重继承,接口多重继承用\",\"隔开<br/>\n\n抽象类中的方法不必全部重载,接口方法必须声明或者重载<br/>\n\n抽象类不必只包含抽象方法,可以定义完整的方法,接口不能包含任何完整定义方法<br/>\n\n\n**__set,__get,__isset,__unset,__call,__sleep(),__wakeup()等魔术方法**\n\n1. __sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用<br/>\n\n__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作<br/>\n\n引入php手册中的例子<br/>\n```\n  class Connection \n  {\n      protected $link;\n      private $server, $username, $password, $db;\n      \n      public function __construct($server, $username, $password, $db)\n      {\n          $this->server = $server;\n          $this->username = $username;\n          $this->password = $password;\n          $this->db = $db;\n          $this->connect();\n      }\n      \n      private function connect()\n      {\n          $this->link = mysql_connect($this->server, $this->username, $this->password);\n          mysql_select_db($this->db, $this->link);\n      }\n      \n      public function __sleep()\n      {\n          return array('server', 'username', 'password', 'db');\n      }\n      \n      public function __wakeup()\n      {\n          $this->connect();\n      }\n  }\n```\n\n2. 属性重载__set,__get,__isset,__unset<br/>\n```\npublic __set ( string $name , mixed $value ) : void // 设置私有属性值的时候调用\npublic __get ( string $name ) : mixed  // 获取私有属性值的时候调用\npublic __isset ( string $name ) : bool // 当判断一个私有成员属性是否被设置过时调用\npublic __unset ( string $name ) : void // 当销毁一个私有成员属性的时候调用\n```\n当实例化一个对象后，调用类中不存在或者没有权限访问的属性的时候，默认调用__get()方法。可以访问内部属性<br/>\n\n\n3. 方法重载__call和__callStatic<br/>\n```\ncall 和 callStatic 是类似的方法，前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。正常情况下如果调用一个类不存在的方法 PHP 会抛出致命错误，而使用这两个魔术方法我们可以替换一些更友好的提示或者记录错误调用日志信息、将用户重定向、抛出异常等等，亦或者是如同set 和 get 那样做方法的重命名。\n```\n\n\n\n\n\n\n\n","source":"_posts/php/oop.md","raw":"---\ntitle: PHP 面向对象\ndate: 2017-01-23 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- PHP\ncategories:\n- PHP\n---\n\n**面向对象基础概念**<br/>\nObject Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数<br/>\n\n**对象的主要三个特性**<br/>\n对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为<br/>\n对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型<br/>\n对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同<br/>\n\n比如 People(人) 是一个抽象类，我们可以具体到男人和女人，男人和女人就是具体的对象，他们有名字属性，可以写，可以学习说话等行为状态。\n\n**面向对象内容**<br/>\n```\n类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作\n\n对象 − 是类的实例\n\n成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性\n\n成员函数 − 定义在类的内部，可用于访问对象的数据\n\n继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容\n\n父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类\n\n子类 − 一个类继承其他类称为子类，也可称为派生类\n\n多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性\n\n重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法\n\n抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关\n\n封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内\n\n构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中\n\n析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做\"清理善后\" 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）\n```\n\n## 代码解析上述概念\n\n**PHP中类的定义**<br/>\n```\n  <?php\n    class People {\n      // 公有成员属性\n      public $name = 'zhangsan';\n      public $age = 28;\n      // 公有成员函数方法\n      public function sayName () {\n        //业务逻辑 \n      }\n    }\n  ?>\n\n```\n**PHP中对象的创建**<br/>\n```\n  class People {\n    // 公有成员属性\n    public $name = 'zhangsan';\n    public $age = 28;\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo $this->name;\n    }\n  }\n  // 通过new操作符创建对象\n  $body = new People();\n  // 成员对象的调用\n  $body->study();\n```\n**PHP中构造函数**<br/>\n构造函数是一种特殊的方法。主要用来在创建对象时初始化对象和JS中构造函数中的constructor相似<br/>\n```\n  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct( $name, $age ) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n  }\n  // 通过new操作符创建zhangsan对象\n  $zhangsan = new People('zhangsan', 28);\n  $zhangsan->sayName();\n\n  // 通过new操作符创建lisi对象\n  $lisi = new People('lisi', 26);\n  $lisi->sayName();\n```\n**PHP中析构函数**<br/>\n析构函数 (destructor) 与构造函数相反，当对象结束其生命周期时，系统自动执行析构函数，常用场景例如连接数据库在__construct中,处理完数据断开连接在__destruct方法中<br/>\n```\n  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct ($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n    // 析构函数用于销毁某些变量、对象，操作等\n    function __destruct () {\n      $this->name = '';\n      return true;\n    }\n  }\n  // 通过new操作符创建lisi对象\n  $lisi = new People('lisi', 26);\n\n  var_dump($lisi);\n  echo '<br/>';\n\n  if ($lisi->__destruct()) {\n    echo '销毁成功 <br/>';\n    var_dump($lisi);\n  }\n```\n\n**PHP中继承实现**<br/>\nPHP 使用关键字 extends 来继承一个类<br/>\n```\n  // 父类\n  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n  }\n  // 子类\n  class Boy extends People {\n\n    function getParentProperty () {\n      var_dump($this);\n    }\n\n  }\n  $lisi = new People('lisi', 26);\n  $boy = new Boy('wangwu',28);\n  $boy->getParentProperty();\n  // 子类调用父类方法\n  $boy->sayName();\n```\n**PHP中方法重写**\n```\n  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n    }\n    public function sayName () {\n      echo(\"my name is &nbsp;\" .$this->name.\",&nbspI`m&nbsp;\" .$this->age .\"&nbsp;years old\");\n      echo '</br>';\n    }\n  }\n  // 子类\n  class Boy extends People {\n    // 重写父类方法\n    public function sayName () {\n      echo (\"my name is &nbsp;\" .$this->name);\n      return $this->name;\n    }\n  }\n  $lisi = new People('lisi', 26);\n  $boy = new Boy('wangwu',28);\n  // 重写方法\n  $boy->sayName();\n```\n**PHP中访问的控制**<br/>\nPHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的<br/>\n\npublic & var（公有）：公有的类成员可以在任何地方被访问<br/>\n\nprotected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问<br/>\n\nprivate（私有）：私有的类成员则只能被其定义所在的类访问<br/>\n\n```\n  /**\n   * 基类\n   * Define People\n   */\n  class People \n  {\n    // 声明一个公有的构造函数\n    public function __construct () {}\n\n    // 声明一个共有的方法\n    public function sayName () \n    {\n      echo 'sayname</br>';\n    }\n\n    // 声明一个受保护的方法\n    protected function swim () \n    {\n      echo 'swim</br>';\n    }\n\n    // 声明一个私有方法\n    private function study () \n    {\n      echo 'study';\n    }\n    \n    // 不加关键字默认公有方法\n    function getFun () {\n      $this->sayName();\n      $this->swim();\n      $this->study();\n    }\n  }\n  $people = new People();\n  // 正常运行输出sayname\n  $people->sayName();\n  // 产生错误\n  $people->swim();\n  // 产生错误\n  $people->study();\n  // 公有，受保护，私有都可以执行\n  $people->getFun(); \n\n  /**\n   * 子类\n   * Define Boy\n   */\n\n  class Boy extends People\n  {\n    function getFun2 ()\n    {\n      $this->sayName();\n      $this->swim();\n      // 这行会产生一个错误\n      $this->study(); \n    }\n  }\n  $body = new Boy();\n  // 这行能被正常执行\n  $body ->sayName();\n  // 公有的和受保护的都可执行，但私有的不行\n  $body->getFun2(); \n```\n\n**PHP中抽象类**<br/>\n利用关键字abstract声明抽象\n\n如果类中有一个方法被是声明为抽象，那么这个类也必须声明为抽象<br/>\n\n抽象方法只声明了调用方式（参数），不能定义其具体的功能实现（相当于没有函数体），子类通过继承实现抽象方法，且不能被实例化<br/>\n\n继承一个抽象类，子类必须定义父类中的所有抽象方法并且必须要和父类的声明访问级别保持一致或者更宽松<br/>\n\n```\n  /**\n   * 定义抽象类People\n   */\n  abstract class People \n  {\n\n    abstract protected function eat();\n    abstract protected function sleep();\n    abstract protected function study();\n    public function runing() \n    {\n      echo '跑啊跑！</br>';\n    }\n  }\n\n  /**\n   * 实现抽象类\n   */\n  class Zhangsan extends People\n  {\n    protected function eat()\n    {\n      echo 'eat </br>';\n      return 'eat';\n    }\n\n    protected function sleep()\n    {\n      echo 'sleep </br>';\n      return 'sleep';\n    }\n\n    protected function study()\n    {\n      echo 'study </br>';\n      return 'study';\n    }\n\n    public function getFunc () \n    {\n      $this->eat();\n      $this->sleep();\n      $this->study();\n    }\n  }\n  // 调用子类\n  $zhangsan = new Zhangsan;\n  $zhangsan->runing(); //跑啊跑！\n  $zhangsan->getFunc(); // eat sleep study\n```\n\n场景：在很多类里面很多的方法都是在重复。这里就可以去用抽象类，当然也可以重写一个类，每个公共类实例化实例化一次，调用相同的方法。但是abstract可以省去实例化的步骤，而且可以重载这个方法,这样不是更方便简单嘛<br/>\n**PHP中接口的使用**<br/>\ninterface主要对类名，类所拥有的方法，以及所传参数起约束和规范作用，和abstract类似。在多人协同开发项目时起重要作用<br/>\n```\n// 定义接口类\ninterface People  \n{\n  public eat () {};\n}\n// 实现接口类\nclass Apple implements People{\n public function eat ()\n {\n   echo '我吃的苹果';\n }\n}\n\n$apple = new Apple();\n$apple->eat(); \n```\n\n参数约束，如果参数名字不一样会报错<br/>\n```\n// 定义接口类\ninterface People  \n{\n  public function eat($color);\n}\n\n// 实现接口类Apple\nclass Apple implements People\n{\n public function eat($color)\n {\n    echo(\"我吃的$color 🍎<br/>\");\n }\n}\n\n// 实现接口类Grape\nclass Grape implements People\n{\n  public function eat($color)\n  {\n    echo(\"我吃的$color 🍇\");\n  }\n}\n\n$apple = new Apple();\n$apple->eat('红'); \n\n$grape = new Grape();\n$grape->eat('紫'); \n```\n\n接口继承<br/>\n```\n  // 定义People接口类\n  interface People  \n  {  \n    public function eat();  \n  }\n\n  // 继承People接口类\n  interface Boy extends People  \n  {  \n    public function drink();  \n  }\n\n  // 接口方法实现\n  class Behavior implements Boy  \n  {  \n    public function eat()  \n    {  \n        echo \"吃东西<br>\";  \n    }  \n    \n    public function drink()  \n    {  \n      echo \"喝饮料<br>\";  \n    }  \n  }         \n  Behavior::eat();      \n  Behavior::drink();\n\n```\n**总结抽象类和接口**<br/>\n抽象类就是一个类的服务提供商，拥有众多服务<br/>\n\n接口类就是一个类的规范，子类必须完成它指定方法<br/>\n\n它们的区别：<br/>\n\n抽象类继承用extends,接口继承用implements<br/>\n\n抽象类能多重继承,接口多重继承用\",\"隔开<br/>\n\n抽象类中的方法不必全部重载,接口方法必须声明或者重载<br/>\n\n抽象类不必只包含抽象方法,可以定义完整的方法,接口不能包含任何完整定义方法<br/>\n\n\n**__set,__get,__isset,__unset,__call,__sleep(),__wakeup()等魔术方法**\n\n1. __sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用<br/>\n\n__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作<br/>\n\n引入php手册中的例子<br/>\n```\n  class Connection \n  {\n      protected $link;\n      private $server, $username, $password, $db;\n      \n      public function __construct($server, $username, $password, $db)\n      {\n          $this->server = $server;\n          $this->username = $username;\n          $this->password = $password;\n          $this->db = $db;\n          $this->connect();\n      }\n      \n      private function connect()\n      {\n          $this->link = mysql_connect($this->server, $this->username, $this->password);\n          mysql_select_db($this->db, $this->link);\n      }\n      \n      public function __sleep()\n      {\n          return array('server', 'username', 'password', 'db');\n      }\n      \n      public function __wakeup()\n      {\n          $this->connect();\n      }\n  }\n```\n\n2. 属性重载__set,__get,__isset,__unset<br/>\n```\npublic __set ( string $name , mixed $value ) : void // 设置私有属性值的时候调用\npublic __get ( string $name ) : mixed  // 获取私有属性值的时候调用\npublic __isset ( string $name ) : bool // 当判断一个私有成员属性是否被设置过时调用\npublic __unset ( string $name ) : void // 当销毁一个私有成员属性的时候调用\n```\n当实例化一个对象后，调用类中不存在或者没有权限访问的属性的时候，默认调用__get()方法。可以访问内部属性<br/>\n\n\n3. 方法重载__call和__callStatic<br/>\n```\ncall 和 callStatic 是类似的方法，前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。正常情况下如果调用一个类不存在的方法 PHP 会抛出致命错误，而使用这两个魔术方法我们可以替换一些更友好的提示或者记录错误调用日志信息、将用户重定向、抛出异常等等，亦或者是如同set 和 get 那样做方法的重命名。\n```\n\n\n\n\n\n\n\n","slug":"php/oop","published":1,"updated":"2019-10-15T01:29:42.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ow9008ob0u6ma9gs42x","content":"<p><strong>面向对象基础概念</strong><br><br>Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数<br></p>\n<p><strong>对象的主要三个特性</strong><br><br>对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为<br><br>对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型<br><br>对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同<br></p>\n<p>比如 People(人) 是一个抽象类，我们可以具体到男人和女人，男人和女人就是具体的对象，他们有名字属性，可以写，可以学习说话等行为状态。</p>\n<p><strong>面向对象内容</strong><br></p>\n<pre><code>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作\n\n对象 − 是类的实例\n\n成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性\n\n成员函数 − 定义在类的内部，可用于访问对象的数据\n\n继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容\n\n父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类\n\n子类 − 一个类继承其他类称为子类，也可称为派生类\n\n多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性\n\n重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法\n\n抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关\n\n封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内\n\n构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中\n\n析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做&quot;清理善后&quot; 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）</code></pre><h2 id=\"代码解析上述概念\"><a href=\"#代码解析上述概念\" class=\"headerlink\" title=\"代码解析上述概念\"></a>代码解析上述概念</h2><p><strong>PHP中类的定义</strong><br></p>\n<pre><code>  &lt;?php\n    class People {\n      // 公有成员属性\n      public $name = &#39;zhangsan&#39;;\n      public $age = 28;\n      // 公有成员函数方法\n      public function sayName () {\n        //业务逻辑 \n      }\n    }\n  ?&gt;\n</code></pre><p><strong>PHP中对象的创建</strong><br></p>\n<pre><code>  class People {\n    // 公有成员属性\n    public $name = &#39;zhangsan&#39;;\n    public $age = 28;\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo $this-&gt;name;\n    }\n  }\n  // 通过new操作符创建对象\n  $body = new People();\n  // 成员对象的调用\n  $body-&gt;study();</code></pre><p><strong>PHP中构造函数</strong><br><br>构造函数是一种特殊的方法。主要用来在创建对象时初始化对象和JS中构造函数中的constructor相似<br></p>\n<pre><code>  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct( $name, $age ) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n  }\n  // 通过new操作符创建zhangsan对象\n  $zhangsan = new People(&#39;zhangsan&#39;, 28);\n  $zhangsan-&gt;sayName();\n\n  // 通过new操作符创建lisi对象\n  $lisi = new People(&#39;lisi&#39;, 26);\n  $lisi-&gt;sayName();</code></pre><p><strong>PHP中析构函数</strong><br><br>析构函数 (destructor) 与构造函数相反，当对象结束其生命周期时，系统自动执行析构函数，常用场景例如连接数据库在<strong>construct中,处理完数据断开连接在</strong>destruct方法中<br></p>\n<pre><code>  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct ($name, $age) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n    // 析构函数用于销毁某些变量、对象，操作等\n    function __destruct () {\n      $this-&gt;name = &#39;&#39;;\n      return true;\n    }\n  }\n  // 通过new操作符创建lisi对象\n  $lisi = new People(&#39;lisi&#39;, 26);\n\n  var_dump($lisi);\n  echo &#39;&lt;br/&gt;&#39;;\n\n  if ($lisi-&gt;__destruct()) {\n    echo &#39;销毁成功 &lt;br/&gt;&#39;;\n    var_dump($lisi);\n  }</code></pre><p><strong>PHP中继承实现</strong><br><br>PHP 使用关键字 extends 来继承一个类<br></p>\n<pre><code>  // 父类\n  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n  }\n  // 子类\n  class Boy extends People {\n\n    function getParentProperty () {\n      var_dump($this);\n    }\n\n  }\n  $lisi = new People(&#39;lisi&#39;, 26);\n  $boy = new Boy(&#39;wangwu&#39;,28);\n  $boy-&gt;getParentProperty();\n  // 子类调用父类方法\n  $boy-&gt;sayName();</code></pre><p><strong>PHP中方法重写</strong></p>\n<pre><code>  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n  }\n  // 子类\n  class Boy extends People {\n    // 重写父类方法\n    public function sayName () {\n      echo (&quot;my name is &amp;nbsp;&quot; .$this-&gt;name);\n      return $this-&gt;name;\n    }\n  }\n  $lisi = new People(&#39;lisi&#39;, 26);\n  $boy = new Boy(&#39;wangwu&#39;,28);\n  // 重写方法\n  $boy-&gt;sayName();</code></pre><p><strong>PHP中访问的控制</strong><br><br>PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的<br></p>\n<p>public &amp; var（公有）：公有的类成员可以在任何地方被访问<br></p>\n<p>protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问<br></p>\n<p>private（私有）：私有的类成员则只能被其定义所在的类访问<br></p>\n<pre><code>  /**\n   * 基类\n   * Define People\n   */\n  class People \n  {\n    // 声明一个公有的构造函数\n    public function __construct () {}\n\n    // 声明一个共有的方法\n    public function sayName () \n    {\n      echo &#39;sayname&lt;/br&gt;&#39;;\n    }\n\n    // 声明一个受保护的方法\n    protected function swim () \n    {\n      echo &#39;swim&lt;/br&gt;&#39;;\n    }\n\n    // 声明一个私有方法\n    private function study () \n    {\n      echo &#39;study&#39;;\n    }\n\n    // 不加关键字默认公有方法\n    function getFun () {\n      $this-&gt;sayName();\n      $this-&gt;swim();\n      $this-&gt;study();\n    }\n  }\n  $people = new People();\n  // 正常运行输出sayname\n  $people-&gt;sayName();\n  // 产生错误\n  $people-&gt;swim();\n  // 产生错误\n  $people-&gt;study();\n  // 公有，受保护，私有都可以执行\n  $people-&gt;getFun(); \n\n  /**\n   * 子类\n   * Define Boy\n   */\n\n  class Boy extends People\n  {\n    function getFun2 ()\n    {\n      $this-&gt;sayName();\n      $this-&gt;swim();\n      // 这行会产生一个错误\n      $this-&gt;study(); \n    }\n  }\n  $body = new Boy();\n  // 这行能被正常执行\n  $body -&gt;sayName();\n  // 公有的和受保护的都可执行，但私有的不行\n  $body-&gt;getFun2(); </code></pre><p><strong>PHP中抽象类</strong><br><br>利用关键字abstract声明抽象</p>\n<p>如果类中有一个方法被是声明为抽象，那么这个类也必须声明为抽象<br></p>\n<p>抽象方法只声明了调用方式（参数），不能定义其具体的功能实现（相当于没有函数体），子类通过继承实现抽象方法，且不能被实例化<br></p>\n<p>继承一个抽象类，子类必须定义父类中的所有抽象方法并且必须要和父类的声明访问级别保持一致或者更宽松<br></p>\n<pre><code>  /**\n   * 定义抽象类People\n   */\n  abstract class People \n  {\n\n    abstract protected function eat();\n    abstract protected function sleep();\n    abstract protected function study();\n    public function runing() \n    {\n      echo &#39;跑啊跑！&lt;/br&gt;&#39;;\n    }\n  }\n\n  /**\n   * 实现抽象类\n   */\n  class Zhangsan extends People\n  {\n    protected function eat()\n    {\n      echo &#39;eat &lt;/br&gt;&#39;;\n      return &#39;eat&#39;;\n    }\n\n    protected function sleep()\n    {\n      echo &#39;sleep &lt;/br&gt;&#39;;\n      return &#39;sleep&#39;;\n    }\n\n    protected function study()\n    {\n      echo &#39;study &lt;/br&gt;&#39;;\n      return &#39;study&#39;;\n    }\n\n    public function getFunc () \n    {\n      $this-&gt;eat();\n      $this-&gt;sleep();\n      $this-&gt;study();\n    }\n  }\n  // 调用子类\n  $zhangsan = new Zhangsan;\n  $zhangsan-&gt;runing(); //跑啊跑！\n  $zhangsan-&gt;getFunc(); // eat sleep study</code></pre><p>场景：在很多类里面很多的方法都是在重复。这里就可以去用抽象类，当然也可以重写一个类，每个公共类实例化实例化一次，调用相同的方法。但是abstract可以省去实例化的步骤，而且可以重载这个方法,这样不是更方便简单嘛<br><br><strong>PHP中接口的使用</strong><br><br>interface主要对类名，类所拥有的方法，以及所传参数起约束和规范作用，和abstract类似。在多人协同开发项目时起重要作用<br></p>\n<pre><code>// 定义接口类\ninterface People  \n{\n  public eat () {};\n}\n// 实现接口类\nclass Apple implements People{\n public function eat ()\n {\n   echo &#39;我吃的苹果&#39;;\n }\n}\n\n$apple = new Apple();\n$apple-&gt;eat(); </code></pre><p>参数约束，如果参数名字不一样会报错<br></p>\n<pre><code>// 定义接口类\ninterface People  \n{\n  public function eat($color);\n}\n\n// 实现接口类Apple\nclass Apple implements People\n{\n public function eat($color)\n {\n    echo(&quot;我吃的$color 🍎&lt;br/&gt;&quot;);\n }\n}\n\n// 实现接口类Grape\nclass Grape implements People\n{\n  public function eat($color)\n  {\n    echo(&quot;我吃的$color 🍇&quot;);\n  }\n}\n\n$apple = new Apple();\n$apple-&gt;eat(&#39;红&#39;); \n\n$grape = new Grape();\n$grape-&gt;eat(&#39;紫&#39;); </code></pre><p>接口继承<br></p>\n<pre><code>  // 定义People接口类\n  interface People  \n  {  \n    public function eat();  \n  }\n\n  // 继承People接口类\n  interface Boy extends People  \n  {  \n    public function drink();  \n  }\n\n  // 接口方法实现\n  class Behavior implements Boy  \n  {  \n    public function eat()  \n    {  \n        echo &quot;吃东西&lt;br&gt;&quot;;  \n    }  \n\n    public function drink()  \n    {  \n      echo &quot;喝饮料&lt;br&gt;&quot;;  \n    }  \n  }         \n  Behavior::eat();      \n  Behavior::drink();\n</code></pre><p><strong>总结抽象类和接口</strong><br><br>抽象类就是一个类的服务提供商，拥有众多服务<br></p>\n<p>接口类就是一个类的规范，子类必须完成它指定方法<br></p>\n<p>它们的区别：<br></p>\n<p>抽象类继承用extends,接口继承用implements<br></p>\n<p>抽象类能多重继承,接口多重继承用”,”隔开<br></p>\n<p>抽象类中的方法不必全部重载,接口方法必须声明或者重载<br></p>\n<p>抽象类不必只包含抽象方法,可以定义完整的方法,接口不能包含任何完整定义方法<br></p>\n<p><strong><strong>set,</strong>get,<strong>isset,</strong>unset,<strong>call,</strong>sleep(),__wakeup()等魔术方法</strong></p>\n<ol>\n<li>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用<br></li>\n</ol>\n<p>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作<br></p>\n<p>引入php手册中的例子<br></p>\n<pre><code>  class Connection \n  {\n      protected $link;\n      private $server, $username, $password, $db;\n\n      public function __construct($server, $username, $password, $db)\n      {\n          $this-&gt;server = $server;\n          $this-&gt;username = $username;\n          $this-&gt;password = $password;\n          $this-&gt;db = $db;\n          $this-&gt;connect();\n      }\n\n      private function connect()\n      {\n          $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password);\n          mysql_select_db($this-&gt;db, $this-&gt;link);\n      }\n\n      public function __sleep()\n      {\n          return array(&#39;server&#39;, &#39;username&#39;, &#39;password&#39;, &#39;db&#39;);\n      }\n\n      public function __wakeup()\n      {\n          $this-&gt;connect();\n      }\n  }</code></pre><ol start=\"2\">\n<li>属性重载<strong>set,</strong>get,<strong>isset,</strong>unset<br><pre><code>public __set ( string $name , mixed $value ) : void // 设置私有属性值的时候调用\npublic __get ( string $name ) : mixed  // 获取私有属性值的时候调用\npublic __isset ( string $name ) : bool // 当判断一个私有成员属性是否被设置过时调用\npublic __unset ( string $name ) : void // 当销毁一个私有成员属性的时候调用</code></pre>当实例化一个对象后，调用类中不存在或者没有权限访问的属性的时候，默认调用__get()方法。可以访问内部属性<br></li>\n</ol>\n<ol start=\"3\">\n<li>方法重载<strong>call和</strong>callStatic<br><pre><code>call 和 callStatic 是类似的方法，前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。正常情况下如果调用一个类不存在的方法 PHP 会抛出致命错误，而使用这两个魔术方法我们可以替换一些更友好的提示或者记录错误调用日志信息、将用户重定向、抛出异常等等，亦或者是如同set 和 get 那样做方法的重命名。</code></pre></li>\n</ol>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p><strong>面向对象基础概念</strong><br><br>Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数<br></p>\n<p><strong>对象的主要三个特性</strong><br><br>对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为<br><br>对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型<br><br>对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同<br></p>\n<p>比如 People(人) 是一个抽象类，我们可以具体到男人和女人，男人和女人就是具体的对象，他们有名字属性，可以写，可以学习说话等行为状态。</p>\n<p><strong>面向对象内容</strong><br></p>\n<pre><code>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作\n\n对象 − 是类的实例\n\n成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性\n\n成员函数 − 定义在类的内部，可用于访问对象的数据\n\n继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容\n\n父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类\n\n子类 − 一个类继承其他类称为子类，也可称为派生类\n\n多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性\n\n重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法\n\n抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关\n\n封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内\n\n构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中\n\n析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做&quot;清理善后&quot; 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）</code></pre><h2 id=\"代码解析上述概念\"><a href=\"#代码解析上述概念\" class=\"headerlink\" title=\"代码解析上述概念\"></a>代码解析上述概念</h2><p><strong>PHP中类的定义</strong><br></p>\n<pre><code>  &lt;?php\n    class People {\n      // 公有成员属性\n      public $name = &#39;zhangsan&#39;;\n      public $age = 28;\n      // 公有成员函数方法\n      public function sayName () {\n        //业务逻辑 \n      }\n    }\n  ?&gt;\n</code></pre><p><strong>PHP中对象的创建</strong><br></p>\n<pre><code>  class People {\n    // 公有成员属性\n    public $name = &#39;zhangsan&#39;;\n    public $age = 28;\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo $this-&gt;name;\n    }\n  }\n  // 通过new操作符创建对象\n  $body = new People();\n  // 成员对象的调用\n  $body-&gt;study();</code></pre><p><strong>PHP中构造函数</strong><br><br>构造函数是一种特殊的方法。主要用来在创建对象时初始化对象和JS中构造函数中的constructor相似<br></p>\n<pre><code>  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct( $name, $age ) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n  }\n  // 通过new操作符创建zhangsan对象\n  $zhangsan = new People(&#39;zhangsan&#39;, 28);\n  $zhangsan-&gt;sayName();\n\n  // 通过new操作符创建lisi对象\n  $lisi = new People(&#39;lisi&#39;, 26);\n  $lisi-&gt;sayName();</code></pre><p><strong>PHP中析构函数</strong><br><br>析构函数 (destructor) 与构造函数相反，当对象结束其生命周期时，系统自动执行析构函数，常用场景例如连接数据库在<strong>construct中,处理完数据断开连接在</strong>destruct方法中<br></p>\n<pre><code>  class People {\n    // 通过构造方法为成员变量赋初始值\n    function __construct ($name, $age) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    // 公有成员函数方法（$this代表自身的对象);\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n    // 析构函数用于销毁某些变量、对象，操作等\n    function __destruct () {\n      $this-&gt;name = &#39;&#39;;\n      return true;\n    }\n  }\n  // 通过new操作符创建lisi对象\n  $lisi = new People(&#39;lisi&#39;, 26);\n\n  var_dump($lisi);\n  echo &#39;&lt;br/&gt;&#39;;\n\n  if ($lisi-&gt;__destruct()) {\n    echo &#39;销毁成功 &lt;br/&gt;&#39;;\n    var_dump($lisi);\n  }</code></pre><p><strong>PHP中继承实现</strong><br><br>PHP 使用关键字 extends 来继承一个类<br></p>\n<pre><code>  // 父类\n  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n  }\n  // 子类\n  class Boy extends People {\n\n    function getParentProperty () {\n      var_dump($this);\n    }\n\n  }\n  $lisi = new People(&#39;lisi&#39;, 26);\n  $boy = new Boy(&#39;wangwu&#39;,28);\n  $boy-&gt;getParentProperty();\n  // 子类调用父类方法\n  $boy-&gt;sayName();</code></pre><p><strong>PHP中方法重写</strong></p>\n<pre><code>  class People {\n    var $name;\n    var $age;\n    function __construct ($name, $age) {\n      $this-&gt;name = $name;\n      $this-&gt;age = $age;\n    }\n    public function sayName () {\n      echo(&quot;my name is &amp;nbsp;&quot; .$this-&gt;name.&quot;,&amp;nbspI`m&amp;nbsp;&quot; .$this-&gt;age .&quot;&amp;nbsp;years old&quot;);\n      echo &#39;&lt;/br&gt;&#39;;\n    }\n  }\n  // 子类\n  class Boy extends People {\n    // 重写父类方法\n    public function sayName () {\n      echo (&quot;my name is &amp;nbsp;&quot; .$this-&gt;name);\n      return $this-&gt;name;\n    }\n  }\n  $lisi = new People(&#39;lisi&#39;, 26);\n  $boy = new Boy(&#39;wangwu&#39;,28);\n  // 重写方法\n  $boy-&gt;sayName();</code></pre><p><strong>PHP中访问的控制</strong><br><br>PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的<br></p>\n<p>public &amp; var（公有）：公有的类成员可以在任何地方被访问<br></p>\n<p>protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问<br></p>\n<p>private（私有）：私有的类成员则只能被其定义所在的类访问<br></p>\n<pre><code>  /**\n   * 基类\n   * Define People\n   */\n  class People \n  {\n    // 声明一个公有的构造函数\n    public function __construct () {}\n\n    // 声明一个共有的方法\n    public function sayName () \n    {\n      echo &#39;sayname&lt;/br&gt;&#39;;\n    }\n\n    // 声明一个受保护的方法\n    protected function swim () \n    {\n      echo &#39;swim&lt;/br&gt;&#39;;\n    }\n\n    // 声明一个私有方法\n    private function study () \n    {\n      echo &#39;study&#39;;\n    }\n\n    // 不加关键字默认公有方法\n    function getFun () {\n      $this-&gt;sayName();\n      $this-&gt;swim();\n      $this-&gt;study();\n    }\n  }\n  $people = new People();\n  // 正常运行输出sayname\n  $people-&gt;sayName();\n  // 产生错误\n  $people-&gt;swim();\n  // 产生错误\n  $people-&gt;study();\n  // 公有，受保护，私有都可以执行\n  $people-&gt;getFun(); \n\n  /**\n   * 子类\n   * Define Boy\n   */\n\n  class Boy extends People\n  {\n    function getFun2 ()\n    {\n      $this-&gt;sayName();\n      $this-&gt;swim();\n      // 这行会产生一个错误\n      $this-&gt;study(); \n    }\n  }\n  $body = new Boy();\n  // 这行能被正常执行\n  $body -&gt;sayName();\n  // 公有的和受保护的都可执行，但私有的不行\n  $body-&gt;getFun2(); </code></pre><p><strong>PHP中抽象类</strong><br><br>利用关键字abstract声明抽象</p>\n<p>如果类中有一个方法被是声明为抽象，那么这个类也必须声明为抽象<br></p>\n<p>抽象方法只声明了调用方式（参数），不能定义其具体的功能实现（相当于没有函数体），子类通过继承实现抽象方法，且不能被实例化<br></p>\n<p>继承一个抽象类，子类必须定义父类中的所有抽象方法并且必须要和父类的声明访问级别保持一致或者更宽松<br></p>\n<pre><code>  /**\n   * 定义抽象类People\n   */\n  abstract class People \n  {\n\n    abstract protected function eat();\n    abstract protected function sleep();\n    abstract protected function study();\n    public function runing() \n    {\n      echo &#39;跑啊跑！&lt;/br&gt;&#39;;\n    }\n  }\n\n  /**\n   * 实现抽象类\n   */\n  class Zhangsan extends People\n  {\n    protected function eat()\n    {\n      echo &#39;eat &lt;/br&gt;&#39;;\n      return &#39;eat&#39;;\n    }\n\n    protected function sleep()\n    {\n      echo &#39;sleep &lt;/br&gt;&#39;;\n      return &#39;sleep&#39;;\n    }\n\n    protected function study()\n    {\n      echo &#39;study &lt;/br&gt;&#39;;\n      return &#39;study&#39;;\n    }\n\n    public function getFunc () \n    {\n      $this-&gt;eat();\n      $this-&gt;sleep();\n      $this-&gt;study();\n    }\n  }\n  // 调用子类\n  $zhangsan = new Zhangsan;\n  $zhangsan-&gt;runing(); //跑啊跑！\n  $zhangsan-&gt;getFunc(); // eat sleep study</code></pre><p>场景：在很多类里面很多的方法都是在重复。这里就可以去用抽象类，当然也可以重写一个类，每个公共类实例化实例化一次，调用相同的方法。但是abstract可以省去实例化的步骤，而且可以重载这个方法,这样不是更方便简单嘛<br><br><strong>PHP中接口的使用</strong><br><br>interface主要对类名，类所拥有的方法，以及所传参数起约束和规范作用，和abstract类似。在多人协同开发项目时起重要作用<br></p>\n<pre><code>// 定义接口类\ninterface People  \n{\n  public eat () {};\n}\n// 实现接口类\nclass Apple implements People{\n public function eat ()\n {\n   echo &#39;我吃的苹果&#39;;\n }\n}\n\n$apple = new Apple();\n$apple-&gt;eat(); </code></pre><p>参数约束，如果参数名字不一样会报错<br></p>\n<pre><code>// 定义接口类\ninterface People  \n{\n  public function eat($color);\n}\n\n// 实现接口类Apple\nclass Apple implements People\n{\n public function eat($color)\n {\n    echo(&quot;我吃的$color 🍎&lt;br/&gt;&quot;);\n }\n}\n\n// 实现接口类Grape\nclass Grape implements People\n{\n  public function eat($color)\n  {\n    echo(&quot;我吃的$color 🍇&quot;);\n  }\n}\n\n$apple = new Apple();\n$apple-&gt;eat(&#39;红&#39;); \n\n$grape = new Grape();\n$grape-&gt;eat(&#39;紫&#39;); </code></pre><p>接口继承<br></p>\n<pre><code>  // 定义People接口类\n  interface People  \n  {  \n    public function eat();  \n  }\n\n  // 继承People接口类\n  interface Boy extends People  \n  {  \n    public function drink();  \n  }\n\n  // 接口方法实现\n  class Behavior implements Boy  \n  {  \n    public function eat()  \n    {  \n        echo &quot;吃东西&lt;br&gt;&quot;;  \n    }  \n\n    public function drink()  \n    {  \n      echo &quot;喝饮料&lt;br&gt;&quot;;  \n    }  \n  }         \n  Behavior::eat();      \n  Behavior::drink();\n</code></pre><p><strong>总结抽象类和接口</strong><br><br>抽象类就是一个类的服务提供商，拥有众多服务<br></p>\n<p>接口类就是一个类的规范，子类必须完成它指定方法<br></p>\n<p>它们的区别：<br></p>\n<p>抽象类继承用extends,接口继承用implements<br></p>\n<p>抽象类能多重继承,接口多重继承用”,”隔开<br></p>\n<p>抽象类中的方法不必全部重载,接口方法必须声明或者重载<br></p>\n<p>抽象类不必只包含抽象方法,可以定义完整的方法,接口不能包含任何完整定义方法<br></p>\n<p><strong><strong>set,</strong>get,<strong>isset,</strong>unset,<strong>call,</strong>sleep(),__wakeup()等魔术方法</strong></p>\n<ol>\n<li>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用<br></li>\n</ol>\n<p>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作<br></p>\n<p>引入php手册中的例子<br></p>\n<pre><code>  class Connection \n  {\n      protected $link;\n      private $server, $username, $password, $db;\n\n      public function __construct($server, $username, $password, $db)\n      {\n          $this-&gt;server = $server;\n          $this-&gt;username = $username;\n          $this-&gt;password = $password;\n          $this-&gt;db = $db;\n          $this-&gt;connect();\n      }\n\n      private function connect()\n      {\n          $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password);\n          mysql_select_db($this-&gt;db, $this-&gt;link);\n      }\n\n      public function __sleep()\n      {\n          return array(&#39;server&#39;, &#39;username&#39;, &#39;password&#39;, &#39;db&#39;);\n      }\n\n      public function __wakeup()\n      {\n          $this-&gt;connect();\n      }\n  }</code></pre><ol start=\"2\">\n<li>属性重载<strong>set,</strong>get,<strong>isset,</strong>unset<br><pre><code>public __set ( string $name , mixed $value ) : void // 设置私有属性值的时候调用\npublic __get ( string $name ) : mixed  // 获取私有属性值的时候调用\npublic __isset ( string $name ) : bool // 当判断一个私有成员属性是否被设置过时调用\npublic __unset ( string $name ) : void // 当销毁一个私有成员属性的时候调用</code></pre>当实例化一个对象后，调用类中不存在或者没有权限访问的属性的时候，默认调用__get()方法。可以访问内部属性<br></li>\n</ol>\n<ol start=\"3\">\n<li>方法重载<strong>call和</strong>callStatic<br><pre><code>call 和 callStatic 是类似的方法，前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。正常情况下如果调用一个类不存在的方法 PHP 会抛出致命错误，而使用这两个魔术方法我们可以替换一些更友好的提示或者记录错误调用日志信息、将用户重定向、抛出异常等等，亦或者是如同set 和 get 那样做方法的重命名。</code></pre></li>\n</ol>\n"},{"title":"React 原理之 JSX 转换","date":"2019-10-01T10:06:25.000Z","top":true,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## JXS 转换\n\n在我们写 react 组件的时候都会去写 jsx，那么 jsx 在 react 内部到底是怎么进行转换编译的呢？\n\n### babel 转换<hr>\n\n在进行转换编译之前，我们先来配置环境。这样方便我们查看转换后的代码。当然我们也使用 babel 去编译，但这里只是简单的说明 jsx 转换，所以不去配置 .babelrc 或者其他配置方式。\n\n执行下面步骤\n\n- 创建并进入文件夹\n- 在终端中执行 npm init -y \n- 在终端中执行 npm install babel-cli@6 babel-preset-react-app@3\n- 创建 demo.html,并写入\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n  <script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script>\n  <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script>\n</head>\n\n<body>\n  <div id=\"root\"></div>\n  <script src=\"demo.js\"></script>\n</body>\n\n</html>\n```\n\n- 创建 src 文件夹，在 src 文件中创建 demo.jsx，并写入\n\n```js\nfunction App() {\n  let arr = [\"zhangsan\", \"lisi\", \"wangwu\"]\n  return (\n    <ul>\n      {\n        arr.map((item, index) => {\n          return <li key={index} >{item}</li>\n        })\n      }\n    </ul>\n  );\n}\nReactDOM.render(\n  <App key=\"app\" />,\n  document.getElementById('root')\n);\n```\n- 执行 npx babel --watch src --out-dir . --presets react-app/prod\n\n\n经过 babel 编译之后的代码为\n\n```js\nfunction App() {\n  var arr = [\"zhangsan\", \"lisi\", \"wangwu\"];\n  return React.createElement(\n    \"ul\",\n    null,\n    arr.map(function (item, index) {\n      return React.createElement(\n        \"li\",\n        { key: index },\n        item\n      );\n    })\n  );\n}\nconsole.log(React.createElement(App));\nReactDOM.render(React.createElement(App, null), document.getElementById('root'));\n```\n\n上面编译完成的代码，可以看到 jsx 只是为 `React.createElement(component, props, ...children)` 方法提供的语法糖，实际上和直接写 `React.createElement（）` 等价，只是 babel 帮助我们完成了这个转换的过程\n\n*`注意 babel 在编译时会判断 jsx 中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，createElement 的第一个变量被编译为字符串，当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象；`*\n\n### createElement<hr/>\n\n在进行编译的时候 jsx 主要调用了 React.createElement 函数，那么接下来我们看看这个函数的主要作用（注意本文主要依托于源码 v16.9.0 版本)， 定义在 `react/packages/react/src/React.js` 中\n\n```js\n// ...\nimport {\n  createElement,\n  createFactory,\n  cloneElement,\n  isValidElement,\n  jsx,\n} from './ReactElement';\n// ...\n```\n\n找到 `react/packages/react/src/ReactElement.js` 文件中定义的 ReactElement 方法\n\n```js\n\n// ...\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  // ...\n  return element;\n};\n\nexport function createElement(type, config, children) {\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n   // 1. 处理 props\n  if (config != null) {\n    // ...\n  }\n  // 2. 获取并处理 children 节点\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // ...\n  } else if (childrenLength > 1) {\n    // ...\n  }\n  // 3. 处理默认 props\n  if (type && type.defaultProps) {\n    // ...\n  }\n\n  // ...\n  // 4. 返回 ReactElement 对象\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n```\n可以看到 createElement 主要的作用很简单就是将 props 和子元素进行处理之后返回一个 ReactElement 对象，下面我们分析上面三个步骤\n\n> 1.处理 props\n\n```js\n if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n```\n\n- 从 config 中取出ref，key\n- 从 config 中取出 self，source\n- 将除特殊属性的其他属性取出并赋值给 props\n\n\n> 2.获取并处理 children 节点\n\n```js\nconst childrenLength = arguments.length - 2;\nif (childrenLength === 1) {\n  props.children = children;\n} else if (childrenLength > 1) {\n  const childArray = Array(childrenLength);\n  for (let i = 0; i < childrenLength; i++) {\n    childArray[i] = arguments[i + 2];\n  }\n  if (__DEV__) {\n    if (Object.freeze) {\n      Object.freeze(childArray);\n    }\n  }\n  props.children = childArray;\n}\n```\n\n- 获取第二个参数后面的所有参数\n- 如果只有一个子元素，直接赋值给 props.children\n- 如果有多个子元素，将子元素改变为数组赋值给 props.children\n\n> 3.处理默认 props\n\n```js\nif (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n```\n\n将组件的静态属性 defaultProps 赋值给定义的默认 props \n\n> 4.返回 ReactElement\n\n可以看到 ReactElement 函数将几个参数进行重新组合，最后返回组合的对象 element，那么这几个参数的是干什么的呢？\n\n- type：元素的类型，可以是字符串或者是函数\n- key：组件的唯一标识，用于Diff算法\n- ref：用于直接访问原生的 DOM\n- props：组件通信的 props\n- owner：维护在构建虚拟DOM过程中，随时会变动的变量的临时保存位置所在，是识别自定义组件的关键\n- $$typeof： 一个 Symbol 类型的变量，防止XSS\n\n$$typeof 在 ReactElement 中被赋值为 `REACT_ELEMENT_TYPE`，定义在 `react/packages/shared/ReactSymbols.js`\n\n```js\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\n```\n\n可以看到上面判断，如果当前环境支持 Symbol， 那么就是用 Symbol.for 来进行组件的标示，否则 $$typeof 被赋值为 0xeac7。至于为什么 React 开发者给出了答案：0xeac7看起来有点像 React 😄😄😄 （如果不熟悉 Symbol.for，请参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for\">MDN</a>。）\n当 React 渲染时会把没有 $$typeof 标识的以及规则校验不通过的组件过滤掉，这样就知道了 React 组件是否是有效的\n\n```js\nReactElement.isValidElement = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n};\n```\n\n### 小结<hr>\n\n通过上述分析我们知道了 React.createElement 实际上返回的是一个特定格式的对象，这个对象大致如下\n\n```js\n{\n  $$typeof: Symbol(react.element)\n  key: null\n  props: {}\n  ref: null\n  type: ƒ App()\n  _owner: null\n  _store: {validated: false}\n  _self: null\n  _source: null\n  __proto__: Object\n}\n```\n\n## React.Children 原理\n\n在 createElement 方法中执行了 props.children，那它到底在那进行处理的呢？下面我们来介绍 React.Children 方法，定义在`react/packages/react/src/React.js`\n\n```js\n// ...\nimport {forEach, map, count, toArray, only} from './ReactChildren';\n\nconst React = {\n  Children: {\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  }\n  // ...\n};\n// ...\n```\n### 原理流程图<hr>\n\nReact.Children.map 调度的时候创建 children 节点防⽌子节点内存抖动，由于代码量比较大所以我们来看一下流程图\n\n<img src=\"/images/react-jsx-children.png\">\n\n\n### map <hr>\n\n来看一下简化后的 map 代码\n\n```js\n\n// ...\n/**\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n// ...\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n// ...\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n```\n\n### contextPool <hr>\n\n从上面的流程图能够看出调用过程和函数的作用，那么 ContextPool 的作用是什么？那么我们来看一下 getPooledTraverseContext 和 releaseTraverseContext 方法\n\n```js\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\n// 获取 contextPool \n// 实际上维护了一个 size 为 10 的缓冲池\n// 如果 contextPool 中有对象, 则 pop 出一个进行使用. 如果 contextPool 为空, 则 return 一个新的对象\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    // 复用对象\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    // 第一次获取 contextPool 中的对象\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n// traverseContext 复用之后，进行清空操作\n// 这里面有一个判断，如果 traverseContextPool 小于 10，就将 traverseContext push 到 traverseContextPool 中，进行对象的复用\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n```\n\n上面提到过 React.Children.map 调度的时候创建 children 节点，防⽌子节点内存抖动。\n因为每次构建新对象的时候都会复用 contextPool。会直接从 contextPool 里获取第一个对象，也就是 traverseContextPool.pop()，进行重新进行赋值。\n当使用完之后调用 releaseTraverseContext 再清空这个对象，最后 push traverseContextPool（contextPool）对象中，以供下次使用。这样就完成了对内存的重复使用，防止节点内存抖动。\n如果在每次构建节点的时候都重新构建对象，那么用完之后会被系统垃圾回收，这样对于内存来讲就是反复分配，释放的过程，会造成内存抖动。\n\n\n### 小结 <hr>\n\n至此, React.Children.map 就分析完了，其实 mapChildren 就是调用了 mapIntoWithKeyPrefixInternal 通过这个函数执行\n\n```js\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  // 将 func（mapFunction） 处理函数和 上下文（mapContext）封装成一个对象 traverseContext \n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  // 深度遍历子元素, 并调用处理函数\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  // 释放 traverseContext 对象\n  releaseTraverseContext(traverseContext);\n}\n```\n\n## 相关链接\n<a href=\"http://www.que01.top/2019/06/28/react-ReactCurrentOwner/\">React ReactCurrentOwner</a>\n<a href=\"http://js.walfud.com/React.Children.xxx%20%E7%9A%84%E4%BD%9C%E7%94%A8/\">React.Children.xxx 的作用</a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/react/library-react-jsx.md","raw":"---\ntitle: React 原理之 JSX 转换\ndate: 2019-10-01 18:06:25\ntop: true\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- react\ncategories:\n- react\n---\n\n## JXS 转换\n\n在我们写 react 组件的时候都会去写 jsx，那么 jsx 在 react 内部到底是怎么进行转换编译的呢？\n\n### babel 转换<hr>\n\n在进行转换编译之前，我们先来配置环境。这样方便我们查看转换后的代码。当然我们也使用 babel 去编译，但这里只是简单的说明 jsx 转换，所以不去配置 .babelrc 或者其他配置方式。\n\n执行下面步骤\n\n- 创建并进入文件夹\n- 在终端中执行 npm init -y \n- 在终端中执行 npm install babel-cli@6 babel-preset-react-app@3\n- 创建 demo.html,并写入\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n  <script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script>\n  <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script>\n</head>\n\n<body>\n  <div id=\"root\"></div>\n  <script src=\"demo.js\"></script>\n</body>\n\n</html>\n```\n\n- 创建 src 文件夹，在 src 文件中创建 demo.jsx，并写入\n\n```js\nfunction App() {\n  let arr = [\"zhangsan\", \"lisi\", \"wangwu\"]\n  return (\n    <ul>\n      {\n        arr.map((item, index) => {\n          return <li key={index} >{item}</li>\n        })\n      }\n    </ul>\n  );\n}\nReactDOM.render(\n  <App key=\"app\" />,\n  document.getElementById('root')\n);\n```\n- 执行 npx babel --watch src --out-dir . --presets react-app/prod\n\n\n经过 babel 编译之后的代码为\n\n```js\nfunction App() {\n  var arr = [\"zhangsan\", \"lisi\", \"wangwu\"];\n  return React.createElement(\n    \"ul\",\n    null,\n    arr.map(function (item, index) {\n      return React.createElement(\n        \"li\",\n        { key: index },\n        item\n      );\n    })\n  );\n}\nconsole.log(React.createElement(App));\nReactDOM.render(React.createElement(App, null), document.getElementById('root'));\n```\n\n上面编译完成的代码，可以看到 jsx 只是为 `React.createElement(component, props, ...children)` 方法提供的语法糖，实际上和直接写 `React.createElement（）` 等价，只是 babel 帮助我们完成了这个转换的过程\n\n*`注意 babel 在编译时会判断 jsx 中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，createElement 的第一个变量被编译为字符串，当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象；`*\n\n### createElement<hr/>\n\n在进行编译的时候 jsx 主要调用了 React.createElement 函数，那么接下来我们看看这个函数的主要作用（注意本文主要依托于源码 v16.9.0 版本)， 定义在 `react/packages/react/src/React.js` 中\n\n```js\n// ...\nimport {\n  createElement,\n  createFactory,\n  cloneElement,\n  isValidElement,\n  jsx,\n} from './ReactElement';\n// ...\n```\n\n找到 `react/packages/react/src/ReactElement.js` 文件中定义的 ReactElement 方法\n\n```js\n\n// ...\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  // ...\n  return element;\n};\n\nexport function createElement(type, config, children) {\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n   // 1. 处理 props\n  if (config != null) {\n    // ...\n  }\n  // 2. 获取并处理 children 节点\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // ...\n  } else if (childrenLength > 1) {\n    // ...\n  }\n  // 3. 处理默认 props\n  if (type && type.defaultProps) {\n    // ...\n  }\n\n  // ...\n  // 4. 返回 ReactElement 对象\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n```\n可以看到 createElement 主要的作用很简单就是将 props 和子元素进行处理之后返回一个 ReactElement 对象，下面我们分析上面三个步骤\n\n> 1.处理 props\n\n```js\n if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n```\n\n- 从 config 中取出ref，key\n- 从 config 中取出 self，source\n- 将除特殊属性的其他属性取出并赋值给 props\n\n\n> 2.获取并处理 children 节点\n\n```js\nconst childrenLength = arguments.length - 2;\nif (childrenLength === 1) {\n  props.children = children;\n} else if (childrenLength > 1) {\n  const childArray = Array(childrenLength);\n  for (let i = 0; i < childrenLength; i++) {\n    childArray[i] = arguments[i + 2];\n  }\n  if (__DEV__) {\n    if (Object.freeze) {\n      Object.freeze(childArray);\n    }\n  }\n  props.children = childArray;\n}\n```\n\n- 获取第二个参数后面的所有参数\n- 如果只有一个子元素，直接赋值给 props.children\n- 如果有多个子元素，将子元素改变为数组赋值给 props.children\n\n> 3.处理默认 props\n\n```js\nif (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n```\n\n将组件的静态属性 defaultProps 赋值给定义的默认 props \n\n> 4.返回 ReactElement\n\n可以看到 ReactElement 函数将几个参数进行重新组合，最后返回组合的对象 element，那么这几个参数的是干什么的呢？\n\n- type：元素的类型，可以是字符串或者是函数\n- key：组件的唯一标识，用于Diff算法\n- ref：用于直接访问原生的 DOM\n- props：组件通信的 props\n- owner：维护在构建虚拟DOM过程中，随时会变动的变量的临时保存位置所在，是识别自定义组件的关键\n- $$typeof： 一个 Symbol 类型的变量，防止XSS\n\n$$typeof 在 ReactElement 中被赋值为 `REACT_ELEMENT_TYPE`，定义在 `react/packages/shared/ReactSymbols.js`\n\n```js\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\n```\n\n可以看到上面判断，如果当前环境支持 Symbol， 那么就是用 Symbol.for 来进行组件的标示，否则 $$typeof 被赋值为 0xeac7。至于为什么 React 开发者给出了答案：0xeac7看起来有点像 React 😄😄😄 （如果不熟悉 Symbol.for，请参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for\">MDN</a>。）\n当 React 渲染时会把没有 $$typeof 标识的以及规则校验不通过的组件过滤掉，这样就知道了 React 组件是否是有效的\n\n```js\nReactElement.isValidElement = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n};\n```\n\n### 小结<hr>\n\n通过上述分析我们知道了 React.createElement 实际上返回的是一个特定格式的对象，这个对象大致如下\n\n```js\n{\n  $$typeof: Symbol(react.element)\n  key: null\n  props: {}\n  ref: null\n  type: ƒ App()\n  _owner: null\n  _store: {validated: false}\n  _self: null\n  _source: null\n  __proto__: Object\n}\n```\n\n## React.Children 原理\n\n在 createElement 方法中执行了 props.children，那它到底在那进行处理的呢？下面我们来介绍 React.Children 方法，定义在`react/packages/react/src/React.js`\n\n```js\n// ...\nimport {forEach, map, count, toArray, only} from './ReactChildren';\n\nconst React = {\n  Children: {\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  }\n  // ...\n};\n// ...\n```\n### 原理流程图<hr>\n\nReact.Children.map 调度的时候创建 children 节点防⽌子节点内存抖动，由于代码量比较大所以我们来看一下流程图\n\n<img src=\"/images/react-jsx-children.png\">\n\n\n### map <hr>\n\n来看一下简化后的 map 代码\n\n```js\n\n// ...\n/**\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n// ...\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n// ...\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n```\n\n### contextPool <hr>\n\n从上面的流程图能够看出调用过程和函数的作用，那么 ContextPool 的作用是什么？那么我们来看一下 getPooledTraverseContext 和 releaseTraverseContext 方法\n\n```js\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\n// 获取 contextPool \n// 实际上维护了一个 size 为 10 的缓冲池\n// 如果 contextPool 中有对象, 则 pop 出一个进行使用. 如果 contextPool 为空, 则 return 一个新的对象\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    // 复用对象\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    // 第一次获取 contextPool 中的对象\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n// traverseContext 复用之后，进行清空操作\n// 这里面有一个判断，如果 traverseContextPool 小于 10，就将 traverseContext push 到 traverseContextPool 中，进行对象的复用\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n```\n\n上面提到过 React.Children.map 调度的时候创建 children 节点，防⽌子节点内存抖动。\n因为每次构建新对象的时候都会复用 contextPool。会直接从 contextPool 里获取第一个对象，也就是 traverseContextPool.pop()，进行重新进行赋值。\n当使用完之后调用 releaseTraverseContext 再清空这个对象，最后 push traverseContextPool（contextPool）对象中，以供下次使用。这样就完成了对内存的重复使用，防止节点内存抖动。\n如果在每次构建节点的时候都重新构建对象，那么用完之后会被系统垃圾回收，这样对于内存来讲就是反复分配，释放的过程，会造成内存抖动。\n\n\n### 小结 <hr>\n\n至此, React.Children.map 就分析完了，其实 mapChildren 就是调用了 mapIntoWithKeyPrefixInternal 通过这个函数执行\n\n```js\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  // 将 func（mapFunction） 处理函数和 上下文（mapContext）封装成一个对象 traverseContext \n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  // 深度遍历子元素, 并调用处理函数\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  // 释放 traverseContext 对象\n  releaseTraverseContext(traverseContext);\n}\n```\n\n## 相关链接\n<a href=\"http://www.que01.top/2019/06/28/react-ReactCurrentOwner/\">React ReactCurrentOwner</a>\n<a href=\"http://js.walfud.com/React.Children.xxx%20%E7%9A%84%E4%BD%9C%E7%94%A8/\">React.Children.xxx 的作用</a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"react/library-react-jsx","published":1,"updated":"2019-10-15T01:29:42.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owb008rb0u6p1vqlgh5","content":"<h2 id=\"JXS-转换\"><a href=\"#JXS-转换\" class=\"headerlink\" title=\"JXS 转换\"></a>JXS 转换</h2><p>在我们写 react 组件的时候都会去写 jsx，那么 jsx 在 react 内部到底是怎么进行转换编译的呢？</p>\n<h3 id=\"babel-转换\"><a href=\"#babel-转换\" class=\"headerlink\" title=\"babel 转换\"></a>babel 转换<hr></h3><p>在进行转换编译之前，我们先来配置环境。这样方便我们查看转换后的代码。当然我们也使用 babel 去编译，但这里只是简单的说明 jsx 转换，所以不去配置 .babelrc 或者其他配置方式。</p>\n<p>执行下面步骤</p>\n<ul>\n<li>创建并进入文件夹</li>\n<li>在终端中执行 npm init -y </li>\n<li>在终端中执行 npm install babel-cli@6 babel-preset-react-app@3</li>\n<li>创建 demo.html,并写入</li>\n</ul>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>width<span class=\"token punctuation\">=</span>device-width, initial-scale<span class=\"token punctuation\">=</span>1.0<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">http-equiv</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>X-UA-Compatible<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>ie<span class=\"token punctuation\">=</span>edge<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>Document<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/react@16/umd/react.development.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">crossorigin</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/react-dom@16/umd/react-dom.development.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">crossorigin</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>root<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>demo.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>创建 src 文件夹，在 src 文件中创建 demo.jsx，并写入</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"zhangsan\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"lisi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>\n        arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>index<span class=\"token punctuation\">}</span> <span class=\"token operator\">></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>App key<span class=\"token operator\">=</span><span class=\"token string\">\"app\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>执行 npx babel –watch src –out-dir . –presets react-app/prod</li>\n</ul>\n<p>经过 babel 编译之后的代码为</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"zhangsan\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"lisi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"ul\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"li\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> key<span class=\"token punctuation\">:</span> index <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        item\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>App<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>App<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面编译完成的代码，可以看到 jsx 只是为 <code>React.createElement(component, props, ...children)</code> 方法提供的语法糖，实际上和直接写 <code>React.createElement（）</code> 等价，只是 babel 帮助我们完成了这个转换的过程</p>\n<p><em><code>注意 babel 在编译时会判断 jsx 中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，createElement 的第一个变量被编译为字符串，当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象；</code></em></p>\n<h3 id=\"createElement\"><a href=\"#createElement\" class=\"headerlink\" title=\"createElement\"></a>createElement<hr></h3><p>在进行编译的时候 jsx 主要调用了 React.createElement 函数，那么接下来我们看看这个函数的主要作用（注意本文主要依托于源码 v16.9.0 版本)， 定义在 <code>react/packages/react/src/React.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>\n  createElement<span class=\"token punctuation\">,</span>\n  createFactory<span class=\"token punctuation\">,</span>\n  cloneElement<span class=\"token punctuation\">,</span>\n  isValidElement<span class=\"token punctuation\">,</span>\n  jsx<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./ReactElement'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>找到 <code>react/packages/react/src/ReactElement.js</code> 文件中定义的 ReactElement 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">const</span> ReactElement <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> owner<span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// This tag allows us to uniquely identify this as a React Element</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span> REACT_ELEMENT_TYPE<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Built-in properties that belong on the element</span>\n    type<span class=\"token punctuation\">:</span> type<span class=\"token punctuation\">,</span>\n    key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">,</span>\n    ref<span class=\"token punctuation\">:</span> ref<span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">:</span> props<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Record the component responsible for creating this element.</span>\n    _owner<span class=\"token punctuation\">:</span> owner<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">let</span> propName<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// Reserved names are extracted</span>\n  <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> key <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> ref <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> source <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token comment\" spellcheck=\"true\">// 1. 处理 props</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>config <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 2. 获取并处理 children 节点</span>\n  <span class=\"token keyword\">const</span> childrenLength <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childrenLength <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childrenLength <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 3. 处理默认 props</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;&amp;</span> type<span class=\"token punctuation\">.</span>defaultProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 4. 返回 ReactElement 对象</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">ReactElement</span><span class=\"token punctuation\">(</span>\n    type<span class=\"token punctuation\">,</span>\n    key<span class=\"token punctuation\">,</span>\n    ref<span class=\"token punctuation\">,</span>\n    self<span class=\"token punctuation\">,</span>\n    source<span class=\"token punctuation\">,</span>\n    ReactCurrentOwner<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到 createElement 主要的作用很简单就是将 props 和子元素进行处理之后返回一个 ReactElement 对象，下面我们分析上面三个步骤</p>\n<blockquote>\n<p>1.处理 props</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>config <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasValidRef</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ref <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasValidKey</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      key <span class=\"token operator\">=</span> <span class=\"token string\">''</span> <span class=\"token operator\">+</span> config<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    self <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>__self <span class=\"token operator\">===</span> undefined <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> config<span class=\"token punctuation\">.</span>__self<span class=\"token punctuation\">;</span>\n    source <span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>__source <span class=\"token operator\">===</span> undefined <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> config<span class=\"token punctuation\">.</span>__source<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Remaining properties are added to a new props object</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>propName <span class=\"token keyword\">in</span> config<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n        hasOwnProperty<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">,</span> propName<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token operator\">!</span>RESERVED_PROPS<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>propName<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        props<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> config<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>从 config 中取出ref，key</li>\n<li>从 config 中取出 self，source</li>\n<li>将除特殊属性的其他属性取出并赋值给 props</li>\n</ul>\n<blockquote>\n<p>2.获取并处理 children 节点</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> childrenLength <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childrenLength <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  props<span class=\"token punctuation\">.</span>children <span class=\"token operator\">=</span> children<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childrenLength <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> childArray <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span>childrenLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> childrenLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    childArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span>freeze<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Object<span class=\"token punctuation\">.</span><span class=\"token function\">freeze</span><span class=\"token punctuation\">(</span>childArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  props<span class=\"token punctuation\">.</span>children <span class=\"token operator\">=</span> childArray<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>获取第二个参数后面的所有参数</li>\n<li>如果只有一个子元素，直接赋值给 props.children</li>\n<li>如果有多个子元素，将子元素改变为数组赋值给 props.children</li>\n</ul>\n<blockquote>\n<p>3.处理默认 props</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">&amp;&amp;</span> type<span class=\"token punctuation\">.</span>defaultProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> defaultProps <span class=\"token operator\">=</span> type<span class=\"token punctuation\">.</span>defaultProps<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>propName <span class=\"token keyword\">in</span> defaultProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        props<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> defaultProps<span class=\"token punctuation\">[</span>propName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将组件的静态属性 defaultProps 赋值给定义的默认 props </p>\n<blockquote>\n<p>4.返回 ReactElement</p>\n</blockquote>\n<p>可以看到 ReactElement 函数将几个参数进行重新组合，最后返回组合的对象 element，那么这几个参数的是干什么的呢？</p>\n<ul>\n<li>type：元素的类型，可以是字符串或者是函数</li>\n<li>key：组件的唯一标识，用于Diff算法</li>\n<li>ref：用于直接访问原生的 DOM</li>\n<li>props：组件通信的 props</li>\n<li>owner：维护在构建虚拟DOM过程中，随时会变动的变量的临时保存位置所在，是识别自定义组件的关键</li>\n<li>$$typeof： 一个 Symbol 类型的变量，防止XSS</li>\n</ul>\n<p>$$typeof 在 ReactElement 中被赋值为 <code>REACT_ELEMENT_TYPE</code>，定义在 <code>react/packages/shared/ReactSymbols.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> hasSymbol <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> Symbol <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">&amp;&amp;</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> REACT_ELEMENT_TYPE <span class=\"token operator\">=</span> hasSymbol\n  <span class=\"token operator\">?</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.element'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token number\">0xeac7</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到上面判断，如果当前环境支持 Symbol， 那么就是用 Symbol.for 来进行组件的标示，否则 $$typeof 被赋值为 0xeac7。至于为什么 React 开发者给出了答案：0xeac7看起来有点像 React 😄😄😄 （如果不熟悉 Symbol.for，请参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for\" target=\"_blank\" rel=\"noopener\">MDN</a>。）<br>当 React 渲染时会把没有 $$typeof 标识的以及规则校验不通过的组件过滤掉，这样就知道了 React 组件是否是有效的</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">ReactElement<span class=\"token punctuation\">.</span>isValidElement <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> object <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> object <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> object<span class=\"token punctuation\">.</span>$$<span class=\"token keyword\">typeof</span> <span class=\"token operator\">===</span> REACT_ELEMENT_TYPE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结<hr></h3><p>通过上述分析我们知道了 React.createElement 实际上返回的是一个特定格式的对象，这个对象大致如下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  $$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span>react<span class=\"token punctuation\">.</span>element<span class=\"token punctuation\">)</span>\n  key<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  props<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  ref<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  type<span class=\"token punctuation\">:</span> ƒ <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  _owner<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  _store<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>validated<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span>\n  _self<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  _source<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  __proto__<span class=\"token punctuation\">:</span> Object\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"React-Children-原理\"><a href=\"#React-Children-原理\" class=\"headerlink\" title=\"React.Children 原理\"></a>React.Children 原理</h2><p>在 createElement 方法中执行了 props.children，那它到底在那进行处理的呢？下面我们来介绍 React.Children 方法，定义在<code>react/packages/react/src/React.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>forEach<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">,</span> toArray<span class=\"token punctuation\">,</span> only<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./ReactChildren'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> React <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  Children<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    map<span class=\"token punctuation\">,</span>\n    forEach<span class=\"token punctuation\">,</span>\n    count<span class=\"token punctuation\">,</span>\n    toArray<span class=\"token punctuation\">,</span>\n    only<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"原理流程图\"><a href=\"#原理流程图\" class=\"headerlink\" title=\"原理流程图\"></a>原理流程图<hr></h3><p>React.Children.map 调度的时候创建 children 节点防⽌子节点内存抖动，由于代码量比较大所以我们来看一下流程图</p>\n<img src=\"/images/react-jsx-children.png\">\n\n\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map \"></a>map <hr></h3><p>来看一下简化后的 map 代码</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token comment\" spellcheck=\"true\">/**\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mapChildren</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>children <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> children<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">mapIntoWithKeyPrefixInternal</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">mapIntoWithKeyPrefixInternal</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> escapedPrefix <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    escapedPrefix <span class=\"token operator\">=</span> <span class=\"token function\">escapeUserProvidedKey</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> traverseContext <span class=\"token operator\">=</span> <span class=\"token function\">getPooledTraverseContext</span><span class=\"token punctuation\">(</span>\n    array<span class=\"token punctuation\">,</span>\n    escapedPrefix<span class=\"token punctuation\">,</span>\n    func<span class=\"token punctuation\">,</span>\n    context<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">traverseAllChildren</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> mapSingleChildIntoContext<span class=\"token punctuation\">,</span> traverseContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">releaseTraverseContext</span><span class=\"token punctuation\">(</span>traverseContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span>\n  forEachChildren <span class=\"token keyword\">as</span> forEach<span class=\"token punctuation\">,</span>\n  mapChildren <span class=\"token keyword\">as</span> map<span class=\"token punctuation\">,</span>\n  countChildren <span class=\"token keyword\">as</span> count<span class=\"token punctuation\">,</span>\n  onlyChild <span class=\"token keyword\">as</span> only<span class=\"token punctuation\">,</span>\n  toArray<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"contextPool\"><a href=\"#contextPool\" class=\"headerlink\" title=\"contextPool \"></a>contextPool <hr></h3><p>从上面的流程图能够看出调用过程和函数的作用，那么 ContextPool 的作用是什么？那么我们来看一下 getPooledTraverseContext 和 releaseTraverseContext 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> POOL_SIZE <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> traverseContextPool <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 获取 contextPool </span>\n<span class=\"token comment\" spellcheck=\"true\">// 实际上维护了一个 size 为 10 的缓冲池</span>\n<span class=\"token comment\" spellcheck=\"true\">// 如果 contextPool 中有对象, 则 pop 出一个进行使用. 如果 contextPool 为空, 则 return 一个新的对象</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPooledTraverseContext</span><span class=\"token punctuation\">(</span>\n  mapResult<span class=\"token punctuation\">,</span>\n  keyPrefix<span class=\"token punctuation\">,</span>\n  mapFunction<span class=\"token punctuation\">,</span>\n  mapContext<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>traverseContextPool<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 复用对象</span>\n    <span class=\"token keyword\">const</span> traverseContext <span class=\"token operator\">=</span> traverseContextPool<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    traverseContext<span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> mapResult<span class=\"token punctuation\">;</span>\n    traverseContext<span class=\"token punctuation\">.</span>keyPrefix <span class=\"token operator\">=</span> keyPrefix<span class=\"token punctuation\">;</span>\n    traverseContext<span class=\"token punctuation\">.</span>func <span class=\"token operator\">=</span> mapFunction<span class=\"token punctuation\">;</span>\n    traverseContext<span class=\"token punctuation\">.</span>context <span class=\"token operator\">=</span> mapContext<span class=\"token punctuation\">;</span>\n    traverseContext<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> traverseContext<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 第一次获取 contextPool 中的对象</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      result<span class=\"token punctuation\">:</span> mapResult<span class=\"token punctuation\">,</span>\n      keyPrefix<span class=\"token punctuation\">:</span> keyPrefix<span class=\"token punctuation\">,</span>\n      func<span class=\"token punctuation\">:</span> mapFunction<span class=\"token punctuation\">,</span>\n      context<span class=\"token punctuation\">:</span> mapContext<span class=\"token punctuation\">,</span>\n      count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// traverseContext 复用之后，进行清空操作</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这里面有一个判断，如果 traverseContextPool 小于 10，就将 traverseContext push 到 traverseContextPool 中，进行对象的复用</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">releaseTraverseContext</span><span class=\"token punctuation\">(</span>traverseContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  traverseContext<span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  traverseContext<span class=\"token punctuation\">.</span>keyPrefix <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  traverseContext<span class=\"token punctuation\">.</span>func <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  traverseContext<span class=\"token punctuation\">.</span>context <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  traverseContext<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>traverseContextPool<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> POOL_SIZE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    traverseContextPool<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>traverseContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面提到过 React.Children.map 调度的时候创建 children 节点，防⽌子节点内存抖动。<br>因为每次构建新对象的时候都会复用 contextPool。会直接从 contextPool 里获取第一个对象，也就是 traverseContextPool.pop()，进行重新进行赋值。<br>当使用完之后调用 releaseTraverseContext 再清空这个对象，最后 push traverseContextPool（contextPool）对象中，以供下次使用。这样就完成了对内存的重复使用，防止节点内存抖动。<br>如果在每次构建节点的时候都重新构建对象，那么用完之后会被系统垃圾回收，这样对于内存来讲就是反复分配，释放的过程，会造成内存抖动。</p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结 \"></a>小结 <hr></h3><p>至此, React.Children.map 就分析完了，其实 mapChildren 就是调用了 mapIntoWithKeyPrefixInternal 通过这个函数执行</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">function</span> <span class=\"token function\">mapIntoWithKeyPrefixInternal</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> escapedPrefix <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    escapedPrefix <span class=\"token operator\">=</span> <span class=\"token function\">escapeUserProvidedKey</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 将 func（mapFunction） 处理函数和 上下文（mapContext）封装成一个对象 traverseContext </span>\n  <span class=\"token keyword\">const</span> traverseContext <span class=\"token operator\">=</span> <span class=\"token function\">getPooledTraverseContext</span><span class=\"token punctuation\">(</span>\n    array<span class=\"token punctuation\">,</span>\n    escapedPrefix<span class=\"token punctuation\">,</span>\n    func<span class=\"token punctuation\">,</span>\n    context<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 深度遍历子元素, 并调用处理函数</span>\n  <span class=\"token function\">traverseAllChildren</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> mapSingleChildIntoContext<span class=\"token punctuation\">,</span> traverseContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 释放 traverseContext 对象</span>\n  <span class=\"token function\">releaseTraverseContext</span><span class=\"token punctuation\">(</span>traverseContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"http://www.que01.top/2019/06/28/react-ReactCurrentOwner/\" target=\"_blank\" rel=\"noopener\">React ReactCurrentOwner</a><br><a href=\"http://js.walfud.com/React.Children.xxx%20%E7%9A%84%E4%BD%9C%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">React.Children.xxx 的作用</a></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"JXS-转换\"><a href=\"#JXS-转换\" class=\"headerlink\" title=\"JXS 转换\"></a>JXS 转换</h2><p>在我们写 react 组件的时候都会去写 jsx，那么 jsx 在 react 内部到底是怎么进行转换编译的呢？</p>\n<h3 id=\"babel-转换\"><a href=\"#babel-转换\" class=\"headerlink\" title=\"babel 转换\"></a>babel 转换<hr></h3><p>在进行转换编译之前，我们先来配置环境。这样方便我们查看转换后的代码。当然我们也使用 babel 去编译，但这里只是简单的说明 jsx 转换，所以不去配置 .babelrc 或者其他配置方式。</p>\n<p>执行下面步骤</p>\n<ul>\n<li>创建并进入文件夹</li>\n<li>在终端中执行 npm init -y </li>\n<li>在终端中执行 npm install babel-cli@6 babel-preset-react-app@3</li>\n<li>创建 demo.html,并写入</li>\n</ul>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt;\n  &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;demo.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<ul>\n<li>创建 src 文件夹，在 src 文件中创建 demo.jsx，并写入</li>\n</ul>\n<pre><code class=\"js\">function App() {\n  let arr = [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;]\n  return (\n    &lt;ul&gt;\n      {\n        arr.map((item, index) =&gt; {\n          return &lt;li key={index} &gt;{item}&lt;/li&gt;\n        })\n      }\n    &lt;/ul&gt;\n  );\n}\nReactDOM.render(\n  &lt;App key=&quot;app&quot; /&gt;,\n  document.getElementById(&#39;root&#39;)\n);</code></pre>\n<ul>\n<li>执行 npx babel –watch src –out-dir . –presets react-app/prod</li>\n</ul>\n<p>经过 babel 编译之后的代码为</p>\n<pre><code class=\"js\">function App() {\n  var arr = [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;];\n  return React.createElement(\n    &quot;ul&quot;,\n    null,\n    arr.map(function (item, index) {\n      return React.createElement(\n        &quot;li&quot;,\n        { key: index },\n        item\n      );\n    })\n  );\n}\nconsole.log(React.createElement(App));\nReactDOM.render(React.createElement(App, null), document.getElementById(&#39;root&#39;));</code></pre>\n<p>上面编译完成的代码，可以看到 jsx 只是为 <code>React.createElement(component, props, ...children)</code> 方法提供的语法糖，实际上和直接写 <code>React.createElement（）</code> 等价，只是 babel 帮助我们完成了这个转换的过程</p>\n<p><em><code>注意 babel 在编译时会判断 jsx 中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，createElement 的第一个变量被编译为字符串，当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象；</code></em></p>\n<h3 id=\"createElement\"><a href=\"#createElement\" class=\"headerlink\" title=\"createElement\"></a>createElement<hr></h3><p>在进行编译的时候 jsx 主要调用了 React.createElement 函数，那么接下来我们看看这个函数的主要作用（注意本文主要依托于源码 v16.9.0 版本)， 定义在 <code>react/packages/react/src/React.js</code> 中</p>\n<pre><code class=\"js\">// ...\nimport {\n  createElement,\n  createFactory,\n  cloneElement,\n  isValidElement,\n  jsx,\n} from &#39;./ReactElement&#39;;\n// ...</code></pre>\n<p>找到 <code>react/packages/react/src/ReactElement.js</code> 文件中定义的 ReactElement 方法</p>\n<pre><code class=\"js\">\n// ...\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  // ...\n  return element;\n};\n\nexport function createElement(type, config, children) {\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n   // 1. 处理 props\n  if (config != null) {\n    // ...\n  }\n  // 2. 获取并处理 children 节点\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // ...\n  } else if (childrenLength &gt; 1) {\n    // ...\n  }\n  // 3. 处理默认 props\n  if (type &amp;&amp; type.defaultProps) {\n    // ...\n  }\n\n  // ...\n  // 4. 返回 ReactElement 对象\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n</code></pre>\n<p>可以看到 createElement 主要的作用很简单就是将 props 和子元素进行处理之后返回一个 ReactElement 对象，下面我们分析上面三个步骤</p>\n<blockquote>\n<p>1.处理 props</p>\n</blockquote>\n<pre><code class=\"js\"> if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = &#39;&#39; + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &amp;&amp;\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }</code></pre>\n<ul>\n<li>从 config 中取出ref，key</li>\n<li>从 config 中取出 self，source</li>\n<li>将除特殊属性的其他属性取出并赋值给 props</li>\n</ul>\n<blockquote>\n<p>2.获取并处理 children 节点</p>\n</blockquote>\n<pre><code class=\"js\">const childrenLength = arguments.length - 2;\nif (childrenLength === 1) {\n  props.children = children;\n} else if (childrenLength &gt; 1) {\n  const childArray = Array(childrenLength);\n  for (let i = 0; i &lt; childrenLength; i++) {\n    childArray[i] = arguments[i + 2];\n  }\n  if (__DEV__) {\n    if (Object.freeze) {\n      Object.freeze(childArray);\n    }\n  }\n  props.children = childArray;\n}</code></pre>\n<ul>\n<li>获取第二个参数后面的所有参数</li>\n<li>如果只有一个子元素，直接赋值给 props.children</li>\n<li>如果有多个子元素，将子元素改变为数组赋值给 props.children</li>\n</ul>\n<blockquote>\n<p>3.处理默认 props</p>\n</blockquote>\n<pre><code class=\"js\">if (type &amp;&amp; type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }</code></pre>\n<p>将组件的静态属性 defaultProps 赋值给定义的默认 props </p>\n<blockquote>\n<p>4.返回 ReactElement</p>\n</blockquote>\n<p>可以看到 ReactElement 函数将几个参数进行重新组合，最后返回组合的对象 element，那么这几个参数的是干什么的呢？</p>\n<ul>\n<li>type：元素的类型，可以是字符串或者是函数</li>\n<li>key：组件的唯一标识，用于Diff算法</li>\n<li>ref：用于直接访问原生的 DOM</li>\n<li>props：组件通信的 props</li>\n<li>owner：维护在构建虚拟DOM过程中，随时会变动的变量的临时保存位置所在，是识别自定义组件的关键</li>\n<li>$$typeof： 一个 Symbol 类型的变量，防止XSS</li>\n</ul>\n<p>$$typeof 在 ReactElement 中被赋值为 <code>REACT_ELEMENT_TYPE</code>，定义在 <code>react/packages/shared/ReactSymbols.js</code></p>\n<pre><code class=\"js\">const hasSymbol = typeof Symbol === &#39;function&#39; &amp;&amp; Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for(&#39;react.element&#39;)\n  : 0xeac7;</code></pre>\n<p>可以看到上面判断，如果当前环境支持 Symbol， 那么就是用 Symbol.for 来进行组件的标示，否则 $$typeof 被赋值为 0xeac7。至于为什么 React 开发者给出了答案：0xeac7看起来有点像 React 😄😄😄 （如果不熟悉 Symbol.for，请参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for\" target=\"_blank\" rel=\"noopener\">MDN</a>。）<br>当 React 渲染时会把没有 $$typeof 标识的以及规则校验不通过的组件过滤掉，这样就知道了 React 组件是否是有效的</p>\n<pre><code class=\"js\">ReactElement.isValidElement = function (object) {\n  return typeof object === &#39;object&#39; &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;\n};</code></pre>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结<hr></h3><p>通过上述分析我们知道了 React.createElement 实际上返回的是一个特定格式的对象，这个对象大致如下</p>\n<pre><code class=\"js\">{\n  $$typeof: Symbol(react.element)\n  key: null\n  props: {}\n  ref: null\n  type: ƒ App()\n  _owner: null\n  _store: {validated: false}\n  _self: null\n  _source: null\n  __proto__: Object\n}</code></pre>\n<h2 id=\"React-Children-原理\"><a href=\"#React-Children-原理\" class=\"headerlink\" title=\"React.Children 原理\"></a>React.Children 原理</h2><p>在 createElement 方法中执行了 props.children，那它到底在那进行处理的呢？下面我们来介绍 React.Children 方法，定义在<code>react/packages/react/src/React.js</code></p>\n<pre><code class=\"js\">// ...\nimport {forEach, map, count, toArray, only} from &#39;./ReactChildren&#39;;\n\nconst React = {\n  Children: {\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  }\n  // ...\n};\n// ...</code></pre>\n<h3 id=\"原理流程图\"><a href=\"#原理流程图\" class=\"headerlink\" title=\"原理流程图\"></a>原理流程图<hr></h3><p>React.Children.map 调度的时候创建 children 节点防⽌子节点内存抖动，由于代码量比较大所以我们来看一下流程图</p>\n<img src=\"/images/react-jsx-children.png\">\n\n\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map \"></a>map <hr></h3><p>来看一下简化后的 map 代码</p>\n<pre><code class=\"js\">\n// ...\n/**\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n// ...\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = &#39;&#39;;\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + &#39;/&#39;;\n  }\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n// ...\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};</code></pre>\n<h3 id=\"contextPool\"><a href=\"#contextPool\" class=\"headerlink\" title=\"contextPool \"></a>contextPool <hr></h3><p>从上面的流程图能够看出调用过程和函数的作用，那么 ContextPool 的作用是什么？那么我们来看一下 getPooledTraverseContext 和 releaseTraverseContext 方法</p>\n<pre><code class=\"js\">const POOL_SIZE = 10;\nconst traverseContextPool = [];\n// 获取 contextPool \n// 实际上维护了一个 size 为 10 的缓冲池\n// 如果 contextPool 中有对象, 则 pop 出一个进行使用. 如果 contextPool 为空, 则 return 一个新的对象\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    // 复用对象\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    // 第一次获取 contextPool 中的对象\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n// traverseContext 复用之后，进行清空操作\n// 这里面有一个判断，如果 traverseContextPool 小于 10，就将 traverseContext push 到 traverseContextPool 中，进行对象的复用\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length &lt; POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}</code></pre>\n<p>上面提到过 React.Children.map 调度的时候创建 children 节点，防⽌子节点内存抖动。<br>因为每次构建新对象的时候都会复用 contextPool。会直接从 contextPool 里获取第一个对象，也就是 traverseContextPool.pop()，进行重新进行赋值。<br>当使用完之后调用 releaseTraverseContext 再清空这个对象，最后 push traverseContextPool（contextPool）对象中，以供下次使用。这样就完成了对内存的重复使用，防止节点内存抖动。<br>如果在每次构建节点的时候都重新构建对象，那么用完之后会被系统垃圾回收，这样对于内存来讲就是反复分配，释放的过程，会造成内存抖动。</p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结 \"></a>小结 <hr></h3><p>至此, React.Children.map 就分析完了，其实 mapChildren 就是调用了 mapIntoWithKeyPrefixInternal 通过这个函数执行</p>\n<pre><code class=\"js\">\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = &#39;&#39;;\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + &#39;/&#39;;\n  }\n  // 将 func（mapFunction） 处理函数和 上下文（mapContext）封装成一个对象 traverseContext \n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  // 深度遍历子元素, 并调用处理函数\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  // 释放 traverseContext 对象\n  releaseTraverseContext(traverseContext);\n}</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"http://www.que01.top/2019/06/28/react-ReactCurrentOwner/\" target=\"_blank\" rel=\"noopener\">React ReactCurrentOwner</a><br><a href=\"http://js.walfud.com/React.Children.xxx%20%E7%9A%84%E4%BD%9C%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">React.Children.xxx 的作用</a></p>\n"},{"title":"React 之生命周期使用","date":"2019-10-02T05:20:25.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n和 Vue 一样 React 也会有对应的生命周期钩子函数，在相对应的钩子函数内，分别在不同时机处理相对应的逻辑，贴一张来至官网<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">生命周期图</a>，通过周期图让我们看看 react 的生命周期具体的含义。\n\n在 react 中，我们可以将生命周期分为四个阶段：\n\n- 初始化阶段\n- 挂载阶段\n- 更新阶段\n- 卸载阶段\n\n\n下面我们就根据不同阶段对应不同的钩子函数进行简单的介绍使用（本文主要依据版本16.9.0）\n\n### 初始化阶段（Initalization）<hr>\n\n挂载阶段实际上就是在做初始化的过程，当组件实例被创建并插入 DOM 中的时候，将依次调用以下生命周期函数\n\n```js\nclass Demo extends React.Component {\n  static propTypes = {}\n  static defaultProps = {}\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {return null}\n  render() {return null}\n  componentDidMount() {}\n}\n```\n\n下面对上面的代码进行拆分\n\n> static propTypes = {} 和 static defaultProps = {}\n\ngetDefaultProps 相当于 ES6中 static defaultProps = {}\ngetInitialState 相当于 constructor中 的 this.state = {}\n\n- static defaultProps = {} 是设置组件的默认 props\n- static propTypes = {} 组件的 props类型检测\n\n> constructor(props)\n\n在组件进行挂载之前，调用它的构造函数，可以做如下事情\n\n- 访问 props\n- 初始化 state 值\n- 绑定事件处理函数\n\n### 挂载阶段（Mounting）<hr>\n\n将虚拟 DOM 转化为真实 DOM 的过程\n\n> static getDerivedStateFromProps(props, state) 此钩子会执行 > 1 次\n\ngetDerivedStateFromProps 是在 render 之前被调用的，主要存在的作用是让组件的 props 变化时更新 state。\n在初始化挂载和后续更新都会被调用，它返回一个对象来更新状态，或者返回 null 来表明新属性不需要更新任何状态。\n\n使用此生命周期有几点需要注意的地方\n\n- 调用 this.setState() 通常不会触发此方法\n- 此方法会被调用多次\n- 必须有返回值，返回一个对象更新 state 或者返回 null\n\n\n> render() 此函数会执行 > 1 次，代表挂载（渲染）组件\n\nrender 函数是组件中唯一一个必须实现的方法，该函数在使用过程中有几点注意的地方\n\n- 此函数会被调用多次\n- 不能在函数中调用 this.setState() 方法\n- render() 函数应该为<a href=\"https://www.studyfe.cn/2019/07/15/javascript/functionalpurity/\">纯函数</a>\n- 必须有返回值，可以有<a href=\"https://zh-hans.reactjs.org/docs/react-component.html#render\">多种类型</a>。如果没有任何返回值，可以直接返回 null。\n\n\n> componentDidMount()，此钩子只执行一次，代表组件渲染完成\n\n此钩子函数并不是在 render 调用后立即调用，会在组件挂载后（插入 DOM 树中）立即调用。\n\n- 依赖于 DOM 节点的初始化应该放在这里\n- 如需通过网络请求获取数据，此处是实例化请求的好地方\n- 在此钩子函数中可以直接调用 setState()，但会触发额外的渲染，调用两次 render，导致性能问题。所以如果不依赖 DOM，做数据初始化最好是用constructor。当然如果使用 redux 作为数据存储就无关紧要了。因为 redux 作初始数据载入时，是可以不需透过 react 组件的生命周期方法。\n\n\n**挂载阶段即将废弃的钩子函数**\n\n```js\n/**\n * componentWillMount\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * 它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染\n * 此钩子做的事情完全可以在 constructor 中做到，所以这个函数没什么存在感\n */\ncomponentWillMount() {}\n```\n\n### 更新阶段（Updation）<hr>\n\n组件 state，props 变化引发的重新渲染的过程，将依次调用以下生命周期函数\n\n```js\nclass Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  static getDerivedStateFromProps(props,state) {return null }\n  shouldComponentUpdate (nextProps, nextState) {return true}\n  render() {return null}\n  getSnapshotBeforeUpdate(prevProps, prevState) {return null}\n  componentDidUpdate(prevProps, prevState, snapshot){}\n}\n```\n> getDerivedStateFromProps(props,state) 在组件挂载阶段有说明，在更新阶段用法一样，就不多做介绍了\n\n> shouldComponentUpdate (nextProps, nextState)\n\n此钩子首次渲染调用 render 的时候不会被触发，在更新阶段接收到新的 state 或者 props 的时候会在 render 方法前面被调用，使用此钩子应注意几个地方\n\n- 首次渲染或使用 forceUpdate() 时不会调用该方法\n- 默认行为是当 props 或 state 发生变化时，此钩子会在 render 之前被调用，返回默认 true\n- 如果要手动的返回 false，则会跳过更新阶段，不会执行 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()\n- 不建议在此钩子中进行深层次的比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。\n- 此钩子可以对 react 进行性能上的优化，因为因为父组件的重新更新，会造成它下面所有的子组件重新执行 render 方法，形成新的虚拟DOM，在进行比对决定是否重新渲染，影响性能。所以我们可以将 this.props 与 nextProps 以及 this.state 与nextState 进行比较，并返回 false 以告知 React 可以跳过更新。也可以考虑使用内置的 PureComponent 组件，来进行浅层比较，减少跳过更新的必要性。\n\n> render () 根据新的状态对象重新挂载(渲染)组件，在挂载阶段有说明，在更新阶段，就不多做介绍了\n\n> getSnapshotBeforeUpdate（prevProps, prevState）\n\n此钩子触发的时机是发生在组件更新阶段，在 render 重新渲染之后，组件 DOM 渲染之前，返回一个值，为 componentDidUpdate 的第三个参数；配合 componentDidUpdate， 可以覆盖 componentWillUpdate 的所有用法。\n\n- 此钩子可以处理异步加载资源和组件在发生更改之前从 DOM 中捕获一些信息（如滚动位置等）\n- 应返回 snapshot 的值（或 null）\n\n\n> componentDidUpdate（prevProps, prevState, snapshot）\n\n此钩子首次渲染调用 render 的时候不会被触发，在更新后被立即调用\n\n\n- 当组件更新后，可以在此处对 DOM 进行操作\n- 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求\n- 可以在此钩子中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，否则会造成死循环。它还会造成额外的重新渲染，影响性能。\n\n```js\ncomponentDidUpdate(prevProps) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n```\n\n**更新阶段即将废弃的钩子函数**\n\n```js\n/**\n * componentWillReceiveProps和 componentWillUpdate\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * componentWillReceiveProps 组件收到新的属性对象时调用，首次渲染不会触发\n * componentWillUpdate 组件更新之前调用的钩子函数\n */\ncomponentWillReceiveProps () {}\ncomponentWillUpdate () {}\n```\n### 卸载阶段（Unmounting）<hr>\n\n组件卸载之前调用此钩子\n\n```js\nclass Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  componentWillUnmount()\n}\n```\n\n> componentWillUnmount()\n\n此钩子会在组件卸载及销毁之前直接调用，在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等\n\n- 此钩子不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它\n\n\n### 其他钩子<hr>\n\n当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法\n\n\n```js\nclass Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  // 两个钩子用其中一个就可以\n  static getDerivedStateFromError(error) {}\n  componentDidCatch(error, info) {}\n}\n```\n\n- Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误\n- Error boundaries 仅捕获组件树中以下组件中的错误。但它本身的错误无法捕获。\n- 如果发生错误，你可以通过调用 setState 使用 componentDidCatch() 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 getDerivedStateFromError() 来处理降级渲染。\n\n> static getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。\n\n此钩子会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以降级 UI\n    return { hasError: true };\n  }\n  render() {\n    if (this.state.hasError) {\n      // 你可以渲染任何自定义的降级  UI\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children; \n  }\n}\n```\n\n> componentDidCatch(error, info) 会在 “提交” 阶段被调用，因此允许执行副作用。 用于记录错误之类的情况.\n\n此生命周期在后代组件抛出错误后被调用。 它接收两个参数：\n\n- error —— 抛出的错误。\n- info —— 带有 componentStack key 的对象。\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以显示降级 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // \"组件堆栈\" 例子:\n    //   in ComponentThatThrows (created by App)\n    //   in ErrorBoundary (created by App)\n    //   in div (created by App)\n    //   in App\n    logComponentStackToMyService(info.componentStack);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以渲染任何自定义的降级 UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n### 版本对比图<hr>\n\n<img src=\"/images/library-react-lifecycle01.png\">\n\n通过上面版本对比图我们能够很清晰的看到在 Mounting 和 Updation 阶段16版本增加了深蓝色部分。 \n- 16版本中 componentWillMount、componentWillReceiveProps、componmentWillUpdate 被标记为不安全的钩子，在17版本中被移除\n- 增加了 getDeriveStateFromProps、getSnapshotBeforeUpdate。\n- 增加了错误处理的钩子分别为 componentDidCatch、getDerivedStateFromError\n\n### 流程图<hr>\n\n<img src=\"/images/library-react-lifecycle02.png\">\n\n### 执行顺序<hr>\n\n用下面的例子进行测试\n\n父组件\n\n```js\nimport React, { Component } from 'react';\nimport './ToDo.css';\nimport ToDoItem from './components/ToDoItem';\n\nclass ToDo extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // this is where the data goes\n      list: [\n        {\n          'todo': 'clean the house'\n        },\n        {\n          'todo': 'buy milk'\n        }\n      ],\n      todo: ''\n    };\n  };\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('getDerivedStateFromProps父')\n    return null\n  }\n  componentDidMount() {\n    console.log('componentDidMount父')\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate父')\n    return true\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate父')\n    return null\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate父')\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount父')\n  }\n\n\n  createNewToDoItem = () => {\n    this.setState(({ list, todo }) => ({\n      list: [\n        ...list,\n        {\n          todo\n        }\n      ],\n      todo: ''\n    }));\n  }\n\n\n  handleKeyPress = e => {\n    if (e.target.value !== '') {\n      if (e.key === 'Enter') {\n        this.createNewToDoItem();\n      }\n    }\n  }\n\n  handleInput = e => {\n    this.setState({\n      todo: e.target.value\n    });\n  }\n\n\n  // this is now being emitted back to the parent from the child component\n  deleteItem = indexToDelete => {\n    this.setState(({ list }) => ({\n      list: list.filter((toDo, index) => index !== indexToDelete)\n    }));\n  }\n\n\n  render() {\n    console.log(\"render 父\")\n    return (\n      <div className=\"ToDo\">\n        <h1 className=\"ToDo-Header\">React To Do</h1>\n        <div className=\"ToDo-Container\">\n          <div className=\"ToDo-Content\">\n            <ToDoItem />\n            {this.state.list.map((item, key) => {\n              return <ToDoItem\n                key={key}\n                item={item.todo}\n                deleteItem={this.deleteItem.bind(this, key)}\n              />\n            }\n            )}\n\n          </div>\n          <input type=\"text\" value={this.state.todo} onChange={this.handleInput} onKeyPress={this.handleKeyPress} />\n          <div className=\"ToDo-Add\" onClick={this.createNewToDoItem}>+</div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default ToDo;\n```\n子组件\n\n```js\nmport React, { Component } from 'react';\nimport './ToDoItem.css';\n\nclass ToDoItem extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      item: this.props.item\n    }\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('getDerivedStateFromProps子')\n    return null\n  }\n  componentDidMount() {\n    console.log('componentDidMount子')\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate子')\n    return true\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate子')\n    return null\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate子')\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount子')\n  }\n\n  render() {\n    console.log(\"render 子\")\n    return (\n      <div className=\"ToDoItem\">\n        <p className=\"ToDoItem-Text\">{this.props.item}</p>\n        <div className=\"ToDoItem-Delete\" onClick={this.props.deleteItem}>-</div>\n      </div>\n    );\n  }\n}\n\nexport default ToDoItem;\n\n```\n\n使用父组件\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport ToDo from './ToDo';\n\nReactDOM.render(<ToDo />, document.getElementById('root'));\n```\n\n通过上面代码看的初始化执行顺序是\n\n<image src=\"/images/library-react-lifecycle03.jpg\" />\n\n可以看到先执行\n- 父组件的 getDerivedStateFromProps -> render\n- 子组件的 getDerivedStateFromProps -> render\n- 子组件的 componentDidMount\n- 父组件的 componentDidMount\n\n更新阶段执行的顺序是\n<image src=\"/images/library-react-lifecycle04.jpg\" />\n\n- 父组件的 getDerivedStateFromProps -> shouldComponentUpdate -> render\n- 子组件的 getDerivedStateFromProps -> shouldComponentUpdate -> render\n- 子组件 getSnapshotBeforeUpdate\n- 父组件 getSnapshotBeforeUpdate\n- 子组件 componentWillUnmount（因为删除了子组件）\n- 子组件的 componentDidUpdate\n- 父组件的 componentDidUpdate\n\n### 相关链接\n\n<a href=\"https://zh-hans.reactjs.org/docs/react-component.html\">组件的生命周期<a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/react/library-react-lifecycle.md","raw":"---\ntitle: React 之生命周期使用\ndate: 2019-10-02 13:20:25\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- react\ncategories:\n- react\n---\n\n\n和 Vue 一样 React 也会有对应的生命周期钩子函数，在相对应的钩子函数内，分别在不同时机处理相对应的逻辑，贴一张来至官网<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">生命周期图</a>，通过周期图让我们看看 react 的生命周期具体的含义。\n\n在 react 中，我们可以将生命周期分为四个阶段：\n\n- 初始化阶段\n- 挂载阶段\n- 更新阶段\n- 卸载阶段\n\n\n下面我们就根据不同阶段对应不同的钩子函数进行简单的介绍使用（本文主要依据版本16.9.0）\n\n### 初始化阶段（Initalization）<hr>\n\n挂载阶段实际上就是在做初始化的过程，当组件实例被创建并插入 DOM 中的时候，将依次调用以下生命周期函数\n\n```js\nclass Demo extends React.Component {\n  static propTypes = {}\n  static defaultProps = {}\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {return null}\n  render() {return null}\n  componentDidMount() {}\n}\n```\n\n下面对上面的代码进行拆分\n\n> static propTypes = {} 和 static defaultProps = {}\n\ngetDefaultProps 相当于 ES6中 static defaultProps = {}\ngetInitialState 相当于 constructor中 的 this.state = {}\n\n- static defaultProps = {} 是设置组件的默认 props\n- static propTypes = {} 组件的 props类型检测\n\n> constructor(props)\n\n在组件进行挂载之前，调用它的构造函数，可以做如下事情\n\n- 访问 props\n- 初始化 state 值\n- 绑定事件处理函数\n\n### 挂载阶段（Mounting）<hr>\n\n将虚拟 DOM 转化为真实 DOM 的过程\n\n> static getDerivedStateFromProps(props, state) 此钩子会执行 > 1 次\n\ngetDerivedStateFromProps 是在 render 之前被调用的，主要存在的作用是让组件的 props 变化时更新 state。\n在初始化挂载和后续更新都会被调用，它返回一个对象来更新状态，或者返回 null 来表明新属性不需要更新任何状态。\n\n使用此生命周期有几点需要注意的地方\n\n- 调用 this.setState() 通常不会触发此方法\n- 此方法会被调用多次\n- 必须有返回值，返回一个对象更新 state 或者返回 null\n\n\n> render() 此函数会执行 > 1 次，代表挂载（渲染）组件\n\nrender 函数是组件中唯一一个必须实现的方法，该函数在使用过程中有几点注意的地方\n\n- 此函数会被调用多次\n- 不能在函数中调用 this.setState() 方法\n- render() 函数应该为<a href=\"https://www.studyfe.cn/2019/07/15/javascript/functionalpurity/\">纯函数</a>\n- 必须有返回值，可以有<a href=\"https://zh-hans.reactjs.org/docs/react-component.html#render\">多种类型</a>。如果没有任何返回值，可以直接返回 null。\n\n\n> componentDidMount()，此钩子只执行一次，代表组件渲染完成\n\n此钩子函数并不是在 render 调用后立即调用，会在组件挂载后（插入 DOM 树中）立即调用。\n\n- 依赖于 DOM 节点的初始化应该放在这里\n- 如需通过网络请求获取数据，此处是实例化请求的好地方\n- 在此钩子函数中可以直接调用 setState()，但会触发额外的渲染，调用两次 render，导致性能问题。所以如果不依赖 DOM，做数据初始化最好是用constructor。当然如果使用 redux 作为数据存储就无关紧要了。因为 redux 作初始数据载入时，是可以不需透过 react 组件的生命周期方法。\n\n\n**挂载阶段即将废弃的钩子函数**\n\n```js\n/**\n * componentWillMount\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * 它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染\n * 此钩子做的事情完全可以在 constructor 中做到，所以这个函数没什么存在感\n */\ncomponentWillMount() {}\n```\n\n### 更新阶段（Updation）<hr>\n\n组件 state，props 变化引发的重新渲染的过程，将依次调用以下生命周期函数\n\n```js\nclass Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  static getDerivedStateFromProps(props,state) {return null }\n  shouldComponentUpdate (nextProps, nextState) {return true}\n  render() {return null}\n  getSnapshotBeforeUpdate(prevProps, prevState) {return null}\n  componentDidUpdate(prevProps, prevState, snapshot){}\n}\n```\n> getDerivedStateFromProps(props,state) 在组件挂载阶段有说明，在更新阶段用法一样，就不多做介绍了\n\n> shouldComponentUpdate (nextProps, nextState)\n\n此钩子首次渲染调用 render 的时候不会被触发，在更新阶段接收到新的 state 或者 props 的时候会在 render 方法前面被调用，使用此钩子应注意几个地方\n\n- 首次渲染或使用 forceUpdate() 时不会调用该方法\n- 默认行为是当 props 或 state 发生变化时，此钩子会在 render 之前被调用，返回默认 true\n- 如果要手动的返回 false，则会跳过更新阶段，不会执行 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()\n- 不建议在此钩子中进行深层次的比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。\n- 此钩子可以对 react 进行性能上的优化，因为因为父组件的重新更新，会造成它下面所有的子组件重新执行 render 方法，形成新的虚拟DOM，在进行比对决定是否重新渲染，影响性能。所以我们可以将 this.props 与 nextProps 以及 this.state 与nextState 进行比较，并返回 false 以告知 React 可以跳过更新。也可以考虑使用内置的 PureComponent 组件，来进行浅层比较，减少跳过更新的必要性。\n\n> render () 根据新的状态对象重新挂载(渲染)组件，在挂载阶段有说明，在更新阶段，就不多做介绍了\n\n> getSnapshotBeforeUpdate（prevProps, prevState）\n\n此钩子触发的时机是发生在组件更新阶段，在 render 重新渲染之后，组件 DOM 渲染之前，返回一个值，为 componentDidUpdate 的第三个参数；配合 componentDidUpdate， 可以覆盖 componentWillUpdate 的所有用法。\n\n- 此钩子可以处理异步加载资源和组件在发生更改之前从 DOM 中捕获一些信息（如滚动位置等）\n- 应返回 snapshot 的值（或 null）\n\n\n> componentDidUpdate（prevProps, prevState, snapshot）\n\n此钩子首次渲染调用 render 的时候不会被触发，在更新后被立即调用\n\n\n- 当组件更新后，可以在此处对 DOM 进行操作\n- 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求\n- 可以在此钩子中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，否则会造成死循环。它还会造成额外的重新渲染，影响性能。\n\n```js\ncomponentDidUpdate(prevProps) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n```\n\n**更新阶段即将废弃的钩子函数**\n\n```js\n/**\n * componentWillReceiveProps和 componentWillUpdate\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * componentWillReceiveProps 组件收到新的属性对象时调用，首次渲染不会触发\n * componentWillUpdate 组件更新之前调用的钩子函数\n */\ncomponentWillReceiveProps () {}\ncomponentWillUpdate () {}\n```\n### 卸载阶段（Unmounting）<hr>\n\n组件卸载之前调用此钩子\n\n```js\nclass Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  componentWillUnmount()\n}\n```\n\n> componentWillUnmount()\n\n此钩子会在组件卸载及销毁之前直接调用，在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等\n\n- 此钩子不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它\n\n\n### 其他钩子<hr>\n\n当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法\n\n\n```js\nclass Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  // 两个钩子用其中一个就可以\n  static getDerivedStateFromError(error) {}\n  componentDidCatch(error, info) {}\n}\n```\n\n- Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误\n- Error boundaries 仅捕获组件树中以下组件中的错误。但它本身的错误无法捕获。\n- 如果发生错误，你可以通过调用 setState 使用 componentDidCatch() 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 getDerivedStateFromError() 来处理降级渲染。\n\n> static getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。\n\n此钩子会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以降级 UI\n    return { hasError: true };\n  }\n  render() {\n    if (this.state.hasError) {\n      // 你可以渲染任何自定义的降级  UI\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children; \n  }\n}\n```\n\n> componentDidCatch(error, info) 会在 “提交” 阶段被调用，因此允许执行副作用。 用于记录错误之类的情况.\n\n此生命周期在后代组件抛出错误后被调用。 它接收两个参数：\n\n- error —— 抛出的错误。\n- info —— 带有 componentStack key 的对象。\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以显示降级 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // \"组件堆栈\" 例子:\n    //   in ComponentThatThrows (created by App)\n    //   in ErrorBoundary (created by App)\n    //   in div (created by App)\n    //   in App\n    logComponentStackToMyService(info.componentStack);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以渲染任何自定义的降级 UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n### 版本对比图<hr>\n\n<img src=\"/images/library-react-lifecycle01.png\">\n\n通过上面版本对比图我们能够很清晰的看到在 Mounting 和 Updation 阶段16版本增加了深蓝色部分。 \n- 16版本中 componentWillMount、componentWillReceiveProps、componmentWillUpdate 被标记为不安全的钩子，在17版本中被移除\n- 增加了 getDeriveStateFromProps、getSnapshotBeforeUpdate。\n- 增加了错误处理的钩子分别为 componentDidCatch、getDerivedStateFromError\n\n### 流程图<hr>\n\n<img src=\"/images/library-react-lifecycle02.png\">\n\n### 执行顺序<hr>\n\n用下面的例子进行测试\n\n父组件\n\n```js\nimport React, { Component } from 'react';\nimport './ToDo.css';\nimport ToDoItem from './components/ToDoItem';\n\nclass ToDo extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // this is where the data goes\n      list: [\n        {\n          'todo': 'clean the house'\n        },\n        {\n          'todo': 'buy milk'\n        }\n      ],\n      todo: ''\n    };\n  };\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('getDerivedStateFromProps父')\n    return null\n  }\n  componentDidMount() {\n    console.log('componentDidMount父')\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate父')\n    return true\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate父')\n    return null\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate父')\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount父')\n  }\n\n\n  createNewToDoItem = () => {\n    this.setState(({ list, todo }) => ({\n      list: [\n        ...list,\n        {\n          todo\n        }\n      ],\n      todo: ''\n    }));\n  }\n\n\n  handleKeyPress = e => {\n    if (e.target.value !== '') {\n      if (e.key === 'Enter') {\n        this.createNewToDoItem();\n      }\n    }\n  }\n\n  handleInput = e => {\n    this.setState({\n      todo: e.target.value\n    });\n  }\n\n\n  // this is now being emitted back to the parent from the child component\n  deleteItem = indexToDelete => {\n    this.setState(({ list }) => ({\n      list: list.filter((toDo, index) => index !== indexToDelete)\n    }));\n  }\n\n\n  render() {\n    console.log(\"render 父\")\n    return (\n      <div className=\"ToDo\">\n        <h1 className=\"ToDo-Header\">React To Do</h1>\n        <div className=\"ToDo-Container\">\n          <div className=\"ToDo-Content\">\n            <ToDoItem />\n            {this.state.list.map((item, key) => {\n              return <ToDoItem\n                key={key}\n                item={item.todo}\n                deleteItem={this.deleteItem.bind(this, key)}\n              />\n            }\n            )}\n\n          </div>\n          <input type=\"text\" value={this.state.todo} onChange={this.handleInput} onKeyPress={this.handleKeyPress} />\n          <div className=\"ToDo-Add\" onClick={this.createNewToDoItem}>+</div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default ToDo;\n```\n子组件\n\n```js\nmport React, { Component } from 'react';\nimport './ToDoItem.css';\n\nclass ToDoItem extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      item: this.props.item\n    }\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('getDerivedStateFromProps子')\n    return null\n  }\n  componentDidMount() {\n    console.log('componentDidMount子')\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate子')\n    return true\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate子')\n    return null\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('componentDidUpdate子')\n  }\n\n  componentWillUnmount() {\n    console.log('componentWillUnmount子')\n  }\n\n  render() {\n    console.log(\"render 子\")\n    return (\n      <div className=\"ToDoItem\">\n        <p className=\"ToDoItem-Text\">{this.props.item}</p>\n        <div className=\"ToDoItem-Delete\" onClick={this.props.deleteItem}>-</div>\n      </div>\n    );\n  }\n}\n\nexport default ToDoItem;\n\n```\n\n使用父组件\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport ToDo from './ToDo';\n\nReactDOM.render(<ToDo />, document.getElementById('root'));\n```\n\n通过上面代码看的初始化执行顺序是\n\n<image src=\"/images/library-react-lifecycle03.jpg\" />\n\n可以看到先执行\n- 父组件的 getDerivedStateFromProps -> render\n- 子组件的 getDerivedStateFromProps -> render\n- 子组件的 componentDidMount\n- 父组件的 componentDidMount\n\n更新阶段执行的顺序是\n<image src=\"/images/library-react-lifecycle04.jpg\" />\n\n- 父组件的 getDerivedStateFromProps -> shouldComponentUpdate -> render\n- 子组件的 getDerivedStateFromProps -> shouldComponentUpdate -> render\n- 子组件 getSnapshotBeforeUpdate\n- 父组件 getSnapshotBeforeUpdate\n- 子组件 componentWillUnmount（因为删除了子组件）\n- 子组件的 componentDidUpdate\n- 父组件的 componentDidUpdate\n\n### 相关链接\n\n<a href=\"https://zh-hans.reactjs.org/docs/react-component.html\">组件的生命周期<a>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"react/library-react-lifecycle","published":1,"updated":"2019-10-15T01:29:42.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owf008ub0u6mvsoi8j2","content":"<p>和 Vue 一样 React 也会有对应的生命周期钩子函数，在相对应的钩子函数内，分别在不同时机处理相对应的逻辑，贴一张来至官网<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"noopener\">生命周期图</a>，通过周期图让我们看看 react 的生命周期具体的含义。</p>\n<p>在 react 中，我们可以将生命周期分为四个阶段：</p>\n<ul>\n<li>初始化阶段</li>\n<li>挂载阶段</li>\n<li>更新阶段</li>\n<li>卸载阶段</li>\n</ul>\n<p>下面我们就根据不同阶段对应不同的钩子函数进行简单的介绍使用（本文主要依据版本16.9.0）</p>\n<h3 id=\"初始化阶段（Initalization）\"><a href=\"#初始化阶段（Initalization）\" class=\"headerlink\" title=\"初始化阶段（Initalization）\"></a>初始化阶段（Initalization）<hr></h3><p>挂载阶段实际上就是在做初始化的过程，当组件实例被创建并插入 DOM 中的时候，将依次调用以下生命周期函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> propTypes <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> defaultProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面对上面的代码进行拆分</p>\n<blockquote>\n<p>static propTypes = {} 和 static defaultProps = {}</p>\n</blockquote>\n<p>getDefaultProps 相当于 ES6中 static defaultProps = {}<br>getInitialState 相当于 constructor中 的 this.state = {}</p>\n<ul>\n<li>static defaultProps = {} 是设置组件的默认 props</li>\n<li>static propTypes = {} 组件的 props类型检测</li>\n</ul>\n<blockquote>\n<p>constructor(props)</p>\n</blockquote>\n<p>在组件进行挂载之前，调用它的构造函数，可以做如下事情</p>\n<ul>\n<li>访问 props</li>\n<li>初始化 state 值</li>\n<li>绑定事件处理函数</li>\n</ul>\n<h3 id=\"挂载阶段（Mounting）\"><a href=\"#挂载阶段（Mounting）\" class=\"headerlink\" title=\"挂载阶段（Mounting）\"></a>挂载阶段（Mounting）<hr></h3><p>将虚拟 DOM 转化为真实 DOM 的过程</p>\n<blockquote>\n<p>static getDerivedStateFromProps(props, state) 此钩子会执行 &gt; 1 次</p>\n</blockquote>\n<p>getDerivedStateFromProps 是在 render 之前被调用的，主要存在的作用是让组件的 props 变化时更新 state。<br>在初始化挂载和后续更新都会被调用，它返回一个对象来更新状态，或者返回 null 来表明新属性不需要更新任何状态。</p>\n<p>使用此生命周期有几点需要注意的地方</p>\n<ul>\n<li>调用 this.setState() 通常不会触发此方法</li>\n<li>此方法会被调用多次</li>\n<li>必须有返回值，返回一个对象更新 state 或者返回 null</li>\n</ul>\n<blockquote>\n<p>render() 此函数会执行 &gt; 1 次，代表挂载（渲染）组件</p>\n</blockquote>\n<p>render 函数是组件中唯一一个必须实现的方法，该函数在使用过程中有几点注意的地方</p>\n<ul>\n<li>此函数会被调用多次</li>\n<li>不能在函数中调用 this.setState() 方法</li>\n<li>render() 函数应该为<a href=\"https://www.studyfe.cn/2019/07/15/javascript/functionalpurity/\">纯函数</a></li>\n<li>必须有返回值，可以有<a href=\"https://zh-hans.reactjs.org/docs/react-component.html#render\" target=\"_blank\" rel=\"noopener\">多种类型</a>。如果没有任何返回值，可以直接返回 null。</li>\n</ul>\n<blockquote>\n<p>componentDidMount()，此钩子只执行一次，代表组件渲染完成</p>\n</blockquote>\n<p>此钩子函数并不是在 render 调用后立即调用，会在组件挂载后（插入 DOM 树中）立即调用。</p>\n<ul>\n<li>依赖于 DOM 节点的初始化应该放在这里</li>\n<li>如需通过网络请求获取数据，此处是实例化请求的好地方</li>\n<li>在此钩子函数中可以直接调用 setState()，但会触发额外的渲染，调用两次 render，导致性能问题。所以如果不依赖 DOM，做数据初始化最好是用constructor。当然如果使用 redux 作为数据存储就无关紧要了。因为 redux 作初始数据载入时，是可以不需透过 react 组件的生命周期方法。</li>\n</ul>\n<p><strong>挂载阶段即将废弃的钩子函数</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * componentWillMount\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * 它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染\n * 此钩子做的事情完全可以在 constructor 中做到，所以这个函数没什么存在感\n */</span>\n<span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"更新阶段（Updation）\"><a href=\"#更新阶段（Updation）\" class=\"headerlink\" title=\"更新阶段（Updation）\"></a>更新阶段（Updation）<hr></h3><p>组件 state，props 变化引发的重新渲染的过程，将依次调用以下生命周期函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">}</span>\n  shouldComponentUpdate <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">getSnapshotBeforeUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">,</span> snapshot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>getDerivedStateFromProps(props,state) 在组件挂载阶段有说明，在更新阶段用法一样，就不多做介绍了</p>\n</blockquote>\n<blockquote>\n<p>shouldComponentUpdate (nextProps, nextState)</p>\n</blockquote>\n<p>此钩子首次渲染调用 render 的时候不会被触发，在更新阶段接收到新的 state 或者 props 的时候会在 render 方法前面被调用，使用此钩子应注意几个地方</p>\n<ul>\n<li>首次渲染或使用 forceUpdate() 时不会调用该方法</li>\n<li>默认行为是当 props 或 state 发生变化时，此钩子会在 render 之前被调用，返回默认 true</li>\n<li>如果要手动的返回 false，则会跳过更新阶段，不会执行 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()</li>\n<li>不建议在此钩子中进行深层次的比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。</li>\n<li>此钩子可以对 react 进行性能上的优化，因为因为父组件的重新更新，会造成它下面所有的子组件重新执行 render 方法，形成新的虚拟DOM，在进行比对决定是否重新渲染，影响性能。所以我们可以将 this.props 与 nextProps 以及 this.state 与nextState 进行比较，并返回 false 以告知 React 可以跳过更新。也可以考虑使用内置的 PureComponent 组件，来进行浅层比较，减少跳过更新的必要性。</li>\n</ul>\n<blockquote>\n<p>render () 根据新的状态对象重新挂载(渲染)组件，在挂载阶段有说明，在更新阶段，就不多做介绍了</p>\n</blockquote>\n<blockquote>\n<p>getSnapshotBeforeUpdate（prevProps, prevState）</p>\n</blockquote>\n<p>此钩子触发的时机是发生在组件更新阶段，在 render 重新渲染之后，组件 DOM 渲染之前，返回一个值，为 componentDidUpdate 的第三个参数；配合 componentDidUpdate， 可以覆盖 componentWillUpdate 的所有用法。</p>\n<ul>\n<li>此钩子可以处理异步加载资源和组件在发生更改之前从 DOM 中捕获一些信息（如滚动位置等）</li>\n<li>应返回 snapshot 的值（或 null）</li>\n</ul>\n<blockquote>\n<p>componentDidUpdate（prevProps, prevState, snapshot）</p>\n</blockquote>\n<p>此钩子首次渲染调用 render 的时候不会被触发，在更新后被立即调用</p>\n<ul>\n<li>当组件更新后，可以在此处对 DOM 进行操作</li>\n<li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求</li>\n<li>可以在此钩子中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，否则会造成死循环。它还会造成额外的重新渲染，影响性能。</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 典型用法（不要忘记比较 props）：</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>userID <span class=\"token operator\">!==</span> prevProps<span class=\"token punctuation\">.</span>userID<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">fetchData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>userID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>更新阶段即将废弃的钩子函数</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * componentWillReceiveProps和 componentWillUpdate\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * componentWillReceiveProps 组件收到新的属性对象时调用，首次渲染不会触发\n * componentWillUpdate 组件更新之前调用的钩子函数\n */</span>\ncomponentWillReceiveProps <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\ncomponentWillUpdate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"卸载阶段（Unmounting）\"><a href=\"#卸载阶段（Unmounting）\" class=\"headerlink\" title=\"卸载阶段（Unmounting）\"></a>卸载阶段（Unmounting）<hr></h3><p>组件卸载之前调用此钩子</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>componentWillUnmount()</p>\n</blockquote>\n<p>此钩子会在组件卸载及销毁之前直接调用，在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等</p>\n<ul>\n<li>此钩子不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它</li>\n</ul>\n<h3 id=\"其他钩子\"><a href=\"#其他钩子\" class=\"headerlink\" title=\"其他钩子\"></a>其他钩子<hr></h3><p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 两个钩子用其中一个就可以</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误</li>\n<li>Error boundaries 仅捕获组件树中以下组件中的错误。但它本身的错误无法捕获。</li>\n<li>如果发生错误，你可以通过调用 setState 使用 componentDidCatch() 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 getDerivedStateFromError() 来处理降级渲染。</li>\n</ul>\n<blockquote>\n<p>static getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。</p>\n</blockquote>\n<p>此钩子会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorBoundary</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 更新 state 使下一次渲染可以降级 UI</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hasError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 你可以渲染任何自定义的降级  UI</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Something went wrong<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>componentDidCatch(error, info) 会在 “提交” 阶段被调用，因此允许执行副作用。 用于记录错误之类的情况.</p>\n</blockquote>\n<p>此生命周期在后代组件抛出错误后被调用。 它接收两个参数：</p>\n<ul>\n<li>error —— 抛出的错误。</li>\n<li>info —— 带有 componentStack key 的对象。</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorBoundary</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 更新 state 使下一次渲染可以显示降级 UI</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// \"组件堆栈\" 例子:</span>\n    <span class=\"token comment\" spellcheck=\"true\">//   in ComponentThatThrows (created by App)</span>\n    <span class=\"token comment\" spellcheck=\"true\">//   in ErrorBoundary (created by App)</span>\n    <span class=\"token comment\" spellcheck=\"true\">//   in div (created by App)</span>\n    <span class=\"token comment\" spellcheck=\"true\">//   in App</span>\n    <span class=\"token function\">logComponentStackToMyService</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">.</span>componentStack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hasError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 你可以渲染任何自定义的降级 UI</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Something went wrong<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"版本对比图\"><a href=\"#版本对比图\" class=\"headerlink\" title=\"版本对比图\"></a>版本对比图<hr></h3><img src=\"/images/library-react-lifecycle01.png\">\n\n<p>通过上面版本对比图我们能够很清晰的看到在 Mounting 和 Updation 阶段16版本增加了深蓝色部分。 </p>\n<ul>\n<li>16版本中 componentWillMount、componentWillReceiveProps、componmentWillUpdate 被标记为不安全的钩子，在17版本中被移除</li>\n<li>增加了 getDeriveStateFromProps、getSnapshotBeforeUpdate。</li>\n<li>增加了错误处理的钩子分别为 componentDidCatch、getDerivedStateFromError</li>\n</ul>\n<h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图<hr></h3><img src=\"/images/library-react-lifecycle02.png\">\n\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序<hr></h3><p>用下面的例子进行测试</p>\n<p>父组件</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./ToDo.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ToDoItem <span class=\"token keyword\">from</span> <span class=\"token string\">'./components/ToDoItem'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ToDo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// this is where the data goes</span>\n      list<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span>\n          <span class=\"token string\">'todo'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'clean the house'</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span>\n          <span class=\"token string\">'todo'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'buy milk'</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      todo<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'getDerivedStateFromProps父'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'componentDidMount父'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'shouldComponentUpdate父'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">getSnapshotBeforeUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'getSnapshotBeforeUpdate父'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">,</span> snapshot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'componentDidUpdate父'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'componentWillUnmount父'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  createNewToDoItem <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> list<span class=\"token punctuation\">,</span> todo <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      list<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token operator\">...</span>list<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span>\n          todo\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      todo<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  handleKeyPress <span class=\"token operator\">=</span> e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token operator\">!==</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'Enter'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">createNewToDoItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  handleInput <span class=\"token operator\">=</span> e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      todo<span class=\"token punctuation\">:</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">// this is now being emitted back to the parent from the child component</span>\n  deleteItem <span class=\"token operator\">=</span> indexToDelete <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> list <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      list<span class=\"token punctuation\">:</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>toDo<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> index <span class=\"token operator\">!==</span> indexToDelete<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"render 父\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDo\"</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>h1 className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDo-Header\"</span><span class=\"token operator\">></span>React To Do<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDo-Container\"</span><span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDo-Content\"</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>ToDoItem <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n            <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>ToDoItem\n                key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>key<span class=\"token punctuation\">}</span>\n                item<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>todo<span class=\"token punctuation\">}</span>\n                deleteItem<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deleteItem<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n              <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n\n          <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"text\"</span> value<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>todo<span class=\"token punctuation\">}</span> onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleInput<span class=\"token punctuation\">}</span> onKeyPress<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleKeyPress<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n          <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDo-Add\"</span> onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createNewToDoItem<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">+</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> ToDo<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>子组件</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">mport React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./ToDoItem.css'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ToDoItem</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      item<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>item\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'getDerivedStateFromProps子'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'componentDidMount子'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'shouldComponentUpdate子'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">getSnapshotBeforeUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'getSnapshotBeforeUpdate子'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> prevState<span class=\"token punctuation\">,</span> snapshot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'componentDidUpdate子'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'componentWillUnmount子'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"render 子\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDoItem\"</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>p className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDoItem-Text\"</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"ToDoItem-Delete\"</span> onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>deleteItem<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> ToDoItem<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用父组件</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./index.css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ToDo <span class=\"token keyword\">from</span> <span class=\"token string\">'./ToDo'</span><span class=\"token punctuation\">;</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>ToDo <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码看的初始化执行顺序是</p>\n<image src=\"/images/library-react-lifecycle03.jpg\">\n\n<p>可以看到先执行</p>\n<ul>\n<li>父组件的 getDerivedStateFromProps -&gt; render</li>\n<li>子组件的 getDerivedStateFromProps -&gt; render</li>\n<li>子组件的 componentDidMount</li>\n<li>父组件的 componentDidMount</li>\n</ul>\n<p>更新阶段执行的顺序是<br><image src=\"/images/library-react-lifecycle04.jpg\"></image></p>\n<ul>\n<li>父组件的 getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render</li>\n<li>子组件的 getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render</li>\n<li>子组件 getSnapshotBeforeUpdate</li>\n<li>父组件 getSnapshotBeforeUpdate</li>\n<li>子组件 componentWillUnmount（因为删除了子组件）</li>\n<li>子组件的 componentDidUpdate</li>\n<li>父组件的 componentDidUpdate</li>\n</ul>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><p><a href=\"https://zh-hans.reactjs.org/docs/react-component.html\" target=\"_blank\" rel=\"noopener\">组件的生命周期<a></a></a></p>\n</image>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>和 Vue 一样 React 也会有对应的生命周期钩子函数，在相对应的钩子函数内，分别在不同时机处理相对应的逻辑，贴一张来至官网<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"noopener\">生命周期图</a>，通过周期图让我们看看 react 的生命周期具体的含义。</p>\n<p>在 react 中，我们可以将生命周期分为四个阶段：</p>\n<ul>\n<li>初始化阶段</li>\n<li>挂载阶段</li>\n<li>更新阶段</li>\n<li>卸载阶段</li>\n</ul>\n<p>下面我们就根据不同阶段对应不同的钩子函数进行简单的介绍使用（本文主要依据版本16.9.0）</p>\n<h3 id=\"初始化阶段（Initalization）\"><a href=\"#初始化阶段（Initalization）\" class=\"headerlink\" title=\"初始化阶段（Initalization）\"></a>初始化阶段（Initalization）<hr></h3><p>挂载阶段实际上就是在做初始化的过程，当组件实例被创建并插入 DOM 中的时候，将依次调用以下生命周期函数</p>\n<pre><code class=\"js\">class Demo extends React.Component {\n  static propTypes = {}\n  static defaultProps = {}\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {return null}\n  render() {return null}\n  componentDidMount() {}\n}</code></pre>\n<p>下面对上面的代码进行拆分</p>\n<blockquote>\n<p>static propTypes = {} 和 static defaultProps = {}</p>\n</blockquote>\n<p>getDefaultProps 相当于 ES6中 static defaultProps = {}<br>getInitialState 相当于 constructor中 的 this.state = {}</p>\n<ul>\n<li>static defaultProps = {} 是设置组件的默认 props</li>\n<li>static propTypes = {} 组件的 props类型检测</li>\n</ul>\n<blockquote>\n<p>constructor(props)</p>\n</blockquote>\n<p>在组件进行挂载之前，调用它的构造函数，可以做如下事情</p>\n<ul>\n<li>访问 props</li>\n<li>初始化 state 值</li>\n<li>绑定事件处理函数</li>\n</ul>\n<h3 id=\"挂载阶段（Mounting）\"><a href=\"#挂载阶段（Mounting）\" class=\"headerlink\" title=\"挂载阶段（Mounting）\"></a>挂载阶段（Mounting）<hr></h3><p>将虚拟 DOM 转化为真实 DOM 的过程</p>\n<blockquote>\n<p>static getDerivedStateFromProps(props, state) 此钩子会执行 &gt; 1 次</p>\n</blockquote>\n<p>getDerivedStateFromProps 是在 render 之前被调用的，主要存在的作用是让组件的 props 变化时更新 state。<br>在初始化挂载和后续更新都会被调用，它返回一个对象来更新状态，或者返回 null 来表明新属性不需要更新任何状态。</p>\n<p>使用此生命周期有几点需要注意的地方</p>\n<ul>\n<li>调用 this.setState() 通常不会触发此方法</li>\n<li>此方法会被调用多次</li>\n<li>必须有返回值，返回一个对象更新 state 或者返回 null</li>\n</ul>\n<blockquote>\n<p>render() 此函数会执行 &gt; 1 次，代表挂载（渲染）组件</p>\n</blockquote>\n<p>render 函数是组件中唯一一个必须实现的方法，该函数在使用过程中有几点注意的地方</p>\n<ul>\n<li>此函数会被调用多次</li>\n<li>不能在函数中调用 this.setState() 方法</li>\n<li>render() 函数应该为<a href=\"https://www.studyfe.cn/2019/07/15/javascript/functionalpurity/\">纯函数</a></li>\n<li>必须有返回值，可以有<a href=\"https://zh-hans.reactjs.org/docs/react-component.html#render\" target=\"_blank\" rel=\"noopener\">多种类型</a>。如果没有任何返回值，可以直接返回 null。</li>\n</ul>\n<blockquote>\n<p>componentDidMount()，此钩子只执行一次，代表组件渲染完成</p>\n</blockquote>\n<p>此钩子函数并不是在 render 调用后立即调用，会在组件挂载后（插入 DOM 树中）立即调用。</p>\n<ul>\n<li>依赖于 DOM 节点的初始化应该放在这里</li>\n<li>如需通过网络请求获取数据，此处是实例化请求的好地方</li>\n<li>在此钩子函数中可以直接调用 setState()，但会触发额外的渲染，调用两次 render，导致性能问题。所以如果不依赖 DOM，做数据初始化最好是用constructor。当然如果使用 redux 作为数据存储就无关紧要了。因为 redux 作初始数据载入时，是可以不需透过 react 组件的生命周期方法。</li>\n</ul>\n<p><strong>挂载阶段即将废弃的钩子函数</strong></p>\n<pre><code class=\"js\">/**\n * componentWillMount\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * 它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染\n * 此钩子做的事情完全可以在 constructor 中做到，所以这个函数没什么存在感\n */\ncomponentWillMount() {}</code></pre>\n<h3 id=\"更新阶段（Updation）\"><a href=\"#更新阶段（Updation）\" class=\"headerlink\" title=\"更新阶段（Updation）\"></a>更新阶段（Updation）<hr></h3><p>组件 state，props 变化引发的重新渲染的过程，将依次调用以下生命周期函数</p>\n<pre><code class=\"js\">class Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  static getDerivedStateFromProps(props,state) {return null }\n  shouldComponentUpdate (nextProps, nextState) {return true}\n  render() {return null}\n  getSnapshotBeforeUpdate(prevProps, prevState) {return null}\n  componentDidUpdate(prevProps, prevState, snapshot){}\n}</code></pre>\n<blockquote>\n<p>getDerivedStateFromProps(props,state) 在组件挂载阶段有说明，在更新阶段用法一样，就不多做介绍了</p>\n</blockquote>\n<blockquote>\n<p>shouldComponentUpdate (nextProps, nextState)</p>\n</blockquote>\n<p>此钩子首次渲染调用 render 的时候不会被触发，在更新阶段接收到新的 state 或者 props 的时候会在 render 方法前面被调用，使用此钩子应注意几个地方</p>\n<ul>\n<li>首次渲染或使用 forceUpdate() 时不会调用该方法</li>\n<li>默认行为是当 props 或 state 发生变化时，此钩子会在 render 之前被调用，返回默认 true</li>\n<li>如果要手动的返回 false，则会跳过更新阶段，不会执行 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()</li>\n<li>不建议在此钩子中进行深层次的比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。</li>\n<li>此钩子可以对 react 进行性能上的优化，因为因为父组件的重新更新，会造成它下面所有的子组件重新执行 render 方法，形成新的虚拟DOM，在进行比对决定是否重新渲染，影响性能。所以我们可以将 this.props 与 nextProps 以及 this.state 与nextState 进行比较，并返回 false 以告知 React 可以跳过更新。也可以考虑使用内置的 PureComponent 组件，来进行浅层比较，减少跳过更新的必要性。</li>\n</ul>\n<blockquote>\n<p>render () 根据新的状态对象重新挂载(渲染)组件，在挂载阶段有说明，在更新阶段，就不多做介绍了</p>\n</blockquote>\n<blockquote>\n<p>getSnapshotBeforeUpdate（prevProps, prevState）</p>\n</blockquote>\n<p>此钩子触发的时机是发生在组件更新阶段，在 render 重新渲染之后，组件 DOM 渲染之前，返回一个值，为 componentDidUpdate 的第三个参数；配合 componentDidUpdate， 可以覆盖 componentWillUpdate 的所有用法。</p>\n<ul>\n<li>此钩子可以处理异步加载资源和组件在发生更改之前从 DOM 中捕获一些信息（如滚动位置等）</li>\n<li>应返回 snapshot 的值（或 null）</li>\n</ul>\n<blockquote>\n<p>componentDidUpdate（prevProps, prevState, snapshot）</p>\n</blockquote>\n<p>此钩子首次渲染调用 render 的时候不会被触发，在更新后被立即调用</p>\n<ul>\n<li>当组件更新后，可以在此处对 DOM 进行操作</li>\n<li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求</li>\n<li>可以在此钩子中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，否则会造成死循环。它还会造成额外的重新渲染，影响性能。</li>\n</ul>\n<pre><code class=\"js\">componentDidUpdate(prevProps) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}</code></pre>\n<p><strong>更新阶段即将废弃的钩子函数</strong></p>\n<pre><code class=\"js\">/**\n * componentWillReceiveProps和 componentWillUpdate\n * 从 15 更新到 16 后不建议使用，该名称将继续使用至 React 17\n * componentWillReceiveProps 组件收到新的属性对象时调用，首次渲染不会触发\n * componentWillUpdate 组件更新之前调用的钩子函数\n */\ncomponentWillReceiveProps () {}\ncomponentWillUpdate () {}</code></pre>\n<h3 id=\"卸载阶段（Unmounting）\"><a href=\"#卸载阶段（Unmounting）\" class=\"headerlink\" title=\"卸载阶段（Unmounting）\"></a>卸载阶段（Unmounting）<hr></h3><p>组件卸载之前调用此钩子</p>\n<pre><code class=\"js\">class Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  componentWillUnmount()\n}</code></pre>\n<blockquote>\n<p>componentWillUnmount()</p>\n</blockquote>\n<p>此钩子会在组件卸载及销毁之前直接调用，在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等</p>\n<ul>\n<li>此钩子不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它</li>\n</ul>\n<h3 id=\"其他钩子\"><a href=\"#其他钩子\" class=\"headerlink\" title=\"其他钩子\"></a>其他钩子<hr></h3><p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法</p>\n<pre><code class=\"js\">class Demo extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {}\n  }\n  // 两个钩子用其中一个就可以\n  static getDerivedStateFromError(error) {}\n  componentDidCatch(error, info) {}\n}</code></pre>\n<ul>\n<li>Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误</li>\n<li>Error boundaries 仅捕获组件树中以下组件中的错误。但它本身的错误无法捕获。</li>\n<li>如果发生错误，你可以通过调用 setState 使用 componentDidCatch() 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 getDerivedStateFromError() 来处理降级渲染。</li>\n</ul>\n<blockquote>\n<p>static getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。</p>\n</blockquote>\n<p>此钩子会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</p>\n<pre><code class=\"js\">class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以降级 UI\n    return { hasError: true };\n  }\n  render() {\n    if (this.state.hasError) {\n      // 你可以渲染任何自定义的降级  UI\n      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n    return this.props.children; \n  }\n}</code></pre>\n<blockquote>\n<p>componentDidCatch(error, info) 会在 “提交” 阶段被调用，因此允许执行副作用。 用于记录错误之类的情况.</p>\n</blockquote>\n<p>此生命周期在后代组件抛出错误后被调用。 它接收两个参数：</p>\n<ul>\n<li>error —— 抛出的错误。</li>\n<li>info —— 带有 componentStack key 的对象。</li>\n</ul>\n<pre><code class=\"js\">class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染可以显示降级 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // &quot;组件堆栈&quot; 例子:\n    //   in ComponentThatThrows (created by App)\n    //   in ErrorBoundary (created by App)\n    //   in div (created by App)\n    //   in App\n    logComponentStackToMyService(info.componentStack);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以渲染任何自定义的降级 UI\n      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n\n    return this.props.children; \n  }\n}</code></pre>\n<h3 id=\"版本对比图\"><a href=\"#版本对比图\" class=\"headerlink\" title=\"版本对比图\"></a>版本对比图<hr></h3><img src=\"/images/library-react-lifecycle01.png\">\n\n<p>通过上面版本对比图我们能够很清晰的看到在 Mounting 和 Updation 阶段16版本增加了深蓝色部分。 </p>\n<ul>\n<li>16版本中 componentWillMount、componentWillReceiveProps、componmentWillUpdate 被标记为不安全的钩子，在17版本中被移除</li>\n<li>增加了 getDeriveStateFromProps、getSnapshotBeforeUpdate。</li>\n<li>增加了错误处理的钩子分别为 componentDidCatch、getDerivedStateFromError</li>\n</ul>\n<h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图<hr></h3><img src=\"/images/library-react-lifecycle02.png\">\n\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序<hr></h3><p>用下面的例子进行测试</p>\n<p>父组件</p>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport &#39;./ToDo.css&#39;;\nimport ToDoItem from &#39;./components/ToDoItem&#39;;\n\nclass ToDo extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // this is where the data goes\n      list: [\n        {\n          &#39;todo&#39;: &#39;clean the house&#39;\n        },\n        {\n          &#39;todo&#39;: &#39;buy milk&#39;\n        }\n      ],\n      todo: &#39;&#39;\n    };\n  };\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log(&#39;getDerivedStateFromProps父&#39;)\n    return null\n  }\n  componentDidMount() {\n    console.log(&#39;componentDidMount父&#39;)\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(&#39;shouldComponentUpdate父&#39;)\n    return true\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log(&#39;getSnapshotBeforeUpdate父&#39;)\n    return null\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(&#39;componentDidUpdate父&#39;)\n  }\n\n  componentWillUnmount() {\n    console.log(&#39;componentWillUnmount父&#39;)\n  }\n\n\n  createNewToDoItem = () =&gt; {\n    this.setState(({ list, todo }) =&gt; ({\n      list: [\n        ...list,\n        {\n          todo\n        }\n      ],\n      todo: &#39;&#39;\n    }));\n  }\n\n\n  handleKeyPress = e =&gt; {\n    if (e.target.value !== &#39;&#39;) {\n      if (e.key === &#39;Enter&#39;) {\n        this.createNewToDoItem();\n      }\n    }\n  }\n\n  handleInput = e =&gt; {\n    this.setState({\n      todo: e.target.value\n    });\n  }\n\n\n  // this is now being emitted back to the parent from the child component\n  deleteItem = indexToDelete =&gt; {\n    this.setState(({ list }) =&gt; ({\n      list: list.filter((toDo, index) =&gt; index !== indexToDelete)\n    }));\n  }\n\n\n  render() {\n    console.log(&quot;render 父&quot;)\n    return (\n      &lt;div className=&quot;ToDo&quot;&gt;\n        &lt;h1 className=&quot;ToDo-Header&quot;&gt;React To Do&lt;/h1&gt;\n        &lt;div className=&quot;ToDo-Container&quot;&gt;\n          &lt;div className=&quot;ToDo-Content&quot;&gt;\n            &lt;ToDoItem /&gt;\n            {this.state.list.map((item, key) =&gt; {\n              return &lt;ToDoItem\n                key={key}\n                item={item.todo}\n                deleteItem={this.deleteItem.bind(this, key)}\n              /&gt;\n            }\n            )}\n\n          &lt;/div&gt;\n          &lt;input type=&quot;text&quot; value={this.state.todo} onChange={this.handleInput} onKeyPress={this.handleKeyPress} /&gt;\n          &lt;div className=&quot;ToDo-Add&quot; onClick={this.createNewToDoItem}&gt;+&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default ToDo;</code></pre>\n<p>子组件</p>\n<pre><code class=\"js\">mport React, { Component } from &#39;react&#39;;\nimport &#39;./ToDoItem.css&#39;;\n\nclass ToDoItem extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      item: this.props.item\n    }\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log(&#39;getDerivedStateFromProps子&#39;)\n    return null\n  }\n  componentDidMount() {\n    console.log(&#39;componentDidMount子&#39;)\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(&#39;shouldComponentUpdate子&#39;)\n    return true\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log(&#39;getSnapshotBeforeUpdate子&#39;)\n    return null\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(&#39;componentDidUpdate子&#39;)\n  }\n\n  componentWillUnmount() {\n    console.log(&#39;componentWillUnmount子&#39;)\n  }\n\n  render() {\n    console.log(&quot;render 子&quot;)\n    return (\n      &lt;div className=&quot;ToDoItem&quot;&gt;\n        &lt;p className=&quot;ToDoItem-Text&quot;&gt;{this.props.item}&lt;/p&gt;\n        &lt;div className=&quot;ToDoItem-Delete&quot; onClick={this.props.deleteItem}&gt;-&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default ToDoItem;\n</code></pre>\n<p>使用父组件</p>\n<pre><code class=\"js\">import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &#39;./index.css&#39;;\nimport ToDo from &#39;./ToDo&#39;;\n\nReactDOM.render(&lt;ToDo /&gt;, document.getElementById(&#39;root&#39;));</code></pre>\n<p>通过上面代码看的初始化执行顺序是</p>\n<image src=\"/images/library-react-lifecycle03.jpg\">\n\n<p>可以看到先执行</p>\n<ul>\n<li>父组件的 getDerivedStateFromProps -&gt; render</li>\n<li>子组件的 getDerivedStateFromProps -&gt; render</li>\n<li>子组件的 componentDidMount</li>\n<li>父组件的 componentDidMount</li>\n</ul>\n<p>更新阶段执行的顺序是<br><image src=\"/images/library-react-lifecycle04.jpg\"></image></p>\n<ul>\n<li>父组件的 getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render</li>\n<li>子组件的 getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render</li>\n<li>子组件 getSnapshotBeforeUpdate</li>\n<li>父组件 getSnapshotBeforeUpdate</li>\n<li>子组件 componentWillUnmount（因为删除了子组件）</li>\n<li>子组件的 componentDidUpdate</li>\n<li>父组件的 componentDidUpdate</li>\n</ul>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><p><a href=\"https://zh-hans.reactjs.org/docs/react-component.html\" target=\"_blank\" rel=\"noopener\">组件的生命周期<a></a></a></p>\n</image>"},{"title":"装饰器","date":"2019-07-18T10:20:27.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n装饰器是一种为类声明和成员添加注释和元编程语法的方法，用于在编译时对类、类的方法、类的属性、类的方法的参数进行处理，通俗的讲就是在原有代码外层包装了一层处理逻辑，这样就可以在不改变原方法、函数等逻辑功能的基础上增加额外的处理行为\n\n### **使用装饰器**\n\n要启用装饰器功能需要开始experimentalDecorators选项，两种方式\n\n命令行\n```\ntsc --target ES5 --experimentalDecorators\n```\n\ntsconfig.json配置\n```\n{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"experimentalDecorators\": true\n    }\n}\n```\n\n### **装饰器的简单应用**\n\n定义一个装饰器\n\n```\nfunction people (target) {\n  console.log(target)\n}\n\n```\n\n在类中使用装饰器（@Decorator的语法是通过 @ 符号后边跟一个装饰器函数的引用）\n\n```\n@people\nclass People {\n  constructor(){}\n} \n```\n\n### 装饰器工厂\n\n解决在类中调用装饰器传参数的场景\n\n```\n// 装饰器工厂\nfunction people(name : string) {   \n  // 装饰器\n  return function(target){       \n    console.log(target);\n  }\n}\n\n// 调用装饰器工厂\n@people('zhangsan')\nclass People{\n  constructor(){}\n} \n```\n\n### 多个装饰器应用\n\n当在一个类上由多个装饰器调用的时候，类似于<a href=\"functionalCombination.md\">函数组合</a>\n\n定义多个装饰器\n\n```\nfunction decorator1() {\n  console.log(\"decorator1(): start\");\n  return function (target) {\n    console.log(\"decorator1(): end\");\n  }\n}\n\nfunction decorator2() {\n    console.log(\"decorator2(): start\");\n    return function (target) {\n      console.log(\"decorator2(): end\");\n    }\n}\n```\n\n调用装饰器\n```\nclass C {\n  @decorator1()\n  @decorator2()\n  method() {}\n}\n```\n\n输出结果为(可以看作组合函数调用 decorator1(decorator2()))\n\n```\ndecorator1(): start\ndecorator2(): start\ndecorator2(): end\ndecorator1(): end\n```\n\n### 类装饰器（Class）\n\n- 类装饰器应用于类的构造函数，用于观察，修改或替换类定义 \n- 类会在class定义前调用，如果函数有返回值，它将使用提供的构造函数替换之前的构造函数\n- 函数接收一个参数 `constructor` 之前的构造函数\n- 如果返回新的构造函数，则必须维护原始原型\n\n我们定义一个类，继承原有的类并对这个类增加一些属性\n\n```\n// 定义类装饰器\nfunction personName<T extends {new(...args:any[]):{}}>(constructor:T){\n  return class extends constructor {\n    name = \"zhangsan\";\n  }\n}\n\n// 使用类装饰器\n@personName\nclass Person {\n public name: string;\n  constructor (name: string) {\n    this.name = name\n    console.log(`Hi, my name is ${this.name}`) // Hi, my name is wangwu\n  }\n}\n\nconsole.log(new Person('wangwu')) // class_1 {name: \"zhangsan\",__proto__:Person}\n```\n\n### 方法装饰器\n\n\n方法，属性，get、set访问器，都可以认为是类成员。所以被分为了Method Decorator、Accessor Decorator和Property Decorator 这三个参数 \n\n\n方法装饰只是一个方法声明之前声明，方法装饰器不能用于声明文件，重载或任何其他环境上下文（例如declare类中）\n\n方法装饰器的表达式将在运行时作为函数调用，具有以下三个参数：\n- 如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型\n- 装饰器挂载的成员名称\n- 方法成员的属性描述对象（Object.getOwnPropertyDescriptor 的返回值）\n\n\n\n所谓的访问器也就是有 get set 前缀的函数，方法是控制属性的赋值及取值，访问器装饰器和方法装饰器一样因为和下面要说到的属性装饰器一样都是类的成员具有三个参数\n\nMethod Decorator、Accessor Decorator和Property Decorator\n使用方法装饰器\n\n```\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n```\nfunction enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor{\n    descriptor.enumerable = value;\n  };\n}\n```\n\n明确一下静态成员与实例成员在返回值上的区别\n\n```\nclass Func {\n\n  // 静态成员\n  static method1 () {}\n  static method2 = () => {}\n  \n  // 实例成员\n  method3 () {}\n  method4 = () => {}\n}\n\n```\n\n静态成员 method1 和 method2 都是定义在 Func 构造函数上，method3 和 method4 区别在于 method3 定义在原型链之上 method4 只有在 Func 类实例化对象之后才有，转化ES5代码之后的样子\n\n```\nvar Func = /** @class */ (function () {\n    function Func() {\n      this.method4 = function () { };\n    }\n    // 静态成员\n    Func.method1 = function () { };\n    // 实例成员\n    Func.prototype.method3 = function () { };\n    Func.method2 = function () { };\n    return Func;\n}());\n```\n通过函数可以证明上述论点装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型 而且 method4 在实例化之前是一个不存在的属性所以没有 descriptor，就是为什么TS在针对Property Decorator不传递第三个参数的原因\n\n\n### 访问器装饰器（get set）\n访问器装饰器就是有get、set前缀的函数，用于控制属性的赋值及取值操作。上面说到和方法装饰器一样有三个参数\n\n定义装饰器三个参数\n\n```\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n\n```\n\n定义带有get，set的类\n\n```\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n      this._x = x;\n      this._y = y;\n  }\n\n  @configurable(false)\n  get x() { return this._x; }\n\n  @configurable(false)\n  get y() { return this._y; }\n}\n```\n\n### 属性装饰器\n\n属性装饰器由于没有返回 descriptor 所以只有两个参数，没有方法成员的属性描述对象，如果想要修改某一个静态属性，可以通过 Object.getOwnPropertyDescriptor 获取 descriptor\n\n\n*注意在TypeScript中如何初始化属性修饰符，因此不提供属性描述符作为属性修饰符的参数。这是因为当定义原型的成员时，当前没有机制来描述实例属性，也无法观察或修改属性的初始化器。返回值也被忽略。因此，属性装饰器只能用于观察已为类声明特定名称的属性。*\n\n定义类\n```\nclass Point {\n  @configurable\n  static x = 1;\n}\n```\n\n定义属性装饰器获取类属性上的值进行更改\n```\nfunction configurable(target,x) {\n  let descriptor = Object.getOwnPropertyDescriptor(target, x)\n  Object.defineProperty(target, x, {\n    ...descriptor,\n    value: 2\n  })\n}\nconsole.log(Point.x) // 2 \n```\n\n也可以使用 reflect-metadata 这个库它主要用来在声明的时候添加和读取元数据\n使用的时候需要安装\n\n```\nnpm i reflect-metadata --save\n```\n之后在tsconfig.json 中配置emitDecoratorMetadata选项\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n\n定义类\n```\nclass Greeter {\n    @format(\"Hello, %s\")\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        let formatString = getFormat(this, \"greeting\");\n        return formatString.replace(\"%s\", this.greeting);\n    }\n}\n```\n\n// 利用 reflect-metadata 定义装饰器\n\nReflect.metadata 当作 Decorator 使用，当修饰类时，在类上添加元数据，当修饰类属性时，在类原型的属性上添加元数据\n\n\nReflect.getMetadata 能获取属性\n\n```\nimport \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n### 参数装饰器\n\n参数装饰器和属性装饰器一样都是在函数运行时调用的，它接收3个参数\n\n- 如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型\n- 参数所处的函数名称\n- 参数在函数中形参中的位置\n\n\n```\nconst obj = []\n\nfunction require (value : string) {\n  return function (target : any , propertyKey : string ,parameterIndex : number) {\n    obj[parameterIndex] = value\n  }\n}\n\nclass Hello{\n  method(@require('lisi') name : string){\n    console.log(name)\n  }\n}\n\nconsole.log(obj) // ['lisi']\n```\n\n","source":"_posts/typescript/decorators.md","raw":"---\ntitle: 装饰器\ndate: 2019-07-18 18:20:27\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- TypeScript\ncategories:\n- TypeScript\n---\n\n装饰器是一种为类声明和成员添加注释和元编程语法的方法，用于在编译时对类、类的方法、类的属性、类的方法的参数进行处理，通俗的讲就是在原有代码外层包装了一层处理逻辑，这样就可以在不改变原方法、函数等逻辑功能的基础上增加额外的处理行为\n\n### **使用装饰器**\n\n要启用装饰器功能需要开始experimentalDecorators选项，两种方式\n\n命令行\n```\ntsc --target ES5 --experimentalDecorators\n```\n\ntsconfig.json配置\n```\n{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"experimentalDecorators\": true\n    }\n}\n```\n\n### **装饰器的简单应用**\n\n定义一个装饰器\n\n```\nfunction people (target) {\n  console.log(target)\n}\n\n```\n\n在类中使用装饰器（@Decorator的语法是通过 @ 符号后边跟一个装饰器函数的引用）\n\n```\n@people\nclass People {\n  constructor(){}\n} \n```\n\n### 装饰器工厂\n\n解决在类中调用装饰器传参数的场景\n\n```\n// 装饰器工厂\nfunction people(name : string) {   \n  // 装饰器\n  return function(target){       \n    console.log(target);\n  }\n}\n\n// 调用装饰器工厂\n@people('zhangsan')\nclass People{\n  constructor(){}\n} \n```\n\n### 多个装饰器应用\n\n当在一个类上由多个装饰器调用的时候，类似于<a href=\"functionalCombination.md\">函数组合</a>\n\n定义多个装饰器\n\n```\nfunction decorator1() {\n  console.log(\"decorator1(): start\");\n  return function (target) {\n    console.log(\"decorator1(): end\");\n  }\n}\n\nfunction decorator2() {\n    console.log(\"decorator2(): start\");\n    return function (target) {\n      console.log(\"decorator2(): end\");\n    }\n}\n```\n\n调用装饰器\n```\nclass C {\n  @decorator1()\n  @decorator2()\n  method() {}\n}\n```\n\n输出结果为(可以看作组合函数调用 decorator1(decorator2()))\n\n```\ndecorator1(): start\ndecorator2(): start\ndecorator2(): end\ndecorator1(): end\n```\n\n### 类装饰器（Class）\n\n- 类装饰器应用于类的构造函数，用于观察，修改或替换类定义 \n- 类会在class定义前调用，如果函数有返回值，它将使用提供的构造函数替换之前的构造函数\n- 函数接收一个参数 `constructor` 之前的构造函数\n- 如果返回新的构造函数，则必须维护原始原型\n\n我们定义一个类，继承原有的类并对这个类增加一些属性\n\n```\n// 定义类装饰器\nfunction personName<T extends {new(...args:any[]):{}}>(constructor:T){\n  return class extends constructor {\n    name = \"zhangsan\";\n  }\n}\n\n// 使用类装饰器\n@personName\nclass Person {\n public name: string;\n  constructor (name: string) {\n    this.name = name\n    console.log(`Hi, my name is ${this.name}`) // Hi, my name is wangwu\n  }\n}\n\nconsole.log(new Person('wangwu')) // class_1 {name: \"zhangsan\",__proto__:Person}\n```\n\n### 方法装饰器\n\n\n方法，属性，get、set访问器，都可以认为是类成员。所以被分为了Method Decorator、Accessor Decorator和Property Decorator 这三个参数 \n\n\n方法装饰只是一个方法声明之前声明，方法装饰器不能用于声明文件，重载或任何其他环境上下文（例如declare类中）\n\n方法装饰器的表达式将在运行时作为函数调用，具有以下三个参数：\n- 如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型\n- 装饰器挂载的成员名称\n- 方法成员的属性描述对象（Object.getOwnPropertyDescriptor 的返回值）\n\n\n\n所谓的访问器也就是有 get set 前缀的函数，方法是控制属性的赋值及取值，访问器装饰器和方法装饰器一样因为和下面要说到的属性装饰器一样都是类的成员具有三个参数\n\nMethod Decorator、Accessor Decorator和Property Decorator\n使用方法装饰器\n\n```\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n```\nfunction enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor{\n    descriptor.enumerable = value;\n  };\n}\n```\n\n明确一下静态成员与实例成员在返回值上的区别\n\n```\nclass Func {\n\n  // 静态成员\n  static method1 () {}\n  static method2 = () => {}\n  \n  // 实例成员\n  method3 () {}\n  method4 = () => {}\n}\n\n```\n\n静态成员 method1 和 method2 都是定义在 Func 构造函数上，method3 和 method4 区别在于 method3 定义在原型链之上 method4 只有在 Func 类实例化对象之后才有，转化ES5代码之后的样子\n\n```\nvar Func = /** @class */ (function () {\n    function Func() {\n      this.method4 = function () { };\n    }\n    // 静态成员\n    Func.method1 = function () { };\n    // 实例成员\n    Func.prototype.method3 = function () { };\n    Func.method2 = function () { };\n    return Func;\n}());\n```\n通过函数可以证明上述论点装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型 而且 method4 在实例化之前是一个不存在的属性所以没有 descriptor，就是为什么TS在针对Property Decorator不传递第三个参数的原因\n\n\n### 访问器装饰器（get set）\n访问器装饰器就是有get、set前缀的函数，用于控制属性的赋值及取值操作。上面说到和方法装饰器一样有三个参数\n\n定义装饰器三个参数\n\n```\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n\n```\n\n定义带有get，set的类\n\n```\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n      this._x = x;\n      this._y = y;\n  }\n\n  @configurable(false)\n  get x() { return this._x; }\n\n  @configurable(false)\n  get y() { return this._y; }\n}\n```\n\n### 属性装饰器\n\n属性装饰器由于没有返回 descriptor 所以只有两个参数，没有方法成员的属性描述对象，如果想要修改某一个静态属性，可以通过 Object.getOwnPropertyDescriptor 获取 descriptor\n\n\n*注意在TypeScript中如何初始化属性修饰符，因此不提供属性描述符作为属性修饰符的参数。这是因为当定义原型的成员时，当前没有机制来描述实例属性，也无法观察或修改属性的初始化器。返回值也被忽略。因此，属性装饰器只能用于观察已为类声明特定名称的属性。*\n\n定义类\n```\nclass Point {\n  @configurable\n  static x = 1;\n}\n```\n\n定义属性装饰器获取类属性上的值进行更改\n```\nfunction configurable(target,x) {\n  let descriptor = Object.getOwnPropertyDescriptor(target, x)\n  Object.defineProperty(target, x, {\n    ...descriptor,\n    value: 2\n  })\n}\nconsole.log(Point.x) // 2 \n```\n\n也可以使用 reflect-metadata 这个库它主要用来在声明的时候添加和读取元数据\n使用的时候需要安装\n\n```\nnpm i reflect-metadata --save\n```\n之后在tsconfig.json 中配置emitDecoratorMetadata选项\n\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n\n定义类\n```\nclass Greeter {\n    @format(\"Hello, %s\")\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        let formatString = getFormat(this, \"greeting\");\n        return formatString.replace(\"%s\", this.greeting);\n    }\n}\n```\n\n// 利用 reflect-metadata 定义装饰器\n\nReflect.metadata 当作 Decorator 使用，当修饰类时，在类上添加元数据，当修饰类属性时，在类原型的属性上添加元数据\n\n\nReflect.getMetadata 能获取属性\n\n```\nimport \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n### 参数装饰器\n\n参数装饰器和属性装饰器一样都是在函数运行时调用的，它接收3个参数\n\n- 如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型\n- 参数所处的函数名称\n- 参数在函数中形参中的位置\n\n\n```\nconst obj = []\n\nfunction require (value : string) {\n  return function (target : any , propertyKey : string ,parameterIndex : number) {\n    obj[parameterIndex] = value\n  }\n}\n\nclass Hello{\n  method(@require('lisi') name : string){\n    console.log(name)\n  }\n}\n\nconsole.log(obj) // ['lisi']\n```\n\n","slug":"typescript/decorators","published":1,"updated":"2019-10-15T01:29:42.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owi008yb0u6vlrh14db","content":"<p>装饰器是一种为类声明和成员添加注释和元编程语法的方法，用于在编译时对类、类的方法、类的属性、类的方法的参数进行处理，通俗的讲就是在原有代码外层包装了一层处理逻辑，这样就可以在不改变原方法、函数等逻辑功能的基础上增加额外的处理行为</p>\n<h3 id=\"使用装饰器\"><a href=\"#使用装饰器\" class=\"headerlink\" title=\"使用装饰器\"></a><strong>使用装饰器</strong></h3><p>要启用装饰器功能需要开始experimentalDecorators选项，两种方式</p>\n<p>命令行</p>\n<pre><code>tsc --target ES5 --experimentalDecorators</code></pre><p>tsconfig.json配置</p>\n<pre><code>{\n    &quot;compilerOptions&quot;: {\n        &quot;target&quot;: &quot;ES5&quot;,\n        &quot;experimentalDecorators&quot;: true\n    }\n}</code></pre><h3 id=\"装饰器的简单应用\"><a href=\"#装饰器的简单应用\" class=\"headerlink\" title=\"装饰器的简单应用\"></a><strong>装饰器的简单应用</strong></h3><p>定义一个装饰器</p>\n<pre><code>function people (target) {\n  console.log(target)\n}\n</code></pre><p>在类中使用装饰器（@Decorator的语法是通过 @ 符号后边跟一个装饰器函数的引用）</p>\n<pre><code>@people\nclass People {\n  constructor(){}\n} </code></pre><h3 id=\"装饰器工厂\"><a href=\"#装饰器工厂\" class=\"headerlink\" title=\"装饰器工厂\"></a>装饰器工厂</h3><p>解决在类中调用装饰器传参数的场景</p>\n<pre><code>// 装饰器工厂\nfunction people(name : string) {   \n  // 装饰器\n  return function(target){       \n    console.log(target);\n  }\n}\n\n// 调用装饰器工厂\n@people(&#39;zhangsan&#39;)\nclass People{\n  constructor(){}\n} </code></pre><h3 id=\"多个装饰器应用\"><a href=\"#多个装饰器应用\" class=\"headerlink\" title=\"多个装饰器应用\"></a>多个装饰器应用</h3><p>当在一个类上由多个装饰器调用的时候，类似于<a href=\"functionalCombination.md\">函数组合</a></p>\n<p>定义多个装饰器</p>\n<pre><code>function decorator1() {\n  console.log(&quot;decorator1(): start&quot;);\n  return function (target) {\n    console.log(&quot;decorator1(): end&quot;);\n  }\n}\n\nfunction decorator2() {\n    console.log(&quot;decorator2(): start&quot;);\n    return function (target) {\n      console.log(&quot;decorator2(): end&quot;);\n    }\n}</code></pre><p>调用装饰器</p>\n<pre><code>class C {\n  @decorator1()\n  @decorator2()\n  method() {}\n}</code></pre><p>输出结果为(可以看作组合函数调用 decorator1(decorator2()))</p>\n<pre><code>decorator1(): start\ndecorator2(): start\ndecorator2(): end\ndecorator1(): end</code></pre><h3 id=\"类装饰器（Class）\"><a href=\"#类装饰器（Class）\" class=\"headerlink\" title=\"类装饰器（Class）\"></a>类装饰器（Class）</h3><ul>\n<li>类装饰器应用于类的构造函数，用于观察，修改或替换类定义 </li>\n<li>类会在class定义前调用，如果函数有返回值，它将使用提供的构造函数替换之前的构造函数</li>\n<li>函数接收一个参数 <code>constructor</code> 之前的构造函数</li>\n<li>如果返回新的构造函数，则必须维护原始原型</li>\n</ul>\n<p>我们定义一个类，继承原有的类并对这个类增加一些属性</p>\n<pre><code>// 定义类装饰器\nfunction personName&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T){\n  return class extends constructor {\n    name = &quot;zhangsan&quot;;\n  }\n}\n\n// 使用类装饰器\n@personName\nclass Person {\n public name: string;\n  constructor (name: string) {\n    this.name = name\n    console.log(`Hi, my name is ${this.name}`) // Hi, my name is wangwu\n  }\n}\n\nconsole.log(new Person(&#39;wangwu&#39;)) // class_1 {name: &quot;zhangsan&quot;,__proto__:Person}</code></pre><h3 id=\"方法装饰器\"><a href=\"#方法装饰器\" class=\"headerlink\" title=\"方法装饰器\"></a>方法装饰器</h3><p>方法，属性，get、set访问器，都可以认为是类成员。所以被分为了Method Decorator、Accessor Decorator和Property Decorator 这三个参数 </p>\n<p>方法装饰只是一个方法声明之前声明，方法装饰器不能用于声明文件，重载或任何其他环境上下文（例如declare类中）</p>\n<p>方法装饰器的表达式将在运行时作为函数调用，具有以下三个参数：</p>\n<ul>\n<li>如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型</li>\n<li>装饰器挂载的成员名称</li>\n<li>方法成员的属性描述对象（Object.getOwnPropertyDescriptor 的返回值）</li>\n</ul>\n<p>所谓的访问器也就是有 get set 前缀的函数，方法是控制属性的赋值及取值，访问器装饰器和方法装饰器一样因为和下面要说到的属性装饰器一样都是类的成员具有三个参数</p>\n<p>Method Decorator、Accessor Decorator和Property Decorator<br>使用方法装饰器</p>\n<pre><code>class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return &quot;Hello, &quot; + this.greeting;\n  }\n}</code></pre><pre><code>function enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor{\n    descriptor.enumerable = value;\n  };\n}</code></pre><p>明确一下静态成员与实例成员在返回值上的区别</p>\n<pre><code>class Func {\n\n  // 静态成员\n  static method1 () {}\n  static method2 = () =&gt; {}\n\n  // 实例成员\n  method3 () {}\n  method4 = () =&gt; {}\n}\n</code></pre><p>静态成员 method1 和 method2 都是定义在 Func 构造函数上，method3 和 method4 区别在于 method3 定义在原型链之上 method4 只有在 Func 类实例化对象之后才有，转化ES5代码之后的样子</p>\n<pre><code>var Func = /** @class */ (function () {\n    function Func() {\n      this.method4 = function () { };\n    }\n    // 静态成员\n    Func.method1 = function () { };\n    // 实例成员\n    Func.prototype.method3 = function () { };\n    Func.method2 = function () { };\n    return Func;\n}());</code></pre><p>通过函数可以证明上述论点装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型 而且 method4 在实例化之前是一个不存在的属性所以没有 descriptor，就是为什么TS在针对Property Decorator不传递第三个参数的原因</p>\n<h3 id=\"访问器装饰器（get-set）\"><a href=\"#访问器装饰器（get-set）\" class=\"headerlink\" title=\"访问器装饰器（get set）\"></a>访问器装饰器（get set）</h3><p>访问器装饰器就是有get、set前缀的函数，用于控制属性的赋值及取值操作。上面说到和方法装饰器一样有三个参数</p>\n<p>定义装饰器三个参数</p>\n<pre><code>function configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n</code></pre><p>定义带有get，set的类</p>\n<pre><code>class Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n      this._x = x;\n      this._y = y;\n  }\n\n  @configurable(false)\n  get x() { return this._x; }\n\n  @configurable(false)\n  get y() { return this._y; }\n}</code></pre><h3 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h3><p>属性装饰器由于没有返回 descriptor 所以只有两个参数，没有方法成员的属性描述对象，如果想要修改某一个静态属性，可以通过 Object.getOwnPropertyDescriptor 获取 descriptor</p>\n<p><em>注意在TypeScript中如何初始化属性修饰符，因此不提供属性描述符作为属性修饰符的参数。这是因为当定义原型的成员时，当前没有机制来描述实例属性，也无法观察或修改属性的初始化器。返回值也被忽略。因此，属性装饰器只能用于观察已为类声明特定名称的属性。</em></p>\n<p>定义类</p>\n<pre><code>class Point {\n  @configurable\n  static x = 1;\n}</code></pre><p>定义属性装饰器获取类属性上的值进行更改</p>\n<pre><code>function configurable(target,x) {\n  let descriptor = Object.getOwnPropertyDescriptor(target, x)\n  Object.defineProperty(target, x, {\n    ...descriptor,\n    value: 2\n  })\n}\nconsole.log(Point.x) // 2 </code></pre><p>也可以使用 reflect-metadata 这个库它主要用来在声明的时候添加和读取元数据<br>使用的时候需要安装</p>\n<pre><code>npm i reflect-metadata --save</code></pre><p>之后在tsconfig.json 中配置emitDecoratorMetadata选项</p>\n<pre><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES5&quot;,\n    &quot;experimentalDecorators&quot;: true,\n    &quot;emitDecoratorMetadata&quot;: true\n  }\n}</code></pre><p>定义类</p>\n<pre><code>class Greeter {\n    @format(&quot;Hello, %s&quot;)\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        let formatString = getFormat(this, &quot;greeting&quot;);\n        return formatString.replace(&quot;%s&quot;, this.greeting);\n    }\n}</code></pre><p>// 利用 reflect-metadata 定义装饰器</p>\n<p>Reflect.metadata 当作 Decorator 使用，当修饰类时，在类上添加元数据，当修饰类属性时，在类原型的属性上添加元数据</p>\n<p>Reflect.getMetadata 能获取属性</p>\n<pre><code>import &quot;reflect-metadata&quot;;\n\nconst formatMetadataKey = Symbol(&quot;format&quot;);\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}</code></pre><h3 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h3><p>参数装饰器和属性装饰器一样都是在函数运行时调用的，它接收3个参数</p>\n<ul>\n<li>如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型</li>\n<li>参数所处的函数名称</li>\n<li>参数在函数中形参中的位置</li>\n</ul>\n<pre><code>const obj = []\n\nfunction require (value : string) {\n  return function (target : any , propertyKey : string ,parameterIndex : number) {\n    obj[parameterIndex] = value\n  }\n}\n\nclass Hello{\n  method(@require(&#39;lisi&#39;) name : string){\n    console.log(name)\n  }\n}\n\nconsole.log(obj) // [&#39;lisi&#39;]</code></pre>","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>装饰器是一种为类声明和成员添加注释和元编程语法的方法，用于在编译时对类、类的方法、类的属性、类的方法的参数进行处理，通俗的讲就是在原有代码外层包装了一层处理逻辑，这样就可以在不改变原方法、函数等逻辑功能的基础上增加额外的处理行为</p>\n<h3 id=\"使用装饰器\"><a href=\"#使用装饰器\" class=\"headerlink\" title=\"使用装饰器\"></a><strong>使用装饰器</strong></h3><p>要启用装饰器功能需要开始experimentalDecorators选项，两种方式</p>\n<p>命令行</p>\n<pre><code>tsc --target ES5 --experimentalDecorators</code></pre><p>tsconfig.json配置</p>\n<pre><code>{\n    &quot;compilerOptions&quot;: {\n        &quot;target&quot;: &quot;ES5&quot;,\n        &quot;experimentalDecorators&quot;: true\n    }\n}</code></pre><h3 id=\"装饰器的简单应用\"><a href=\"#装饰器的简单应用\" class=\"headerlink\" title=\"装饰器的简单应用\"></a><strong>装饰器的简单应用</strong></h3><p>定义一个装饰器</p>\n<pre><code>function people (target) {\n  console.log(target)\n}\n</code></pre><p>在类中使用装饰器（@Decorator的语法是通过 @ 符号后边跟一个装饰器函数的引用）</p>\n<pre><code>@people\nclass People {\n  constructor(){}\n} </code></pre><h3 id=\"装饰器工厂\"><a href=\"#装饰器工厂\" class=\"headerlink\" title=\"装饰器工厂\"></a>装饰器工厂</h3><p>解决在类中调用装饰器传参数的场景</p>\n<pre><code>// 装饰器工厂\nfunction people(name : string) {   \n  // 装饰器\n  return function(target){       \n    console.log(target);\n  }\n}\n\n// 调用装饰器工厂\n@people(&#39;zhangsan&#39;)\nclass People{\n  constructor(){}\n} </code></pre><h3 id=\"多个装饰器应用\"><a href=\"#多个装饰器应用\" class=\"headerlink\" title=\"多个装饰器应用\"></a>多个装饰器应用</h3><p>当在一个类上由多个装饰器调用的时候，类似于<a href=\"functionalCombination.md\">函数组合</a></p>\n<p>定义多个装饰器</p>\n<pre><code>function decorator1() {\n  console.log(&quot;decorator1(): start&quot;);\n  return function (target) {\n    console.log(&quot;decorator1(): end&quot;);\n  }\n}\n\nfunction decorator2() {\n    console.log(&quot;decorator2(): start&quot;);\n    return function (target) {\n      console.log(&quot;decorator2(): end&quot;);\n    }\n}</code></pre><p>调用装饰器</p>\n<pre><code>class C {\n  @decorator1()\n  @decorator2()\n  method() {}\n}</code></pre><p>输出结果为(可以看作组合函数调用 decorator1(decorator2()))</p>\n<pre><code>decorator1(): start\ndecorator2(): start\ndecorator2(): end\ndecorator1(): end</code></pre><h3 id=\"类装饰器（Class）\"><a href=\"#类装饰器（Class）\" class=\"headerlink\" title=\"类装饰器（Class）\"></a>类装饰器（Class）</h3><ul>\n<li>类装饰器应用于类的构造函数，用于观察，修改或替换类定义 </li>\n<li>类会在class定义前调用，如果函数有返回值，它将使用提供的构造函数替换之前的构造函数</li>\n<li>函数接收一个参数 <code>constructor</code> 之前的构造函数</li>\n<li>如果返回新的构造函数，则必须维护原始原型</li>\n</ul>\n<p>我们定义一个类，继承原有的类并对这个类增加一些属性</p>\n<pre><code>// 定义类装饰器\nfunction personName&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T){\n  return class extends constructor {\n    name = &quot;zhangsan&quot;;\n  }\n}\n\n// 使用类装饰器\n@personName\nclass Person {\n public name: string;\n  constructor (name: string) {\n    this.name = name\n    console.log(`Hi, my name is ${this.name}`) // Hi, my name is wangwu\n  }\n}\n\nconsole.log(new Person(&#39;wangwu&#39;)) // class_1 {name: &quot;zhangsan&quot;,__proto__:Person}</code></pre><h3 id=\"方法装饰器\"><a href=\"#方法装饰器\" class=\"headerlink\" title=\"方法装饰器\"></a>方法装饰器</h3><p>方法，属性，get、set访问器，都可以认为是类成员。所以被分为了Method Decorator、Accessor Decorator和Property Decorator 这三个参数 </p>\n<p>方法装饰只是一个方法声明之前声明，方法装饰器不能用于声明文件，重载或任何其他环境上下文（例如declare类中）</p>\n<p>方法装饰器的表达式将在运行时作为函数调用，具有以下三个参数：</p>\n<ul>\n<li>如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型</li>\n<li>装饰器挂载的成员名称</li>\n<li>方法成员的属性描述对象（Object.getOwnPropertyDescriptor 的返回值）</li>\n</ul>\n<p>所谓的访问器也就是有 get set 前缀的函数，方法是控制属性的赋值及取值，访问器装饰器和方法装饰器一样因为和下面要说到的属性装饰器一样都是类的成员具有三个参数</p>\n<p>Method Decorator、Accessor Decorator和Property Decorator<br>使用方法装饰器</p>\n<pre><code>class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return &quot;Hello, &quot; + this.greeting;\n  }\n}</code></pre><pre><code>function enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor{\n    descriptor.enumerable = value;\n  };\n}</code></pre><p>明确一下静态成员与实例成员在返回值上的区别</p>\n<pre><code>class Func {\n\n  // 静态成员\n  static method1 () {}\n  static method2 = () =&gt; {}\n\n  // 实例成员\n  method3 () {}\n  method4 = () =&gt; {}\n}\n</code></pre><p>静态成员 method1 和 method2 都是定义在 Func 构造函数上，method3 和 method4 区别在于 method3 定义在原型链之上 method4 只有在 Func 类实例化对象之后才有，转化ES5代码之后的样子</p>\n<pre><code>var Func = /** @class */ (function () {\n    function Func() {\n      this.method4 = function () { };\n    }\n    // 静态成员\n    Func.method1 = function () { };\n    // 实例成员\n    Func.prototype.method3 = function () { };\n    Func.method2 = function () { };\n    return Func;\n}());</code></pre><p>通过函数可以证明上述论点装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型 而且 method4 在实例化之前是一个不存在的属性所以没有 descriptor，就是为什么TS在针对Property Decorator不传递第三个参数的原因</p>\n<h3 id=\"访问器装饰器（get-set）\"><a href=\"#访问器装饰器（get-set）\" class=\"headerlink\" title=\"访问器装饰器（get set）\"></a>访问器装饰器（get set）</h3><p>访问器装饰器就是有get、set前缀的函数，用于控制属性的赋值及取值操作。上面说到和方法装饰器一样有三个参数</p>\n<p>定义装饰器三个参数</p>\n<pre><code>function configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n</code></pre><p>定义带有get，set的类</p>\n<pre><code>class Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n      this._x = x;\n      this._y = y;\n  }\n\n  @configurable(false)\n  get x() { return this._x; }\n\n  @configurable(false)\n  get y() { return this._y; }\n}</code></pre><h3 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h3><p>属性装饰器由于没有返回 descriptor 所以只有两个参数，没有方法成员的属性描述对象，如果想要修改某一个静态属性，可以通过 Object.getOwnPropertyDescriptor 获取 descriptor</p>\n<p><em>注意在TypeScript中如何初始化属性修饰符，因此不提供属性描述符作为属性修饰符的参数。这是因为当定义原型的成员时，当前没有机制来描述实例属性，也无法观察或修改属性的初始化器。返回值也被忽略。因此，属性装饰器只能用于观察已为类声明特定名称的属性。</em></p>\n<p>定义类</p>\n<pre><code>class Point {\n  @configurable\n  static x = 1;\n}</code></pre><p>定义属性装饰器获取类属性上的值进行更改</p>\n<pre><code>function configurable(target,x) {\n  let descriptor = Object.getOwnPropertyDescriptor(target, x)\n  Object.defineProperty(target, x, {\n    ...descriptor,\n    value: 2\n  })\n}\nconsole.log(Point.x) // 2 </code></pre><p>也可以使用 reflect-metadata 这个库它主要用来在声明的时候添加和读取元数据<br>使用的时候需要安装</p>\n<pre><code>npm i reflect-metadata --save</code></pre><p>之后在tsconfig.json 中配置emitDecoratorMetadata选项</p>\n<pre><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES5&quot;,\n    &quot;experimentalDecorators&quot;: true,\n    &quot;emitDecoratorMetadata&quot;: true\n  }\n}</code></pre><p>定义类</p>\n<pre><code>class Greeter {\n    @format(&quot;Hello, %s&quot;)\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        let formatString = getFormat(this, &quot;greeting&quot;);\n        return formatString.replace(&quot;%s&quot;, this.greeting);\n    }\n}</code></pre><p>// 利用 reflect-metadata 定义装饰器</p>\n<p>Reflect.metadata 当作 Decorator 使用，当修饰类时，在类上添加元数据，当修饰类属性时，在类原型的属性上添加元数据</p>\n<p>Reflect.getMetadata 能获取属性</p>\n<pre><code>import &quot;reflect-metadata&quot;;\n\nconst formatMetadataKey = Symbol(&quot;format&quot;);\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}</code></pre><h3 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h3><p>参数装饰器和属性装饰器一样都是在函数运行时调用的，它接收3个参数</p>\n<ul>\n<li>如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型</li>\n<li>参数所处的函数名称</li>\n<li>参数在函数中形参中的位置</li>\n</ul>\n<pre><code>const obj = []\n\nfunction require (value : string) {\n  return function (target : any , propertyKey : string ,parameterIndex : number) {\n    obj[parameterIndex] = value\n  }\n}\n\nclass Hello{\n  method(@require(&#39;lisi&#39;) name : string){\n    console.log(name)\n  }\n}\n\nconsole.log(obj) // [&#39;lisi&#39;]</code></pre>"},{"title":"computed 和 watcher","date":"2019-09-07T14:25:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\nvue 的 computed 和 watch 是我们在开发中经常用的方法，从而实现数据的响应与监听，下面我们从使用和源码来分析一下这两个属性的实现原理是什么。\n\n### computed 和 watch 使用<hr>\n\n> computed 计算属性，根据依赖的数据动态显示新的计算结果。当依赖的属性值改变之后，通过调用对应的 getter 来计算并进行缓存，计算的属性名称不能在组件的 props 和 data 中定义，否则会报错。\n\n```js\n<template>\n  <div class=\"hello\">\n    {{fullName}}\n  </div>\n</template>\n\n<script>\nexport default {\n    data() {\n      return {\n        firstName: 'ren',\n        lastName: \"bo\"\n      }\n    },\n    computed: {\n      fullName() {\n        return this.firstName + ' ' + this.lastName\n      }\n    }\n}\n</script>\n```\n\n> watcher 侦听属性，当依赖的 data 的数据变化，执行回调方法，在方法中传入 newVal 和 oldVal。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。来实现数据的监听和观察，并在使用watch 的时候可以执行异步操作，设置中间状态等。\n\n```js\n<template>\n  <div class=\"hello\">\n    {{fullName}}\n    <button @click=\"handleChangName\">改变姓名</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      firstName: 'ren',\n      lastName: \"bo\",\n      fullName: ''\n    }\n  },\n  methods: {\n    handleChangName() {\n      this.firstName = \"zhang\";\n      this.lastName = \"san\"\n    }\n  },\n  watch: {\n    firstName: {\n      handler(newval, oldval) {\n        console.log(newval)\n        console.log(oldval)\n        this.fullName = newval + ' ' + this.lastName\n      },\n      immediate: true\n    }\n  }\n}\n</script>\n```\n\nwatch 只有在数据发生变化的时候，执行回调方法，但是初始化的时候也可以执行，如上面的 firstName 方法中增加 handler 和 immediate 立即执行，具体为什么会立即执行，稍后在做分析，如果我们要监听对象中属性的添加和删除那么我们必须为 watch 中添加 deep 来进行对象深度遍历，进行监听，如下所示\n\n```js\n<template>\n  <div class=\"hello\">\n    {{fullName}}\n    <button @click=\"handleChangName\">改变姓名</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      person: {\n        name: 'renbo',\n        age: 26\n      },\n      fullName: '',\n    }\n  },\n  methods: {\n    handleChangName() {\n      this.person.name = \"zhangsan\";\n      this.person.age = 27\n    }\n  },\n  watch: {\n    person: {\n      handler(newVal, oldVal) {\n        this.fullName = newVal.name + newVal.age\n      },\n      immediate: true,\n      deep: true\n    }\n  }\n}\n</script>\n```\n\n### computed 和 watch 的异同<hr>\n\n通过上面的使用对比\n\n相同点\n- computed 和watch 都能起到监听和依赖处理数据\n- 都是通过 vue 的监听器实现的\n\n不同点\n- computed 主要用于对同步数据的处理\n- watch 则主要用于监听某个值的变化去完成开销较大的复杂业务逻辑\n\n主要的应用场景就是如果一个数据依赖另一个数据那么就用 computed，如果在监听数据发生变化去实现某一些功能，状态，异步等那就就用 watch，但是由于 watch 使用deep进行深度遍历监听会消耗性能，所以还是尽量少用 \n\n### computed 本质 -- computed watch<hr>\n\n前面分析过 new Vue() 的时候会调用 _init 方法，该方法会初始化生命周期，初始化事件，初始化render，初始化data，computed，methods，wacther等等，不清楚大致流程的请参考另一篇文章 <a href=\"https://www.studyfe.cn/2019/08/27/vue/vueprinciple/#toc-heading-12\">vue 的主线流程</a>。计算属性的初始化是发生在 vue 实例初始化阶段的 initState 函数中\n\n```js\n export function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\n上面进行了判断，我们先来看看 opts.computed 存在的情况执行 initComputed 方法，该方法定义在`src/core/instance/state.js` 中\n\n```js\n// 用于传入 Watcher 实例的一个对象，即computed watcher\nconst computedWatcherOptions = { lazy: true }\nfunction initComputed (vm: Component, computed: Object) {\n  // 声明 watchers，同时在实例上挂载 _computedWatchers\n  const watchers = vm._computedWatchers = Object.create(null)\n  // 计算属性在 ssr 模式在只能使用 getter 方法\n  const isSSR = isServerRendering()\n\n  for (const key in computed) {\n    // 遍历取出 computed 对象中的每个方法并赋值给 userDef\n    const userDef = computed[key]\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        `Getter is missing for computed property \"${key}\".`,\n        vm\n      )\n    }\n\n    if (!isSSR) {\n      // 如果不是SSR服务端渲染，则创建一个watcher实例\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    // 组件定义的计算属性已经在组件原型上定义。我们只需要定义在实例化时定义的计算属性。\n    if (!(key in vm)) {\n      // 如果computed 中的 key 没有设置到 vm 中，通过defineComputed函数挂载上去\n      defineComputed(vm, key, userDef)\n    } else if (process.env.NODE_ENV !== 'production') {\n      // props 和 data 中不能和 computed 的 key 同名\n      if (key in vm.$data) {\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\n      }\n    }\n  }\n}\n```\n\n通过上面源码我们发现它先声明了一个名为 watchers 的空对象，同时在 vm 上也挂载了这个空对象。接着对 computed 对象做遍历，拿到每个 userDef，如果 userDef 是 function 的话就赋给 getter，如果不是服务端渲染，就会为这个 getter 创建一个 watcher，这个 watcher 和渲染 watcher 有一点很大的不同，我们在新建实例的时候传入了第四个参数 computedWatcherOptions，其实也就是在代码的第一行，`const computedWatcherOptions = { lazy: true }`，这个对象是实现computed watcher的关键，这样watcher 中就出现了变化，watcher 定义在 `src/core/observer/watcher.js`\n\n```js\n// ...\n\n// options\nif (options) {\n  this.deep = !!options.deep\n  this.user = !!options.user\n  this.lazy = !!options.lazy\n  this.sync = !!options.sync\n  this.before = options.before\n} else {\n  this.deep = this.user = this.lazy = this.sync = false\n}\nthis.cb = cb\nthis.id = ++uid // uid for batching\nthis.active = true\nthis.dirty = this.lazy // for lazy watchers\n\n// ...\n```\n\n上面的 this.lazy 实际上就是 computedWatcherOptions 传递过来的，将 dirty 状态改为 true 之后在 createComputedGetter 方法中\n```js\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers && this._computedWatchers[key]\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate()\n      }\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\n\n```\n\n可以看到之后执行了 watcher.evaluate()，通过调用 this.get() 方法实际上就是在执行 `value = this.getter.call(vm, vm)`，这样就能执行计算属性定义的 getter 函数\n\n```js\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n```\n之后在执行 watcher.depend() 把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候 Dep.target 就是这个 computed watcher，最后拿到当前 watcher 的 value，当计算属性依赖的数据发生改变的时候，会触发 setter 过程，通知所有订阅它变化的 watcher 进行更新，执行 watcher.update() 方法\n\n```js\nupdate () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n```\n\n### watch 的工作原理<hr>\n和 computed 一样也是在执行 initState 的时候执行了 `initWatch(vm, opts.watch)`\n```js\n export function initState (vm: Component) {\n   // ...\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\ninitWatch 方法定义在 `src/core/instance/state.js` 中 \n\n```js\nfunction initWatch (vm: Component, watch: Object) {\n  for (const key in watch) {\n    // 遍历 watch 取到 key \n    const handler = watch[key]\n    if (Array.isArray(handler)) {\n      // 因为 Vue 是支持 watch 的同一个 key 对应多个 handler，所以如果 handler 是一个数组，则遍历这个数组\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      createWatcher(vm, key, handler)\n    }\n  }\n}\n```\n```js\nfunction createWatcher (\n  vm: Component,\n  expOrFn: string | Function,\n  handler: any,\n  options?: Object\n) {\n  if (isPlainObject(handler)) {\n    options = handler\n    handler = handler.handler\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler]\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n```\n通过对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 `vm.$watch(keyOrFn, handler, options)` 函数，vm.$watch 实际上是执行了 Vue.prototype.$watch\n\n```js\nVue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n```\n通过上面代码可以看到，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 const watcher = new Watcher(vm, expOrFn, cb, options) 实例化了一个 watcher，这里需要注意一点这是一个 user watcher，因为 options.user = true。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，上面还有两点需要注意 如果参数传递的 deep ，这样就创建了一个 deep watcher 则会执行\n\n```js\nget() {\n  let value = this.getter.call(vm, vm)\n  // ...\n  if (this.deep) {\n    traverse(value)\n  }\n}\n```\n\n执行 traverse 函数进行深层递归遍历，那么这样就解决了我们开篇时使用 watch 观察改变一个复杂对象不起作用的问题，那么是 watch 立即执行是怎么做到的呢\n\n```js\n// ...\nif (options.immediate) {\n  try {\n    cb.call(vm, watcher.value)\n  } catch (error) {\n    handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n  }\n}\n//...\n```\n通过设置 immediate 为 true，则直接会执行回调函数 cb。这样就会立即执行 watch 属性\n\n\n\n### 总结<hr>\n\n通过以上的分析，我们大概了解了计算属性本质上是一个computed watch，侦听属性本质上是一个user watch。计算属性适合在模版渲染中某一个值依赖了其他响应对象甚至是计算属性计算而来，而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。","source":"_posts/vue/vueComputedWatcher.md","raw":"---\ntitle: computed 和 watcher \ndate: 2019-09-7 22:25:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n\nvue 的 computed 和 watch 是我们在开发中经常用的方法，从而实现数据的响应与监听，下面我们从使用和源码来分析一下这两个属性的实现原理是什么。\n\n### computed 和 watch 使用<hr>\n\n> computed 计算属性，根据依赖的数据动态显示新的计算结果。当依赖的属性值改变之后，通过调用对应的 getter 来计算并进行缓存，计算的属性名称不能在组件的 props 和 data 中定义，否则会报错。\n\n```js\n<template>\n  <div class=\"hello\">\n    {{fullName}}\n  </div>\n</template>\n\n<script>\nexport default {\n    data() {\n      return {\n        firstName: 'ren',\n        lastName: \"bo\"\n      }\n    },\n    computed: {\n      fullName() {\n        return this.firstName + ' ' + this.lastName\n      }\n    }\n}\n</script>\n```\n\n> watcher 侦听属性，当依赖的 data 的数据变化，执行回调方法，在方法中传入 newVal 和 oldVal。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。来实现数据的监听和观察，并在使用watch 的时候可以执行异步操作，设置中间状态等。\n\n```js\n<template>\n  <div class=\"hello\">\n    {{fullName}}\n    <button @click=\"handleChangName\">改变姓名</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      firstName: 'ren',\n      lastName: \"bo\",\n      fullName: ''\n    }\n  },\n  methods: {\n    handleChangName() {\n      this.firstName = \"zhang\";\n      this.lastName = \"san\"\n    }\n  },\n  watch: {\n    firstName: {\n      handler(newval, oldval) {\n        console.log(newval)\n        console.log(oldval)\n        this.fullName = newval + ' ' + this.lastName\n      },\n      immediate: true\n    }\n  }\n}\n</script>\n```\n\nwatch 只有在数据发生变化的时候，执行回调方法，但是初始化的时候也可以执行，如上面的 firstName 方法中增加 handler 和 immediate 立即执行，具体为什么会立即执行，稍后在做分析，如果我们要监听对象中属性的添加和删除那么我们必须为 watch 中添加 deep 来进行对象深度遍历，进行监听，如下所示\n\n```js\n<template>\n  <div class=\"hello\">\n    {{fullName}}\n    <button @click=\"handleChangName\">改变姓名</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      person: {\n        name: 'renbo',\n        age: 26\n      },\n      fullName: '',\n    }\n  },\n  methods: {\n    handleChangName() {\n      this.person.name = \"zhangsan\";\n      this.person.age = 27\n    }\n  },\n  watch: {\n    person: {\n      handler(newVal, oldVal) {\n        this.fullName = newVal.name + newVal.age\n      },\n      immediate: true,\n      deep: true\n    }\n  }\n}\n</script>\n```\n\n### computed 和 watch 的异同<hr>\n\n通过上面的使用对比\n\n相同点\n- computed 和watch 都能起到监听和依赖处理数据\n- 都是通过 vue 的监听器实现的\n\n不同点\n- computed 主要用于对同步数据的处理\n- watch 则主要用于监听某个值的变化去完成开销较大的复杂业务逻辑\n\n主要的应用场景就是如果一个数据依赖另一个数据那么就用 computed，如果在监听数据发生变化去实现某一些功能，状态，异步等那就就用 watch，但是由于 watch 使用deep进行深度遍历监听会消耗性能，所以还是尽量少用 \n\n### computed 本质 -- computed watch<hr>\n\n前面分析过 new Vue() 的时候会调用 _init 方法，该方法会初始化生命周期，初始化事件，初始化render，初始化data，computed，methods，wacther等等，不清楚大致流程的请参考另一篇文章 <a href=\"https://www.studyfe.cn/2019/08/27/vue/vueprinciple/#toc-heading-12\">vue 的主线流程</a>。计算属性的初始化是发生在 vue 实例初始化阶段的 initState 函数中\n\n```js\n export function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\n上面进行了判断，我们先来看看 opts.computed 存在的情况执行 initComputed 方法，该方法定义在`src/core/instance/state.js` 中\n\n```js\n// 用于传入 Watcher 实例的一个对象，即computed watcher\nconst computedWatcherOptions = { lazy: true }\nfunction initComputed (vm: Component, computed: Object) {\n  // 声明 watchers，同时在实例上挂载 _computedWatchers\n  const watchers = vm._computedWatchers = Object.create(null)\n  // 计算属性在 ssr 模式在只能使用 getter 方法\n  const isSSR = isServerRendering()\n\n  for (const key in computed) {\n    // 遍历取出 computed 对象中的每个方法并赋值给 userDef\n    const userDef = computed[key]\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        `Getter is missing for computed property \"${key}\".`,\n        vm\n      )\n    }\n\n    if (!isSSR) {\n      // 如果不是SSR服务端渲染，则创建一个watcher实例\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    // 组件定义的计算属性已经在组件原型上定义。我们只需要定义在实例化时定义的计算属性。\n    if (!(key in vm)) {\n      // 如果computed 中的 key 没有设置到 vm 中，通过defineComputed函数挂载上去\n      defineComputed(vm, key, userDef)\n    } else if (process.env.NODE_ENV !== 'production') {\n      // props 和 data 中不能和 computed 的 key 同名\n      if (key in vm.$data) {\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\n      }\n    }\n  }\n}\n```\n\n通过上面源码我们发现它先声明了一个名为 watchers 的空对象，同时在 vm 上也挂载了这个空对象。接着对 computed 对象做遍历，拿到每个 userDef，如果 userDef 是 function 的话就赋给 getter，如果不是服务端渲染，就会为这个 getter 创建一个 watcher，这个 watcher 和渲染 watcher 有一点很大的不同，我们在新建实例的时候传入了第四个参数 computedWatcherOptions，其实也就是在代码的第一行，`const computedWatcherOptions = { lazy: true }`，这个对象是实现computed watcher的关键，这样watcher 中就出现了变化，watcher 定义在 `src/core/observer/watcher.js`\n\n```js\n// ...\n\n// options\nif (options) {\n  this.deep = !!options.deep\n  this.user = !!options.user\n  this.lazy = !!options.lazy\n  this.sync = !!options.sync\n  this.before = options.before\n} else {\n  this.deep = this.user = this.lazy = this.sync = false\n}\nthis.cb = cb\nthis.id = ++uid // uid for batching\nthis.active = true\nthis.dirty = this.lazy // for lazy watchers\n\n// ...\n```\n\n上面的 this.lazy 实际上就是 computedWatcherOptions 传递过来的，将 dirty 状态改为 true 之后在 createComputedGetter 方法中\n```js\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers && this._computedWatchers[key]\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate()\n      }\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\n\n```\n\n可以看到之后执行了 watcher.evaluate()，通过调用 this.get() 方法实际上就是在执行 `value = this.getter.call(vm, vm)`，这样就能执行计算属性定义的 getter 函数\n\n```js\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n```\n之后在执行 watcher.depend() 把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候 Dep.target 就是这个 computed watcher，最后拿到当前 watcher 的 value，当计算属性依赖的数据发生改变的时候，会触发 setter 过程，通知所有订阅它变化的 watcher 进行更新，执行 watcher.update() 方法\n\n```js\nupdate () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n```\n\n### watch 的工作原理<hr>\n和 computed 一样也是在执行 initState 的时候执行了 `initWatch(vm, opts.watch)`\n```js\n export function initState (vm: Component) {\n   // ...\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\ninitWatch 方法定义在 `src/core/instance/state.js` 中 \n\n```js\nfunction initWatch (vm: Component, watch: Object) {\n  for (const key in watch) {\n    // 遍历 watch 取到 key \n    const handler = watch[key]\n    if (Array.isArray(handler)) {\n      // 因为 Vue 是支持 watch 的同一个 key 对应多个 handler，所以如果 handler 是一个数组，则遍历这个数组\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      createWatcher(vm, key, handler)\n    }\n  }\n}\n```\n```js\nfunction createWatcher (\n  vm: Component,\n  expOrFn: string | Function,\n  handler: any,\n  options?: Object\n) {\n  if (isPlainObject(handler)) {\n    options = handler\n    handler = handler.handler\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler]\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n```\n通过对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 `vm.$watch(keyOrFn, handler, options)` 函数，vm.$watch 实际上是执行了 Vue.prototype.$watch\n\n```js\nVue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n```\n通过上面代码可以看到，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 const watcher = new Watcher(vm, expOrFn, cb, options) 实例化了一个 watcher，这里需要注意一点这是一个 user watcher，因为 options.user = true。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，上面还有两点需要注意 如果参数传递的 deep ，这样就创建了一个 deep watcher 则会执行\n\n```js\nget() {\n  let value = this.getter.call(vm, vm)\n  // ...\n  if (this.deep) {\n    traverse(value)\n  }\n}\n```\n\n执行 traverse 函数进行深层递归遍历，那么这样就解决了我们开篇时使用 watch 观察改变一个复杂对象不起作用的问题，那么是 watch 立即执行是怎么做到的呢\n\n```js\n// ...\nif (options.immediate) {\n  try {\n    cb.call(vm, watcher.value)\n  } catch (error) {\n    handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\n  }\n}\n//...\n```\n通过设置 immediate 为 true，则直接会执行回调函数 cb。这样就会立即执行 watch 属性\n\n\n\n### 总结<hr>\n\n通过以上的分析，我们大概了解了计算属性本质上是一个computed watch，侦听属性本质上是一个user watch。计算属性适合在模版渲染中某一个值依赖了其他响应对象甚至是计算属性计算而来，而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。","slug":"vue/vueComputedWatcher","published":1,"updated":"2019-10-15T01:29:42.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owk0090b0u6crtm3zhq","content":"<p>vue 的 computed 和 watch 是我们在开发中经常用的方法，从而实现数据的响应与监听，下面我们从使用和源码来分析一下这两个属性的实现原理是什么。</p>\n<h3 id=\"computed-和-watch-使用\"><a href=\"#computed-和-watch-使用\" class=\"headerlink\" title=\"computed 和 watch 使用\"></a>computed 和 watch 使用<hr></h3><blockquote>\n<p>computed 计算属性，根据依赖的数据动态显示新的计算结果。当依赖的属性值改变之后，通过调用对应的 getter 来计算并进行缓存，计算的属性名称不能在组件的 props 和 data 中定义，否则会报错。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>template<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"hello\"</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>fullName<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>template<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        firstName<span class=\"token punctuation\">:</span> <span class=\"token string\">'ren'</span><span class=\"token punctuation\">,</span>\n        lastName<span class=\"token punctuation\">:</span> <span class=\"token string\">\"bo\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">fullName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>watcher 侦听属性，当依赖的 data 的数据变化，执行回调方法，在方法中传入 newVal 和 oldVal。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。来实现数据的监听和观察，并在使用watch 的时候可以执行异步操作，设置中间状态等。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>template<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"hello\"</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>fullName<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span>button @click<span class=\"token operator\">=</span><span class=\"token string\">\"handleChangName\"</span><span class=\"token operator\">></span>改变姓名<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>template<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      firstName<span class=\"token punctuation\">:</span> <span class=\"token string\">'ren'</span><span class=\"token punctuation\">,</span>\n      lastName<span class=\"token punctuation\">:</span> <span class=\"token string\">\"bo\"</span><span class=\"token punctuation\">,</span>\n      fullName<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">handleChangName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">=</span> <span class=\"token string\">\"zhang\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName <span class=\"token operator\">=</span> <span class=\"token string\">\"san\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  watch<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    firstName<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>newval<span class=\"token punctuation\">,</span> oldval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newval<span class=\"token punctuation\">)</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>oldval<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fullName <span class=\"token operator\">=</span> newval <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      immediate<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>watch 只有在数据发生变化的时候，执行回调方法，但是初始化的时候也可以执行，如上面的 firstName 方法中增加 handler 和 immediate 立即执行，具体为什么会立即执行，稍后在做分析，如果我们要监听对象中属性的添加和删除那么我们必须为 watch 中添加 deep 来进行对象深度遍历，进行监听，如下所示</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>template<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"hello\"</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>fullName<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span>button @click<span class=\"token operator\">=</span><span class=\"token string\">\"handleChangName\"</span><span class=\"token operator\">></span>改变姓名<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>template<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      person<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        name<span class=\"token punctuation\">:</span> <span class=\"token string\">'renbo'</span><span class=\"token punctuation\">,</span>\n        age<span class=\"token punctuation\">:</span> <span class=\"token number\">26</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      fullName<span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">handleChangName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>person<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"zhangsan\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>person<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">27</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  watch<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    person<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">,</span> oldVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fullName <span class=\"token operator\">=</span> newVal<span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> newVal<span class=\"token punctuation\">.</span>age\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      immediate<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n      deep<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"computed-和-watch-的异同\"><a href=\"#computed-和-watch-的异同\" class=\"headerlink\" title=\"computed 和 watch 的异同\"></a>computed 和 watch 的异同<hr></h3><p>通过上面的使用对比</p>\n<p>相同点</p>\n<ul>\n<li>computed 和watch 都能起到监听和依赖处理数据</li>\n<li>都是通过 vue 的监听器实现的</li>\n</ul>\n<p>不同点</p>\n<ul>\n<li>computed 主要用于对同步数据的处理</li>\n<li>watch 则主要用于监听某个值的变化去完成开销较大的复杂业务逻辑</li>\n</ul>\n<p>主要的应用场景就是如果一个数据依赖另一个数据那么就用 computed，如果在监听数据发生变化去实现某一些功能，状态，异步等那就就用 watch，但是由于 watch 使用deep进行深度遍历监听会消耗性能，所以还是尽量少用 </p>\n<h3 id=\"computed-本质-–-computed-watch\"><a href=\"#computed-本质-–-computed-watch\" class=\"headerlink\" title=\"computed 本质 – computed watch\"></a>computed 本质 – computed watch<hr></h3><p>前面分析过 new Vue() 的时候会调用 _init 方法，该方法会初始化生命周期，初始化事件，初始化render，初始化data，computed，methods，wacther等等，不清楚大致流程的请参考另一篇文章 <a href=\"https://www.studyfe.cn/2019/08/27/vue/vueprinciple/#toc-heading-12\">vue 的主线流程</a>。计算属性的初始化是发生在 vue 实例初始化阶段的 initState 函数中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initState <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  vm<span class=\"token punctuation\">.</span>_watchers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> opts <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span> <span class=\"token function\">initProps</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>methods<span class=\"token punctuation\">)</span> <span class=\"token function\">initMethods</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>methods<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">initData</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_data <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* asRootData */</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span> <span class=\"token function\">initComputed</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>watch <span class=\"token operator\">&amp;&amp;</span> opts<span class=\"token punctuation\">.</span>watch <span class=\"token operator\">!==</span> nativeWatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">initWatch</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面进行了判断，我们先来看看 opts.computed 存在的情况执行 initComputed 方法，该方法定义在<code>src/core/instance/state.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 用于传入 Watcher 实例的一个对象，即computed watcher</span>\n<span class=\"token keyword\">const</span> computedWatcherOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> lazy<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> initComputed <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span> computed<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 声明 watchers，同时在实例上挂载 _computedWatchers</span>\n  <span class=\"token keyword\">const</span> watchers <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_computedWatchers <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 计算属性在 ssr 模式在只能使用 getter 方法</span>\n  <span class=\"token keyword\">const</span> isSSR <span class=\"token operator\">=</span> <span class=\"token function\">isServerRendering</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> computed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 遍历取出 computed 对象中的每个方法并赋值给 userDef</span>\n    <span class=\"token keyword\">const</span> userDef <span class=\"token operator\">=</span> computed<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">const</span> getter <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> userDef <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span> userDef <span class=\"token punctuation\">:</span> userDef<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> getter <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n        <span class=\"token template-string\"><span class=\"token string\">`Getter is missing for computed property \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\".`</span></span><span class=\"token punctuation\">,</span>\n        vm\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isSSR<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果不是SSR服务端渲染，则创建一个watcher实例</span>\n      watchers<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Watcher</span><span class=\"token punctuation\">(</span>\n        vm<span class=\"token punctuation\">,</span>\n        getter <span class=\"token operator\">||</span> noop<span class=\"token punctuation\">,</span>\n        noop<span class=\"token punctuation\">,</span>\n        computedWatcherOptions\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 组件定义的计算属性已经在组件原型上定义。我们只需要定义在实例化时定义的计算属性。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">in</span> vm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果computed 中的 key 没有设置到 vm 中，通过defineComputed函数挂载上去</span>\n      <span class=\"token function\">defineComputed</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> userDef<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// props 和 data 中不能和 computed 的 key 同名</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token keyword\">in</span> vm<span class=\"token punctuation\">.</span>$data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`The computed property \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" is already defined in data.`</span></span><span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>props <span class=\"token operator\">&amp;&amp;</span> key <span class=\"token keyword\">in</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`The computed property \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" is already defined as a prop.`</span></span><span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面源码我们发现它先声明了一个名为 watchers 的空对象，同时在 vm 上也挂载了这个空对象。接着对 computed 对象做遍历，拿到每个 userDef，如果 userDef 是 function 的话就赋给 getter，如果不是服务端渲染，就会为这个 getter 创建一个 watcher，这个 watcher 和渲染 watcher 有一点很大的不同，我们在新建实例的时候传入了第四个参数 computedWatcherOptions，其实也就是在代码的第一行，<code>const computedWatcherOptions = { lazy: true }</code>，这个对象是实现computed watcher的关键，这样watcher 中就出现了变化，watcher 定义在 <code>src/core/observer/watcher.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// options</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>deep\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>user\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lazy <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>lazy\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sync <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>sync\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>before <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>before\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lazy <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sync <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cb <span class=\"token operator\">=</span> cb\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>uid <span class=\"token comment\" spellcheck=\"true\">// uid for batching</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>active <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lazy <span class=\"token comment\" spellcheck=\"true\">// for lazy watchers</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的 this.lazy 实际上就是 computedWatcherOptions 传递过来的，将 dirty 状态改为 true 之后在 createComputedGetter 方法中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> createComputedGetter <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> computedGetter <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> watcher <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_computedWatchers <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_computedWatchers<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        watcher<span class=\"token punctuation\">.</span><span class=\"token function\">evaluate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Dep<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        watcher<span class=\"token punctuation\">.</span><span class=\"token function\">depend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> watcher<span class=\"token punctuation\">.</span>value\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到之后执行了 watcher.evaluate()，通过调用 this.get() 方法实际上就是在执行 <code>value = this.getter.call(vm, vm)</code>，这样就能执行计算属性定义的 getter 函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  evaluate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>之后在执行 watcher.depend() 把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候 Dep.target 就是这个 computed watcher，最后拿到当前 watcher 的 value，当计算属性依赖的数据发生改变的时候，会触发 setter 过程，通知所有订阅它变化的 watcher 进行更新，执行 watcher.update() 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">update <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore else */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lazy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">queueWatcher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"watch-的工作原理\"><a href=\"#watch-的工作原理\" class=\"headerlink\" title=\"watch 的工作原理\"></a>watch 的工作原理<hr></h3><p>和 computed 一样也是在执行 initState 的时候执行了 <code>initWatch(vm, opts.watch)</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initState <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>watch <span class=\"token operator\">&amp;&amp;</span> opts<span class=\"token punctuation\">.</span>watch <span class=\"token operator\">!==</span> nativeWatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">initWatch</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>initWatch 方法定义在 <code>src/core/instance/state.js</code> 中 </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> initWatch <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span> watch<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> watch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 遍历 watch 取到 key </span>\n    <span class=\"token keyword\">const</span> handler <span class=\"token operator\">=</span> watch<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 因为 Vue 是支持 watch 的同一个 key 对应多个 handler，所以如果 handler 是一个数组，则遍历这个数组</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> handler<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">createWatcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">createWatcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> createWatcher <span class=\"token punctuation\">(</span>\n  vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n  expOrFn<span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Function<span class=\"token punctuation\">,</span>\n  handler<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Object\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isPlainObject</span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    options <span class=\"token operator\">=</span> handler\n    handler <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">.</span>handler\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> handler <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    handler <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">[</span>handler<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> vm<span class=\"token punctuation\">.</span><span class=\"token function\">$watch</span><span class=\"token punctuation\">(</span>expOrFn<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 <code>vm.$watch(keyOrFn, handler, options)</code> 函数，vm.$watch 实际上是执行了 Vue.prototype.$watch</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>$watch <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>\n    expOrFn<span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Function<span class=\"token punctuation\">,</span>\n    cb<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n    options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Object\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> vm<span class=\"token punctuation\">:</span> Component <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isPlainObject</span><span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">createWatcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> expOrFn<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    options <span class=\"token operator\">=</span> options <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    options<span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">const</span> watcher <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Watcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> expOrFn<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>immediate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        cb<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> watcher<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">handleError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`callback for immediate watcher \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>watcher<span class=\"token punctuation\">.</span>expression<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"`</span></span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> unwatchFn <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      watcher<span class=\"token punctuation\">.</span><span class=\"token function\">teardown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码可以看到，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 const watcher = new Watcher(vm, expOrFn, cb, options) 实例化了一个 watcher，这里需要注意一点这是一个 user watcher，因为 options.user = true。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，上面还有两点需要注意 如果参数传递的 deep ，这样就创建了一个 deep watcher 则会执行</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行 traverse 函数进行深层递归遍历，那么这样就解决了我们开篇时使用 watch 观察改变一个复杂对象不起作用的问题，那么是 watch 立即执行是怎么做到的呢</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>immediate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    cb<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> watcher<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">handleError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`callback for immediate watcher \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>watcher<span class=\"token punctuation\">.</span>expression<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过设置 immediate 为 true，则直接会执行回调函数 cb。这样就会立即执行 watch 属性</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结<hr></h3><p>通过以上的分析，我们大概了解了计算属性本质上是一个computed watch，侦听属性本质上是一个user watch。计算属性适合在模版渲染中某一个值依赖了其他响应对象甚至是计算属性计算而来，而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>vue 的 computed 和 watch 是我们在开发中经常用的方法，从而实现数据的响应与监听，下面我们从使用和源码来分析一下这两个属性的实现原理是什么。</p>\n<h3 id=\"computed-和-watch-使用\"><a href=\"#computed-和-watch-使用\" class=\"headerlink\" title=\"computed 和 watch 使用\"></a>computed 和 watch 使用<hr></h3><blockquote>\n<p>computed 计算属性，根据依赖的数据动态显示新的计算结果。当依赖的属性值改变之后，通过调用对应的 getter 来计算并进行缓存，计算的属性名称不能在组件的 props 和 data 中定义，否则会报错。</p>\n</blockquote>\n<pre><code class=\"js\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    {{fullName}}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    data() {\n      return {\n        firstName: &#39;ren&#39;,\n        lastName: &quot;bo&quot;\n      }\n    },\n    computed: {\n      fullName() {\n        return this.firstName + &#39; &#39; + this.lastName\n      }\n    }\n}\n&lt;/script&gt;</code></pre>\n<blockquote>\n<p>watcher 侦听属性，当依赖的 data 的数据变化，执行回调方法，在方法中传入 newVal 和 oldVal。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。来实现数据的监听和观察，并在使用watch 的时候可以执行异步操作，设置中间状态等。</p>\n</blockquote>\n<pre><code class=\"js\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    {{fullName}}\n    &lt;button @click=&quot;handleChangName&quot;&gt;改变姓名&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      firstName: &#39;ren&#39;,\n      lastName: &quot;bo&quot;,\n      fullName: &#39;&#39;\n    }\n  },\n  methods: {\n    handleChangName() {\n      this.firstName = &quot;zhang&quot;;\n      this.lastName = &quot;san&quot;\n    }\n  },\n  watch: {\n    firstName: {\n      handler(newval, oldval) {\n        console.log(newval)\n        console.log(oldval)\n        this.fullName = newval + &#39; &#39; + this.lastName\n      },\n      immediate: true\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>watch 只有在数据发生变化的时候，执行回调方法，但是初始化的时候也可以执行，如上面的 firstName 方法中增加 handler 和 immediate 立即执行，具体为什么会立即执行，稍后在做分析，如果我们要监听对象中属性的添加和删除那么我们必须为 watch 中添加 deep 来进行对象深度遍历，进行监听，如下所示</p>\n<pre><code class=\"js\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    {{fullName}}\n    &lt;button @click=&quot;handleChangName&quot;&gt;改变姓名&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      person: {\n        name: &#39;renbo&#39;,\n        age: 26\n      },\n      fullName: &#39;&#39;,\n    }\n  },\n  methods: {\n    handleChangName() {\n      this.person.name = &quot;zhangsan&quot;;\n      this.person.age = 27\n    }\n  },\n  watch: {\n    person: {\n      handler(newVal, oldVal) {\n        this.fullName = newVal.name + newVal.age\n      },\n      immediate: true,\n      deep: true\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<h3 id=\"computed-和-watch-的异同\"><a href=\"#computed-和-watch-的异同\" class=\"headerlink\" title=\"computed 和 watch 的异同\"></a>computed 和 watch 的异同<hr></h3><p>通过上面的使用对比</p>\n<p>相同点</p>\n<ul>\n<li>computed 和watch 都能起到监听和依赖处理数据</li>\n<li>都是通过 vue 的监听器实现的</li>\n</ul>\n<p>不同点</p>\n<ul>\n<li>computed 主要用于对同步数据的处理</li>\n<li>watch 则主要用于监听某个值的变化去完成开销较大的复杂业务逻辑</li>\n</ul>\n<p>主要的应用场景就是如果一个数据依赖另一个数据那么就用 computed，如果在监听数据发生变化去实现某一些功能，状态，异步等那就就用 watch，但是由于 watch 使用deep进行深度遍历监听会消耗性能，所以还是尽量少用 </p>\n<h3 id=\"computed-本质-–-computed-watch\"><a href=\"#computed-本质-–-computed-watch\" class=\"headerlink\" title=\"computed 本质 – computed watch\"></a>computed 本质 – computed watch<hr></h3><p>前面分析过 new Vue() 的时候会调用 _init 方法，该方法会初始化生命周期，初始化事件，初始化render，初始化data，computed，methods，wacther等等，不清楚大致流程的请参考另一篇文章 <a href=\"https://www.studyfe.cn/2019/08/27/vue/vueprinciple/#toc-heading-12\">vue 的主线流程</a>。计算属性的初始化是发生在 vue 实例初始化阶段的 initState 函数中</p>\n<pre><code class=\"js\"> export function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}</code></pre>\n<p>上面进行了判断，我们先来看看 opts.computed 存在的情况执行 initComputed 方法，该方法定义在<code>src/core/instance/state.js</code> 中</p>\n<pre><code class=\"js\">// 用于传入 Watcher 实例的一个对象，即computed watcher\nconst computedWatcherOptions = { lazy: true }\nfunction initComputed (vm: Component, computed: Object) {\n  // 声明 watchers，同时在实例上挂载 _computedWatchers\n  const watchers = vm._computedWatchers = Object.create(null)\n  // 计算属性在 ssr 模式在只能使用 getter 方法\n  const isSSR = isServerRendering()\n\n  for (const key in computed) {\n    // 遍历取出 computed 对象中的每个方法并赋值给 userDef\n    const userDef = computed[key]\n    const getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get\n    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; getter == null) {\n      warn(\n        `Getter is missing for computed property &quot;${key}&quot;.`,\n        vm\n      )\n    }\n\n    if (!isSSR) {\n      // 如果不是SSR服务端渲染，则创建一个watcher实例\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    // 组件定义的计算属性已经在组件原型上定义。我们只需要定义在实例化时定义的计算属性。\n    if (!(key in vm)) {\n      // 如果computed 中的 key 没有设置到 vm 中，通过defineComputed函数挂载上去\n      defineComputed(vm, key, userDef)\n    } else if (process.env.NODE_ENV !== &#39;production&#39;) {\n      // props 和 data 中不能和 computed 的 key 同名\n      if (key in vm.$data) {\n        warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)\n      } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {\n        warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)\n      }\n    }\n  }\n}</code></pre>\n<p>通过上面源码我们发现它先声明了一个名为 watchers 的空对象，同时在 vm 上也挂载了这个空对象。接着对 computed 对象做遍历，拿到每个 userDef，如果 userDef 是 function 的话就赋给 getter，如果不是服务端渲染，就会为这个 getter 创建一个 watcher，这个 watcher 和渲染 watcher 有一点很大的不同，我们在新建实例的时候传入了第四个参数 computedWatcherOptions，其实也就是在代码的第一行，<code>const computedWatcherOptions = { lazy: true }</code>，这个对象是实现computed watcher的关键，这样watcher 中就出现了变化，watcher 定义在 <code>src/core/observer/watcher.js</code></p>\n<pre><code class=\"js\">// ...\n\n// options\nif (options) {\n  this.deep = !!options.deep\n  this.user = !!options.user\n  this.lazy = !!options.lazy\n  this.sync = !!options.sync\n  this.before = options.before\n} else {\n  this.deep = this.user = this.lazy = this.sync = false\n}\nthis.cb = cb\nthis.id = ++uid // uid for batching\nthis.active = true\nthis.dirty = this.lazy // for lazy watchers\n\n// ...</code></pre>\n<p>上面的 this.lazy 实际上就是 computedWatcherOptions 传递过来的，将 dirty 状态改为 true 之后在 createComputedGetter 方法中</p>\n<pre><code class=\"js\">function createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate()\n      }\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\n</code></pre>\n<p>可以看到之后执行了 watcher.evaluate()，通过调用 this.get() 方法实际上就是在执行 <code>value = this.getter.call(vm, vm)</code>，这样就能执行计算属性定义的 getter 函数</p>\n<pre><code class=\"js\">  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }</code></pre>\n<p>之后在执行 watcher.depend() 把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候 Dep.target 就是这个 computed watcher，最后拿到当前 watcher 的 value，当计算属性依赖的数据发生改变的时候，会触发 setter 过程，通知所有订阅它变化的 watcher 进行更新，执行 watcher.update() 方法</p>\n<pre><code class=\"js\">update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }</code></pre>\n<h3 id=\"watch-的工作原理\"><a href=\"#watch-的工作原理\" class=\"headerlink\" title=\"watch 的工作原理\"></a>watch 的工作原理<hr></h3><p>和 computed 一样也是在执行 initState 的时候执行了 <code>initWatch(vm, opts.watch)</code></p>\n<pre><code class=\"js\"> export function initState (vm: Component) {\n   // ...\n  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}</code></pre>\n<p>initWatch 方法定义在 <code>src/core/instance/state.js</code> 中 </p>\n<pre><code class=\"js\">function initWatch (vm: Component, watch: Object) {\n  for (const key in watch) {\n    // 遍历 watch 取到 key \n    const handler = watch[key]\n    if (Array.isArray(handler)) {\n      // 因为 Vue 是支持 watch 的同一个 key 对应多个 handler，所以如果 handler 是一个数组，则遍历这个数组\n      for (let i = 0; i &lt; handler.length; i++) {\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      createWatcher(vm, key, handler)\n    }\n  }\n}</code></pre>\n<pre><code class=\"js\">function createWatcher (\n  vm: Component,\n  expOrFn: string | Function,\n  handler: any,\n  options?: Object\n) {\n  if (isPlainObject(handler)) {\n    options = handler\n    handler = handler.handler\n  }\n  if (typeof handler === &#39;string&#39;) {\n    handler = vm[handler]\n  }\n  return vm.$watch(expOrFn, handler, options)\n}</code></pre>\n<p>通过对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 <code>vm.$watch(keyOrFn, handler, options)</code> 函数，vm.$watch 实际上是执行了 Vue.prototype.$watch</p>\n<pre><code class=\"js\">Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value)\n      } catch (error) {\n        handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }</code></pre>\n<p>通过上面代码可以看到，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 const watcher = new Watcher(vm, expOrFn, cb, options) 实例化了一个 watcher，这里需要注意一点这是一个 user watcher，因为 options.user = true。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，上面还有两点需要注意 如果参数传递的 deep ，这样就创建了一个 deep watcher 则会执行</p>\n<pre><code class=\"js\">get() {\n  let value = this.getter.call(vm, vm)\n  // ...\n  if (this.deep) {\n    traverse(value)\n  }\n}</code></pre>\n<p>执行 traverse 函数进行深层递归遍历，那么这样就解决了我们开篇时使用 watch 观察改变一个复杂对象不起作用的问题，那么是 watch 立即执行是怎么做到的呢</p>\n<pre><code class=\"js\">// ...\nif (options.immediate) {\n  try {\n    cb.call(vm, watcher.value)\n  } catch (error) {\n    handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)\n  }\n}\n//...</code></pre>\n<p>通过设置 immediate 为 true，则直接会执行回调函数 cb。这样就会立即执行 watch 属性</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结<hr></h3><p>通过以上的分析，我们大概了解了计算属性本质上是一个computed watch，侦听属性本质上是一个user watch。计算属性适合在模版渲染中某一个值依赖了其他响应对象甚至是计算属性计算而来，而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>\n"},{"title":"vue 原理之keep-alive","date":"2019-09-22T12:55:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n在我们的平时开发工作中，有很多组件没有必要多次初始化，通过缓存组件的状态减少性能上的开销。而 vue 的组件缓存优化则使用内置组件 <keep-alive>\n\n### 基本用法\n\n```js\n<keep-alive>\n  <component />\n</keep-alive>\n```\n上面代码示例说明被 keep-alive 包含的组件已经成为被缓存的组件，只渲染一次，也就是说生命周期也不起任何作用。但是如果你想要重新在某一个时机想要重新渲染，keep-alive 内置组件提供了两个钩子函数\n\n- activated 当 keepalive 包含的组件再次渲染的时候触发\n- deactivated 当 keepalive 包含的组件销毁的时候触发\n\nvue 对 keep-alive 内置组件还提供了 3个属性作为参数进行匹配对应的组件进行缓存\n\n- include 通过字符串、数组、正则表达式进行匹配，匹配到的组件会进行缓存\n- exclude 通过字符串、数组、正则表达式进行匹配，匹配到的组件不会进行缓存\n- max 通过设置字符或者数字控制组件缓存的最大个数\n\n```js\n// 只缓存a或者b组件\n<keep-alive include=\"a,b\"> \n  <component />\n</keep-alive>\n\n// c组件不被缓存\n<keep-alive exclude=\"c\"> \n  <component />\n</keep-alive>\n\n// 缓存的最大个数\n<keep-alive  max=\"5\"> \n  <component />\n</keep-alive>\n\n// 如果同时使用 exclude 优先级高于 include 所以只缓存 a,c 组件\n<keep-alive include=\"a,b,c\" exclude=\"b\"> \n  <component />\n</keep-alive>\n```\n### 配合 router\n\n```js\n<keep-alive :include=\"cacheList\">\n  <router-view />\n</keep-alive>\n```\n只有路径匹配到的 name 是 cacheList 方法中返回的组件名称就会被缓存，当然也可以所有路由都缓存\n\n```js\n<keep-alive>\n  <router-view>\n      <!-- 所有路径匹配到的视图组件都会被缓存！ -->\n  </router-view>\n</keep-alive>\n```\n\n也可以使用 meta 属性单独控制路由的缓存\n\n```js\n// routes 配置\nexport default [\n  {\n    path: '/',\n    name: 'home',\n    component: Home,\n    meta: {\n      keepAlive: true // 需要被缓存\n    }\n  }, {\n    path: '/user-registration',\n    name: 'user-registration',\n    component: UserRegistrationManager,\n    meta: {\n      keepAlive: false // 不需要被缓存\n    }\n  }\n]\n```\n\n```js\n<keep-alive>\n  <router-view v-if=\"$route.meta.keepAlive\">\n    <!-- 这里是会被缓存的视图组件，比如 Home！ -->\n  </router-view>\n</keep-alive>\n\n<router-view v-if=\"!$route.meta.keepAlive\">\n  <!--   -->\n</router-view>\n```\n\n### 源码理解\n\n通过上面的例子我们已经基本的了解了 keep-alive 的使用，接下来我们通过源码来分析它的实现，它定义在`定义在 src/core/components/keep-alive.js`\n\n```js\nexport default {\n  name: 'keep-alive,\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created () {\n    this.cache = Object.create(null)\n    this.keys = []\n  },\n\n  destroyed () {\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys)\n    }\n  },\n\n  mounted () {\n    this.$watch('include', val => {\n      pruneCache(this, name => matches(val, name))\n    })\n    this.$watch('exclude', val => {\n      pruneCache(this, name => !matches(val, name))\n    })\n  },\n\n  render () {\n    const slot = this.$slots.default\n    const vnode: VNode = getFirstComponentChild(slot)\n    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions\n    if (componentOptions) {\n      // check pattern\n      const name: ?string = getComponentName(componentOptions)\n      const { include, exclude } = this\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      const { cache, keys } = this\n      const key: ?string = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\n        : vnode.key\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance\n        // make current key freshest\n        remove(keys, key)\n        keys.push(key)\n      } else {\n        cache[key] = vnode\n        keys.push(key)\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode)\n        }\n      }\n\n      vnode.data.keepAlive = true\n    }\n    return vnode || (slot && slot[0])\n  }\n}\n```\n\n通过上面源码我们可以看到通过 getFirstComponentChild 函数获取第一个子节点，<keep-alive> 只处理第一个子元素，所以一般和它搭配使用的有 component 动态组件或者是 router-view，之后又根据传的 include 和 exclude， 用 matches 去做匹配，如果命中缓存则直接从缓存中拿 vnode 组件实例，重新调整 key 的顺序，放在最后一个，否则重新放进缓存，如果配置了 max 并且缓存的长度超过了 this.max 则要从缓存中删除第一个\n\n```js\nfunction pruneCacheEntry (\n  cache: VNodeCache,\n  key: string,\n  keys: Array<string>,\n  current?: VNode\n) {\n  const cached = cache[key]\n  if (cached && (!current || cached.tag !== current.tag)) {\n    cached.componentInstance.$destroy()\n  }\n  cache[key] = null \n  remove(keys, key)\n}\n```\n\n\n### 首次渲染\n我们前面介绍过渲染最后在 patch 过程中会执行 createComponent 方法\n\n```js\nfunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should've created a child instance and mounted it. the child\n    // component also has set the placeholder vnode's elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}\n```\n\n当 vnode 已经执行完 patch 后，执行 initComponent 函数：\n\n```js\nfunction initComponent (vnode, insertedVnodeQueue) {\n  if (isDef(vnode.data.pendingInsert)) {\n    insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)\n    vnode.data.pendingInsert = null\n  }\n  vnode.elm = vnode.componentInstance.$el\n  if (isPatchable(vnode)) {\n    invokeCreateHooks(vnode, insertedVnodeQueue)\n    setScope(vnode)\n  } else {\n    // empty component root.\n    // skip all element-related modules except for ref (#3455)\n    registerRef(vnode)\n    // make sure to invoke the insert hook\n    insertedVnodeQueue.push(vnode)\n  }\n}\n```\n\n这里会有 vnode.elm 缓存了 vnode 创建生成的 DOM 节点。所以对于首次渲染而言，除了在 <keep-alive> 中建立缓存，和普通组件渲染没什么区别。\n\n### 缓存渲染\n\n当数据发送变化，在 patch 执行 patchVnode 的逻辑,对比新旧节点之前 会执行 prepatch 函数,定义在 `src/core/vdom/create-component` 中\n\n```js\nconst componentVNodeHooks = {\n  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {\n    const options = vnode.componentOptions\n    const child = vnode.componentInstance = oldVnode.componentInstance\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    )\n  },\n  // ...\n}\n```\n\n它会执行 updateChildComponent 方法，定义在 `src/core/instance/lifecycle.js` 中\n\n```js\nexport function updateChildComponent (\n  vm: Component,\n  propsData: ?Object,\n  listeners: ?Object,\n  parentVnode: MountedComponentVNode,\n  renderChildren: ?Array<VNode>\n) {\n  const hasChildren = !!(\n    renderChildren ||          \n    vm.$options._renderChildren ||\n    parentVnode.data.scopedSlots || \n    vm.$scopedSlots !== emptyObject \n  )\n\n  // ...\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context)\n    vm.$forceUpdate()\n  }\n}\n```\n\n上面看到在执行过中会 触发 <keep-alive> 组件实例 $forceUpdate 逻辑，也就是重新执行 <keep-alive> 的 render 方法，如果这个时候命中缓存，则直接返回 vnode.componentInstance ，再次执行 createComponent \n\n```js\nunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should've created a child instance and mounted it. the child\n    // component also has set the placeholder vnode's elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}\n```\n\n这个时候 isReactivated 为 true，就会执行 reactivateComponent 方法\n\n```js\nunction reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i\n  // hack for #4339: a reactivated component with inner transition\n  // does not trigger because the inner node's created hooks are not called\n  // again. It's not ideal to involve module-specific logic in here but\n  // there doesn't seem to be a better way to do it.\n  let innerNode = vnode\n  while (innerNode.componentInstance) {\n    innerNode = innerNode.componentInstance._vnode\n    if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n      for (i = 0; i < cbs.activate.length; ++i) {\n        cbs.activate[i](emptyNode, innerNode)\n      }\n      insertedVnodeQueue.push(innerNode)\n      break\n    }\n  }\n  // unlike a newly created component,\n  // a reactivated keep-alive component doesn't insert itself\n  insert(parentElm, vnode.elm, refElm)\n}\n```\n\n这个时候会执行 insert(parentElm, vnode.elm, refElm) 就把缓存的 DOM 对象直接插入到目标元素中，所以就不会在执行组件的 created、mounted 等钩子函数了。\n\n<keep-alive> 组件的钩子函数 activated 和 deactivated,则是定义在 insert 方法中,定义在 `src/core/vdom/create-component.js` \n\n```js\nconst componentVNodeHooks = {\n  insert (vnode: MountedComponentVNode) {\n    const { context, componentInstance } = vnode\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true\n      callHook(componentInstance, 'mounted')\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance)\n      } else {\n        activateChildComponent(componentInstance, true /* direct */)\n      }\n    }\n  },\n  // ...\n}\n```\n\n通过判断包裹组件是否被 mounted 分别执行 queueActivatedComponent(componentInstance) 和 activateChildComponent(componentInstance, true)\n\n在上述两个方法中会执行 callHook(vm, 'activated') 钩子函数，唯一不同点是 queueActivatedComponent 是等所有的渲染完毕，在 nextTick后会执行 flushSchedulerQueue，通过队列的方式就是把整个 activated 时机延后的，而组件的 deactivated 钩子，也是同理进行递归销毁。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue/vueKeepAlive.md","raw":"---\ntitle: vue 原理之keep-alive\ndate: 2019-09-22 20:55:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n在我们的平时开发工作中，有很多组件没有必要多次初始化，通过缓存组件的状态减少性能上的开销。而 vue 的组件缓存优化则使用内置组件 <keep-alive>\n\n### 基本用法\n\n```js\n<keep-alive>\n  <component />\n</keep-alive>\n```\n上面代码示例说明被 keep-alive 包含的组件已经成为被缓存的组件，只渲染一次，也就是说生命周期也不起任何作用。但是如果你想要重新在某一个时机想要重新渲染，keep-alive 内置组件提供了两个钩子函数\n\n- activated 当 keepalive 包含的组件再次渲染的时候触发\n- deactivated 当 keepalive 包含的组件销毁的时候触发\n\nvue 对 keep-alive 内置组件还提供了 3个属性作为参数进行匹配对应的组件进行缓存\n\n- include 通过字符串、数组、正则表达式进行匹配，匹配到的组件会进行缓存\n- exclude 通过字符串、数组、正则表达式进行匹配，匹配到的组件不会进行缓存\n- max 通过设置字符或者数字控制组件缓存的最大个数\n\n```js\n// 只缓存a或者b组件\n<keep-alive include=\"a,b\"> \n  <component />\n</keep-alive>\n\n// c组件不被缓存\n<keep-alive exclude=\"c\"> \n  <component />\n</keep-alive>\n\n// 缓存的最大个数\n<keep-alive  max=\"5\"> \n  <component />\n</keep-alive>\n\n// 如果同时使用 exclude 优先级高于 include 所以只缓存 a,c 组件\n<keep-alive include=\"a,b,c\" exclude=\"b\"> \n  <component />\n</keep-alive>\n```\n### 配合 router\n\n```js\n<keep-alive :include=\"cacheList\">\n  <router-view />\n</keep-alive>\n```\n只有路径匹配到的 name 是 cacheList 方法中返回的组件名称就会被缓存，当然也可以所有路由都缓存\n\n```js\n<keep-alive>\n  <router-view>\n      <!-- 所有路径匹配到的视图组件都会被缓存！ -->\n  </router-view>\n</keep-alive>\n```\n\n也可以使用 meta 属性单独控制路由的缓存\n\n```js\n// routes 配置\nexport default [\n  {\n    path: '/',\n    name: 'home',\n    component: Home,\n    meta: {\n      keepAlive: true // 需要被缓存\n    }\n  }, {\n    path: '/user-registration',\n    name: 'user-registration',\n    component: UserRegistrationManager,\n    meta: {\n      keepAlive: false // 不需要被缓存\n    }\n  }\n]\n```\n\n```js\n<keep-alive>\n  <router-view v-if=\"$route.meta.keepAlive\">\n    <!-- 这里是会被缓存的视图组件，比如 Home！ -->\n  </router-view>\n</keep-alive>\n\n<router-view v-if=\"!$route.meta.keepAlive\">\n  <!--   -->\n</router-view>\n```\n\n### 源码理解\n\n通过上面的例子我们已经基本的了解了 keep-alive 的使用，接下来我们通过源码来分析它的实现，它定义在`定义在 src/core/components/keep-alive.js`\n\n```js\nexport default {\n  name: 'keep-alive,\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created () {\n    this.cache = Object.create(null)\n    this.keys = []\n  },\n\n  destroyed () {\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys)\n    }\n  },\n\n  mounted () {\n    this.$watch('include', val => {\n      pruneCache(this, name => matches(val, name))\n    })\n    this.$watch('exclude', val => {\n      pruneCache(this, name => !matches(val, name))\n    })\n  },\n\n  render () {\n    const slot = this.$slots.default\n    const vnode: VNode = getFirstComponentChild(slot)\n    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions\n    if (componentOptions) {\n      // check pattern\n      const name: ?string = getComponentName(componentOptions)\n      const { include, exclude } = this\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      const { cache, keys } = this\n      const key: ?string = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\n        : vnode.key\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance\n        // make current key freshest\n        remove(keys, key)\n        keys.push(key)\n      } else {\n        cache[key] = vnode\n        keys.push(key)\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode)\n        }\n      }\n\n      vnode.data.keepAlive = true\n    }\n    return vnode || (slot && slot[0])\n  }\n}\n```\n\n通过上面源码我们可以看到通过 getFirstComponentChild 函数获取第一个子节点，<keep-alive> 只处理第一个子元素，所以一般和它搭配使用的有 component 动态组件或者是 router-view，之后又根据传的 include 和 exclude， 用 matches 去做匹配，如果命中缓存则直接从缓存中拿 vnode 组件实例，重新调整 key 的顺序，放在最后一个，否则重新放进缓存，如果配置了 max 并且缓存的长度超过了 this.max 则要从缓存中删除第一个\n\n```js\nfunction pruneCacheEntry (\n  cache: VNodeCache,\n  key: string,\n  keys: Array<string>,\n  current?: VNode\n) {\n  const cached = cache[key]\n  if (cached && (!current || cached.tag !== current.tag)) {\n    cached.componentInstance.$destroy()\n  }\n  cache[key] = null \n  remove(keys, key)\n}\n```\n\n\n### 首次渲染\n我们前面介绍过渲染最后在 patch 过程中会执行 createComponent 方法\n\n```js\nfunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should've created a child instance and mounted it. the child\n    // component also has set the placeholder vnode's elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}\n```\n\n当 vnode 已经执行完 patch 后，执行 initComponent 函数：\n\n```js\nfunction initComponent (vnode, insertedVnodeQueue) {\n  if (isDef(vnode.data.pendingInsert)) {\n    insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)\n    vnode.data.pendingInsert = null\n  }\n  vnode.elm = vnode.componentInstance.$el\n  if (isPatchable(vnode)) {\n    invokeCreateHooks(vnode, insertedVnodeQueue)\n    setScope(vnode)\n  } else {\n    // empty component root.\n    // skip all element-related modules except for ref (#3455)\n    registerRef(vnode)\n    // make sure to invoke the insert hook\n    insertedVnodeQueue.push(vnode)\n  }\n}\n```\n\n这里会有 vnode.elm 缓存了 vnode 创建生成的 DOM 节点。所以对于首次渲染而言，除了在 <keep-alive> 中建立缓存，和普通组件渲染没什么区别。\n\n### 缓存渲染\n\n当数据发送变化，在 patch 执行 patchVnode 的逻辑,对比新旧节点之前 会执行 prepatch 函数,定义在 `src/core/vdom/create-component` 中\n\n```js\nconst componentVNodeHooks = {\n  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {\n    const options = vnode.componentOptions\n    const child = vnode.componentInstance = oldVnode.componentInstance\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    )\n  },\n  // ...\n}\n```\n\n它会执行 updateChildComponent 方法，定义在 `src/core/instance/lifecycle.js` 中\n\n```js\nexport function updateChildComponent (\n  vm: Component,\n  propsData: ?Object,\n  listeners: ?Object,\n  parentVnode: MountedComponentVNode,\n  renderChildren: ?Array<VNode>\n) {\n  const hasChildren = !!(\n    renderChildren ||          \n    vm.$options._renderChildren ||\n    parentVnode.data.scopedSlots || \n    vm.$scopedSlots !== emptyObject \n  )\n\n  // ...\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context)\n    vm.$forceUpdate()\n  }\n}\n```\n\n上面看到在执行过中会 触发 <keep-alive> 组件实例 $forceUpdate 逻辑，也就是重新执行 <keep-alive> 的 render 方法，如果这个时候命中缓存，则直接返回 vnode.componentInstance ，再次执行 createComponent \n\n```js\nunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should've created a child instance and mounted it. the child\n    // component also has set the placeholder vnode's elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}\n```\n\n这个时候 isReactivated 为 true，就会执行 reactivateComponent 方法\n\n```js\nunction reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i\n  // hack for #4339: a reactivated component with inner transition\n  // does not trigger because the inner node's created hooks are not called\n  // again. It's not ideal to involve module-specific logic in here but\n  // there doesn't seem to be a better way to do it.\n  let innerNode = vnode\n  while (innerNode.componentInstance) {\n    innerNode = innerNode.componentInstance._vnode\n    if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n      for (i = 0; i < cbs.activate.length; ++i) {\n        cbs.activate[i](emptyNode, innerNode)\n      }\n      insertedVnodeQueue.push(innerNode)\n      break\n    }\n  }\n  // unlike a newly created component,\n  // a reactivated keep-alive component doesn't insert itself\n  insert(parentElm, vnode.elm, refElm)\n}\n```\n\n这个时候会执行 insert(parentElm, vnode.elm, refElm) 就把缓存的 DOM 对象直接插入到目标元素中，所以就不会在执行组件的 created、mounted 等钩子函数了。\n\n<keep-alive> 组件的钩子函数 activated 和 deactivated,则是定义在 insert 方法中,定义在 `src/core/vdom/create-component.js` \n\n```js\nconst componentVNodeHooks = {\n  insert (vnode: MountedComponentVNode) {\n    const { context, componentInstance } = vnode\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true\n      callHook(componentInstance, 'mounted')\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance)\n      } else {\n        activateChildComponent(componentInstance, true /* direct */)\n      }\n    }\n  },\n  // ...\n}\n```\n\n通过判断包裹组件是否被 mounted 分别执行 queueActivatedComponent(componentInstance) 和 activateChildComponent(componentInstance, true)\n\n在上述两个方法中会执行 callHook(vm, 'activated') 钩子函数，唯一不同点是 queueActivatedComponent 是等所有的渲染完毕，在 nextTick后会执行 flushSchedulerQueue，通过队列的方式就是把整个 activated 时机延后的，而组件的 deactivated 钩子，也是同理进行递归销毁。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue/vueKeepAlive","published":1,"updated":"2019-10-15T01:29:42.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owl0092b0u63eah0ie9","content":"<p>在我们的平时开发工作中，有很多组件没有必要多次初始化，通过缓存组件的状态减少性能上的开销。而 vue 的组件缓存优化则使用内置组件 <keep-alive></keep-alive></p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>上面代码示例说明被 keep-alive 包含的组件已经成为被缓存的组件，只渲染一次，也就是说生命周期也不起任何作用。但是如果你想要重新在某一个时机想要重新渲染，keep-alive 内置组件提供了两个钩子函数</p>\n<ul>\n<li>activated 当 keepalive 包含的组件再次渲染的时候触发</li>\n<li>deactivated 当 keepalive 包含的组件销毁的时候触发</li>\n</ul>\n<p>vue 对 keep-alive 内置组件还提供了 3个属性作为参数进行匹配对应的组件进行缓存</p>\n<ul>\n<li>include 通过字符串、数组、正则表达式进行匹配，匹配到的组件会进行缓存</li>\n<li>exclude 通过字符串、数组、正则表达式进行匹配，匹配到的组件不会进行缓存</li>\n<li>max 通过设置字符或者数字控制组件缓存的最大个数</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 只缓存a或者b组件</span>\n<span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive include<span class=\"token operator\">=</span><span class=\"token string\">\"a,b\"</span><span class=\"token operator\">></span> \n  <span class=\"token operator\">&lt;</span>component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// c组件不被缓存</span>\n<span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive exclude<span class=\"token operator\">=</span><span class=\"token string\">\"c\"</span><span class=\"token operator\">></span> \n  <span class=\"token operator\">&lt;</span>component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 缓存的最大个数</span>\n<span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive  max<span class=\"token operator\">=</span><span class=\"token string\">\"5\"</span><span class=\"token operator\">></span> \n  <span class=\"token operator\">&lt;</span>component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 如果同时使用 exclude 优先级高于 include 所以只缓存 a,c 组件</span>\n<span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive include<span class=\"token operator\">=</span><span class=\"token string\">\"a,b,c\"</span> exclude<span class=\"token operator\">=</span><span class=\"token string\">\"b\"</span><span class=\"token operator\">></span> \n  <span class=\"token operator\">&lt;</span>component <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"配合-router\"><a href=\"#配合-router\" class=\"headerlink\" title=\"配合 router\"></a>配合 router</h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive <span class=\"token punctuation\">:</span>include<span class=\"token operator\">=</span><span class=\"token string\">\"cacheList\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>view <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>只有路径匹配到的 name 是 cacheList 方法中返回的组件名称就会被缓存，当然也可以所有路由都缓存</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>view<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 所有路径匹配到的视图组件都会被缓存！ <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>router<span class=\"token operator\">-</span>view<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>也可以使用 meta 属性单独控制路由的缓存</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// routes 配置</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">'home'</span><span class=\"token punctuation\">,</span>\n    component<span class=\"token punctuation\">:</span> Home<span class=\"token punctuation\">,</span>\n    meta<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      keepAlive<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">// 需要被缓存</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/user-registration'</span><span class=\"token punctuation\">,</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">'user-registration'</span><span class=\"token punctuation\">,</span>\n    component<span class=\"token punctuation\">:</span> UserRegistrationManager<span class=\"token punctuation\">,</span>\n    meta<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      keepAlive<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token comment\" spellcheck=\"true\">// 不需要被缓存</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>view v<span class=\"token operator\">-</span><span class=\"token keyword\">if</span><span class=\"token operator\">=</span><span class=\"token string\">\"$route.meta.keepAlive\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 这里是会被缓存的视图组件，比如 Home！ <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>router<span class=\"token operator\">-</span>view<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>keep<span class=\"token operator\">-</span>alive<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>router<span class=\"token operator\">-</span>view v<span class=\"token operator\">-</span><span class=\"token keyword\">if</span><span class=\"token operator\">=</span><span class=\"token string\">\"!$route.meta.keepAlive\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>   <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>router<span class=\"token operator\">-</span>view<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"源码理解\"><a href=\"#源码理解\" class=\"headerlink\" title=\"源码理解\"></a>源码理解</h3><p>通过上面的例子我们已经基本的了解了 keep-alive 的使用，接下来我们通过源码来分析它的实现，它定义在<code>定义在 src/core/components/keep-alive.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> 'keep<span class=\"token operator\">-</span>alive<span class=\"token punctuation\">,</span>\n  abstract<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n  props<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    include<span class=\"token punctuation\">:</span> patternTypes<span class=\"token punctuation\">,</span>\n    exclude<span class=\"token punctuation\">:</span> patternTypes<span class=\"token punctuation\">,</span>\n    max<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>String<span class=\"token punctuation\">,</span> Number<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  created <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cache <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>keys <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  destroyed <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">pruneCacheEntry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  mounted <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">$watch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'include'</span><span class=\"token punctuation\">,</span> val <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">pruneCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">matches</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">$watch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'exclude'</span><span class=\"token punctuation\">,</span> val <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">pruneCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token operator\">!</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  render <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> slot <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$slots<span class=\"token punctuation\">.</span><span class=\"token keyword\">default</span>\n    <span class=\"token keyword\">const</span> vnode<span class=\"token punctuation\">:</span> VNode <span class=\"token operator\">=</span> <span class=\"token function\">getFirstComponentChild</span><span class=\"token punctuation\">(</span>slot<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> componentOptions<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>VNodeComponentOptions <span class=\"token operator\">=</span> vnode <span class=\"token operator\">&amp;&amp;</span> vnode<span class=\"token punctuation\">.</span>componentOptions\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>componentOptions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// check pattern</span>\n      <span class=\"token keyword\">const</span> name<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>string <span class=\"token operator\">=</span> <span class=\"token function\">getComponentName</span><span class=\"token punctuation\">(</span>componentOptions<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> include<span class=\"token punctuation\">,</span> exclude <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token comment\" spellcheck=\"true\">// not included</span>\n        <span class=\"token punctuation\">(</span>include <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>name <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span>include<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n        <span class=\"token comment\" spellcheck=\"true\">// excluded</span>\n        <span class=\"token punctuation\">(</span>exclude <span class=\"token operator\">&amp;&amp;</span> name <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">matches</span><span class=\"token punctuation\">(</span>exclude<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> vnode\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> cache<span class=\"token punctuation\">,</span> keys <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n      <span class=\"token keyword\">const</span> key<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>string <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>key <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span>\n        <span class=\"token comment\" spellcheck=\"true\">// same constructor may get registered as different local components</span>\n        <span class=\"token comment\" spellcheck=\"true\">// so cid alone is not enough (#3269)</span>\n        <span class=\"token operator\">?</span> componentOptions<span class=\"token punctuation\">.</span>Ctor<span class=\"token punctuation\">.</span>cid <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>componentOptions<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token string\">`::</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>componentOptions<span class=\"token punctuation\">.</span>tag<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span> <span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">:</span> vnode<span class=\"token punctuation\">.</span>key\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        vnode<span class=\"token punctuation\">.</span>componentInstance <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>componentInstance\n        <span class=\"token comment\" spellcheck=\"true\">// make current key freshest</span>\n        <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n        keys<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> vnode\n        keys<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// prune oldest entry</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>max <span class=\"token operator\">&amp;&amp;</span> keys<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">pruneCacheEntry</span><span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_vnode<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>keepAlive <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> vnode <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>slot <span class=\"token operator\">&amp;&amp;</span> slot<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面源码我们可以看到通过 getFirstComponentChild 函数获取第一个子节点，<keep-alive> 只处理第一个子元素，所以一般和它搭配使用的有 component 动态组件或者是 router-view，之后又根据传的 include 和 exclude， 用 matches 去做匹配，如果命中缓存则直接从缓存中拿 vnode 组件实例，重新调整 key 的顺序，放在最后一个，否则重新放进缓存，如果配置了 max 并且缓存的长度超过了 this.max 则要从缓存中删除第一个</keep-alive></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> pruneCacheEntry <span class=\"token punctuation\">(</span>\n  cache<span class=\"token punctuation\">:</span> VNodeCache<span class=\"token punctuation\">,</span>\n  key<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  keys<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  current<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> VNode\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> cached <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cached <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>current <span class=\"token operator\">||</span> cached<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">!==</span> current<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cached<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">.</span><span class=\"token function\">$destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> \n  <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"首次渲染\"><a href=\"#首次渲染\" class=\"headerlink\" title=\"首次渲染\"></a>首次渲染</h3><p>我们前面介绍过渲染最后在 patch 过程中会执行 createComponent 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> createComponent <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>data\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> isReactivated <span class=\"token operator\">=</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> i<span class=\"token punctuation\">.</span>keepAlive\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>init<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span> <span class=\"token comment\" spellcheck=\"true\">/* hydrating */</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// after calling the init hook, if the vnode is a child component</span>\n    <span class=\"token comment\" spellcheck=\"true\">// it should've created a child instance and mounted it. the child</span>\n    <span class=\"token comment\" spellcheck=\"true\">// component also has set the placeholder vnode's elm.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// in that case we can just return the element and be done.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">initComponent</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>isReactivated<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reactivateComponent</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当 vnode 已经执行完 patch 后，执行 initComponent 函数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> initComponent <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>pendingInsert<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    insertedVnodeQueue<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>insertedVnodeQueue<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>pendingInsert<span class=\"token punctuation\">)</span>\n    vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>pendingInsert <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span>\n  vnode<span class=\"token punctuation\">.</span>elm <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">.</span>$el\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isPatchable</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">invokeCreateHooks</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">setScope</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// empty component root.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// skip all element-related modules except for ref (#3455)</span>\n    <span class=\"token function\">registerRef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// make sure to invoke the insert hook</span>\n    insertedVnodeQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里会有 vnode.elm 缓存了 vnode 创建生成的 DOM 节点。所以对于首次渲染而言，除了在 <keep-alive> 中建立缓存，和普通组件渲染没什么区别。</keep-alive></p>\n<h3 id=\"缓存渲染\"><a href=\"#缓存渲染\" class=\"headerlink\" title=\"缓存渲染\"></a>缓存渲染</h3><p>当数据发送变化，在 patch 执行 patchVnode 的逻辑,对比新旧节点之前 会执行 prepatch 函数,定义在 <code>src/core/vdom/create-component</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> componentVNodeHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  prepatch <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentOptions\n    <span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentInstance <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>componentInstance\n    <span class=\"token function\">updateChildComponent</span><span class=\"token punctuation\">(</span>\n      child<span class=\"token punctuation\">,</span>\n      options<span class=\"token punctuation\">.</span>propsData<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// updated props</span>\n      options<span class=\"token punctuation\">.</span>listeners<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// updated listeners</span>\n      vnode<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// new parent vnode</span>\n      options<span class=\"token punctuation\">.</span>children <span class=\"token comment\" spellcheck=\"true\">// new children</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>它会执行 updateChildComponent 方法，定义在 <code>src/core/instance/lifecycle.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> updateChildComponent <span class=\"token punctuation\">(</span>\n  vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n  propsData<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Object<span class=\"token punctuation\">,</span>\n  listeners<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Object<span class=\"token punctuation\">,</span>\n  parentVnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">,</span>\n  renderChildren<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Array<span class=\"token operator\">&lt;</span>VNode<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hasChildren <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>\n    renderChildren <span class=\"token operator\">||</span>          \n    vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>_renderChildren <span class=\"token operator\">||</span>\n    parentVnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>scopedSlots <span class=\"token operator\">||</span> \n    vm<span class=\"token punctuation\">.</span>$scopedSlots <span class=\"token operator\">!==</span> emptyObject \n  <span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasChildren<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span>$slots <span class=\"token operator\">=</span> <span class=\"token function\">resolveSlots</span><span class=\"token punctuation\">(</span>renderChildren<span class=\"token punctuation\">,</span> parentVnode<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">)</span>\n    vm<span class=\"token punctuation\">.</span><span class=\"token function\">$forceUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面看到在执行过中会 触发 <keep-alive> 组件实例 $forceUpdate 逻辑，也就是重新执行 <keep-alive> 的 render 方法，如果这个时候命中缓存，则直接返回 vnode.componentInstance ，再次执行 createComponent </keep-alive></keep-alive></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">unction createComponent <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>data\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> isReactivated <span class=\"token operator\">=</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> i<span class=\"token punctuation\">.</span>keepAlive\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>init<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span> <span class=\"token comment\" spellcheck=\"true\">/* hydrating */</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// after calling the init hook, if the vnode is a child component</span>\n    <span class=\"token comment\" spellcheck=\"true\">// it should've created a child instance and mounted it. the child</span>\n    <span class=\"token comment\" spellcheck=\"true\">// component also has set the placeholder vnode's elm.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// in that case we can just return the element and be done.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">initComponent</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>isReactivated<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reactivateComponent</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个时候 isReactivated 为 true，就会执行 reactivateComponent 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">unction reactivateComponent <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i\n  <span class=\"token comment\" spellcheck=\"true\">// hack for #4339: a reactivated component with inner transition</span>\n  <span class=\"token comment\" spellcheck=\"true\">// does not trigger because the inner node's created hooks are not called</span>\n  <span class=\"token comment\" spellcheck=\"true\">// again. It's not ideal to involve module-specific logic in here but</span>\n  <span class=\"token comment\" spellcheck=\"true\">// there doesn't seem to be a better way to do it.</span>\n  <span class=\"token keyword\">let</span> innerNode <span class=\"token operator\">=</span> vnode\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>innerNode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    innerNode <span class=\"token operator\">=</span> innerNode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">.</span>_vnode\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> innerNode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>transition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>activate<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cbs<span class=\"token punctuation\">.</span>activate<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>emptyNode<span class=\"token punctuation\">,</span> innerNode<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      insertedVnodeQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>innerNode<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">break</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// unlike a newly created component,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// a reactivated keep-alive component doesn't insert itself</span>\n  <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个时候会执行 insert(parentElm, vnode.elm, refElm) 就把缓存的 DOM 对象直接插入到目标元素中，所以就不会在执行组件的 created、mounted 等钩子函数了。</p>\n<p><keep-alive> 组件的钩子函数 activated 和 deactivated,则是定义在 insert 方法中,定义在 <code>src/core/vdom/create-component.js</code> </keep-alive></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> componentVNodeHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  insert <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> context<span class=\"token punctuation\">,</span> componentInstance <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> vnode\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>componentInstance<span class=\"token punctuation\">.</span>_isMounted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      componentInstance<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>componentInstance<span class=\"token punctuation\">,</span> <span class=\"token string\">'mounted'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>keepAlive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>_isMounted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// vue-router#1212</span>\n        <span class=\"token comment\" spellcheck=\"true\">// During updates, a kept-alive component's child components may</span>\n        <span class=\"token comment\" spellcheck=\"true\">// change, so directly walking the tree here may call activated hooks</span>\n        <span class=\"token comment\" spellcheck=\"true\">// on incorrect children. Instead we push them into a queue which will</span>\n        <span class=\"token comment\" spellcheck=\"true\">// be processed after the whole patch process ended.</span>\n        <span class=\"token function\">queueActivatedComponent</span><span class=\"token punctuation\">(</span>componentInstance<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">activateChildComponent</span><span class=\"token punctuation\">(</span>componentInstance<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* direct */</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过判断包裹组件是否被 mounted 分别执行 queueActivatedComponent(componentInstance) 和 activateChildComponent(componentInstance, true)</p>\n<p>在上述两个方法中会执行 callHook(vm, ‘activated’) 钩子函数，唯一不同点是 queueActivatedComponent 是等所有的渲染完毕，在 nextTick后会执行 flushSchedulerQueue，通过队列的方式就是把整个 activated 时机延后的，而组件的 deactivated 钩子，也是同理进行递归销毁。</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>在我们的平时开发工作中，有很多组件没有必要多次初始化，通过缓存组件的状态减少性能上的开销。而 vue 的组件缓存优化则使用内置组件 <keep-alive></keep-alive></p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><pre><code class=\"js\">&lt;keep-alive&gt;\n  &lt;component /&gt;\n&lt;/keep-alive&gt;</code></pre>\n<p>上面代码示例说明被 keep-alive 包含的组件已经成为被缓存的组件，只渲染一次，也就是说生命周期也不起任何作用。但是如果你想要重新在某一个时机想要重新渲染，keep-alive 内置组件提供了两个钩子函数</p>\n<ul>\n<li>activated 当 keepalive 包含的组件再次渲染的时候触发</li>\n<li>deactivated 当 keepalive 包含的组件销毁的时候触发</li>\n</ul>\n<p>vue 对 keep-alive 内置组件还提供了 3个属性作为参数进行匹配对应的组件进行缓存</p>\n<ul>\n<li>include 通过字符串、数组、正则表达式进行匹配，匹配到的组件会进行缓存</li>\n<li>exclude 通过字符串、数组、正则表达式进行匹配，匹配到的组件不会进行缓存</li>\n<li>max 通过设置字符或者数字控制组件缓存的最大个数</li>\n</ul>\n<pre><code class=\"js\">// 只缓存a或者b组件\n&lt;keep-alive include=&quot;a,b&quot;&gt; \n  &lt;component /&gt;\n&lt;/keep-alive&gt;\n\n// c组件不被缓存\n&lt;keep-alive exclude=&quot;c&quot;&gt; \n  &lt;component /&gt;\n&lt;/keep-alive&gt;\n\n// 缓存的最大个数\n&lt;keep-alive  max=&quot;5&quot;&gt; \n  &lt;component /&gt;\n&lt;/keep-alive&gt;\n\n// 如果同时使用 exclude 优先级高于 include 所以只缓存 a,c 组件\n&lt;keep-alive include=&quot;a,b,c&quot; exclude=&quot;b&quot;&gt; \n  &lt;component /&gt;\n&lt;/keep-alive&gt;</code></pre>\n<h3 id=\"配合-router\"><a href=\"#配合-router\" class=\"headerlink\" title=\"配合 router\"></a>配合 router</h3><pre><code class=\"js\">&lt;keep-alive :include=&quot;cacheList&quot;&gt;\n  &lt;router-view /&gt;\n&lt;/keep-alive&gt;</code></pre>\n<p>只有路径匹配到的 name 是 cacheList 方法中返回的组件名称就会被缓存，当然也可以所有路由都缓存</p>\n<pre><code class=\"js\">&lt;keep-alive&gt;\n  &lt;router-view&gt;\n      &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;\n  &lt;/router-view&gt;\n&lt;/keep-alive&gt;</code></pre>\n<p>也可以使用 meta 属性单独控制路由的缓存</p>\n<pre><code class=\"js\">// routes 配置\nexport default [\n  {\n    path: &#39;/&#39;,\n    name: &#39;home&#39;,\n    component: Home,\n    meta: {\n      keepAlive: true // 需要被缓存\n    }\n  }, {\n    path: &#39;/user-registration&#39;,\n    name: &#39;user-registration&#39;,\n    component: UserRegistrationManager,\n    meta: {\n      keepAlive: false // 不需要被缓存\n    }\n  }\n]</code></pre>\n<pre><code class=\"js\">&lt;keep-alive&gt;\n  &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;\n    &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;\n  &lt;/router-view&gt;\n&lt;/keep-alive&gt;\n\n&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;\n  &lt;!--   --&gt;\n&lt;/router-view&gt;</code></pre>\n<h3 id=\"源码理解\"><a href=\"#源码理解\" class=\"headerlink\" title=\"源码理解\"></a>源码理解</h3><p>通过上面的例子我们已经基本的了解了 keep-alive 的使用，接下来我们通过源码来分析它的实现，它定义在<code>定义在 src/core/components/keep-alive.js</code></p>\n<pre><code class=\"js\">export default {\n  name: &#39;keep-alive,\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created () {\n    this.cache = Object.create(null)\n    this.keys = []\n  },\n\n  destroyed () {\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys)\n    }\n  },\n\n  mounted () {\n    this.$watch(&#39;include&#39;, val =&gt; {\n      pruneCache(this, name =&gt; matches(val, name))\n    })\n    this.$watch(&#39;exclude&#39;, val =&gt; {\n      pruneCache(this, name =&gt; !matches(val, name))\n    })\n  },\n\n  render () {\n    const slot = this.$slots.default\n    const vnode: VNode = getFirstComponentChild(slot)\n    const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions\n    if (componentOptions) {\n      // check pattern\n      const name: ?string = getComponentName(componentOptions)\n      const { include, exclude } = this\n      if (\n        // not included\n        (include &amp;&amp; (!name || !matches(include, name))) ||\n        // excluded\n        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      const { cache, keys } = this\n      const key: ?string = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : &#39;&#39;)\n        : vnode.key\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance\n        // make current key freshest\n        remove(keys, key)\n        keys.push(key)\n      } else {\n        cache[key] = vnode\n        keys.push(key)\n        // prune oldest entry\n        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode)\n        }\n      }\n\n      vnode.data.keepAlive = true\n    }\n    return vnode || (slot &amp;&amp; slot[0])\n  }\n}</code></pre>\n<p>通过上面源码我们可以看到通过 getFirstComponentChild 函数获取第一个子节点，<keep-alive> 只处理第一个子元素，所以一般和它搭配使用的有 component 动态组件或者是 router-view，之后又根据传的 include 和 exclude， 用 matches 去做匹配，如果命中缓存则直接从缓存中拿 vnode 组件实例，重新调整 key 的顺序，放在最后一个，否则重新放进缓存，如果配置了 max 并且缓存的长度超过了 this.max 则要从缓存中删除第一个</keep-alive></p>\n<pre><code class=\"js\">function pruneCacheEntry (\n  cache: VNodeCache,\n  key: string,\n  keys: Array&lt;string&gt;,\n  current?: VNode\n) {\n  const cached = cache[key]\n  if (cached &amp;&amp; (!current || cached.tag !== current.tag)) {\n    cached.componentInstance.$destroy()\n  }\n  cache[key] = null \n  remove(keys, key)\n}</code></pre>\n<h3 id=\"首次渲染\"><a href=\"#首次渲染\" class=\"headerlink\" title=\"首次渲染\"></a>首次渲染</h3><p>我们前面介绍过渲染最后在 patch 过程中会执行 createComponent 方法</p>\n<pre><code class=\"js\">function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive\n    if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should&#39;ve created a child instance and mounted it. the child\n    // component also has set the placeholder vnode&#39;s elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}</code></pre>\n<p>当 vnode 已经执行完 patch 后，执行 initComponent 函数：</p>\n<pre><code class=\"js\">function initComponent (vnode, insertedVnodeQueue) {\n  if (isDef(vnode.data.pendingInsert)) {\n    insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)\n    vnode.data.pendingInsert = null\n  }\n  vnode.elm = vnode.componentInstance.$el\n  if (isPatchable(vnode)) {\n    invokeCreateHooks(vnode, insertedVnodeQueue)\n    setScope(vnode)\n  } else {\n    // empty component root.\n    // skip all element-related modules except for ref (#3455)\n    registerRef(vnode)\n    // make sure to invoke the insert hook\n    insertedVnodeQueue.push(vnode)\n  }\n}</code></pre>\n<p>这里会有 vnode.elm 缓存了 vnode 创建生成的 DOM 节点。所以对于首次渲染而言，除了在 <keep-alive> 中建立缓存，和普通组件渲染没什么区别。</keep-alive></p>\n<h3 id=\"缓存渲染\"><a href=\"#缓存渲染\" class=\"headerlink\" title=\"缓存渲染\"></a>缓存渲染</h3><p>当数据发送变化，在 patch 执行 patchVnode 的逻辑,对比新旧节点之前 会执行 prepatch 函数,定义在 <code>src/core/vdom/create-component</code> 中</p>\n<pre><code class=\"js\">const componentVNodeHooks = {\n  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {\n    const options = vnode.componentOptions\n    const child = vnode.componentInstance = oldVnode.componentInstance\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    )\n  },\n  // ...\n}</code></pre>\n<p>它会执行 updateChildComponent 方法，定义在 <code>src/core/instance/lifecycle.js</code> 中</p>\n<pre><code class=\"js\">export function updateChildComponent (\n  vm: Component,\n  propsData: ?Object,\n  listeners: ?Object,\n  parentVnode: MountedComponentVNode,\n  renderChildren: ?Array&lt;VNode&gt;\n) {\n  const hasChildren = !!(\n    renderChildren ||          \n    vm.$options._renderChildren ||\n    parentVnode.data.scopedSlots || \n    vm.$scopedSlots !== emptyObject \n  )\n\n  // ...\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context)\n    vm.$forceUpdate()\n  }\n}</code></pre>\n<p>上面看到在执行过中会 触发 <keep-alive> 组件实例 $forceUpdate 逻辑，也就是重新执行 <keep-alive> 的 render 方法，如果这个时候命中缓存，则直接返回 vnode.componentInstance ，再次执行 createComponent </keep-alive></keep-alive></p>\n<pre><code class=\"js\">unction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive\n    if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should&#39;ve created a child instance and mounted it. the child\n    // component also has set the placeholder vnode&#39;s elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}</code></pre>\n<p>这个时候 isReactivated 为 true，就会执行 reactivateComponent 方法</p>\n<pre><code class=\"js\">unction reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i\n  // hack for #4339: a reactivated component with inner transition\n  // does not trigger because the inner node&#39;s created hooks are not called\n  // again. It&#39;s not ideal to involve module-specific logic in here but\n  // there doesn&#39;t seem to be a better way to do it.\n  let innerNode = vnode\n  while (innerNode.componentInstance) {\n    innerNode = innerNode.componentInstance._vnode\n    if (isDef(i = innerNode.data) &amp;&amp; isDef(i = i.transition)) {\n      for (i = 0; i &lt; cbs.activate.length; ++i) {\n        cbs.activate[i](emptyNode, innerNode)\n      }\n      insertedVnodeQueue.push(innerNode)\n      break\n    }\n  }\n  // unlike a newly created component,\n  // a reactivated keep-alive component doesn&#39;t insert itself\n  insert(parentElm, vnode.elm, refElm)\n}</code></pre>\n<p>这个时候会执行 insert(parentElm, vnode.elm, refElm) 就把缓存的 DOM 对象直接插入到目标元素中，所以就不会在执行组件的 created、mounted 等钩子函数了。</p>\n<p><keep-alive> 组件的钩子函数 activated 和 deactivated,则是定义在 insert 方法中,定义在 <code>src/core/vdom/create-component.js</code> </keep-alive></p>\n<pre><code class=\"js\">const componentVNodeHooks = {\n  insert (vnode: MountedComponentVNode) {\n    const { context, componentInstance } = vnode\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true\n      callHook(componentInstance, &#39;mounted&#39;)\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component&#39;s child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance)\n      } else {\n        activateChildComponent(componentInstance, true /* direct */)\n      }\n    }\n  },\n  // ...\n}</code></pre>\n<p>通过判断包裹组件是否被 mounted 分别执行 queueActivatedComponent(componentInstance) 和 activateChildComponent(componentInstance, true)</p>\n<p>在上述两个方法中会执行 callHook(vm, ‘activated’) 钩子函数，唯一不同点是 queueActivatedComponent 是等所有的渲染完毕，在 nextTick后会执行 flushSchedulerQueue，通过队列的方式就是把整个 activated 时机延后的，而组件的 deactivated 钩子，也是同理进行递归销毁。</p>\n"},{"title":"vue 原理之生命周期","date":"2019-09-21T05:50:28.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n每一个 vue 的实例在创建的时候都经过一系列的初始化操作，在每一个阶段都会有相对应的生命周期钩子函数，来在特定的场景实现一些功能\n\n\n### 生命周期方法<hr>\n\n- beforeCreate（实例创建前）\n- created（实例创建后）\n- beforeMount（渲染 DOM 前）\n- mounted（渲染 DOM 后）\n- beforeUpdate（更新数据前）\n- updated（更新数据后）\n- beforeDestroy（销毁组件前）\n- destroyed（销毁组件后）\n\n\n\n\n### 执行流程 <hr>\n\n通过上面生命周期的方法，看一下来至官网的一张神图，告诉我们大致的工作流程。通过每个阶段的源码来分析，在日常开发中遇到的问题。比如到底那个阶段做请求好，父子组件的生命周期在不同情况的下执行顺序是怎样的。\n\n<img src=\"/images/lifecycle.png\" width=\"50%\">\n\n\n### callHook<hr>\n\n我们在介绍 vue 主流程的时候知道首先会执行实例的 _init(options)，然后会执行一个 merge options 的逻辑，通过调用 mergeOptions 处理不同的合并策略，其中 mergeHook 就是关于生命周期的\n\n```js\nfunction mergeHook (\n  parentVal: ?Array<Function>,\n  childVal: ?Function | ?Array<Function>\n): ?Array<Function> {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(hook => {\n  strats[hook] = mergeHook\n})\n\n```\n\n这其中的 LIFECYCLE_HOOKS 的定义在 `src/shared/constants.js` 中：\n\n```js\nexport const LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n]\n```\n\n通过上面我们看到了生命周期的钩子函数， 然后再通过 callHook 就能调用某个生命周期钩子注册的所有回调函数了，callHook 定义在 `src/core/instance/lifecycle.js` 中\n\n```js\nexport function callHook (vm: Component, hook: string) {\n  pushTarget()\n  const handlers = vm.$options[hook] \n  const info = `${hook} hook`\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info)\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook)\n  }\n  popTarget()\n}\n```\n\n上面 callHook 主要执行了 invokeWithErrorHandling 定义在 `src/core/util/error.js` 中\n\n```js\nexport function invokeWithErrorHandling (\n  handler: Function,\n  context: any,\n  args: null | any[],\n  vm: any,\n  info: string\n) {\n  let res\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context)\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res._handled = true\n    }\n  } catch (e) {\n    handleError(e, vm, info)\n  }\n  return res\n}\n```\n\n通过调用 handler.apply(context, args) : handler.call(context)，改变了当前的 this，这就是我们在写生命周期的时候不能用箭头函数的原因。接下来我们继续探讨生命周期的执行时机。\n\n### beforeCreate & created<hr>\n\n这两个钩子函数主要是在 vue 初始化实例阶段，定义在 `src/core/instance/init.js` 中\n\n```js\nVue.prototype._init = function (options?: Object) {\n  // ...\n  initLifecycle(vm)\n  initEvents(vm)\n  initRender(vm)\n  callHook(vm, 'beforeCreate')\n  initInjections(vm) // resolve injections before data/props\n  initState(vm)\n  initProvide(vm) // resolve provide after data/props\n  callHook(vm, 'created')\n  // ...\n}\n```\n\n可以看到 beforeCreate 是在初始化生命周期、事件，渲染函数之后调用，那么 created 是在初始化 initInjections、initState 等函数之后，那么这里的 initState 在前面的文章说过，主要是初始化 props、data、methods、watch、computed 等属性，所以 beforeCreate 中是不能够操作 data、props 等数据、也不能调用 methods 中定义的函数。 \n\n### beforeMount & mounted <hr>\n\n在 mounted 阶段主要是执行了 mountComponent 方法，核心就是先实例化一个渲染 Watcher，在前面主流程中和响应式数据中我们经常提到两个核型方法 vm._render() 和 vm._update()，用于生成 DOM，mountComponent 方法定义在 `src/core/instance/lifecycle` 中\n\n```js\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    ...\n  }\n  callHook(vm, 'beforeMount')  // beforeMount 钩子\n\n  let updateComponent\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      //...\n      // 渲染 VNode\n      const vnode = vm._render()\n      // ...\n\n      // 渲染真实 DOM\n      vm._update(vnode, hydrating)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n     // 判断是否 mouted 完成阶段并且没有被销毁\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate') // 数据更新之前\n      }\n    }\n  }, true /* isRenderWatcher */)\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')  // mounted 钩子\n  }\n  return vm\n}\n```\n\n通过上面的代码，我们可以看出 beforeMount 钩子函数是在执行 vm._render() 函数渲染 VNode 之前执行的 ，在执行完 vm._update() 把 VNode patch 到真实 DOM 后，执行 mouted 钩子。上面有个逻辑 `vm.$vnode == null` 这表明不是一次组件的初始化过程，而是通过 new Vue() 创建的。当组件的 VNode patch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue 里保存的钩子函数依次执行一遍，它的定义在 `src/core/vdom/patch.js` 中\n\n```js\nfunction invokeInsertHook (vnode, queue, initial) {\n  // 在真正插入元素后调用，延迟组件根节点的插入钩子，\n  if (isTrue(initial) && isDef(vnode.parent)) {\n    vnode.parent.data.pendingInsert = queue\n  } else {\n    for (let i = 0; i < queue.length; ++i) {\n      queue[i].data.hook.insert(queue[i])\n    }\n  }\n}\n```\n\n该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 `src/core/vdom/create-component.js` 中的 componentVNodeHooks 中\n\n```js\nconst componentVNodeHooks = {\n  // ...\n  insert (vnode: MountedComponentVNode) {\n    const { context, componentInstance } = vnode\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true\n      callHook(componentInstance, 'mounted')\n    }\n    // ...\n  },\n}\n```\n\n每个子组件都是在这个钩子函数中执行 mounted 钩子函数，insertedVnodeQueue 的添加顺序是先子后父，所以对于同步渲染的子组件而言，mounted 钩子函数的执行顺序也是先子后父。\n\n### beforeUpdate & updated <hr>\n\nupdated 阶段也就是数据的依赖收集更新阶段，在响应式数据中我们已经提到，在文件 `src/core/instance/lifecycle` 中定义\n\n```js\n new Watcher(vm, updateComponent, noop, {\n    before () {\n      // 判断是否 mouted 完成阶段并且没有被销毁\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate')  // 调用 beforeUpdate 钩子\n      }\n    }\n  }, true /* isRenderWatcher */)\n\n```\n\n通过上面可以看到 beforeUpdate 是在满足 vm._isMounted && !vm._isDestroyed 条件才会被调用的,那么 updated 调用时机是在哪里呢，它被定义在 `src/core/observer/scheduler.js`\n\n```js\nfunction callUpdatedHooks (queue) {\n  let i = queue.length\n  while (i--) {\n    const watcher = queue[i]\n    const vm = watcher.vm\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated')\n    }\n  }\n}\n```\n\n我们可以看到在执行 updated 之前，对 watcher 队列进行了遍历，只有条件满足当前 watcher 为 vm._watcher 和 mounted 阶段，才会执行 updated 钩子函数，那么接下来我们看一下 watcher 到底做了什么，其实在响应式数据中我们已经分析过，被定义在 `src/instance/observer/watcher.js` 中\n\n```js\nexport default class Watcher {\n  // ...\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    ...\n}\n```\n\n在 watcher 实例化的过程中会会判断 isRenderWatcher。 接着把当前 watcher 的实例赋值给 vm._watcher,同时将 watcher 的实例 push 到 vm._watchers 中。通过 vm._watcher 对 vm 上数据变化的监测，当数据发生变化就会重新渲染。所以在 callUpdatedHooks 函数中，只有 vm._watcher 的回调执行完毕后，才会执 updated 钩子函数。所以是通过 watcher 监听实例上的数据变化来控制整个 vue 的渲染流程。\n\n### beforeDestroy & destroyed<hr>\n\n这个阶段也是最后一个阶段进行组件的销毁，它被定义在 `src/core/instance/lifecycle.js` 中\n\n```js\nVue.prototype.$destroy = function () {\n    const vm: Component = this\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy')\n    vm._isBeingDestroyed = true\n    // 从 parent 的 $children 中删掉自身\n    const parent = vm.$parent\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm)\n    }\n    // 删除 watcher\n    if (vm._watcher) {\n      vm._watcher.teardown()\n    }\n    let i = vm._watchers.length\n    while (i--) {\n      vm._watchers[i].teardown()\n    }\n    ...\n    vm._isDestroyed = true\n    vm.__patch__(vm._vnode, null)\n    callHook(vm, 'destroyed')  // 调用 destroyed 钩子\n    // 关闭实例侦听器。\n    vm.$off()\n    // 删除 __vue__ 引用\n    if (vm.$el) {\n      vm.$el.__vue__ = null\n    }\n    // 释放循环引用\n    if (vm.$vnode) {\n      vm.$vnode.parent = null\n    }\n  }\n}\n\n```\n\n在 $destroy 的执行过程中，它又会执行 `vm.__patch__(vm._vnode, null)` 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。\n\n通过上面八种钩子，我们了解了组件销毁阶段的拆卸过程，那么在官网中除了这八种钩子函数其实还有集中不常见的钩子\n\n### activated & deactivated<hr>\n\n这两个钩子函数是 keep-alive 组件独有的。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。\n\n\n### errorCaptured<hr>\n\n通过 errorCaptured 钩子可以捕获来自子孙组件的错误，通过设置钩子的返回状态为 false，防止当一个错误被捕获时该组件进入无限的渲染循环，导致程序失败。\n\n\n### 总结<hr>\n\n通过对上面的理解我们总结一下 vue 生命周期在不同场景的执行顺序\n\n<img src=\"/images/vue-lifecycle.png\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue/vueLifecycle.md","raw":"---\ntitle: vue 原理之生命周期\ndate: 2019-09-21 13:50:28\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n每一个 vue 的实例在创建的时候都经过一系列的初始化操作，在每一个阶段都会有相对应的生命周期钩子函数，来在特定的场景实现一些功能\n\n\n### 生命周期方法<hr>\n\n- beforeCreate（实例创建前）\n- created（实例创建后）\n- beforeMount（渲染 DOM 前）\n- mounted（渲染 DOM 后）\n- beforeUpdate（更新数据前）\n- updated（更新数据后）\n- beforeDestroy（销毁组件前）\n- destroyed（销毁组件后）\n\n\n\n\n### 执行流程 <hr>\n\n通过上面生命周期的方法，看一下来至官网的一张神图，告诉我们大致的工作流程。通过每个阶段的源码来分析，在日常开发中遇到的问题。比如到底那个阶段做请求好，父子组件的生命周期在不同情况的下执行顺序是怎样的。\n\n<img src=\"/images/lifecycle.png\" width=\"50%\">\n\n\n### callHook<hr>\n\n我们在介绍 vue 主流程的时候知道首先会执行实例的 _init(options)，然后会执行一个 merge options 的逻辑，通过调用 mergeOptions 处理不同的合并策略，其中 mergeHook 就是关于生命周期的\n\n```js\nfunction mergeHook (\n  parentVal: ?Array<Function>,\n  childVal: ?Function | ?Array<Function>\n): ?Array<Function> {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(hook => {\n  strats[hook] = mergeHook\n})\n\n```\n\n这其中的 LIFECYCLE_HOOKS 的定义在 `src/shared/constants.js` 中：\n\n```js\nexport const LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n]\n```\n\n通过上面我们看到了生命周期的钩子函数， 然后再通过 callHook 就能调用某个生命周期钩子注册的所有回调函数了，callHook 定义在 `src/core/instance/lifecycle.js` 中\n\n```js\nexport function callHook (vm: Component, hook: string) {\n  pushTarget()\n  const handlers = vm.$options[hook] \n  const info = `${hook} hook`\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info)\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook)\n  }\n  popTarget()\n}\n```\n\n上面 callHook 主要执行了 invokeWithErrorHandling 定义在 `src/core/util/error.js` 中\n\n```js\nexport function invokeWithErrorHandling (\n  handler: Function,\n  context: any,\n  args: null | any[],\n  vm: any,\n  info: string\n) {\n  let res\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context)\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res._handled = true\n    }\n  } catch (e) {\n    handleError(e, vm, info)\n  }\n  return res\n}\n```\n\n通过调用 handler.apply(context, args) : handler.call(context)，改变了当前的 this，这就是我们在写生命周期的时候不能用箭头函数的原因。接下来我们继续探讨生命周期的执行时机。\n\n### beforeCreate & created<hr>\n\n这两个钩子函数主要是在 vue 初始化实例阶段，定义在 `src/core/instance/init.js` 中\n\n```js\nVue.prototype._init = function (options?: Object) {\n  // ...\n  initLifecycle(vm)\n  initEvents(vm)\n  initRender(vm)\n  callHook(vm, 'beforeCreate')\n  initInjections(vm) // resolve injections before data/props\n  initState(vm)\n  initProvide(vm) // resolve provide after data/props\n  callHook(vm, 'created')\n  // ...\n}\n```\n\n可以看到 beforeCreate 是在初始化生命周期、事件，渲染函数之后调用，那么 created 是在初始化 initInjections、initState 等函数之后，那么这里的 initState 在前面的文章说过，主要是初始化 props、data、methods、watch、computed 等属性，所以 beforeCreate 中是不能够操作 data、props 等数据、也不能调用 methods 中定义的函数。 \n\n### beforeMount & mounted <hr>\n\n在 mounted 阶段主要是执行了 mountComponent 方法，核心就是先实例化一个渲染 Watcher，在前面主流程中和响应式数据中我们经常提到两个核型方法 vm._render() 和 vm._update()，用于生成 DOM，mountComponent 方法定义在 `src/core/instance/lifecycle` 中\n\n```js\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    ...\n  }\n  callHook(vm, 'beforeMount')  // beforeMount 钩子\n\n  let updateComponent\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      //...\n      // 渲染 VNode\n      const vnode = vm._render()\n      // ...\n\n      // 渲染真实 DOM\n      vm._update(vnode, hydrating)\n    }\n  } else {\n    updateComponent = () => {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n     // 判断是否 mouted 完成阶段并且没有被销毁\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate') // 数据更新之前\n      }\n    }\n  }, true /* isRenderWatcher */)\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')  // mounted 钩子\n  }\n  return vm\n}\n```\n\n通过上面的代码，我们可以看出 beforeMount 钩子函数是在执行 vm._render() 函数渲染 VNode 之前执行的 ，在执行完 vm._update() 把 VNode patch 到真实 DOM 后，执行 mouted 钩子。上面有个逻辑 `vm.$vnode == null` 这表明不是一次组件的初始化过程，而是通过 new Vue() 创建的。当组件的 VNode patch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue 里保存的钩子函数依次执行一遍，它的定义在 `src/core/vdom/patch.js` 中\n\n```js\nfunction invokeInsertHook (vnode, queue, initial) {\n  // 在真正插入元素后调用，延迟组件根节点的插入钩子，\n  if (isTrue(initial) && isDef(vnode.parent)) {\n    vnode.parent.data.pendingInsert = queue\n  } else {\n    for (let i = 0; i < queue.length; ++i) {\n      queue[i].data.hook.insert(queue[i])\n    }\n  }\n}\n```\n\n该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 `src/core/vdom/create-component.js` 中的 componentVNodeHooks 中\n\n```js\nconst componentVNodeHooks = {\n  // ...\n  insert (vnode: MountedComponentVNode) {\n    const { context, componentInstance } = vnode\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true\n      callHook(componentInstance, 'mounted')\n    }\n    // ...\n  },\n}\n```\n\n每个子组件都是在这个钩子函数中执行 mounted 钩子函数，insertedVnodeQueue 的添加顺序是先子后父，所以对于同步渲染的子组件而言，mounted 钩子函数的执行顺序也是先子后父。\n\n### beforeUpdate & updated <hr>\n\nupdated 阶段也就是数据的依赖收集更新阶段，在响应式数据中我们已经提到，在文件 `src/core/instance/lifecycle` 中定义\n\n```js\n new Watcher(vm, updateComponent, noop, {\n    before () {\n      // 判断是否 mouted 完成阶段并且没有被销毁\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate')  // 调用 beforeUpdate 钩子\n      }\n    }\n  }, true /* isRenderWatcher */)\n\n```\n\n通过上面可以看到 beforeUpdate 是在满足 vm._isMounted && !vm._isDestroyed 条件才会被调用的,那么 updated 调用时机是在哪里呢，它被定义在 `src/core/observer/scheduler.js`\n\n```js\nfunction callUpdatedHooks (queue) {\n  let i = queue.length\n  while (i--) {\n    const watcher = queue[i]\n    const vm = watcher.vm\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated')\n    }\n  }\n}\n```\n\n我们可以看到在执行 updated 之前，对 watcher 队列进行了遍历，只有条件满足当前 watcher 为 vm._watcher 和 mounted 阶段，才会执行 updated 钩子函数，那么接下来我们看一下 watcher 到底做了什么，其实在响应式数据中我们已经分析过，被定义在 `src/instance/observer/watcher.js` 中\n\n```js\nexport default class Watcher {\n  // ...\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    ...\n}\n```\n\n在 watcher 实例化的过程中会会判断 isRenderWatcher。 接着把当前 watcher 的实例赋值给 vm._watcher,同时将 watcher 的实例 push 到 vm._watchers 中。通过 vm._watcher 对 vm 上数据变化的监测，当数据发生变化就会重新渲染。所以在 callUpdatedHooks 函数中，只有 vm._watcher 的回调执行完毕后，才会执 updated 钩子函数。所以是通过 watcher 监听实例上的数据变化来控制整个 vue 的渲染流程。\n\n### beforeDestroy & destroyed<hr>\n\n这个阶段也是最后一个阶段进行组件的销毁，它被定义在 `src/core/instance/lifecycle.js` 中\n\n```js\nVue.prototype.$destroy = function () {\n    const vm: Component = this\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy')\n    vm._isBeingDestroyed = true\n    // 从 parent 的 $children 中删掉自身\n    const parent = vm.$parent\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm)\n    }\n    // 删除 watcher\n    if (vm._watcher) {\n      vm._watcher.teardown()\n    }\n    let i = vm._watchers.length\n    while (i--) {\n      vm._watchers[i].teardown()\n    }\n    ...\n    vm._isDestroyed = true\n    vm.__patch__(vm._vnode, null)\n    callHook(vm, 'destroyed')  // 调用 destroyed 钩子\n    // 关闭实例侦听器。\n    vm.$off()\n    // 删除 __vue__ 引用\n    if (vm.$el) {\n      vm.$el.__vue__ = null\n    }\n    // 释放循环引用\n    if (vm.$vnode) {\n      vm.$vnode.parent = null\n    }\n  }\n}\n\n```\n\n在 $destroy 的执行过程中，它又会执行 `vm.__patch__(vm._vnode, null)` 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。\n\n通过上面八种钩子，我们了解了组件销毁阶段的拆卸过程，那么在官网中除了这八种钩子函数其实还有集中不常见的钩子\n\n### activated & deactivated<hr>\n\n这两个钩子函数是 keep-alive 组件独有的。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。\n\n\n### errorCaptured<hr>\n\n通过 errorCaptured 钩子可以捕获来自子孙组件的错误，通过设置钩子的返回状态为 false，防止当一个错误被捕获时该组件进入无限的渲染循环，导致程序失败。\n\n\n### 总结<hr>\n\n通过对上面的理解我们总结一下 vue 生命周期在不同场景的执行顺序\n\n<img src=\"/images/vue-lifecycle.png\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue/vueLifecycle","published":1,"updated":"2019-10-15T01:29:42.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owo0096b0u6mxmfbppr","content":"<p>每一个 vue 的实例在创建的时候都经过一系列的初始化操作，在每一个阶段都会有相对应的生命周期钩子函数，来在特定的场景实现一些功能</p>\n<h3 id=\"生命周期方法\"><a href=\"#生命周期方法\" class=\"headerlink\" title=\"生命周期方法\"></a>生命周期方法<hr></h3><ul>\n<li>beforeCreate（实例创建前）</li>\n<li>created（实例创建后）</li>\n<li>beforeMount（渲染 DOM 前）</li>\n<li>mounted（渲染 DOM 后）</li>\n<li>beforeUpdate（更新数据前）</li>\n<li>updated（更新数据后）</li>\n<li>beforeDestroy（销毁组件前）</li>\n<li>destroyed（销毁组件后）</li>\n</ul>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程 \"></a>执行流程 <hr></h3><p>通过上面生命周期的方法，看一下来至官网的一张神图，告诉我们大致的工作流程。通过每个阶段的源码来分析，在日常开发中遇到的问题。比如到底那个阶段做请求好，父子组件的生命周期在不同情况的下执行顺序是怎样的。</p>\n<img src=\"/images/lifecycle.png\" width=\"50%\">\n\n\n<h3 id=\"callHook\"><a href=\"#callHook\" class=\"headerlink\" title=\"callHook\"></a>callHook<hr></h3><p>我们在介绍 vue 主流程的时候知道首先会执行实例的 _init(options)，然后会执行一个 merge options 的逻辑，通过调用 mergeOptions 处理不同的合并策略，其中 mergeHook 就是关于生命周期的</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> mergeHook <span class=\"token punctuation\">(</span>\n  parentVal<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Array<span class=\"token operator\">&lt;</span>Function<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  childVal<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Function <span class=\"token operator\">|</span> <span class=\"token operator\">?</span>Array<span class=\"token operator\">&lt;</span>Function<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Array<span class=\"token operator\">&lt;</span>Function<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> childVal\n    <span class=\"token operator\">?</span> parentVal\n      <span class=\"token operator\">?</span> parentVal<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>childVal<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">:</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>childVal<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">?</span> childVal\n        <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>childVal<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">:</span> parentVal\n<span class=\"token punctuation\">}</span>\n\nLIFECYCLE_HOOKS<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>hook <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  strats<span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mergeHook\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这其中的 LIFECYCLE_HOOKS 的定义在 <code>src/shared/constants.js</code> 中：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> LIFECYCLE_HOOKS <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token string\">'beforeCreate'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'created'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'beforeMount'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'mounted'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'beforeUpdate'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'updated'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'beforeDestroy'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'destroyed'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'activated'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'deactivated'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">'errorCaptured'</span>\n<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面我们看到了生命周期的钩子函数， 然后再通过 callHook 就能调用某个生命周期钩子注册的所有回调函数了，callHook 定义在 <code>src/core/instance/lifecycle.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> callHook <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span> hook<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">pushTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> handlers <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">const</span> info <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>hook<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> hook`</span></span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handlers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> handlers<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">invokeWithErrorHandling</span><span class=\"token punctuation\">(</span>handlers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_hasHookEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span><span class=\"token function\">$emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hook:'</span> <span class=\"token operator\">+</span> hook<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">popTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面 callHook 主要执行了 invokeWithErrorHandling 定义在 <code>src/core/util/error.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> invokeWithErrorHandling <span class=\"token punctuation\">(</span>\n  handler<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span>\n  context<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  args<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> any<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  vm<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  info<span class=\"token punctuation\">:</span> string\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> res\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    res <span class=\"token operator\">=</span> args <span class=\"token operator\">?</span> handler<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> handler<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>res<span class=\"token punctuation\">.</span>_isVue <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isPromise</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>res<span class=\"token punctuation\">.</span>_handled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      res<span class=\"token punctuation\">.</span>_handled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">handleError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> res\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过调用 handler.apply(context, args) : handler.call(context)，改变了当前的 this，这就是我们在写生命周期的时候不能用箭头函数的原因。接下来我们继续探讨生命周期的执行时机。</p>\n<h3 id=\"beforeCreate-amp-created\"><a href=\"#beforeCreate-amp-created\" class=\"headerlink\" title=\"beforeCreate &amp; created\"></a>beforeCreate &amp; created<hr></h3><p>这两个钩子函数主要是在 vue 初始化实例阶段，定义在 <code>src/core/instance/init.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_init <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token function\">initLifecycle</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">initEvents</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">initRender</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeCreate'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">initInjections</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// resolve injections before data/props</span>\n  <span class=\"token function\">initState</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">initProvide</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// resolve provide after data/props</span>\n  <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'created'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到 beforeCreate 是在初始化生命周期、事件，渲染函数之后调用，那么 created 是在初始化 initInjections、initState 等函数之后，那么这里的 initState 在前面的文章说过，主要是初始化 props、data、methods、watch、computed 等属性，所以 beforeCreate 中是不能够操作 data、props 等数据、也不能调用 methods 中定义的函数。 </p>\n<h3 id=\"beforeMount-amp-mounted\"><a href=\"#beforeMount-amp-mounted\" class=\"headerlink\" title=\"beforeMount &amp; mounted \"></a>beforeMount &amp; mounted <hr></h3><p>在 mounted 阶段主要是执行了 mountComponent 方法，核心就是先实例化一个渲染 Watcher，在前面主流程中和响应式数据中我们经常提到两个核型方法 vm._render() 和 vm._update()，用于生成 DOM，mountComponent 方法定义在 <code>src/core/instance/lifecycle</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> mountComponent <span class=\"token punctuation\">(</span>\n  vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Element<span class=\"token punctuation\">,</span>\n  hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Component <span class=\"token punctuation\">{</span>\n  vm<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> el\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>render <span class=\"token operator\">=</span> createEmptyVNode\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeMount'</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// beforeMount 钩子</span>\n\n  <span class=\"token keyword\">let</span> updateComponent\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> config<span class=\"token punctuation\">.</span>performance <span class=\"token operator\">&amp;&amp;</span> mark<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    updateComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">//...</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 渲染 VNode</span>\n      <span class=\"token keyword\">const</span> vnode <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span><span class=\"token function\">_render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 渲染真实 DOM</span>\n      vm<span class=\"token punctuation\">.</span><span class=\"token function\">_update</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    updateComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span><span class=\"token function\">_update</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">_render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Watcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> updateComponent<span class=\"token punctuation\">,</span> noop<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    before <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">// 判断是否 mouted 完成阶段并且没有被销毁</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>_isDestroyed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeUpdate'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 数据更新之前</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* isRenderWatcher */</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'mounted'</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// mounted 钩子</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> vm\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的代码，我们可以看出 beforeMount 钩子函数是在执行 vm._render() 函数渲染 VNode 之前执行的 ，在执行完 vm._update() 把 VNode patch 到真实 DOM 后，执行 mouted 钩子。上面有个逻辑 <code>vm.$vnode == null</code> 这表明不是一次组件的初始化过程，而是通过 new Vue() 创建的。当组件的 VNode patch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue 里保存的钩子函数依次执行一遍，它的定义在 <code>src/core/vdom/patch.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> invokeInsertHook <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> queue<span class=\"token punctuation\">,</span> initial<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 在真正插入元素后调用，延迟组件根节点的插入钩子，</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>initial<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vnode<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>pendingInsert <span class=\"token operator\">=</span> queue\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 <code>src/core/vdom/create-component.js</code> 中的 componentVNodeHooks 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> componentVNodeHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  insert <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">:</span> MountedComponentVNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> context<span class=\"token punctuation\">,</span> componentInstance <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> vnode\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>componentInstance<span class=\"token punctuation\">.</span>_isMounted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      componentInstance<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>componentInstance<span class=\"token punctuation\">,</span> <span class=\"token string\">'mounted'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>每个子组件都是在这个钩子函数中执行 mounted 钩子函数，insertedVnodeQueue 的添加顺序是先子后父，所以对于同步渲染的子组件而言，mounted 钩子函数的执行顺序也是先子后父。</p>\n<h3 id=\"beforeUpdate-amp-updated\"><a href=\"#beforeUpdate-amp-updated\" class=\"headerlink\" title=\"beforeUpdate &amp; updated \"></a>beforeUpdate &amp; updated <hr></h3><p>updated 阶段也就是数据的依赖收集更新阶段，在响应式数据中我们已经提到，在文件 <code>src/core/instance/lifecycle</code> 中定义</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Watcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> updateComponent<span class=\"token punctuation\">,</span> noop<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    before <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 判断是否 mouted 完成阶段并且没有被销毁</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>_isDestroyed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeUpdate'</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 调用 beforeUpdate 钩子</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* isRenderWatcher */</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面可以看到 beforeUpdate 是在满足 vm._isMounted &amp;&amp; !vm._isDestroyed 条件才会被调用的,那么 updated 调用时机是在哪里呢，它被定义在 <code>src/core/observer/scheduler.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> callUpdatedHooks <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> watcher <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">const</span> vm <span class=\"token operator\">=</span> watcher<span class=\"token punctuation\">.</span>vm\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_watcher <span class=\"token operator\">===</span> watcher <span class=\"token operator\">&amp;&amp;</span> vm<span class=\"token punctuation\">.</span>_isMounted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'updated'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以看到在执行 updated 之前，对 watcher 队列进行了遍历，只有条件满足当前 watcher 为 vm._watcher 和 mounted 阶段，才会执行 updated 钩子函数，那么接下来我们看一下 watcher 到底做了什么，其实在响应式数据中我们已经分析过，被定义在 <code>src/instance/observer/watcher.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Watcher</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  constructor <span class=\"token punctuation\">(</span>\n    vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n    expOrFn<span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Function<span class=\"token punctuation\">,</span>\n    cb<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span>\n    options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Object<span class=\"token punctuation\">,</span>\n    isRenderWatcher<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>vm <span class=\"token operator\">=</span> vm\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isRenderWatcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>_watcher <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token punctuation\">}</span>\n    vm<span class=\"token punctuation\">.</span>_watchers<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在 watcher 实例化的过程中会会判断 isRenderWatcher。 接着把当前 watcher 的实例赋值给 vm._watcher,同时将 watcher 的实例 push 到 vm._watchers 中。通过 vm._watcher 对 vm 上数据变化的监测，当数据发生变化就会重新渲染。所以在 callUpdatedHooks 函数中，只有 vm._watcher 的回调执行完毕后，才会执 updated 钩子函数。所以是通过 watcher 监听实例上的数据变化来控制整个 vue 的渲染流程。</p>\n<h3 id=\"beforeDestroy-amp-destroyed\"><a href=\"#beforeDestroy-amp-destroyed\" class=\"headerlink\" title=\"beforeDestroy &amp; destroyed\"></a>beforeDestroy &amp; destroyed<hr></h3><p>这个阶段也是最后一个阶段进行组件的销毁，它被定义在 <code>src/core/instance/lifecycle.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>$destroy <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> vm<span class=\"token punctuation\">:</span> Component <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_isBeingDestroyed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeDestroy'</span><span class=\"token punctuation\">)</span>\n    vm<span class=\"token punctuation\">.</span>_isBeingDestroyed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 从 parent 的 $children 中删掉自身</span>\n    <span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$parent\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>parent<span class=\"token punctuation\">.</span>_isBeingDestroyed <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>abstract<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">.</span>$children<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 删除 watcher</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>_watcher<span class=\"token punctuation\">.</span><span class=\"token function\">teardown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_watchers<span class=\"token punctuation\">.</span>length\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>_watchers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">teardown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">...</span>\n    vm<span class=\"token punctuation\">.</span>_isDestroyed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    vm<span class=\"token punctuation\">.</span><span class=\"token function\">__patch__</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_vnode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'destroyed'</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 调用 destroyed 钩子</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 关闭实例侦听器。</span>\n    vm<span class=\"token punctuation\">.</span><span class=\"token function\">$off</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 删除 __vue__ 引用</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>$el<span class=\"token punctuation\">.</span>__vue__ <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 释放循环引用</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$vnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>$vnode<span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在 $destroy 的执行过程中，它又会执行 <code>vm.__patch__(vm._vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。</p>\n<p>通过上面八种钩子，我们了解了组件销毁阶段的拆卸过程，那么在官网中除了这八种钩子函数其实还有集中不常见的钩子</p>\n<h3 id=\"activated-amp-deactivated\"><a href=\"#activated-amp-deactivated\" class=\"headerlink\" title=\"activated &amp; deactivated\"></a>activated &amp; deactivated<hr></h3><p>这两个钩子函数是 keep-alive 组件独有的。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。</p>\n<h3 id=\"errorCaptured\"><a href=\"#errorCaptured\" class=\"headerlink\" title=\"errorCaptured\"></a>errorCaptured<hr></h3><p>通过 errorCaptured 钩子可以捕获来自子孙组件的错误，通过设置钩子的返回状态为 false，防止当一个错误被捕获时该组件进入无限的渲染循环，导致程序失败。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结<hr></h3><p>通过对上面的理解我们总结一下 vue 生命周期在不同场景的执行顺序</p>\n<img src=\"/images/vue-lifecycle.png\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>每一个 vue 的实例在创建的时候都经过一系列的初始化操作，在每一个阶段都会有相对应的生命周期钩子函数，来在特定的场景实现一些功能</p>\n<h3 id=\"生命周期方法\"><a href=\"#生命周期方法\" class=\"headerlink\" title=\"生命周期方法\"></a>生命周期方法<hr></h3><ul>\n<li>beforeCreate（实例创建前）</li>\n<li>created（实例创建后）</li>\n<li>beforeMount（渲染 DOM 前）</li>\n<li>mounted（渲染 DOM 后）</li>\n<li>beforeUpdate（更新数据前）</li>\n<li>updated（更新数据后）</li>\n<li>beforeDestroy（销毁组件前）</li>\n<li>destroyed（销毁组件后）</li>\n</ul>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程 \"></a>执行流程 <hr></h3><p>通过上面生命周期的方法，看一下来至官网的一张神图，告诉我们大致的工作流程。通过每个阶段的源码来分析，在日常开发中遇到的问题。比如到底那个阶段做请求好，父子组件的生命周期在不同情况的下执行顺序是怎样的。</p>\n<img src=\"/images/lifecycle.png\" width=\"50%\">\n\n\n<h3 id=\"callHook\"><a href=\"#callHook\" class=\"headerlink\" title=\"callHook\"></a>callHook<hr></h3><p>我们在介绍 vue 主流程的时候知道首先会执行实例的 _init(options)，然后会执行一个 merge options 的逻辑，通过调用 mergeOptions 处理不同的合并策略，其中 mergeHook 就是关于生命周期的</p>\n<pre><code class=\"js\">function mergeHook (\n  parentVal: ?Array&lt;Function&gt;,\n  childVal: ?Function | ?Array&lt;Function&gt;\n): ?Array&lt;Function&gt; {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(hook =&gt; {\n  strats[hook] = mergeHook\n})\n</code></pre>\n<p>这其中的 LIFECYCLE_HOOKS 的定义在 <code>src/shared/constants.js</code> 中：</p>\n<pre><code class=\"js\">export const LIFECYCLE_HOOKS = [\n  &#39;beforeCreate&#39;,\n  &#39;created&#39;,\n  &#39;beforeMount&#39;,\n  &#39;mounted&#39;,\n  &#39;beforeUpdate&#39;,\n  &#39;updated&#39;,\n  &#39;beforeDestroy&#39;,\n  &#39;destroyed&#39;,\n  &#39;activated&#39;,\n  &#39;deactivated&#39;,\n  &#39;errorCaptured&#39;\n]</code></pre>\n<p>通过上面我们看到了生命周期的钩子函数， 然后再通过 callHook 就能调用某个生命周期钩子注册的所有回调函数了，callHook 定义在 <code>src/core/instance/lifecycle.js</code> 中</p>\n<pre><code class=\"js\">export function callHook (vm: Component, hook: string) {\n  pushTarget()\n  const handlers = vm.$options[hook] \n  const info = `${hook} hook`\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i &lt; j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info)\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit(&#39;hook:&#39; + hook)\n  }\n  popTarget()\n}</code></pre>\n<p>上面 callHook 主要执行了 invokeWithErrorHandling 定义在 <code>src/core/util/error.js</code> 中</p>\n<pre><code class=\"js\">export function invokeWithErrorHandling (\n  handler: Function,\n  context: any,\n  args: null | any[],\n  vm: any,\n  info: string\n) {\n  let res\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context)\n    if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) {\n      res._handled = true\n    }\n  } catch (e) {\n    handleError(e, vm, info)\n  }\n  return res\n}</code></pre>\n<p>通过调用 handler.apply(context, args) : handler.call(context)，改变了当前的 this，这就是我们在写生命周期的时候不能用箭头函数的原因。接下来我们继续探讨生命周期的执行时机。</p>\n<h3 id=\"beforeCreate-amp-created\"><a href=\"#beforeCreate-amp-created\" class=\"headerlink\" title=\"beforeCreate &amp; created\"></a>beforeCreate &amp; created<hr></h3><p>这两个钩子函数主要是在 vue 初始化实例阶段，定义在 <code>src/core/instance/init.js</code> 中</p>\n<pre><code class=\"js\">Vue.prototype._init = function (options?: Object) {\n  // ...\n  initLifecycle(vm)\n  initEvents(vm)\n  initRender(vm)\n  callHook(vm, &#39;beforeCreate&#39;)\n  initInjections(vm) // resolve injections before data/props\n  initState(vm)\n  initProvide(vm) // resolve provide after data/props\n  callHook(vm, &#39;created&#39;)\n  // ...\n}</code></pre>\n<p>可以看到 beforeCreate 是在初始化生命周期、事件，渲染函数之后调用，那么 created 是在初始化 initInjections、initState 等函数之后，那么这里的 initState 在前面的文章说过，主要是初始化 props、data、methods、watch、computed 等属性，所以 beforeCreate 中是不能够操作 data、props 等数据、也不能调用 methods 中定义的函数。 </p>\n<h3 id=\"beforeMount-amp-mounted\"><a href=\"#beforeMount-amp-mounted\" class=\"headerlink\" title=\"beforeMount &amp; mounted \"></a>beforeMount &amp; mounted <hr></h3><p>在 mounted 阶段主要是执行了 mountComponent 方法，核心就是先实例化一个渲染 Watcher，在前面主流程中和响应式数据中我们经常提到两个核型方法 vm._render() 和 vm._update()，用于生成 DOM，mountComponent 方法定义在 <code>src/core/instance/lifecycle</code> 中</p>\n<pre><code class=\"js\">export function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    ...\n  }\n  callHook(vm, &#39;beforeMount&#39;)  // beforeMount 钩子\n\n  let updateComponent\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) {\n    updateComponent = () =&gt; {\n      //...\n      // 渲染 VNode\n      const vnode = vm._render()\n      // ...\n\n      // 渲染真实 DOM\n      vm._update(vnode, hydrating)\n    }\n  } else {\n    updateComponent = () =&gt; {\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n     // 判断是否 mouted 完成阶段并且没有被销毁\n      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n        callHook(vm, &#39;beforeUpdate&#39;) // 数据更新之前\n      }\n    }\n  }, true /* isRenderWatcher */)\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, &#39;mounted&#39;)  // mounted 钩子\n  }\n  return vm\n}</code></pre>\n<p>通过上面的代码，我们可以看出 beforeMount 钩子函数是在执行 vm._render() 函数渲染 VNode 之前执行的 ，在执行完 vm._update() 把 VNode patch 到真实 DOM 后，执行 mouted 钩子。上面有个逻辑 <code>vm.$vnode == null</code> 这表明不是一次组件的初始化过程，而是通过 new Vue() 创建的。当组件的 VNode patch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue 里保存的钩子函数依次执行一遍，它的定义在 <code>src/core/vdom/patch.js</code> 中</p>\n<pre><code class=\"js\">function invokeInsertHook (vnode, queue, initial) {\n  // 在真正插入元素后调用，延迟组件根节点的插入钩子，\n  if (isTrue(initial) &amp;&amp; isDef(vnode.parent)) {\n    vnode.parent.data.pendingInsert = queue\n  } else {\n    for (let i = 0; i &lt; queue.length; ++i) {\n      queue[i].data.hook.insert(queue[i])\n    }\n  }\n}</code></pre>\n<p>该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 <code>src/core/vdom/create-component.js</code> 中的 componentVNodeHooks 中</p>\n<pre><code class=\"js\">const componentVNodeHooks = {\n  // ...\n  insert (vnode: MountedComponentVNode) {\n    const { context, componentInstance } = vnode\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true\n      callHook(componentInstance, &#39;mounted&#39;)\n    }\n    // ...\n  },\n}</code></pre>\n<p>每个子组件都是在这个钩子函数中执行 mounted 钩子函数，insertedVnodeQueue 的添加顺序是先子后父，所以对于同步渲染的子组件而言，mounted 钩子函数的执行顺序也是先子后父。</p>\n<h3 id=\"beforeUpdate-amp-updated\"><a href=\"#beforeUpdate-amp-updated\" class=\"headerlink\" title=\"beforeUpdate &amp; updated \"></a>beforeUpdate &amp; updated <hr></h3><p>updated 阶段也就是数据的依赖收集更新阶段，在响应式数据中我们已经提到，在文件 <code>src/core/instance/lifecycle</code> 中定义</p>\n<pre><code class=\"js\"> new Watcher(vm, updateComponent, noop, {\n    before () {\n      // 判断是否 mouted 完成阶段并且没有被销毁\n      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n        callHook(vm, &#39;beforeUpdate&#39;)  // 调用 beforeUpdate 钩子\n      }\n    }\n  }, true /* isRenderWatcher */)\n</code></pre>\n<p>通过上面可以看到 beforeUpdate 是在满足 vm._isMounted &amp;&amp; !vm._isDestroyed 条件才会被调用的,那么 updated 调用时机是在哪里呢，它被定义在 <code>src/core/observer/scheduler.js</code></p>\n<pre><code class=\"js\">function callUpdatedHooks (queue) {\n  let i = queue.length\n  while (i--) {\n    const watcher = queue[i]\n    const vm = watcher.vm\n    if (vm._watcher === watcher &amp;&amp; vm._isMounted) {\n      callHook(vm, &#39;updated&#39;)\n    }\n  }\n}</code></pre>\n<p>我们可以看到在执行 updated 之前，对 watcher 队列进行了遍历，只有条件满足当前 watcher 为 vm._watcher 和 mounted 阶段，才会执行 updated 钩子函数，那么接下来我们看一下 watcher 到底做了什么，其实在响应式数据中我们已经分析过，被定义在 <code>src/instance/observer/watcher.js</code> 中</p>\n<pre><code class=\"js\">export default class Watcher {\n  // ...\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    ...\n}</code></pre>\n<p>在 watcher 实例化的过程中会会判断 isRenderWatcher。 接着把当前 watcher 的实例赋值给 vm._watcher,同时将 watcher 的实例 push 到 vm._watchers 中。通过 vm._watcher 对 vm 上数据变化的监测，当数据发生变化就会重新渲染。所以在 callUpdatedHooks 函数中，只有 vm._watcher 的回调执行完毕后，才会执 updated 钩子函数。所以是通过 watcher 监听实例上的数据变化来控制整个 vue 的渲染流程。</p>\n<h3 id=\"beforeDestroy-amp-destroyed\"><a href=\"#beforeDestroy-amp-destroyed\" class=\"headerlink\" title=\"beforeDestroy &amp; destroyed\"></a>beforeDestroy &amp; destroyed<hr></h3><p>这个阶段也是最后一个阶段进行组件的销毁，它被定义在 <code>src/core/instance/lifecycle.js</code> 中</p>\n<pre><code class=\"js\">Vue.prototype.$destroy = function () {\n    const vm: Component = this\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, &#39;beforeDestroy&#39;)\n    vm._isBeingDestroyed = true\n    // 从 parent 的 $children 中删掉自身\n    const parent = vm.$parent\n    if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {\n      remove(parent.$children, vm)\n    }\n    // 删除 watcher\n    if (vm._watcher) {\n      vm._watcher.teardown()\n    }\n    let i = vm._watchers.length\n    while (i--) {\n      vm._watchers[i].teardown()\n    }\n    ...\n    vm._isDestroyed = true\n    vm.__patch__(vm._vnode, null)\n    callHook(vm, &#39;destroyed&#39;)  // 调用 destroyed 钩子\n    // 关闭实例侦听器。\n    vm.$off()\n    // 删除 __vue__ 引用\n    if (vm.$el) {\n      vm.$el.__vue__ = null\n    }\n    // 释放循环引用\n    if (vm.$vnode) {\n      vm.$vnode.parent = null\n    }\n  }\n}\n</code></pre>\n<p>在 $destroy 的执行过程中，它又会执行 <code>vm.__patch__(vm._vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。</p>\n<p>通过上面八种钩子，我们了解了组件销毁阶段的拆卸过程，那么在官网中除了这八种钩子函数其实还有集中不常见的钩子</p>\n<h3 id=\"activated-amp-deactivated\"><a href=\"#activated-amp-deactivated\" class=\"headerlink\" title=\"activated &amp; deactivated\"></a>activated &amp; deactivated<hr></h3><p>这两个钩子函数是 keep-alive 组件独有的。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。</p>\n<h3 id=\"errorCaptured\"><a href=\"#errorCaptured\" class=\"headerlink\" title=\"errorCaptured\"></a>errorCaptured<hr></h3><p>通过 errorCaptured 钩子可以捕获来自子孙组件的错误，通过设置钩子的返回状态为 false，防止当一个错误被捕获时该组件进入无限的渲染循环，导致程序失败。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结<hr></h3><p>通过对上面的理解我们总结一下 vue 生命周期在不同场景的执行顺序</p>\n<img src=\"/images/vue-lifecycle.png\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"vue 原理之编译","date":"2019-09-19T07:02:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n## 编译入口\n\n还记得我们在第一篇文章介绍整理的执行过程的时候通过，在 $mount 这个函数内调用 compileToFunctions 吗？下面我们再来看看这个方法\n\n```js\n// ...\n  const { render, staticRenderFns } = compileToFunctions(template, {\n    shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref,\n    delimiters: options.delimiters,\n    comments: options.comments\n  }, this)\n  options.render = render\n  options.staticRenderFns = staticRenderFns\n// ...\n```\n\ncompileToFunctions 来至于 `src/compiler/index.js` 中  createCompiler(baseOptions) \n\n```js\n\n// createCompilerCreator 允许创建使用alternative的编译器\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// 这里我们只是使用默认部分导出一个默认编译器\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n```\n\n### createCompilerCreator <hr>\n\ncreateCompilerCreator 来至于 `src/compiler/create-compiler.js`中\n\n```js\nexport function createCompilerCreator (baseCompile: Function): Function {\n  return function createCompiler (baseOptions: CompilerOptions) {\n    function compile (\n      template: string,\n      options?: CompilerOptions\n    ): CompiledResult {\n      const finalOptions = Object.create(baseOptions)\n      const errors = []\n      const tips = []\n      finalOptions.warn = (msg, tip) => {\n        (tip ? tips : errors).push(msg)\n      }\n\n      if (options) {\n        // 合并自定义模块\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules)\n        }\n        // 合并自定义指令\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          )\n        }\n        // 复制其他参数\n        for (const key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key]\n          }\n        }\n      }\n\n      const compiled = baseCompile(template, finalOptions)\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast))\n      }\n      compiled.errors = errors\n      compiled.tips = tips\n      return compiled\n    }\n\n    return {\n      compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n```\n\n该方法返回了一个 createCompiler 的函数，它接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法属性和 compileToFunctions 属性，这个 compileToFunctions 对应的就是 $mount 函数调用的 compileToFunctions 方法，它是调用 createCompileToFunctionFn 方法的返回值。\n\n### createCompileToFunctionFn <hr>\n\n我们接下来看一下 createCompileToFunctionFn 方法，它的定义在 `src/compiler/to-function/js` 中\n\n```js\nexport function createCompileToFunctionFn (compile: Function): Function {\n  const cache = Object.create(null)\n\n  return function compileToFunctions (\n    template: string,\n    options?: CompilerOptions,\n    vm?: Component\n  ): CompiledFunctionResult {\n    options = extend({}, options)\n    const warn = options.warn || baseWarn\n    delete options.warn\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1')\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          )\n        }\n      }\n    }\n\n    // check cache\n    const key = options.delimiters\n      ? String(options.delimiters) + template\n      : template\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // 编译\n    const compiled = compile(template, options)\n\n    // 检查编译错误/提示\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          `Error compiling template:\\n\\n${template}\\n\\n` +\n          compiled.errors.map(e => `- ${e}`).join('\\n') + '\\n',\n          vm\n        )\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(msg => tip(msg, vm))\n      }\n    }\n\n    // 将代码转换为函数\n    const res = {}\n    const fnGenErrors = []\n    res.render = createFunction(compiled.render, fnGenErrors)\n    res.staticRenderFns = compiled.staticRenderFns.map(code => {\n      return createFunction(code, fnGenErrors)\n    })\n\n    // 检查函数生成错误.\n    // 只有当编译器本身存在错误时，才会发生这种情况\n    // 主要用于codegen 开发使用\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          `Failed to generate render function:\\n\\n` +\n          fnGenErrors.map(({ err, code }) => `${err.toString()} in\\n\\n${code}\\n`).join('\\n'),\n          vm\n        )\n      }\n    }\n\n    return (cache[key] = res)\n  }\n```\n\n### compile<hr>\n\n通过上面函数我们看到 compileToFunctions 接收三个参数，编译模板 template，编译配置 options 和 Vue 实例 vm。核心代码只有一行\n\n```js\nconst compiled = compile(template, options)\n```\n\n### baseCompile<hr>\n\ncompile 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码：\n\n```js\nconst compiled = baseCompile(template, finalOptions)\n```\n\nbaseCompile 是在执行 createCompilerCreator 方法时作为参数传入的所以绕了一圈真正的入口就是\n\n```js\n// `createCompilerCreator`允许创建使用alternative的编译器\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// 这里我们只是使用默认部分导出一个默认编译器\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n```\n### 主要执行步骤<hr>\n\n> 解析模板字符串生成 AST\n\n```js\nconst ast = parse(template.trim(), options)\n```\n\n> 优化语法树\n\n```js\noptimize(ast, options)\n```\n\n> 生成代码\n\n```js\nconst code = generate(ast, options)\n```\n\n\n## parse\n\nparse 定义在 `src/compiler/parser/index.js` 中，由于编译流程较为复杂难懂所以我们只了解大概的流程\n\nparse 接收两个参数 template 和 options 对于 options 不去研究平台特殊性，template 模板的解析主要是通过 parseHTML 函数循环解析\n\n```js\nparseHTML(template, options)\n```\n\n对于不同情况分别进行不同的处理，在匹配的过程中会利用 advance 函数不断前进整个模板字符串，直到字符串末尾。\n\n```js\nfunction advance (n) {\n  index += n\n  html = html.substring(n)\n}\n```\n\n- 对于注释和条件注释节点，前进至它们的末尾位置；对于文档类型节点，则前进它自身长度的距离\n- 通过 parseStartTag 解析开始标签(通过 startTagOpen配置开始标签，然后定义了 match 对象，通过 handleStartTag 处理 match.attrs,最后调用 options.start回调函数)\n- 通过正则 endTag 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 parseEndTag 方法对闭合，最后调用 options.end 回调函数\n- 判断 textEnd 是否大于等于 0 说明从当前位置到 textEnd 位置都是文本，如果 extEnd 小于 0 的情况，则说明整个 template 解析完毕了，将剩余的 html 都赋值给了 text，最后调用了 options.chars 回调函数，并传 text 参数\n\n### options.start 处理开始标签<hr>\n\n```js\n// ...\nstart (tag, attrs, unary) {\n  let element = createASTElement(tag, attrs)\n  processElement(element)\n  treeManagement()\n}\n// ...\n```\n- 通过 createASTElement 创建 AST 元素\n- 处理 AST 元素\n- AST 树管理\n\n> createASTElement\n\n```js\n// ...\n// 每一个 AST 元素是一个普通的 JavaScript 对象\n// type 表示 AST 元素类型\n// tag 表示标签名\n// attrsList 表示属性列表\n// attrsMap 表示属性映射表\n// parent 表示父的 AST 元素\n// children 表示子 AST 元素集合。\nexport function createASTElement (\n  tag: string,\n  attrs: Array<Attr>,\n  parent: ASTElement | void\n): ASTElement {\n  return {\n    type: 1,\n    tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent,\n    children: []\n  }\n}\n// ...\n```\n> processElement(element)\n\n调用 preTransforms、transforms、postTransforms 函，然后通过各种指令 processXXX 做处理，处理的结果就是扩展 AST 元素的属性，如 processFor 解析 v-for 指令内容，将解析的属性值添加到 AST 的元素上\n\n> treeManagement()\n\nAST 树管理的目标是构建一颗 AST 树，本质上利用 stack 栈的数据结构来维护 root 根节点和当前父节点 currentParent。\n\n\n\n### options.end 处理闭合标签<hr>\n\n```js\nend () {\n  treeManagement()\n  closeElement()\n}\n```\n\n> 首先处理了尾部空格的情况,然后把 stack 的元素弹一个出栈，并把 stack 最后一个元素赋值给 currentParent，这样就维护了整个 AST 树。\n\n```js\n// remove trailing whitespace\nconst element = stack[stack.length - 1]\nconst lastNode = element.children[element.children.length - 1]\nif (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n  element.children.pop()\n}\n// pop stack\nstack.length -= 1\ncurrentParent = stack[stack.length - 1]\ncloseElement(element)\n```\n\n> closeElement 更新一下 inVPre 和 inPre 的状态，以及执行 postTransforms 函数 \n\n```js\nfunction closeElement (element) {\n  // check pre state\n  if (element.pre) {\n    inVPre = false\n  }\n  if (platformIsPreTag(element.tag)) {\n    inPre = false\n  }\n  // apply post-transforms\n  for (let i = 0; i < postTransforms.length; i++) {\n    postTransforms[i](element, options)\n  }\n}\n```\n\n### options.chars 处理文本内容<hr>\n\n```js\nchars (text: string) {\n  handleText()\n  createChildrenASTOfText()\n}\n```\n\n通过执行 parseText(text, delimiters) 对文本解析, 定义在 `src/compiler/parser/text-parsre.js` 中，主要流程就是\n\n```js\n\n// 先根据分隔符（默认是 `{{}}`）构造了文本匹配的正则表达式，然后再循环匹配文本\n// 遇到普通文本就 push 到 rawTokens 和 tokens 中\n// 如果是表达式就转换成 `_s(${exp})` push 到 tokens 中\n// 转换成 `{@binding:exp}` push 到 rawTokens 中\n\nconst defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g\nconst regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\n\nconst buildRegex = cached(delimiters => {\n  const open = delimiters[0].replace(regexEscapeRE, '\\\\$&')\n  const close = delimiters[1].replace(regexEscapeRE, '\\\\$&')\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n})\n\nexport function parseText (\n  text: string,\n  delimiters?: [string, string]\n): TextParseResult | void {\n  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE\n  if (!tagRE.test(text)) {\n    return\n  }\n  const tokens = []\n  const rawTokens = []\n  let lastIndex = tagRE.lastIndex = 0\n  let match, index, tokenValue\n  while ((match = tagRE.exec(text))) {\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index))\n      tokens.push(JSON.stringify(tokenValue))\n    }\n    // tag token\n    const exp = parseFilters(match[1].trim())\n    tokens.push(`_s(${exp})`)\n    rawTokens.push({ '@binding': exp })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex))\n    tokens.push(JSON.stringify(tokenValue))\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n```\n\n### 小结 <hr>\n\n- parse 的作用就是将 template 模版字符串转换成 AST 树。其实是用对象的形式来描述整个模版，用正则顺序解析模版，达到构建 AST 树的目的\n- AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本\n\n\n## optimize\n\noptimize 方法的定义，在 `src/compiler/optimizer.js` 中\n\n```js\nexport function optimize (root: ?ASTElement, options: CompilerOptions) {\n  if (!root) return\n  isStaticKey = genStaticKeysCached(options.staticKeys || '')\n  isPlatformReservedTag = options.isReservedTag || no\n  // first pass: mark all non-static nodes.\n  markStatic(root)\n  // second pass: mark static roots.\n  markStaticRoots(root, false)\n}\n\nfunction genStaticKeys (keys: string): Function {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n```\n\n通过 optimize 函数我们看到优化主要就做了两件事情\n\n### markStatic(root) 标记静态节点<hr>\n\n```js\nfunction markStatic (node: ASTNode) {\n  node.static = isStatic(node)\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (let i = 0, l = node.children.length; i < l; i++) {\n      const child = node.children[i]\n      markStatic(child)\n      if (!child.static) {\n        node.static = false\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n          node.static = false\n        }\n      }\n    }\n  }\n}\n\nfunction isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n```\n- 通过 isStatic 函数判断 AST 是否是静态\n- type === 2 为表达式不是静态\n- type === 3 是纯文本是静态\n- 普通元素，如果有 pre 属性 是静态\n- 没有使用 v-if、 v-for 、没有使用其它指令（不包括 v-once）、非内置组件、是平台保留的标签、节点的所有属性的 key 都满足静态 key，这些都满足则这个 AST 节点是一个静态节点\n- 递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false\n\n### markStaticRoots(root, false) 标记静态根<hr>\n\n```js\nfunction markStaticRoots (node: ASTNode, isInFor: boolean) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true\n      return\n    } else {\n      node.staticRoot = false\n    }\n    if (node.children) {\n      for (let i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n      }\n    }\n  }\n}\n```\n\n- 对于已经是 static 的节点或者是 v-once 指令的节点，node.staticInFor = isInFor\n- 本身是一个静态节点外，满足拥有 children，并且 children 不能只是一个文本节点，才有资格成为 staticRoot 的节点\n- 递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false\n\n\n### 小结<hr>\n\noptimize 的过程，就是深度遍历这个 AST 树，检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这样我们在 patch 的过程就不会对比为静态属性的节点\n\n\n## codegen\n\n最后一步就是将优化过后的 AST 树转化成执行的代码\n\n```js\nconst code = generate(ast, options)\n```\n\ngenerate 函数的定义在 src/compiler/codegen/index.js 中\n\n```js\nexport function generate (\n  ast: ASTElement | void,\n  options: CompilerOptions\n): CodegenResult {\n  const state = new CodegenState(options)\n  const code = ast ? genElement(ast, state) : '_c(\"div\")'\n  return {\n    render: `with(this){return ${code}}`,\n    staticRenderFns: state.staticRenderFns\n  }\n}\n```\n### CodegenState <hr>\n\n调用 CodegenState 函数，获取所有 modules 中的 genData 函数\n\n### genElement <hr>\n\n调用 genElement 函数生成 code\n\n```js\nexport function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      const data = el.plain ? undefined : genData(el, state)\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c('${el.tag}'${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n根据 AST 的属性执行不同的代码生成函数，这里面有 genStatic、genOnce、genFor、genIf、genChildren、genSlot、genData、genComponent\n\n### 执行 code <hr> \n\n用 `with(this){return ${code}}` 将 code 传入 render 中执行 new Function()\n\n```js\nconst compiled = compile(template, options)\nres.render = createFunction(compiled.render, fnGenErrors)\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n  }\n}\n```\n\n## 总结\n\n<img src=\"/images/vue-dom-diff12.png\"></img>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue/vueCompile.md","raw":"---\ntitle: vue 原理之编译\ndate: 2019-09-19 15:02:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n\n## 编译入口\n\n还记得我们在第一篇文章介绍整理的执行过程的时候通过，在 $mount 这个函数内调用 compileToFunctions 吗？下面我们再来看看这个方法\n\n```js\n// ...\n  const { render, staticRenderFns } = compileToFunctions(template, {\n    shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref,\n    delimiters: options.delimiters,\n    comments: options.comments\n  }, this)\n  options.render = render\n  options.staticRenderFns = staticRenderFns\n// ...\n```\n\ncompileToFunctions 来至于 `src/compiler/index.js` 中  createCompiler(baseOptions) \n\n```js\n\n// createCompilerCreator 允许创建使用alternative的编译器\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// 这里我们只是使用默认部分导出一个默认编译器\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n```\n\n### createCompilerCreator <hr>\n\ncreateCompilerCreator 来至于 `src/compiler/create-compiler.js`中\n\n```js\nexport function createCompilerCreator (baseCompile: Function): Function {\n  return function createCompiler (baseOptions: CompilerOptions) {\n    function compile (\n      template: string,\n      options?: CompilerOptions\n    ): CompiledResult {\n      const finalOptions = Object.create(baseOptions)\n      const errors = []\n      const tips = []\n      finalOptions.warn = (msg, tip) => {\n        (tip ? tips : errors).push(msg)\n      }\n\n      if (options) {\n        // 合并自定义模块\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules)\n        }\n        // 合并自定义指令\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          )\n        }\n        // 复制其他参数\n        for (const key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key]\n          }\n        }\n      }\n\n      const compiled = baseCompile(template, finalOptions)\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast))\n      }\n      compiled.errors = errors\n      compiled.tips = tips\n      return compiled\n    }\n\n    return {\n      compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n```\n\n该方法返回了一个 createCompiler 的函数，它接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法属性和 compileToFunctions 属性，这个 compileToFunctions 对应的就是 $mount 函数调用的 compileToFunctions 方法，它是调用 createCompileToFunctionFn 方法的返回值。\n\n### createCompileToFunctionFn <hr>\n\n我们接下来看一下 createCompileToFunctionFn 方法，它的定义在 `src/compiler/to-function/js` 中\n\n```js\nexport function createCompileToFunctionFn (compile: Function): Function {\n  const cache = Object.create(null)\n\n  return function compileToFunctions (\n    template: string,\n    options?: CompilerOptions,\n    vm?: Component\n  ): CompiledFunctionResult {\n    options = extend({}, options)\n    const warn = options.warn || baseWarn\n    delete options.warn\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1')\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          )\n        }\n      }\n    }\n\n    // check cache\n    const key = options.delimiters\n      ? String(options.delimiters) + template\n      : template\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // 编译\n    const compiled = compile(template, options)\n\n    // 检查编译错误/提示\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          `Error compiling template:\\n\\n${template}\\n\\n` +\n          compiled.errors.map(e => `- ${e}`).join('\\n') + '\\n',\n          vm\n        )\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(msg => tip(msg, vm))\n      }\n    }\n\n    // 将代码转换为函数\n    const res = {}\n    const fnGenErrors = []\n    res.render = createFunction(compiled.render, fnGenErrors)\n    res.staticRenderFns = compiled.staticRenderFns.map(code => {\n      return createFunction(code, fnGenErrors)\n    })\n\n    // 检查函数生成错误.\n    // 只有当编译器本身存在错误时，才会发生这种情况\n    // 主要用于codegen 开发使用\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          `Failed to generate render function:\\n\\n` +\n          fnGenErrors.map(({ err, code }) => `${err.toString()} in\\n\\n${code}\\n`).join('\\n'),\n          vm\n        )\n      }\n    }\n\n    return (cache[key] = res)\n  }\n```\n\n### compile<hr>\n\n通过上面函数我们看到 compileToFunctions 接收三个参数，编译模板 template，编译配置 options 和 Vue 实例 vm。核心代码只有一行\n\n```js\nconst compiled = compile(template, options)\n```\n\n### baseCompile<hr>\n\ncompile 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码：\n\n```js\nconst compiled = baseCompile(template, finalOptions)\n```\n\nbaseCompile 是在执行 createCompilerCreator 方法时作为参数传入的所以绕了一圈真正的入口就是\n\n```js\n// `createCompilerCreator`允许创建使用alternative的编译器\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// 这里我们只是使用默认部分导出一个默认编译器\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n```\n### 主要执行步骤<hr>\n\n> 解析模板字符串生成 AST\n\n```js\nconst ast = parse(template.trim(), options)\n```\n\n> 优化语法树\n\n```js\noptimize(ast, options)\n```\n\n> 生成代码\n\n```js\nconst code = generate(ast, options)\n```\n\n\n## parse\n\nparse 定义在 `src/compiler/parser/index.js` 中，由于编译流程较为复杂难懂所以我们只了解大概的流程\n\nparse 接收两个参数 template 和 options 对于 options 不去研究平台特殊性，template 模板的解析主要是通过 parseHTML 函数循环解析\n\n```js\nparseHTML(template, options)\n```\n\n对于不同情况分别进行不同的处理，在匹配的过程中会利用 advance 函数不断前进整个模板字符串，直到字符串末尾。\n\n```js\nfunction advance (n) {\n  index += n\n  html = html.substring(n)\n}\n```\n\n- 对于注释和条件注释节点，前进至它们的末尾位置；对于文档类型节点，则前进它自身长度的距离\n- 通过 parseStartTag 解析开始标签(通过 startTagOpen配置开始标签，然后定义了 match 对象，通过 handleStartTag 处理 match.attrs,最后调用 options.start回调函数)\n- 通过正则 endTag 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 parseEndTag 方法对闭合，最后调用 options.end 回调函数\n- 判断 textEnd 是否大于等于 0 说明从当前位置到 textEnd 位置都是文本，如果 extEnd 小于 0 的情况，则说明整个 template 解析完毕了，将剩余的 html 都赋值给了 text，最后调用了 options.chars 回调函数，并传 text 参数\n\n### options.start 处理开始标签<hr>\n\n```js\n// ...\nstart (tag, attrs, unary) {\n  let element = createASTElement(tag, attrs)\n  processElement(element)\n  treeManagement()\n}\n// ...\n```\n- 通过 createASTElement 创建 AST 元素\n- 处理 AST 元素\n- AST 树管理\n\n> createASTElement\n\n```js\n// ...\n// 每一个 AST 元素是一个普通的 JavaScript 对象\n// type 表示 AST 元素类型\n// tag 表示标签名\n// attrsList 表示属性列表\n// attrsMap 表示属性映射表\n// parent 表示父的 AST 元素\n// children 表示子 AST 元素集合。\nexport function createASTElement (\n  tag: string,\n  attrs: Array<Attr>,\n  parent: ASTElement | void\n): ASTElement {\n  return {\n    type: 1,\n    tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent,\n    children: []\n  }\n}\n// ...\n```\n> processElement(element)\n\n调用 preTransforms、transforms、postTransforms 函，然后通过各种指令 processXXX 做处理，处理的结果就是扩展 AST 元素的属性，如 processFor 解析 v-for 指令内容，将解析的属性值添加到 AST 的元素上\n\n> treeManagement()\n\nAST 树管理的目标是构建一颗 AST 树，本质上利用 stack 栈的数据结构来维护 root 根节点和当前父节点 currentParent。\n\n\n\n### options.end 处理闭合标签<hr>\n\n```js\nend () {\n  treeManagement()\n  closeElement()\n}\n```\n\n> 首先处理了尾部空格的情况,然后把 stack 的元素弹一个出栈，并把 stack 最后一个元素赋值给 currentParent，这样就维护了整个 AST 树。\n\n```js\n// remove trailing whitespace\nconst element = stack[stack.length - 1]\nconst lastNode = element.children[element.children.length - 1]\nif (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n  element.children.pop()\n}\n// pop stack\nstack.length -= 1\ncurrentParent = stack[stack.length - 1]\ncloseElement(element)\n```\n\n> closeElement 更新一下 inVPre 和 inPre 的状态，以及执行 postTransforms 函数 \n\n```js\nfunction closeElement (element) {\n  // check pre state\n  if (element.pre) {\n    inVPre = false\n  }\n  if (platformIsPreTag(element.tag)) {\n    inPre = false\n  }\n  // apply post-transforms\n  for (let i = 0; i < postTransforms.length; i++) {\n    postTransforms[i](element, options)\n  }\n}\n```\n\n### options.chars 处理文本内容<hr>\n\n```js\nchars (text: string) {\n  handleText()\n  createChildrenASTOfText()\n}\n```\n\n通过执行 parseText(text, delimiters) 对文本解析, 定义在 `src/compiler/parser/text-parsre.js` 中，主要流程就是\n\n```js\n\n// 先根据分隔符（默认是 `{{}}`）构造了文本匹配的正则表达式，然后再循环匹配文本\n// 遇到普通文本就 push 到 rawTokens 和 tokens 中\n// 如果是表达式就转换成 `_s(${exp})` push 到 tokens 中\n// 转换成 `{@binding:exp}` push 到 rawTokens 中\n\nconst defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g\nconst regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\n\nconst buildRegex = cached(delimiters => {\n  const open = delimiters[0].replace(regexEscapeRE, '\\\\$&')\n  const close = delimiters[1].replace(regexEscapeRE, '\\\\$&')\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n})\n\nexport function parseText (\n  text: string,\n  delimiters?: [string, string]\n): TextParseResult | void {\n  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE\n  if (!tagRE.test(text)) {\n    return\n  }\n  const tokens = []\n  const rawTokens = []\n  let lastIndex = tagRE.lastIndex = 0\n  let match, index, tokenValue\n  while ((match = tagRE.exec(text))) {\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index))\n      tokens.push(JSON.stringify(tokenValue))\n    }\n    // tag token\n    const exp = parseFilters(match[1].trim())\n    tokens.push(`_s(${exp})`)\n    rawTokens.push({ '@binding': exp })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex))\n    tokens.push(JSON.stringify(tokenValue))\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n```\n\n### 小结 <hr>\n\n- parse 的作用就是将 template 模版字符串转换成 AST 树。其实是用对象的形式来描述整个模版，用正则顺序解析模版，达到构建 AST 树的目的\n- AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本\n\n\n## optimize\n\noptimize 方法的定义，在 `src/compiler/optimizer.js` 中\n\n```js\nexport function optimize (root: ?ASTElement, options: CompilerOptions) {\n  if (!root) return\n  isStaticKey = genStaticKeysCached(options.staticKeys || '')\n  isPlatformReservedTag = options.isReservedTag || no\n  // first pass: mark all non-static nodes.\n  markStatic(root)\n  // second pass: mark static roots.\n  markStaticRoots(root, false)\n}\n\nfunction genStaticKeys (keys: string): Function {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n```\n\n通过 optimize 函数我们看到优化主要就做了两件事情\n\n### markStatic(root) 标记静态节点<hr>\n\n```js\nfunction markStatic (node: ASTNode) {\n  node.static = isStatic(node)\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (let i = 0, l = node.children.length; i < l; i++) {\n      const child = node.children[i]\n      markStatic(child)\n      if (!child.static) {\n        node.static = false\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n          node.static = false\n        }\n      }\n    }\n  }\n}\n\nfunction isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n```\n- 通过 isStatic 函数判断 AST 是否是静态\n- type === 2 为表达式不是静态\n- type === 3 是纯文本是静态\n- 普通元素，如果有 pre 属性 是静态\n- 没有使用 v-if、 v-for 、没有使用其它指令（不包括 v-once）、非内置组件、是平台保留的标签、节点的所有属性的 key 都满足静态 key，这些都满足则这个 AST 节点是一个静态节点\n- 递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false\n\n### markStaticRoots(root, false) 标记静态根<hr>\n\n```js\nfunction markStaticRoots (node: ASTNode, isInFor: boolean) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true\n      return\n    } else {\n      node.staticRoot = false\n    }\n    if (node.children) {\n      for (let i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n      }\n    }\n  }\n}\n```\n\n- 对于已经是 static 的节点或者是 v-once 指令的节点，node.staticInFor = isInFor\n- 本身是一个静态节点外，满足拥有 children，并且 children 不能只是一个文本节点，才有资格成为 staticRoot 的节点\n- 递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false\n\n\n### 小结<hr>\n\noptimize 的过程，就是深度遍历这个 AST 树，检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这样我们在 patch 的过程就不会对比为静态属性的节点\n\n\n## codegen\n\n最后一步就是将优化过后的 AST 树转化成执行的代码\n\n```js\nconst code = generate(ast, options)\n```\n\ngenerate 函数的定义在 src/compiler/codegen/index.js 中\n\n```js\nexport function generate (\n  ast: ASTElement | void,\n  options: CompilerOptions\n): CodegenResult {\n  const state = new CodegenState(options)\n  const code = ast ? genElement(ast, state) : '_c(\"div\")'\n  return {\n    render: `with(this){return ${code}}`,\n    staticRenderFns: state.staticRenderFns\n  }\n}\n```\n### CodegenState <hr>\n\n调用 CodegenState 函数，获取所有 modules 中的 genData 函数\n\n### genElement <hr>\n\n调用 genElement 函数生成 code\n\n```js\nexport function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      const data = el.plain ? undefined : genData(el, state)\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c('${el.tag}'${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n根据 AST 的属性执行不同的代码生成函数，这里面有 genStatic、genOnce、genFor、genIf、genChildren、genSlot、genData、genComponent\n\n### 执行 code <hr> \n\n用 `with(this){return ${code}}` 将 code 传入 render 中执行 new Function()\n\n```js\nconst compiled = compile(template, options)\nres.render = createFunction(compiled.render, fnGenErrors)\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n  }\n}\n```\n\n## 总结\n\n<img src=\"/images/vue-dom-diff12.png\"></img>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue/vueCompile","published":1,"updated":"2019-10-15T01:29:42.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owt009hb0u6gtfpkiv7","content":"<h2 id=\"编译入口\"><a href=\"#编译入口\" class=\"headerlink\" title=\"编译入口\"></a>编译入口</h2><p>还记得我们在第一篇文章介绍整理的执行过程的时候通过，在 $mount 这个函数内调用 compileToFunctions 吗？下面我们再来看看这个方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> render<span class=\"token punctuation\">,</span> staticRenderFns <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">compileToFunctions</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    shouldDecodeNewlines<span class=\"token punctuation\">,</span>\n    shouldDecodeNewlinesForHref<span class=\"token punctuation\">,</span>\n    delimiters<span class=\"token punctuation\">:</span> options<span class=\"token punctuation\">.</span>delimiters<span class=\"token punctuation\">,</span>\n    comments<span class=\"token punctuation\">:</span> options<span class=\"token punctuation\">.</span>comments\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n  options<span class=\"token punctuation\">.</span>render <span class=\"token operator\">=</span> render\n  options<span class=\"token punctuation\">.</span>staticRenderFns <span class=\"token operator\">=</span> staticRenderFns\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>compileToFunctions 来至于 <code>src/compiler/index.js</code> 中  createCompiler(baseOptions) </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// createCompilerCreator 允许创建使用alternative的编译器</span>\n<span class=\"token comment\" spellcheck=\"true\">// parser/optimizer/codegen, e.g the SSR optimizing compiler.</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这里我们只是使用默认部分导出一个默认编译器</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> createCompiler <span class=\"token operator\">=</span> <span class=\"token function\">createCompilerCreator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> baseCompile <span class=\"token punctuation\">(</span>\n  template<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  options<span class=\"token punctuation\">:</span> CompilerOptions\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> CompiledResult <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> ast <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>optimize <span class=\"token operator\">!==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">optimize</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    ast<span class=\"token punctuation\">,</span>\n    render<span class=\"token punctuation\">:</span> code<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">,</span>\n    staticRenderFns<span class=\"token punctuation\">:</span> code<span class=\"token punctuation\">.</span>staticRenderFns\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"createCompilerCreator\"><a href=\"#createCompilerCreator\" class=\"headerlink\" title=\"createCompilerCreator \"></a>createCompilerCreator <hr></h3><p>createCompilerCreator 来至于 <code>src/compiler/create-compiler.js</code>中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> createCompilerCreator <span class=\"token punctuation\">(</span>baseCompile<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> createCompiler <span class=\"token punctuation\">(</span>baseOptions<span class=\"token punctuation\">:</span> CompilerOptions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">function</span> compile <span class=\"token punctuation\">(</span>\n      template<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n      options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> CompilerOptions\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> CompiledResult <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> finalOptions <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>baseOptions<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> errors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">const</span> tips <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n      finalOptions<span class=\"token punctuation\">.</span>warn <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> tip<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span>tip <span class=\"token operator\">?</span> tips <span class=\"token punctuation\">:</span> errors<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 合并自定义模块</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          finalOptions<span class=\"token punctuation\">.</span>modules <span class=\"token operator\">=</span>\n            <span class=\"token punctuation\">(</span>baseOptions<span class=\"token punctuation\">.</span>modules <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 合并自定义指令</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>directives<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          finalOptions<span class=\"token punctuation\">.</span>directives <span class=\"token operator\">=</span> <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>\n            Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>baseOptions<span class=\"token punctuation\">.</span>directives <span class=\"token operator\">||</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            options<span class=\"token punctuation\">.</span>directives\n          <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 复制其他参数</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!==</span> <span class=\"token string\">'modules'</span> <span class=\"token operator\">&amp;&amp;</span> key <span class=\"token operator\">!==</span> <span class=\"token string\">'directives'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            finalOptions<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> options<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">const</span> compiled <span class=\"token operator\">=</span> <span class=\"token function\">baseCompile</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> finalOptions<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        errors<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>errors<span class=\"token punctuation\">,</span> <span class=\"token function\">detectErrors</span><span class=\"token punctuation\">(</span>compiled<span class=\"token punctuation\">.</span>ast<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      compiled<span class=\"token punctuation\">.</span>errors <span class=\"token operator\">=</span> errors\n      compiled<span class=\"token punctuation\">.</span>tips <span class=\"token operator\">=</span> tips\n      <span class=\"token keyword\">return</span> compiled\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      compile<span class=\"token punctuation\">,</span>\n      compileToFunctions<span class=\"token punctuation\">:</span> <span class=\"token function\">createCompileToFunctionFn</span><span class=\"token punctuation\">(</span>compile<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>该方法返回了一个 createCompiler 的函数，它接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法属性和 compileToFunctions 属性，这个 compileToFunctions 对应的就是 $mount 函数调用的 compileToFunctions 方法，它是调用 createCompileToFunctionFn 方法的返回值。</p>\n<h3 id=\"createCompileToFunctionFn\"><a href=\"#createCompileToFunctionFn\" class=\"headerlink\" title=\"createCompileToFunctionFn \"></a>createCompileToFunctionFn <hr></h3><p>我们接下来看一下 createCompileToFunctionFn 方法，它的定义在 <code>src/compiler/to-function/js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> createCompileToFunctionFn <span class=\"token punctuation\">(</span>compile<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> cache <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> compileToFunctions <span class=\"token punctuation\">(</span>\n    template<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n    options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> CompilerOptions<span class=\"token punctuation\">,</span>\n    vm<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Component\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> CompiledFunctionResult <span class=\"token punctuation\">{</span>\n    options <span class=\"token operator\">=</span> <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> warn <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>warn <span class=\"token operator\">||</span> baseWarn\n    <span class=\"token keyword\">delete</span> options<span class=\"token punctuation\">.</span>warn\n\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// detect possible CSP restriction</span>\n      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">'return 1'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/unsafe-eval|CSP/</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string\">'It seems you are using the standalone build of Vue.js in an '</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">'environment with Content Security Policy that prohibits unsafe-eval. '</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">'The template compiler cannot work in this environment. Consider '</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">'relaxing the policy to allow unsafe-eval or pre-compiling your '</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">'templates into render functions.'</span>\n          <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// check cache</span>\n    <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>delimiters\n      <span class=\"token operator\">?</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>delimiters<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> template\n      <span class=\"token punctuation\">:</span> template\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 编译</span>\n    <span class=\"token keyword\">const</span> compiled <span class=\"token operator\">=</span> <span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 检查编译错误/提示</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>compiled<span class=\"token punctuation\">.</span>errors <span class=\"token operator\">&amp;&amp;</span> compiled<span class=\"token punctuation\">.</span>errors<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token template-string\"><span class=\"token string\">`Error compiling template:\\n\\n</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>template<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\n\\n`</span></span> <span class=\"token operator\">+</span>\n          compiled<span class=\"token punctuation\">.</span>errors<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token template-string\"><span class=\"token string\">`- </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>e<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">,</span>\n          vm\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>compiled<span class=\"token punctuation\">.</span>tips <span class=\"token operator\">&amp;&amp;</span> compiled<span class=\"token punctuation\">.</span>tips<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        compiled<span class=\"token punctuation\">.</span>tips<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>msg <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">tip</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 将代码转换为函数</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> fnGenErrors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    res<span class=\"token punctuation\">.</span>render <span class=\"token operator\">=</span> <span class=\"token function\">createFunction</span><span class=\"token punctuation\">(</span>compiled<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">,</span> fnGenErrors<span class=\"token punctuation\">)</span>\n    res<span class=\"token punctuation\">.</span>staticRenderFns <span class=\"token operator\">=</span> compiled<span class=\"token punctuation\">.</span>staticRenderFns<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>code <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">createFunction</span><span class=\"token punctuation\">(</span>code<span class=\"token punctuation\">,</span> fnGenErrors<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 检查函数生成错误.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 只有当编译器本身存在错误时，才会发生这种情况</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 主要用于codegen 开发使用</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>compiled<span class=\"token punctuation\">.</span>errors <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>compiled<span class=\"token punctuation\">.</span>errors<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> fnGenErrors<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token template-string\"><span class=\"token string\">`Failed to generate render function:\\n\\n`</span></span> <span class=\"token operator\">+</span>\n          fnGenErrors<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> err<span class=\"token punctuation\">,</span> code <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> in\\n\\n</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>code<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\n`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          vm\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> res<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"compile\"><a href=\"#compile\" class=\"headerlink\" title=\"compile\"></a>compile<hr></h3><p>通过上面函数我们看到 compileToFunctions 接收三个参数，编译模板 template，编译配置 options 和 Vue 实例 vm。核心代码只有一行</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> compiled <span class=\"token operator\">=</span> <span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"baseCompile\"><a href=\"#baseCompile\" class=\"headerlink\" title=\"baseCompile\"></a>baseCompile<hr></h3><p>compile 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> compiled <span class=\"token operator\">=</span> <span class=\"token function\">baseCompile</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> finalOptions<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>baseCompile 是在执行 createCompilerCreator 方法时作为参数传入的所以绕了一圈真正的入口就是</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// `createCompilerCreator`允许创建使用alternative的编译器</span>\n<span class=\"token comment\" spellcheck=\"true\">// parser/optimizer/codegen, e.g the SSR optimizing compiler.</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这里我们只是使用默认部分导出一个默认编译器</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> createCompiler <span class=\"token operator\">=</span> <span class=\"token function\">createCompilerCreator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> baseCompile <span class=\"token punctuation\">(</span>\n  template<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  options<span class=\"token punctuation\">:</span> CompilerOptions\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> CompiledResult <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> ast <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>optimize <span class=\"token operator\">!==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">optimize</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    ast<span class=\"token punctuation\">,</span>\n    render<span class=\"token punctuation\">:</span> code<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">,</span>\n    staticRenderFns<span class=\"token punctuation\">:</span> code<span class=\"token punctuation\">.</span>staticRenderFns\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"主要执行步骤\"><a href=\"#主要执行步骤\" class=\"headerlink\" title=\"主要执行步骤\"></a>主要执行步骤<hr></h3><blockquote>\n<p>解析模板字符串生成 AST</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> ast <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>优化语法树</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">optimize</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>生成代码</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h2><p>parse 定义在 <code>src/compiler/parser/index.js</code> 中，由于编译流程较为复杂难懂所以我们只了解大概的流程</p>\n<p>parse 接收两个参数 template 和 options 对于 options 不去研究平台特殊性，template 模板的解析主要是通过 parseHTML 函数循环解析</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">parseHTML</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>对于不同情况分别进行不同的处理，在匹配的过程中会利用 advance 函数不断前进整个模板字符串，直到字符串末尾。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> advance <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  index <span class=\"token operator\">+</span><span class=\"token operator\">=</span> n\n  html <span class=\"token operator\">=</span> html<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>对于注释和条件注释节点，前进至它们的末尾位置；对于文档类型节点，则前进它自身长度的距离</li>\n<li>通过 parseStartTag 解析开始标签(通过 startTagOpen配置开始标签，然后定义了 match 对象，通过 handleStartTag 处理 match.attrs,最后调用 options.start回调函数)</li>\n<li>通过正则 endTag 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 parseEndTag 方法对闭合，最后调用 options.end 回调函数</li>\n<li>判断 textEnd 是否大于等于 0 说明从当前位置到 textEnd 位置都是文本，如果 extEnd 小于 0 的情况，则说明整个 template 解析完毕了，将剩余的 html 都赋值给了 text，最后调用了 options.chars 回调函数，并传 text 参数</li>\n</ul>\n<h3 id=\"options-start-处理开始标签\"><a href=\"#options-start-处理开始标签\" class=\"headerlink\" title=\"options.start 处理开始标签\"></a>options.start 处理开始标签<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\nstart <span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">,</span> unary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> <span class=\"token function\">createASTElement</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">processElement</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">treeManagement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>通过 createASTElement 创建 AST 元素</li>\n<li>处理 AST 元素</li>\n<li>AST 树管理</li>\n</ul>\n<blockquote>\n<p>createASTElement</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token comment\" spellcheck=\"true\">// 每一个 AST 元素是一个普通的 JavaScript 对象</span>\n<span class=\"token comment\" spellcheck=\"true\">// type 表示 AST 元素类型</span>\n<span class=\"token comment\" spellcheck=\"true\">// tag 表示标签名</span>\n<span class=\"token comment\" spellcheck=\"true\">// attrsList 表示属性列表</span>\n<span class=\"token comment\" spellcheck=\"true\">// attrsMap 表示属性映射表</span>\n<span class=\"token comment\" spellcheck=\"true\">// parent 表示父的 AST 元素</span>\n<span class=\"token comment\" spellcheck=\"true\">// children 表示子 AST 元素集合。</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> createASTElement <span class=\"token punctuation\">(</span>\n  tag<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  attrs<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>Attr<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  parent<span class=\"token punctuation\">:</span> ASTElement <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> ASTElement <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    tag<span class=\"token punctuation\">,</span>\n    attrsList<span class=\"token punctuation\">:</span> attrs<span class=\"token punctuation\">,</span>\n    attrsMap<span class=\"token punctuation\">:</span> <span class=\"token function\">makeAttrsMap</span><span class=\"token punctuation\">(</span>attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    parent<span class=\"token punctuation\">,</span>\n    children<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>processElement(element)</p>\n</blockquote>\n<p>调用 preTransforms、transforms、postTransforms 函，然后通过各种指令 processXXX 做处理，处理的结果就是扩展 AST 元素的属性，如 processFor 解析 v-for 指令内容，将解析的属性值添加到 AST 的元素上</p>\n<blockquote>\n<p>treeManagement()</p>\n</blockquote>\n<p>AST 树管理的目标是构建一颗 AST 树，本质上利用 stack 栈的数据结构来维护 root 根节点和当前父节点 currentParent。</p>\n<h3 id=\"options-end-处理闭合标签\"><a href=\"#options-end-处理闭合标签\" class=\"headerlink\" title=\"options.end 处理闭合标签\"></a>options.end 处理闭合标签<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">end <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">treeManagement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">closeElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>首先处理了尾部空格的情况,然后把 stack 的元素弹一个出栈，并把 stack 最后一个元素赋值给 currentParent，这样就维护了整个 AST 树。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// remove trailing whitespace</span>\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">const</span> lastNode <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>element<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastNode <span class=\"token operator\">&amp;&amp;</span> lastNode<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token number\">3</span> <span class=\"token operator\">&amp;&amp;</span> lastNode<span class=\"token punctuation\">.</span>text <span class=\"token operator\">===</span> <span class=\"token string\">' '</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>inPre<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  element<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// pop stack</span>\nstack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span>\ncurrentParent <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token function\">closeElement</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>closeElement 更新一下 inVPre 和 inPre 的状态，以及执行 postTransforms 函数 </p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> closeElement <span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// check pre state</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>pre<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    inVPre <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">platformIsPreTag</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    inPre <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// apply post-transforms</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> postTransforms<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    postTransforms<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"options-chars-处理文本内容\"><a href=\"#options-chars-处理文本内容\" class=\"headerlink\" title=\"options.chars 处理文本内容\"></a>options.chars 处理文本内容<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">chars <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">handleText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">createChildrenASTOfText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过执行 parseText(text, delimiters) 对文本解析, 定义在 <code>src/compiler/parser/text-parsre.js</code> 中，主要流程就是</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// 先根据分隔符（默认是 `{{}}`）构造了文本匹配的正则表达式，然后再循环匹配文本</span>\n<span class=\"token comment\" spellcheck=\"true\">// 遇到普通文本就 push 到 rawTokens 和 tokens 中</span>\n<span class=\"token comment\" spellcheck=\"true\">// 如果是表达式就转换成 `_s(${exp})` push 到 tokens 中</span>\n<span class=\"token comment\" spellcheck=\"true\">// 转换成 `{@binding:exp}` push 到 rawTokens 中</span>\n\n<span class=\"token keyword\">const</span> defaultTagRE <span class=\"token operator\">=</span> <span class=\"token regex\">/\\{\\{((?:.|\\n)+?)\\}\\}/g</span>\n<span class=\"token keyword\">const</span> regexEscapeRE <span class=\"token operator\">=</span> <span class=\"token regex\">/[-.*+?^${}()|[\\]\\/\\\\]/g</span>\n\n<span class=\"token keyword\">const</span> buildRegex <span class=\"token operator\">=</span> <span class=\"token function\">cached</span><span class=\"token punctuation\">(</span>delimiters <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> open <span class=\"token operator\">=</span> delimiters<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>regexEscapeRE<span class=\"token punctuation\">,</span> <span class=\"token string\">'\\\\$&amp;'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> close <span class=\"token operator\">=</span> delimiters<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>regexEscapeRE<span class=\"token punctuation\">,</span> <span class=\"token string\">'\\\\$&amp;'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span>open <span class=\"token operator\">+</span> <span class=\"token string\">'((?:.|\\\\n)+?)'</span> <span class=\"token operator\">+</span> close<span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> parseText <span class=\"token punctuation\">(</span>\n  text<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  delimiters<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>string<span class=\"token punctuation\">,</span> string<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> TextParseResult <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> tagRE <span class=\"token operator\">=</span> delimiters <span class=\"token operator\">?</span> <span class=\"token function\">buildRegex</span><span class=\"token punctuation\">(</span>delimiters<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> defaultTagRE\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>tagRE<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> tokens <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> rawTokens <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">let</span> lastIndex <span class=\"token operator\">=</span> tagRE<span class=\"token punctuation\">.</span>lastIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> match<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> tokenValue\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>match <span class=\"token operator\">=</span> tagRE<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    index <span class=\"token operator\">=</span> match<span class=\"token punctuation\">.</span>index\n    <span class=\"token comment\" spellcheck=\"true\">// push text token</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> lastIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      rawTokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>tokenValue <span class=\"token operator\">=</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>lastIndex<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>tokenValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// tag token</span>\n    <span class=\"token keyword\">const</span> exp <span class=\"token operator\">=</span> <span class=\"token function\">parseFilters</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`_s(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>exp<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">)`</span></span><span class=\"token punctuation\">)</span>\n    rawTokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'@binding'</span><span class=\"token punctuation\">:</span> exp <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    lastIndex <span class=\"token operator\">=</span> index <span class=\"token operator\">+</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastIndex <span class=\"token operator\">&lt;</span> text<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    rawTokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>tokenValue <span class=\"token operator\">=</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    tokens<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>tokenValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    expression<span class=\"token punctuation\">:</span> tokens<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'+'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    tokens<span class=\"token punctuation\">:</span> rawTokens\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结 \"></a>小结 <hr></h3><ul>\n<li>parse 的作用就是将 template 模版字符串转换成 AST 树。其实是用对象的形式来描述整个模版，用正则顺序解析模版，达到构建 AST 树的目的</li>\n<li>AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本</li>\n</ul>\n<h2 id=\"optimize\"><a href=\"#optimize\" class=\"headerlink\" title=\"optimize\"></a>optimize</h2><p>optimize 方法的定义，在 <code>src/compiler/optimizer.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> optimize <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>ASTElement<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">:</span> CompilerOptions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span>\n  isStaticKey <span class=\"token operator\">=</span> <span class=\"token function\">genStaticKeysCached</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>staticKeys <span class=\"token operator\">||</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  isPlatformReservedTag <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>isReservedTag <span class=\"token operator\">||</span> no\n  <span class=\"token comment\" spellcheck=\"true\">// first pass: mark all non-static nodes.</span>\n  <span class=\"token function\">markStatic</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// second pass: mark static roots.</span>\n  <span class=\"token function\">markStaticRoots</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> genStaticKeys <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">makeMap</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'type,tag,attrsList,attrsMap,plain,parent,children,attrs'</span> <span class=\"token operator\">+</span>\n    <span class=\"token punctuation\">(</span>keys <span class=\"token operator\">?</span> <span class=\"token string\">','</span> <span class=\"token operator\">+</span> keys <span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过 optimize 函数我们看到优化主要就做了两件事情</p>\n<h3 id=\"markStatic-root-标记静态节点\"><a href=\"#markStatic-root-标记静态节点\" class=\"headerlink\" title=\"markStatic(root) 标记静态节点\"></a>markStatic(root) 标记静态节点<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> markStatic <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">:</span> ASTNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  node<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span> <span class=\"token operator\">=</span> <span class=\"token function\">isStatic</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// do not make component slot content static. this avoids</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 1. components not able to mutate slot nodes</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 2. static slot content fails for hot-reloading</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">!</span><span class=\"token function\">isPlatformReservedTag</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n      node<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">!==</span> <span class=\"token string\">'slot'</span> <span class=\"token operator\">&amp;&amp;</span>\n      node<span class=\"token punctuation\">.</span>attrsMap<span class=\"token punctuation\">[</span><span class=\"token string\">'inline-template'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n      <span class=\"token function\">markStatic</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>child<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>ifConditions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>ifConditions<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> block <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>ifConditions<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>block\n        <span class=\"token function\">markStatic</span><span class=\"token punctuation\">(</span>block<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>block<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          node<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> isStatic <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">:</span> ASTNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> boolean <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// expression</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// text</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>pre <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">!</span>node<span class=\"token punctuation\">.</span>hasBindings <span class=\"token operator\">&amp;&amp;</span> <span class=\"token comment\" spellcheck=\"true\">// no dynamic bindings</span>\n    <span class=\"token operator\">!</span>node<span class=\"token punctuation\">.</span><span class=\"token keyword\">if</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>node<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token comment\" spellcheck=\"true\">// not v-if or v-for or v-else</span>\n    <span class=\"token operator\">!</span><span class=\"token function\">isBuiltInTag</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token comment\" spellcheck=\"true\">// not a built-in</span>\n    <span class=\"token function\">isPlatformReservedTag</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token comment\" spellcheck=\"true\">// not a component</span>\n    <span class=\"token operator\">!</span><span class=\"token function\">isDirectChildOfTemplateFor</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">every</span><span class=\"token punctuation\">(</span>isStaticKey<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>通过 isStatic 函数判断 AST 是否是静态</li>\n<li>type === 2 为表达式不是静态</li>\n<li>type === 3 是纯文本是静态</li>\n<li>普通元素，如果有 pre 属性 是静态</li>\n<li>没有使用 v-if、 v-for 、没有使用其它指令（不包括 v-once）、非内置组件、是平台保留的标签、节点的所有属性的 key 都满足静态 key，这些都满足则这个 AST 节点是一个静态节点</li>\n<li>递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false</li>\n</ul>\n<h3 id=\"markStaticRoots-root-false-标记静态根\"><a href=\"#markStaticRoots-root-false-标记静态根\" class=\"headerlink\" title=\"markStaticRoots(root, false) 标记静态根\"></a>markStaticRoots(root, false) 标记静态根<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> markStaticRoots <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">:</span> ASTNode<span class=\"token punctuation\">,</span> isInFor<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span> <span class=\"token operator\">||</span> node<span class=\"token punctuation\">.</span>once<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      node<span class=\"token punctuation\">.</span>staticInFor <span class=\"token operator\">=</span> isInFor\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// For a node to qualify as a static root, it should have children that</span>\n    <span class=\"token comment\" spellcheck=\"true\">// are not just static text. Otherwise the cost of hoisting out will</span>\n    <span class=\"token comment\" spellcheck=\"true\">// outweigh the benefits and it's better off to just always render it fresh.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span><span class=\"token keyword\">static</span> <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>\n      node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n      node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token number\">3</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      node<span class=\"token punctuation\">.</span>staticRoot <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      node<span class=\"token punctuation\">.</span>staticRoot <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">markStaticRoots</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> isInFor <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>node<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>ifConditions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>ifConditions<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">markStaticRoots</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>ifConditions<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>block<span class=\"token punctuation\">,</span> isInFor<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>对于已经是 static 的节点或者是 v-once 指令的节点，node.staticInFor = isInFor</li>\n<li>本身是一个静态节点外，满足拥有 children，并且 children 不能只是一个文本节点，才有资格成为 staticRoot 的节点</li>\n<li>递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结<hr></h3><p>optimize 的过程，就是深度遍历这个 AST 树，检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这样我们在 patch 的过程就不会对比为静态属性的节点</p>\n<h2 id=\"codegen\"><a href=\"#codegen\" class=\"headerlink\" title=\"codegen\"></a>codegen</h2><p>最后一步就是将优化过后的 AST 树转化成执行的代码</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> <span class=\"token function\">generate</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>generate 函数的定义在 src/compiler/codegen/index.js 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> generate <span class=\"token punctuation\">(</span>\n  ast<span class=\"token punctuation\">:</span> ASTElement <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">,</span>\n  options<span class=\"token punctuation\">:</span> CompilerOptions\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> CodegenResult <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> state <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CodegenState</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> code <span class=\"token operator\">=</span> ast <span class=\"token operator\">?</span> <span class=\"token function\">genElement</span><span class=\"token punctuation\">(</span>ast<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'_c(\"div\")'</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    render<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`with(this){return </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>code<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}`</span></span><span class=\"token punctuation\">,</span>\n    staticRenderFns<span class=\"token punctuation\">:</span> state<span class=\"token punctuation\">.</span>staticRenderFns\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"CodegenState\"><a href=\"#CodegenState\" class=\"headerlink\" title=\"CodegenState \"></a>CodegenState <hr></h3><p>调用 CodegenState 函数，获取所有 modules 中的 genData 函数</p>\n<h3 id=\"genElement\"><a href=\"#genElement\" class=\"headerlink\" title=\"genElement \"></a>genElement <hr></h3><p>调用 genElement 函数生成 code</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> genElement <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">:</span> ASTElement<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">:</span> CodegenState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> string <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>staticRoot <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>el<span class=\"token punctuation\">.</span>staticProcessed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">genStatic</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>once <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>el<span class=\"token punctuation\">.</span>onceProcessed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">genOnce</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>el<span class=\"token punctuation\">.</span>forProcessed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">genFor</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span><span class=\"token keyword\">if</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>el<span class=\"token punctuation\">.</span>ifProcessed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">genIf</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">'template'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>el<span class=\"token punctuation\">.</span>slotTarget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">genChildren</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token string\">'void 0'</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">'slot'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">genSlot</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// component or element</span>\n    <span class=\"token keyword\">let</span> code\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      code <span class=\"token operator\">=</span> <span class=\"token function\">genComponent</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>component<span class=\"token punctuation\">,</span> el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> el<span class=\"token punctuation\">.</span>plain <span class=\"token operator\">?</span> undefined <span class=\"token punctuation\">:</span> <span class=\"token function\">genData</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">const</span> children <span class=\"token operator\">=</span> el<span class=\"token punctuation\">.</span>inlineTemplate <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">genChildren</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n      code <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`_c('</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>el<span class=\"token punctuation\">.</span>tag<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">'${\n        data ? `</span></span><span class=\"token punctuation\">,</span>$<span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span><span class=\"token template-string\"><span class=\"token string\">` : '' // data\n      }${\n        children ? `</span></span><span class=\"token punctuation\">,</span>$<span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token template-string\"><span class=\"token string\">` : '' // children\n      })`</span></span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// module transforms</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> state<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      code <span class=\"token operator\">=</span> state<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> code<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> code\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>根据 AST 的属性执行不同的代码生成函数，这里面有 genStatic、genOnce、genFor、genIf、genChildren、genSlot、genData、genComponent</p>\n<h3 id=\"执行-code\"><a href=\"#执行-code\" class=\"headerlink\" title=\"执行 code \"></a>执行 code <hr></h3><p>用 <code>with(this){return ${code}}</code> 将 code 传入 render 中执行 new Function()</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> compiled <span class=\"token operator\">=</span> <span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\nres<span class=\"token punctuation\">.</span>render <span class=\"token operator\">=</span> <span class=\"token function\">createFunction</span><span class=\"token punctuation\">(</span>compiled<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">,</span> fnGenErrors<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> createFunction <span class=\"token punctuation\">(</span>code<span class=\"token punctuation\">,</span> errors<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span>code<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    errors<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> err<span class=\"token punctuation\">,</span> code <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> noop\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/images/vue-dom-diff12.png\"></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"编译入口\"><a href=\"#编译入口\" class=\"headerlink\" title=\"编译入口\"></a>编译入口</h2><p>还记得我们在第一篇文章介绍整理的执行过程的时候通过，在 $mount 这个函数内调用 compileToFunctions 吗？下面我们再来看看这个方法</p>\n<pre><code class=\"js\">// ...\n  const { render, staticRenderFns } = compileToFunctions(template, {\n    shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref,\n    delimiters: options.delimiters,\n    comments: options.comments\n  }, this)\n  options.render = render\n  options.staticRenderFns = staticRenderFns\n// ...</code></pre>\n<p>compileToFunctions 来至于 <code>src/compiler/index.js</code> 中  createCompiler(baseOptions) </p>\n<pre><code class=\"js\">\n// createCompilerCreator 允许创建使用alternative的编译器\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// 这里我们只是使用默认部分导出一个默认编译器\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})</code></pre>\n<h3 id=\"createCompilerCreator\"><a href=\"#createCompilerCreator\" class=\"headerlink\" title=\"createCompilerCreator \"></a>createCompilerCreator <hr></h3><p>createCompilerCreator 来至于 <code>src/compiler/create-compiler.js</code>中</p>\n<pre><code class=\"js\">export function createCompilerCreator (baseCompile: Function): Function {\n  return function createCompiler (baseOptions: CompilerOptions) {\n    function compile (\n      template: string,\n      options?: CompilerOptions\n    ): CompiledResult {\n      const finalOptions = Object.create(baseOptions)\n      const errors = []\n      const tips = []\n      finalOptions.warn = (msg, tip) =&gt; {\n        (tip ? tips : errors).push(msg)\n      }\n\n      if (options) {\n        // 合并自定义模块\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules)\n        }\n        // 合并自定义指令\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          )\n        }\n        // 复制其他参数\n        for (const key in options) {\n          if (key !== &#39;modules&#39; &amp;&amp; key !== &#39;directives&#39;) {\n            finalOptions[key] = options[key]\n          }\n        }\n      }\n\n      const compiled = baseCompile(template, finalOptions)\n      if (process.env.NODE_ENV !== &#39;production&#39;) {\n        errors.push.apply(errors, detectErrors(compiled.ast))\n      }\n      compiled.errors = errors\n      compiled.tips = tips\n      return compiled\n    }\n\n    return {\n      compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}</code></pre>\n<p>该方法返回了一个 createCompiler 的函数，它接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法属性和 compileToFunctions 属性，这个 compileToFunctions 对应的就是 $mount 函数调用的 compileToFunctions 方法，它是调用 createCompileToFunctionFn 方法的返回值。</p>\n<h3 id=\"createCompileToFunctionFn\"><a href=\"#createCompileToFunctionFn\" class=\"headerlink\" title=\"createCompileToFunctionFn \"></a>createCompileToFunctionFn <hr></h3><p>我们接下来看一下 createCompileToFunctionFn 方法，它的定义在 <code>src/compiler/to-function/js</code> 中</p>\n<pre><code class=\"js\">export function createCompileToFunctionFn (compile: Function): Function {\n  const cache = Object.create(null)\n\n  return function compileToFunctions (\n    template: string,\n    options?: CompilerOptions,\n    vm?: Component\n  ): CompiledFunctionResult {\n    options = extend({}, options)\n    const warn = options.warn || baseWarn\n    delete options.warn\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      // detect possible CSP restriction\n      try {\n        new Function(&#39;return 1&#39;)\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            &#39;It seems you are using the standalone build of Vue.js in an &#39; +\n            &#39;environment with Content Security Policy that prohibits unsafe-eval. &#39; +\n            &#39;The template compiler cannot work in this environment. Consider &#39; +\n            &#39;relaxing the policy to allow unsafe-eval or pre-compiling your &#39; +\n            &#39;templates into render functions.&#39;\n          )\n        }\n      }\n    }\n\n    // check cache\n    const key = options.delimiters\n      ? String(options.delimiters) + template\n      : template\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // 编译\n    const compiled = compile(template, options)\n\n    // 检查编译错误/提示\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      if (compiled.errors &amp;&amp; compiled.errors.length) {\n        warn(\n          `Error compiling template:\\n\\n${template}\\n\\n` +\n          compiled.errors.map(e =&gt; `- ${e}`).join(&#39;\\n&#39;) + &#39;\\n&#39;,\n          vm\n        )\n      }\n      if (compiled.tips &amp;&amp; compiled.tips.length) {\n        compiled.tips.forEach(msg =&gt; tip(msg, vm))\n      }\n    }\n\n    // 将代码转换为函数\n    const res = {}\n    const fnGenErrors = []\n    res.render = createFunction(compiled.render, fnGenErrors)\n    res.staticRenderFns = compiled.staticRenderFns.map(code =&gt; {\n      return createFunction(code, fnGenErrors)\n    })\n\n    // 检查函数生成错误.\n    // 只有当编译器本身存在错误时，才会发生这种情况\n    // 主要用于codegen 开发使用\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      if ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) {\n        warn(\n          `Failed to generate render function:\\n\\n` +\n          fnGenErrors.map(({ err, code }) =&gt; `${err.toString()} in\\n\\n${code}\\n`).join(&#39;\\n&#39;),\n          vm\n        )\n      }\n    }\n\n    return (cache[key] = res)\n  }</code></pre>\n<h3 id=\"compile\"><a href=\"#compile\" class=\"headerlink\" title=\"compile\"></a>compile<hr></h3><p>通过上面函数我们看到 compileToFunctions 接收三个参数，编译模板 template，编译配置 options 和 Vue 实例 vm。核心代码只有一行</p>\n<pre><code class=\"js\">const compiled = compile(template, options)</code></pre>\n<h3 id=\"baseCompile\"><a href=\"#baseCompile\" class=\"headerlink\" title=\"baseCompile\"></a>baseCompile<hr></h3><p>compile 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码：</p>\n<pre><code class=\"js\">const compiled = baseCompile(template, finalOptions)</code></pre>\n<p>baseCompile 是在执行 createCompilerCreator 方法时作为参数传入的所以绕了一圈真正的入口就是</p>\n<pre><code class=\"js\">// `createCompilerCreator`允许创建使用alternative的编译器\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// 这里我们只是使用默认部分导出一个默认编译器\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})</code></pre>\n<h3 id=\"主要执行步骤\"><a href=\"#主要执行步骤\" class=\"headerlink\" title=\"主要执行步骤\"></a>主要执行步骤<hr></h3><blockquote>\n<p>解析模板字符串生成 AST</p>\n</blockquote>\n<pre><code class=\"js\">const ast = parse(template.trim(), options)</code></pre>\n<blockquote>\n<p>优化语法树</p>\n</blockquote>\n<pre><code class=\"js\">optimize(ast, options)</code></pre>\n<blockquote>\n<p>生成代码</p>\n</blockquote>\n<pre><code class=\"js\">const code = generate(ast, options)</code></pre>\n<h2 id=\"parse\"><a href=\"#parse\" class=\"headerlink\" title=\"parse\"></a>parse</h2><p>parse 定义在 <code>src/compiler/parser/index.js</code> 中，由于编译流程较为复杂难懂所以我们只了解大概的流程</p>\n<p>parse 接收两个参数 template 和 options 对于 options 不去研究平台特殊性，template 模板的解析主要是通过 parseHTML 函数循环解析</p>\n<pre><code class=\"js\">parseHTML(template, options)</code></pre>\n<p>对于不同情况分别进行不同的处理，在匹配的过程中会利用 advance 函数不断前进整个模板字符串，直到字符串末尾。</p>\n<pre><code class=\"js\">function advance (n) {\n  index += n\n  html = html.substring(n)\n}</code></pre>\n<ul>\n<li>对于注释和条件注释节点，前进至它们的末尾位置；对于文档类型节点，则前进它自身长度的距离</li>\n<li>通过 parseStartTag 解析开始标签(通过 startTagOpen配置开始标签，然后定义了 match 对象，通过 handleStartTag 处理 match.attrs,最后调用 options.start回调函数)</li>\n<li>通过正则 endTag 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 parseEndTag 方法对闭合，最后调用 options.end 回调函数</li>\n<li>判断 textEnd 是否大于等于 0 说明从当前位置到 textEnd 位置都是文本，如果 extEnd 小于 0 的情况，则说明整个 template 解析完毕了，将剩余的 html 都赋值给了 text，最后调用了 options.chars 回调函数，并传 text 参数</li>\n</ul>\n<h3 id=\"options-start-处理开始标签\"><a href=\"#options-start-处理开始标签\" class=\"headerlink\" title=\"options.start 处理开始标签\"></a>options.start 处理开始标签<hr></h3><pre><code class=\"js\">// ...\nstart (tag, attrs, unary) {\n  let element = createASTElement(tag, attrs)\n  processElement(element)\n  treeManagement()\n}\n// ...</code></pre>\n<ul>\n<li>通过 createASTElement 创建 AST 元素</li>\n<li>处理 AST 元素</li>\n<li>AST 树管理</li>\n</ul>\n<blockquote>\n<p>createASTElement</p>\n</blockquote>\n<pre><code class=\"js\">// ...\n// 每一个 AST 元素是一个普通的 JavaScript 对象\n// type 表示 AST 元素类型\n// tag 表示标签名\n// attrsList 表示属性列表\n// attrsMap 表示属性映射表\n// parent 表示父的 AST 元素\n// children 表示子 AST 元素集合。\nexport function createASTElement (\n  tag: string,\n  attrs: Array&lt;Attr&gt;,\n  parent: ASTElement | void\n): ASTElement {\n  return {\n    type: 1,\n    tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent,\n    children: []\n  }\n}\n// ...</code></pre>\n<blockquote>\n<p>processElement(element)</p>\n</blockquote>\n<p>调用 preTransforms、transforms、postTransforms 函，然后通过各种指令 processXXX 做处理，处理的结果就是扩展 AST 元素的属性，如 processFor 解析 v-for 指令内容，将解析的属性值添加到 AST 的元素上</p>\n<blockquote>\n<p>treeManagement()</p>\n</blockquote>\n<p>AST 树管理的目标是构建一颗 AST 树，本质上利用 stack 栈的数据结构来维护 root 根节点和当前父节点 currentParent。</p>\n<h3 id=\"options-end-处理闭合标签\"><a href=\"#options-end-处理闭合标签\" class=\"headerlink\" title=\"options.end 处理闭合标签\"></a>options.end 处理闭合标签<hr></h3><pre><code class=\"js\">end () {\n  treeManagement()\n  closeElement()\n}</code></pre>\n<blockquote>\n<p>首先处理了尾部空格的情况,然后把 stack 的元素弹一个出栈，并把 stack 最后一个元素赋值给 currentParent，这样就维护了整个 AST 树。</p>\n</blockquote>\n<pre><code class=\"js\">// remove trailing whitespace\nconst element = stack[stack.length - 1]\nconst lastNode = element.children[element.children.length - 1]\nif (lastNode &amp;&amp; lastNode.type === 3 &amp;&amp; lastNode.text === &#39; &#39; &amp;&amp; !inPre) {\n  element.children.pop()\n}\n// pop stack\nstack.length -= 1\ncurrentParent = stack[stack.length - 1]\ncloseElement(element)</code></pre>\n<blockquote>\n<p>closeElement 更新一下 inVPre 和 inPre 的状态，以及执行 postTransforms 函数 </p>\n</blockquote>\n<pre><code class=\"js\">function closeElement (element) {\n  // check pre state\n  if (element.pre) {\n    inVPre = false\n  }\n  if (platformIsPreTag(element.tag)) {\n    inPre = false\n  }\n  // apply post-transforms\n  for (let i = 0; i &lt; postTransforms.length; i++) {\n    postTransforms[i](element, options)\n  }\n}</code></pre>\n<h3 id=\"options-chars-处理文本内容\"><a href=\"#options-chars-处理文本内容\" class=\"headerlink\" title=\"options.chars 处理文本内容\"></a>options.chars 处理文本内容<hr></h3><pre><code class=\"js\">chars (text: string) {\n  handleText()\n  createChildrenASTOfText()\n}</code></pre>\n<p>通过执行 parseText(text, delimiters) 对文本解析, 定义在 <code>src/compiler/parser/text-parsre.js</code> 中，主要流程就是</p>\n<pre><code class=\"js\">\n// 先根据分隔符（默认是 `{{}}`）构造了文本匹配的正则表达式，然后再循环匹配文本\n// 遇到普通文本就 push 到 rawTokens 和 tokens 中\n// 如果是表达式就转换成 `_s(${exp})` push 到 tokens 中\n// 转换成 `{@binding:exp}` push 到 rawTokens 中\n\nconst defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g\nconst regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\n\nconst buildRegex = cached(delimiters =&gt; {\n  const open = delimiters[0].replace(regexEscapeRE, &#39;\\\\$&amp;&#39;)\n  const close = delimiters[1].replace(regexEscapeRE, &#39;\\\\$&amp;&#39;)\n  return new RegExp(open + &#39;((?:.|\\\\n)+?)&#39; + close, &#39;g&#39;)\n})\n\nexport function parseText (\n  text: string,\n  delimiters?: [string, string]\n): TextParseResult | void {\n  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE\n  if (!tagRE.test(text)) {\n    return\n  }\n  const tokens = []\n  const rawTokens = []\n  let lastIndex = tagRE.lastIndex = 0\n  let match, index, tokenValue\n  while ((match = tagRE.exec(text))) {\n    index = match.index\n    // push text token\n    if (index &gt; lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index))\n      tokens.push(JSON.stringify(tokenValue))\n    }\n    // tag token\n    const exp = parseFilters(match[1].trim())\n    tokens.push(`_s(${exp})`)\n    rawTokens.push({ &#39;@binding&#39;: exp })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex &lt; text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex))\n    tokens.push(JSON.stringify(tokenValue))\n  }\n  return {\n    expression: tokens.join(&#39;+&#39;),\n    tokens: rawTokens\n  }\n}</code></pre>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结 \"></a>小结 <hr></h3><ul>\n<li>parse 的作用就是将 template 模版字符串转换成 AST 树。其实是用对象的形式来描述整个模版，用正则顺序解析模版，达到构建 AST 树的目的</li>\n<li>AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本</li>\n</ul>\n<h2 id=\"optimize\"><a href=\"#optimize\" class=\"headerlink\" title=\"optimize\"></a>optimize</h2><p>optimize 方法的定义，在 <code>src/compiler/optimizer.js</code> 中</p>\n<pre><code class=\"js\">export function optimize (root: ?ASTElement, options: CompilerOptions) {\n  if (!root) return\n  isStaticKey = genStaticKeysCached(options.staticKeys || &#39;&#39;)\n  isPlatformReservedTag = options.isReservedTag || no\n  // first pass: mark all non-static nodes.\n  markStatic(root)\n  // second pass: mark static roots.\n  markStaticRoots(root, false)\n}\n\nfunction genStaticKeys (keys: string): Function {\n  return makeMap(\n    &#39;type,tag,attrsList,attrsMap,plain,parent,children,attrs&#39; +\n    (keys ? &#39;,&#39; + keys : &#39;&#39;)\n  )\n}</code></pre>\n<p>通过 optimize 函数我们看到优化主要就做了两件事情</p>\n<h3 id=\"markStatic-root-标记静态节点\"><a href=\"#markStatic-root-标记静态节点\" class=\"headerlink\" title=\"markStatic(root) 标记静态节点\"></a>markStatic(root) 标记静态节点<hr></h3><pre><code class=\"js\">function markStatic (node: ASTNode) {\n  node.static = isStatic(node)\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &amp;&amp;\n      node.tag !== &#39;slot&#39; &amp;&amp;\n      node.attrsMap[&#39;inline-template&#39;] == null\n    ) {\n      return\n    }\n    for (let i = 0, l = node.children.length; i &lt; l; i++) {\n      const child = node.children[i]\n      markStatic(child)\n      if (!child.static) {\n        node.static = false\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n          node.static = false\n        }\n      }\n    }\n  }\n}\n\nfunction isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings &amp;&amp; // no dynamic bindings\n    !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) &amp;&amp; // not a built-in\n    isPlatformReservedTag(node.tag) &amp;&amp; // not a component\n    !isDirectChildOfTemplateFor(node) &amp;&amp;\n    Object.keys(node).every(isStaticKey)\n  ))\n}</code></pre>\n<ul>\n<li>通过 isStatic 函数判断 AST 是否是静态</li>\n<li>type === 2 为表达式不是静态</li>\n<li>type === 3 是纯文本是静态</li>\n<li>普通元素，如果有 pre 属性 是静态</li>\n<li>没有使用 v-if、 v-for 、没有使用其它指令（不包括 v-once）、非内置组件、是平台保留的标签、节点的所有属性的 key 都满足静态 key，这些都满足则这个 AST 节点是一个静态节点</li>\n<li>递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false</li>\n</ul>\n<h3 id=\"markStaticRoots-root-false-标记静态根\"><a href=\"#markStaticRoots-root-false-标记静态根\" class=\"headerlink\" title=\"markStaticRoots(root, false) 标记静态根\"></a>markStaticRoots(root, false) 标记静态根<hr></h3><pre><code class=\"js\">function markStaticRoots (node: ASTNode, isInFor: boolean) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it&#39;s better off to just always render it fresh.\n    if (node.static &amp;&amp; node.children.length &amp;&amp; !(\n      node.children.length === 1 &amp;&amp;\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true\n      return\n    } else {\n      node.staticRoot = false\n    }\n    if (node.children) {\n      for (let i = 0, l = node.children.length; i &lt; l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n      }\n    }\n  }\n}</code></pre>\n<ul>\n<li>对于已经是 static 的节点或者是 v-once 指令的节点，node.staticInFor = isInFor</li>\n<li>本身是一个静态节点外，满足拥有 children，并且 children 不能只是一个文本节点，才有资格成为 staticRoot 的节点</li>\n<li>递归遍历普通元素，如果一旦子节点有不是静态的情况，则父节点的 static 变为 false</li>\n</ul>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结<hr></h3><p>optimize 的过程，就是深度遍历这个 AST 树，检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这样我们在 patch 的过程就不会对比为静态属性的节点</p>\n<h2 id=\"codegen\"><a href=\"#codegen\" class=\"headerlink\" title=\"codegen\"></a>codegen</h2><p>最后一步就是将优化过后的 AST 树转化成执行的代码</p>\n<pre><code class=\"js\">const code = generate(ast, options)</code></pre>\n<p>generate 函数的定义在 src/compiler/codegen/index.js 中</p>\n<pre><code class=\"js\">export function generate (\n  ast: ASTElement | void,\n  options: CompilerOptions\n): CodegenResult {\n  const state = new CodegenState(options)\n  const code = ast ? genElement(ast, state) : &#39;_c(&quot;div&quot;)&#39;\n  return {\n    render: `with(this){return ${code}}`,\n    staticRenderFns: state.staticRenderFns\n  }\n}</code></pre>\n<h3 id=\"CodegenState\"><a href=\"#CodegenState\" class=\"headerlink\" title=\"CodegenState \"></a>CodegenState <hr></h3><p>调用 CodegenState 函数，获取所有 modules 中的 genData 函数</p>\n<h3 id=\"genElement\"><a href=\"#genElement\" class=\"headerlink\" title=\"genElement \"></a>genElement <hr></h3><p>调用 genElement 函数生成 code</p>\n<pre><code class=\"js\">export function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.staticRoot &amp;&amp; !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once &amp;&amp; !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for &amp;&amp; !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if &amp;&amp; !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === &#39;template&#39; &amp;&amp; !el.slotTarget) {\n    return genChildren(el, state) || &#39;void 0&#39;\n  } else if (el.tag === &#39;slot&#39;) {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      const data = el.plain ? undefined : genData(el, state)\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c(&#39;${el.tag}&#39;${\n        data ? `,${data}` : &#39;&#39; // data\n      }${\n        children ? `,${children}` : &#39;&#39; // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i &lt; state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}</code></pre>\n<p>根据 AST 的属性执行不同的代码生成函数，这里面有 genStatic、genOnce、genFor、genIf、genChildren、genSlot、genData、genComponent</p>\n<h3 id=\"执行-code\"><a href=\"#执行-code\" class=\"headerlink\" title=\"执行 code \"></a>执行 code <hr></h3><p>用 <code>with(this){return ${code}}</code> 将 code 传入 render 中执行 new Function()</p>\n<pre><code class=\"js\">const compiled = compile(template, options)\nres.render = createFunction(compiled.render, fnGenErrors)\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n  }\n}</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/images/vue-dom-diff12.png\"></p>\n"},{"title":"vue 原理之组件更新","date":"2019-09-18T02:50:28.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n上一篇文章我们对响应式原理进行了梳理，知道了当数据发生变化会触发 watcher 的回调，进行组件更新，那么接下来我们看看更新的操作是怎么进行了。`src/core/instance/lifecycle.js` 中 `vm._update` 方法\n\n### vm._update <hr>\n\n```js\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  // ...\n  const prevVnode = vm._vnode\n  if (!prevVnode) {\n     // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  // ...\n}\n```\n\n###  vm.__patch__ <hr>\n\n`vm._update` 方法主要通过节点来判断传入的参数，但是执行的方法都是 `vm.__patch__`,接下我们看一下 `src/core/vdom/patch.js` 中 patch 函数\n\n ```js\nreturn function patch (oldVnode, vnode, hydrating, removeOnly) {\n  if (isUndef(vnode)) {\n    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n    return\n  }\n\n  let isInitialPatch = false\n  const insertedVnodeQueue = []\n\n  if (isUndef(oldVnode)) {\n    // empty mount (likely as component), create new root element\n    isInitialPatch = true\n    createElm(vnode, insertedVnodeQueue)\n  } else {\n    const isRealElement = isDef(oldVnode.nodeType)\n    if (!isRealElement && sameVnode(oldVnode, vnode)) {\n      // patch existing root node\n      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n    } else {\n      if (isRealElement) {\n         // ...\n      }\n\n      // replacing existing element\n      const oldElm = oldVnode.elm\n      const parentElm = nodeOps.parentNode(oldElm)\n\n      // create new node\n      createElm(\n        vnode,\n        insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm,\n        nodeOps.nextSibling(oldElm)\n      )\n\n      // update parent placeholder node element, recursively\n      if (isDef(vnode.parent)) {\n        let ancestor = vnode.parent\n        const patchable = isPatchable(vnode)\n        while (ancestor) {\n          for (let i = 0; i < cbs.destroy.length; ++i) {\n            cbs.destroy[i](ancestor)\n          }\n          ancestor.elm = vnode.elm\n          if (patchable) {\n            for (let i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, ancestor)\n            }\n            // #6513\n            // invoke insert hooks that may have been merged by create hooks.\n            // e.g. for directives that uses the \"inserted\" hook.\n            const insert = ancestor.data.hook.insert\n            if (insert.merged) {\n              // start at index 1 to avoid re-invoking component mounted hook\n              for (let i = 1; i < insert.fns.length; i++) {\n                insert.fns[i]()\n              }\n            }\n          } else {\n            registerRef(ancestor)\n          }\n          ancestor = ancestor.parent\n        }\n      }\n\n      // destroy old node\n      if (isDef(parentElm)) {\n        removeVnodes(parentElm, [oldVnode], 0, 0)\n      } else if (isDef(oldVnode.tag)) {\n        invokeDestroyHook(oldVnode)\n      }\n    }\n  }\n\n  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n  return vnode.elm\n}\n ```\n\n\n 可以看到 patch 的逻辑进来通过判断是否有 oldVnode 来区分是否是首次渲染，进行不同的逻辑，接下来我们通过  `sameVNode(oldVnode, vnode)` \n\n```js\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n```\n\n根据 vnode 的 key 进行判断是否是相同的，再继续根据 isComment、data、sameInputType 的类型是否相同来判断同步组件，对于异步组件则通过判断 asyncFactory 是否相同，所以是根据判断它们是否是相同的 vnode 来区分不同的更新逻辑\n\n### 新旧节点不同<hr>\n\n如果新旧节点不同,那么就是替换已经存在的节点大致流程为\n\n- 创建新节点\n- 更新父的占位符节点\n- 删除旧节点\n\n```js\nconst oldElm = oldVnode.elm\nconst parentElm = nodeOps.parentNode(oldElm)\n// create new node\ncreateElm(\n  vnode,\n  insertedVnodeQueue,\n  // extremely rare edge case: do not insert if old element is in a\n  // leaving transition. Only happens when combining  transition +\n  // keep-alive + HOCs. (#4590)\n  oldElm._leaveCb ? null : parentElm,\n  nodeOps.nextSibling(oldElm)\n)\n```\n创建新节点调用的是 createElm 方法， 以当前旧节点为参考，创建新的节点，并插入到 DOM 中\n\n```js\n// update parent placeholder node element, recursively\nif (isDef(vnode.parent)) {\n  let ancestor = vnode.parent\n  const patchable = isPatchable(vnode)\n  while (ancestor) {\n    for (let i = 0; i < cbs.destroy.length; ++i) {\n      cbs.destroy[i](ancestor)\n    }\n    ancestor.elm = vnode.elm\n    if (patchable) {\n      for (let i = 0; i < cbs.create.length; ++i) {\n        cbs.create[i](emptyNode, ancestor)\n      }\n      // #6513\n      // invoke insert hooks that may have been merged by create hooks.\n      // e.g. for directives that uses the \"inserted\" hook.\n      const insert = ancestor.data.hook.insert\n      if (insert.merged) {\n        // start at index 1 to avoid re-invoking component mounted hook\n        for (let i = 1; i < insert.fns.length; i++) {\n          insert.fns[i]()\n        }\n      }\n    } else {\n      registerRef(ancestor)\n    }\n    ancestor = ancestor.parent\n  }\n}\n```\n\n找到当前的 vnode 的 父的占位符节点，先执行 cbs.destroy 钩子函数，如果当前占位符是一个可挂载的节点，则执行 cbs.create 钩子函数\n\n```js\n// destroy old node\nif (isDef(parentElm)) {\n  removeVnodes(parentElm, [oldVnode], 0, 0)\n} else if (isDef(oldVnode.tag)) {\n  invokeDestroyHook(oldVnode)\n}\n```\n\n将 oldVnode 从当前 DOM 树中删除，如果存在父节点，执行 removeVnodes 方法\n\n```js\nfunction removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]\n    if (isDef(ch)) {\n      if (isDef(ch.tag)) {\n        removeAndInvokeRemoveHook(ch)\n        invokeDestroyHook(ch)\n      } else { // Text node\n        removeNode(ch.elm)\n      }\n    }\n  }\n}\n\nfunction removeAndInvokeRemoveHook (vnode, rm) {\n  if (isDef(rm) || isDef(vnode.data)) {\n    let i\n    const listeners = cbs.remove.length + 1\n    if (isDef(rm)) {\n      // we have a recursively passed down rm callback\n      // increase the listeners count\n      rm.listeners += listeners\n    } else {\n      // directly removing\n      rm = createRmCb(vnode.elm, listeners)\n    }\n    // recursively invoke hooks on child component root node\n    if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n      removeAndInvokeRemoveHook(i, rm)\n    }\n    for (i = 0; i < cbs.remove.length; ++i) {\n      cbs.remove[i](vnode, rm)\n    }\n    if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n      i(vnode, rm)\n    } else {\n      rm()\n    }\n  } else {\n    removeNode(vnode.elm)\n  }\n}\n\nfunction invokeDestroyHook (vnode) {\n  let i, j\n  const data = vnode.data\n  if (isDef(data)) {\n    if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode)\n    for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)\n  }\n  if (isDef(i = vnode.children)) {\n    for (j = 0; j < vnode.children.length; ++j) {\n      invokeDestroyHook(vnode.children[j])\n    }\n  }\n}\n```\n\n- 遍历待删除的 vnodes 做删除，\n- 调用 removeAndInvokeRemoveHook 执行 cbs.remove 钩子进行删除。如果存在子节点则进行递归调用 removeAndInvokeRemoveHook\n- 调用 invokeDestroyHook 执行 cbs.destroy 钩子，进行销毁。如果存在子节点则进行递归调用 invokeDestroyHook\n- 执行 removeNode 调用平台的 DOM API 删除真正的 DOM 节点\n\n\n### 新旧节点相同<hr>\n\n```js\n if (!isRealElement && sameVnode(oldVnode, vnode)) {\n    // patch existing root node\n    patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n  } else {\n    // ...\n  }\n```\n\n当新旧节点相同的时候,会调用 patchVnode 方法\n\n```js\nfunction patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n  if (oldVnode === vnode) {\n    return\n  }\n\n  const elm = vnode.elm = oldVnode.elm\n\n  if (isTrue(oldVnode.isAsyncPlaceholder)) {\n    if (isDef(vnode.asyncFactory.resolved)) {\n      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n    } else {\n      vnode.isAsyncPlaceholder = true\n    }\n    return\n  }\n\n  // reuse element for static trees.\n  // note we only do this if the vnode is cloned -\n  // if the new node is not cloned it means the render functions have been\n  // reset by the hot-reload-api and we need to do a proper re-render.\n  if (isTrue(vnode.isStatic) &&\n    isTrue(oldVnode.isStatic) &&\n    vnode.key === oldVnode.key &&\n    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n  ) {\n    vnode.componentInstance = oldVnode.componentInstance\n    return\n  }\n\n  let i\n  const data = vnode.data\n  if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n    i(oldVnode, vnode)\n  }\n\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  if (isDef(data) && isPatchable(vnode)) {\n    for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n    if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)\n  }\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) && isDef(ch)) {\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {\n      nodeOps.setTextContent(elm, '')\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n  if (isDef(data)) {\n    if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)\n  }\n}\n```\n\npatchVnode 将 vnode patch 到旧的 vnode 上将执行以下主要过程\n- 如果两个vnode相等，不需要 patch\n- 如果是异步占位，执行 hydrate 方法或者定义 isAsyncPlaceholder 为 true\n- 当更新的 vnode 是组件 vnode 的时候， 执行 i.prepatch 钩子函数，拿到最新的 vnode 组件配置以及组件的实例后，执行 updateChildComponent 方法更新 vm 实例上一系列的属性和方法\n- 执行 cbs.update 钩子函数\n- 完成 patch 过程\n- 执行 postpatch 钩子函数\n\n上面执行的步骤我们重点关注一下完成 patch 的过程，这也是 vnode diff 最复杂的地方\n\n```js\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) && isDef(ch)) {\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {\n      nodeOps.setTextContent(elm, '')\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n```\n\n- 如果 vnode 是个文本节点且新旧文本不相同，则直接替换文本内容，否则根据不同情况处理逻辑\n- oldCh 与 ch 都存在且不相同时，调用 updateChildren 来更新子节点\n- 当只有 ch 存在，判断旧的节点是文本节点则先将节点的文本清除，然后通过 addVnodes 将 ch 批量插入到新节点 elm 下，表示不需要旧节点了\n- 当只有 oldCh 存在，将旧的节点通过 removeVnodes 全部清除，表示更新的是空节点\n- 当只有旧节点是文本节点的时候，则清除其节点文本内容\n\n### updateChildren <hr>\n上面在判断 oldCh 与 ch 都存在且不相同时调用 updateChildren 来更新子节点，接下来我们看看这个函数\n\n```js\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n  let oldStartIdx = 0\n  let newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0] \n  let oldEndVnode = oldCh[oldEndIdx] \n  let newEndIdx = newCh.length - 1 \n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n  \n  // removeOnly 是一个只用于 <transition-group> 的特殊标签，\n  // 确保移除元素过程中保持一个正确的相对位置。\n  const canMove = !removeOnly\n\n  if (process.env.NODE_ENV !== 'production') {\n    checkDuplicateKeys(newCh)\n  }\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (isUndef(oldStartVnode)) {\n      // 开始老 vnode 向右一位\n      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n    } else if (isUndef(oldEndVnode)) {\n      // 结束老 vnode 向左一位\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      // 新旧开始 vnode 相似，进行pacth。开始 vnode 向右一位\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      // 新旧结束 vnode 相似，进行patch。结束 vnode 向左一位\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n      // 新结束 vnode 和老开始 vnode 相似，进行patch。\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      // 老开始 vnode 插入到真实 DOM 中，老开始 vnode 向右一位，新结束 vnode 向左一位\n      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n     // 老结束 vnode 和新开始 vnode 相似，进行 patch。\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      // 老结束 vnode 插入到真实 DOM 中，老结束 vnode 向左一位，新开始 vnode 向右一位\n      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      // 获取老 Idx 的 key\n      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n      // 给老 idx 赋值\n      idxInOld = isDef(newStartVnode.key)\n        ? oldKeyToIdx[newStartVnode.key]\n        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n      if (isUndef(idxInOld)) { // New element\n        // 如果老 idx 为 undefined，说明没有这个元素，创建新 DOM 元素。\n        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n      } else {\n        // 获取 vnode\n        vnodeToMove = oldCh[idxInOld]\n        if (sameVnode(vnodeToMove, newStartVnode)) {\n          // 如果生成的 vnode 和新开始 vnode 相似，执行 patch。\n          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n          // 赋值 undefined，插入 vnodeToMove 元素\n          oldCh[idxInOld] = undefined\n          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n        } else {\n          // 相同的key不同的元素，视为新元素\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        }\n      }\n      // 新开始 vnode 向右一位\n      newStartVnode = newCh[++newStartIdx]\n    }\n  }\n  // 如果老开始 idx 大于老结束 idx，如果是有效数据则添加 vnode 到新 vnode 中。\n  if (oldStartIdx > oldEndIdx) {\n    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n```\n\n\n上面的逻辑比较复杂，我们通过一个简单的例子先来看一下\n```js\n<div id=\"app\">\n  <div>\n    <ul>\n      <li v-for=\"item in items\" :key=\"item.id\">{{ item.val }}</li>\n    </ul>\n  </div>\n  <button @click=\"change\">点击我</button>\n</div>\n\n<script>\n  var app = new Vue({\n    el: '#app',\n    data: {\n      items: [\n        { id: 0, val: 'A' },\n        { id: 1, val: 'B' },\n        { id: 2, val: 'C' },\n        { id: 3, val: 'D' }\n      ]\n    },\n    methods: {\n      change() {\n        this.items.reverse().push({ id: 4, val: 'E' })\n      }\n    }\n  })\n</script>\n```\n\n上面的代码很简单就是初始化的时候渲染列表为 A、B、C、D，当点击的时候将数据中 push 一个 E 并且进行反转，结果为 D、C、B、A、E 那么具体怎么更新的呢，看一下下面的流程\n\n第一步:\n<img src=\"/images/vue-dom-diff01.png\">\n\n第二步:\n<img src=\"/images/vue-dom-diff02.png\">\n\n第三步:\n<img src=\"/images/vue-dom-diff03.png\">\n\n第四步:\n<img src=\"/images/vue-dom-diff04.png\">\n\n第五步:\n<img src=\"/images/vue-dom-diff05.png\">\n\n第六步:\n<img src=\"/images/vue-dom-diff06.png\">\n\n\n通过上面流程图，我们很清晰的知道实际上就是新旧节点对比移动的过程那么我们拆分 updateChildren 函数\n\n> 初始化全局变量\n\n```js\n  let oldStartIdx = 0  // 旧节点索引开始位置\n  let newStartIdx = 0 // 新节点索引开始位置\n  let oldEndIdx = oldCh.length - 1 // 旧节点索引终点位置\n  let oldStartVnode = oldCh[0] //  旧节点开始值\n  let oldEndVnode = oldCh[oldEndIdx] // 旧节点最后一位的值\n  let newEndIdx = newCh.length - 1 // 新节点索引结束位置\n  let newStartVnode = newCh[0] // 新节点开始值\n  let newEndVnode = newCh[newEndIdx] // 新节点结束的值\n```\n\n> 定义循环，在遍历过程中，oldStartIdx 和 newStartIdx 递增，oldEndIdx 和 newEndIdx 递减。当条件不符合跳出遍历循环\n\n```js\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n  // ...\n}\n```\n\n> 检测 oldStartVnode、oldEndVnode。如果 oldStartVnode 不存在，oldCh 起始点向后移动。如果 oldEndVnode 不存在，oldCh 终止点向前移动。\n\n```js\nif (isUndef(oldStartVnode)) {\n  oldStartVnode = oldCh[++oldStartIdx]\n} else if (isUndef(oldEndVnode)) {\n  oldEndVnode = oldCh[--oldEndIdx]\n}\n```\n\n> 对比 oldStartVnode 和 newStartVnode 如果为真则执行 patchVnode 同时彼此向后移动一位\n\n```js\nelse if (sameVnode(oldStartVnode, newStartVnode)) {\n  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n  oldStartVnode = oldCh[++oldStartIdx]\n  newStartVnode = newCh[++newStartIdx]\n}\n```\n\n>  对比 oldEndVnode 和 newEndVnode 如果为真则执行 patchVnode 同时彼此向前移动一位\n\n```js\nelse if (sameVnode(oldEndVnode, newEndVnode)) {\n  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newEndVnode = newCh[--newEndIdx]\n}\n```\n\n> 对比 oldStartVnode 和 newEndVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组最后一位\n\n```js\nelse if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n  canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n  oldStartVnode = oldCh[++oldStartIdx]\n  newEndVnode = newCh[--newEndIdx]\n}\n```\n\n> 对比 oldEndVnode 和 newStartVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组第一位\n\n```js\nelse if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n  patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n  canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newStartVnode = newCh[++newStartIdx]\n}\n```\n> 对比 idx 如果没有相同的 idx 则执行 createElm 创建元素。\n\n```js\nif (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\nidxInOld = isDef(newStartVnode.key)\n  ? oldKeyToIdx[newStartVnode.key]\n  : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\nif (isUndef(idxInOld)) { // New element\n  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n}\n```\n\n>  对比 idx 如果两个 vnode 相似，则先执行 patchVnode，节点移动到 vnode 数组第一位。如果两个 vnode 不相似，视为新元素，执行 createElm 创建\n\n```js\nvnodeToMove = oldCh[idxInOld]\nif (sameVnode(vnodeToMove, newStartVnode)) {\n  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n  oldCh[idxInOld] = undefined\n  canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n} else {\n // same key but different element. treat as new element\n createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n}\nnewStartVnode = newCh[++newStartIdx]\n```\n\n>  如果老 vnode 数组的开始索引大于结束索引，说明新 node 数组长度大于老 vnode 数组，执行 addVnodes 方法添加这些新 vnode 到 DOM 中\n\n```js\nif (oldStartIdx > oldEndIdx) {\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n}\n```\n\n> 如果老 vnode 数组的开始索引小于结束索引，说明老 node 数组长度大于新 vnode 数组，执行 removeVnodes 方法从 DOM 中移除老 vnode 数组中多余的 vnode\n\n```js\nelse if (newStartIdx > newEndIdx) {\n  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n}\n```\n\n### 总结\n\n经过上面的代码解析我们知道 vue 的 diff 对默认的 diff 执行了优化，查找的同一级的节点通过唯一的 key 去区分。如果节点类型相同重新设置该节点的属性，直接更新。如果不同，直接干掉前面的节点，创建并插入新的节点，不再比较这个节点以后的子节点。而不是同一级别每一个去比较并更新替换。如下图\n<img src=\"/images/vue-dom-diff08.png\">\n\n如上图我们希望在 A 和 B 之间加一个 F，那默认的 diff 算法是这样的\n<img src=\"/images/vue-dom-diff09.png\">\n\nvue 通过每一个节点的 key 标识符是这样的\n<img src=\"/images/vue-dom-diff10.png\">\n\n下面我们通过 一张图来大致总结 patchVnode 的流程\n<img src=\"/images/vue-dom-diff11.png\">\n","source":"_posts/vue/vueComUpdate.md","raw":"---\ntitle: vue 原理之组件更新\ndate: 2019-09-18 10:50:28\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n上一篇文章我们对响应式原理进行了梳理，知道了当数据发生变化会触发 watcher 的回调，进行组件更新，那么接下来我们看看更新的操作是怎么进行了。`src/core/instance/lifecycle.js` 中 `vm._update` 方法\n\n### vm._update <hr>\n\n```js\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  // ...\n  const prevVnode = vm._vnode\n  if (!prevVnode) {\n     // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  // ...\n}\n```\n\n###  vm.__patch__ <hr>\n\n`vm._update` 方法主要通过节点来判断传入的参数，但是执行的方法都是 `vm.__patch__`,接下我们看一下 `src/core/vdom/patch.js` 中 patch 函数\n\n ```js\nreturn function patch (oldVnode, vnode, hydrating, removeOnly) {\n  if (isUndef(vnode)) {\n    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n    return\n  }\n\n  let isInitialPatch = false\n  const insertedVnodeQueue = []\n\n  if (isUndef(oldVnode)) {\n    // empty mount (likely as component), create new root element\n    isInitialPatch = true\n    createElm(vnode, insertedVnodeQueue)\n  } else {\n    const isRealElement = isDef(oldVnode.nodeType)\n    if (!isRealElement && sameVnode(oldVnode, vnode)) {\n      // patch existing root node\n      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n    } else {\n      if (isRealElement) {\n         // ...\n      }\n\n      // replacing existing element\n      const oldElm = oldVnode.elm\n      const parentElm = nodeOps.parentNode(oldElm)\n\n      // create new node\n      createElm(\n        vnode,\n        insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm,\n        nodeOps.nextSibling(oldElm)\n      )\n\n      // update parent placeholder node element, recursively\n      if (isDef(vnode.parent)) {\n        let ancestor = vnode.parent\n        const patchable = isPatchable(vnode)\n        while (ancestor) {\n          for (let i = 0; i < cbs.destroy.length; ++i) {\n            cbs.destroy[i](ancestor)\n          }\n          ancestor.elm = vnode.elm\n          if (patchable) {\n            for (let i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, ancestor)\n            }\n            // #6513\n            // invoke insert hooks that may have been merged by create hooks.\n            // e.g. for directives that uses the \"inserted\" hook.\n            const insert = ancestor.data.hook.insert\n            if (insert.merged) {\n              // start at index 1 to avoid re-invoking component mounted hook\n              for (let i = 1; i < insert.fns.length; i++) {\n                insert.fns[i]()\n              }\n            }\n          } else {\n            registerRef(ancestor)\n          }\n          ancestor = ancestor.parent\n        }\n      }\n\n      // destroy old node\n      if (isDef(parentElm)) {\n        removeVnodes(parentElm, [oldVnode], 0, 0)\n      } else if (isDef(oldVnode.tag)) {\n        invokeDestroyHook(oldVnode)\n      }\n    }\n  }\n\n  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n  return vnode.elm\n}\n ```\n\n\n 可以看到 patch 的逻辑进来通过判断是否有 oldVnode 来区分是否是首次渲染，进行不同的逻辑，接下来我们通过  `sameVNode(oldVnode, vnode)` \n\n```js\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n```\n\n根据 vnode 的 key 进行判断是否是相同的，再继续根据 isComment、data、sameInputType 的类型是否相同来判断同步组件，对于异步组件则通过判断 asyncFactory 是否相同，所以是根据判断它们是否是相同的 vnode 来区分不同的更新逻辑\n\n### 新旧节点不同<hr>\n\n如果新旧节点不同,那么就是替换已经存在的节点大致流程为\n\n- 创建新节点\n- 更新父的占位符节点\n- 删除旧节点\n\n```js\nconst oldElm = oldVnode.elm\nconst parentElm = nodeOps.parentNode(oldElm)\n// create new node\ncreateElm(\n  vnode,\n  insertedVnodeQueue,\n  // extremely rare edge case: do not insert if old element is in a\n  // leaving transition. Only happens when combining  transition +\n  // keep-alive + HOCs. (#4590)\n  oldElm._leaveCb ? null : parentElm,\n  nodeOps.nextSibling(oldElm)\n)\n```\n创建新节点调用的是 createElm 方法， 以当前旧节点为参考，创建新的节点，并插入到 DOM 中\n\n```js\n// update parent placeholder node element, recursively\nif (isDef(vnode.parent)) {\n  let ancestor = vnode.parent\n  const patchable = isPatchable(vnode)\n  while (ancestor) {\n    for (let i = 0; i < cbs.destroy.length; ++i) {\n      cbs.destroy[i](ancestor)\n    }\n    ancestor.elm = vnode.elm\n    if (patchable) {\n      for (let i = 0; i < cbs.create.length; ++i) {\n        cbs.create[i](emptyNode, ancestor)\n      }\n      // #6513\n      // invoke insert hooks that may have been merged by create hooks.\n      // e.g. for directives that uses the \"inserted\" hook.\n      const insert = ancestor.data.hook.insert\n      if (insert.merged) {\n        // start at index 1 to avoid re-invoking component mounted hook\n        for (let i = 1; i < insert.fns.length; i++) {\n          insert.fns[i]()\n        }\n      }\n    } else {\n      registerRef(ancestor)\n    }\n    ancestor = ancestor.parent\n  }\n}\n```\n\n找到当前的 vnode 的 父的占位符节点，先执行 cbs.destroy 钩子函数，如果当前占位符是一个可挂载的节点，则执行 cbs.create 钩子函数\n\n```js\n// destroy old node\nif (isDef(parentElm)) {\n  removeVnodes(parentElm, [oldVnode], 0, 0)\n} else if (isDef(oldVnode.tag)) {\n  invokeDestroyHook(oldVnode)\n}\n```\n\n将 oldVnode 从当前 DOM 树中删除，如果存在父节点，执行 removeVnodes 方法\n\n```js\nfunction removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]\n    if (isDef(ch)) {\n      if (isDef(ch.tag)) {\n        removeAndInvokeRemoveHook(ch)\n        invokeDestroyHook(ch)\n      } else { // Text node\n        removeNode(ch.elm)\n      }\n    }\n  }\n}\n\nfunction removeAndInvokeRemoveHook (vnode, rm) {\n  if (isDef(rm) || isDef(vnode.data)) {\n    let i\n    const listeners = cbs.remove.length + 1\n    if (isDef(rm)) {\n      // we have a recursively passed down rm callback\n      // increase the listeners count\n      rm.listeners += listeners\n    } else {\n      // directly removing\n      rm = createRmCb(vnode.elm, listeners)\n    }\n    // recursively invoke hooks on child component root node\n    if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n      removeAndInvokeRemoveHook(i, rm)\n    }\n    for (i = 0; i < cbs.remove.length; ++i) {\n      cbs.remove[i](vnode, rm)\n    }\n    if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n      i(vnode, rm)\n    } else {\n      rm()\n    }\n  } else {\n    removeNode(vnode.elm)\n  }\n}\n\nfunction invokeDestroyHook (vnode) {\n  let i, j\n  const data = vnode.data\n  if (isDef(data)) {\n    if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode)\n    for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)\n  }\n  if (isDef(i = vnode.children)) {\n    for (j = 0; j < vnode.children.length; ++j) {\n      invokeDestroyHook(vnode.children[j])\n    }\n  }\n}\n```\n\n- 遍历待删除的 vnodes 做删除，\n- 调用 removeAndInvokeRemoveHook 执行 cbs.remove 钩子进行删除。如果存在子节点则进行递归调用 removeAndInvokeRemoveHook\n- 调用 invokeDestroyHook 执行 cbs.destroy 钩子，进行销毁。如果存在子节点则进行递归调用 invokeDestroyHook\n- 执行 removeNode 调用平台的 DOM API 删除真正的 DOM 节点\n\n\n### 新旧节点相同<hr>\n\n```js\n if (!isRealElement && sameVnode(oldVnode, vnode)) {\n    // patch existing root node\n    patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n  } else {\n    // ...\n  }\n```\n\n当新旧节点相同的时候,会调用 patchVnode 方法\n\n```js\nfunction patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n  if (oldVnode === vnode) {\n    return\n  }\n\n  const elm = vnode.elm = oldVnode.elm\n\n  if (isTrue(oldVnode.isAsyncPlaceholder)) {\n    if (isDef(vnode.asyncFactory.resolved)) {\n      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n    } else {\n      vnode.isAsyncPlaceholder = true\n    }\n    return\n  }\n\n  // reuse element for static trees.\n  // note we only do this if the vnode is cloned -\n  // if the new node is not cloned it means the render functions have been\n  // reset by the hot-reload-api and we need to do a proper re-render.\n  if (isTrue(vnode.isStatic) &&\n    isTrue(oldVnode.isStatic) &&\n    vnode.key === oldVnode.key &&\n    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n  ) {\n    vnode.componentInstance = oldVnode.componentInstance\n    return\n  }\n\n  let i\n  const data = vnode.data\n  if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n    i(oldVnode, vnode)\n  }\n\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  if (isDef(data) && isPatchable(vnode)) {\n    for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n    if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)\n  }\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) && isDef(ch)) {\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {\n      nodeOps.setTextContent(elm, '')\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n  if (isDef(data)) {\n    if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)\n  }\n}\n```\n\npatchVnode 将 vnode patch 到旧的 vnode 上将执行以下主要过程\n- 如果两个vnode相等，不需要 patch\n- 如果是异步占位，执行 hydrate 方法或者定义 isAsyncPlaceholder 为 true\n- 当更新的 vnode 是组件 vnode 的时候， 执行 i.prepatch 钩子函数，拿到最新的 vnode 组件配置以及组件的实例后，执行 updateChildComponent 方法更新 vm 实例上一系列的属性和方法\n- 执行 cbs.update 钩子函数\n- 完成 patch 过程\n- 执行 postpatch 钩子函数\n\n上面执行的步骤我们重点关注一下完成 patch 的过程，这也是 vnode diff 最复杂的地方\n\n```js\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) && isDef(ch)) {\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {\n      nodeOps.setTextContent(elm, '')\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n```\n\n- 如果 vnode 是个文本节点且新旧文本不相同，则直接替换文本内容，否则根据不同情况处理逻辑\n- oldCh 与 ch 都存在且不相同时，调用 updateChildren 来更新子节点\n- 当只有 ch 存在，判断旧的节点是文本节点则先将节点的文本清除，然后通过 addVnodes 将 ch 批量插入到新节点 elm 下，表示不需要旧节点了\n- 当只有 oldCh 存在，将旧的节点通过 removeVnodes 全部清除，表示更新的是空节点\n- 当只有旧节点是文本节点的时候，则清除其节点文本内容\n\n### updateChildren <hr>\n上面在判断 oldCh 与 ch 都存在且不相同时调用 updateChildren 来更新子节点，接下来我们看看这个函数\n\n```js\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n  let oldStartIdx = 0\n  let newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0] \n  let oldEndVnode = oldCh[oldEndIdx] \n  let newEndIdx = newCh.length - 1 \n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n  \n  // removeOnly 是一个只用于 <transition-group> 的特殊标签，\n  // 确保移除元素过程中保持一个正确的相对位置。\n  const canMove = !removeOnly\n\n  if (process.env.NODE_ENV !== 'production') {\n    checkDuplicateKeys(newCh)\n  }\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (isUndef(oldStartVnode)) {\n      // 开始老 vnode 向右一位\n      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n    } else if (isUndef(oldEndVnode)) {\n      // 结束老 vnode 向左一位\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      // 新旧开始 vnode 相似，进行pacth。开始 vnode 向右一位\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      // 新旧结束 vnode 相似，进行patch。结束 vnode 向左一位\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n      // 新结束 vnode 和老开始 vnode 相似，进行patch。\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      // 老开始 vnode 插入到真实 DOM 中，老开始 vnode 向右一位，新结束 vnode 向左一位\n      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n     // 老结束 vnode 和新开始 vnode 相似，进行 patch。\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      // 老结束 vnode 插入到真实 DOM 中，老结束 vnode 向左一位，新开始 vnode 向右一位\n      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      // 获取老 Idx 的 key\n      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n      // 给老 idx 赋值\n      idxInOld = isDef(newStartVnode.key)\n        ? oldKeyToIdx[newStartVnode.key]\n        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n      if (isUndef(idxInOld)) { // New element\n        // 如果老 idx 为 undefined，说明没有这个元素，创建新 DOM 元素。\n        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n      } else {\n        // 获取 vnode\n        vnodeToMove = oldCh[idxInOld]\n        if (sameVnode(vnodeToMove, newStartVnode)) {\n          // 如果生成的 vnode 和新开始 vnode 相似，执行 patch。\n          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n          // 赋值 undefined，插入 vnodeToMove 元素\n          oldCh[idxInOld] = undefined\n          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n        } else {\n          // 相同的key不同的元素，视为新元素\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        }\n      }\n      // 新开始 vnode 向右一位\n      newStartVnode = newCh[++newStartIdx]\n    }\n  }\n  // 如果老开始 idx 大于老结束 idx，如果是有效数据则添加 vnode 到新 vnode 中。\n  if (oldStartIdx > oldEndIdx) {\n    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n```\n\n\n上面的逻辑比较复杂，我们通过一个简单的例子先来看一下\n```js\n<div id=\"app\">\n  <div>\n    <ul>\n      <li v-for=\"item in items\" :key=\"item.id\">{{ item.val }}</li>\n    </ul>\n  </div>\n  <button @click=\"change\">点击我</button>\n</div>\n\n<script>\n  var app = new Vue({\n    el: '#app',\n    data: {\n      items: [\n        { id: 0, val: 'A' },\n        { id: 1, val: 'B' },\n        { id: 2, val: 'C' },\n        { id: 3, val: 'D' }\n      ]\n    },\n    methods: {\n      change() {\n        this.items.reverse().push({ id: 4, val: 'E' })\n      }\n    }\n  })\n</script>\n```\n\n上面的代码很简单就是初始化的时候渲染列表为 A、B、C、D，当点击的时候将数据中 push 一个 E 并且进行反转，结果为 D、C、B、A、E 那么具体怎么更新的呢，看一下下面的流程\n\n第一步:\n<img src=\"/images/vue-dom-diff01.png\">\n\n第二步:\n<img src=\"/images/vue-dom-diff02.png\">\n\n第三步:\n<img src=\"/images/vue-dom-diff03.png\">\n\n第四步:\n<img src=\"/images/vue-dom-diff04.png\">\n\n第五步:\n<img src=\"/images/vue-dom-diff05.png\">\n\n第六步:\n<img src=\"/images/vue-dom-diff06.png\">\n\n\n通过上面流程图，我们很清晰的知道实际上就是新旧节点对比移动的过程那么我们拆分 updateChildren 函数\n\n> 初始化全局变量\n\n```js\n  let oldStartIdx = 0  // 旧节点索引开始位置\n  let newStartIdx = 0 // 新节点索引开始位置\n  let oldEndIdx = oldCh.length - 1 // 旧节点索引终点位置\n  let oldStartVnode = oldCh[0] //  旧节点开始值\n  let oldEndVnode = oldCh[oldEndIdx] // 旧节点最后一位的值\n  let newEndIdx = newCh.length - 1 // 新节点索引结束位置\n  let newStartVnode = newCh[0] // 新节点开始值\n  let newEndVnode = newCh[newEndIdx] // 新节点结束的值\n```\n\n> 定义循环，在遍历过程中，oldStartIdx 和 newStartIdx 递增，oldEndIdx 和 newEndIdx 递减。当条件不符合跳出遍历循环\n\n```js\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n  // ...\n}\n```\n\n> 检测 oldStartVnode、oldEndVnode。如果 oldStartVnode 不存在，oldCh 起始点向后移动。如果 oldEndVnode 不存在，oldCh 终止点向前移动。\n\n```js\nif (isUndef(oldStartVnode)) {\n  oldStartVnode = oldCh[++oldStartIdx]\n} else if (isUndef(oldEndVnode)) {\n  oldEndVnode = oldCh[--oldEndIdx]\n}\n```\n\n> 对比 oldStartVnode 和 newStartVnode 如果为真则执行 patchVnode 同时彼此向后移动一位\n\n```js\nelse if (sameVnode(oldStartVnode, newStartVnode)) {\n  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n  oldStartVnode = oldCh[++oldStartIdx]\n  newStartVnode = newCh[++newStartIdx]\n}\n```\n\n>  对比 oldEndVnode 和 newEndVnode 如果为真则执行 patchVnode 同时彼此向前移动一位\n\n```js\nelse if (sameVnode(oldEndVnode, newEndVnode)) {\n  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newEndVnode = newCh[--newEndIdx]\n}\n```\n\n> 对比 oldStartVnode 和 newEndVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组最后一位\n\n```js\nelse if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n  canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n  oldStartVnode = oldCh[++oldStartIdx]\n  newEndVnode = newCh[--newEndIdx]\n}\n```\n\n> 对比 oldEndVnode 和 newStartVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组第一位\n\n```js\nelse if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n  patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n  canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newStartVnode = newCh[++newStartIdx]\n}\n```\n> 对比 idx 如果没有相同的 idx 则执行 createElm 创建元素。\n\n```js\nif (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\nidxInOld = isDef(newStartVnode.key)\n  ? oldKeyToIdx[newStartVnode.key]\n  : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\nif (isUndef(idxInOld)) { // New element\n  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n}\n```\n\n>  对比 idx 如果两个 vnode 相似，则先执行 patchVnode，节点移动到 vnode 数组第一位。如果两个 vnode 不相似，视为新元素，执行 createElm 创建\n\n```js\nvnodeToMove = oldCh[idxInOld]\nif (sameVnode(vnodeToMove, newStartVnode)) {\n  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n  oldCh[idxInOld] = undefined\n  canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n} else {\n // same key but different element. treat as new element\n createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n}\nnewStartVnode = newCh[++newStartIdx]\n```\n\n>  如果老 vnode 数组的开始索引大于结束索引，说明新 node 数组长度大于老 vnode 数组，执行 addVnodes 方法添加这些新 vnode 到 DOM 中\n\n```js\nif (oldStartIdx > oldEndIdx) {\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n}\n```\n\n> 如果老 vnode 数组的开始索引小于结束索引，说明老 node 数组长度大于新 vnode 数组，执行 removeVnodes 方法从 DOM 中移除老 vnode 数组中多余的 vnode\n\n```js\nelse if (newStartIdx > newEndIdx) {\n  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n}\n```\n\n### 总结\n\n经过上面的代码解析我们知道 vue 的 diff 对默认的 diff 执行了优化，查找的同一级的节点通过唯一的 key 去区分。如果节点类型相同重新设置该节点的属性，直接更新。如果不同，直接干掉前面的节点，创建并插入新的节点，不再比较这个节点以后的子节点。而不是同一级别每一个去比较并更新替换。如下图\n<img src=\"/images/vue-dom-diff08.png\">\n\n如上图我们希望在 A 和 B 之间加一个 F，那默认的 diff 算法是这样的\n<img src=\"/images/vue-dom-diff09.png\">\n\nvue 通过每一个节点的 key 标识符是这样的\n<img src=\"/images/vue-dom-diff10.png\">\n\n下面我们通过 一张图来大致总结 patchVnode 的流程\n<img src=\"/images/vue-dom-diff11.png\">\n","slug":"vue/vueComUpdate","published":1,"updated":"2019-10-15T01:29:42.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8owv009ib0u6vejhfjlc","content":"<p>上一篇文章我们对响应式原理进行了梳理，知道了当数据发生变化会触发 watcher 的回调，进行组件更新，那么接下来我们看看更新的操作是怎么进行了。<code>src/core/instance/lifecycle.js</code> 中 <code>vm._update</code> 方法</p>\n<h3 id=\"vm-update\"><a href=\"#vm-update\" class=\"headerlink\" title=\"vm._update \"></a>vm._update <hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_update <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">:</span> VNode<span class=\"token punctuation\">,</span> hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> vm<span class=\"token punctuation\">:</span> Component <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">const</span> prevVnode <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_vnode\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>prevVnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">// initial render</span>\n    vm<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span><span class=\"token function\">__patch__</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$el<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span> <span class=\"token comment\" spellcheck=\"true\">/* removeOnly */</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// updates</span>\n    vm<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span><span class=\"token function\">__patch__</span><span class=\"token punctuation\">(</span>prevVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"vm-patch\"><a href=\"#vm-patch\" class=\"headerlink\" title=\"vm.patch \"></a>vm.<strong>patch</strong> <hr></h3><p><code>vm._update</code> 方法主要通过节点来判断传入的参数，但是执行的方法都是 <code>vm.__patch__</code>,接下我们看一下 <code>src/core/vdom/patch.js</code> 中 patch 函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> patch <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">let</span> isInitialPatch <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token keyword\">const</span> insertedVnodeQueue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// empty mount (likely as component), create new root element</span>\n    isInitialPatch <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> isRealElement <span class=\"token operator\">=</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>nodeType<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isRealElement <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// patch existing root node</span>\n      <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isRealElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// replacing existing element</span>\n      <span class=\"token keyword\">const</span> oldElm <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>elm\n      <span class=\"token keyword\">const</span> parentElm <span class=\"token operator\">=</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">parentNode</span><span class=\"token punctuation\">(</span>oldElm<span class=\"token punctuation\">)</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// create new node</span>\n      <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>\n        vnode<span class=\"token punctuation\">,</span>\n        insertedVnodeQueue<span class=\"token punctuation\">,</span>\n        <span class=\"token comment\" spellcheck=\"true\">// extremely rare edge case: do not insert if old element is in a</span>\n        <span class=\"token comment\" spellcheck=\"true\">// leaving transition. Only happens when combining transition +</span>\n        <span class=\"token comment\" spellcheck=\"true\">// keep-alive + HOCs. (#4590)</span>\n        oldElm<span class=\"token punctuation\">.</span>_leaveCb <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> parentElm<span class=\"token punctuation\">,</span>\n        nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">nextSibling</span><span class=\"token punctuation\">(</span>oldElm<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// update parent placeholder node element, recursively</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> ancestor <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>parent\n        <span class=\"token keyword\">const</span> patchable <span class=\"token operator\">=</span> <span class=\"token function\">isPatchable</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n          ancestor<span class=\"token punctuation\">.</span>elm <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>elm\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>patchable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              cbs<span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>emptyNode<span class=\"token punctuation\">,</span> ancestor<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// #6513</span>\n            <span class=\"token comment\" spellcheck=\"true\">// invoke insert hooks that may have been merged by create hooks.</span>\n            <span class=\"token comment\" spellcheck=\"true\">// e.g. for directives that uses the \"inserted\" hook.</span>\n            <span class=\"token keyword\">const</span> insert <span class=\"token operator\">=</span> ancestor<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">.</span>insert\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>insert<span class=\"token punctuation\">.</span>merged<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// start at index 1 to avoid re-invoking component mounted hook</span>\n              <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> insert<span class=\"token punctuation\">.</span>fns<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                insert<span class=\"token punctuation\">.</span>fns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">registerRef</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n          ancestor <span class=\"token operator\">=</span> ancestor<span class=\"token punctuation\">.</span>parent\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// destroy old node</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>oldVnode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">invokeInsertHook</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> isInitialPatch<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> vnode<span class=\"token punctuation\">.</span>elm\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p> 可以看到 patch 的逻辑进来通过判断是否有 oldVnode 来区分是否是首次渲染，进行不同的逻辑，接下来我们通过  <code>sameVNode(oldVnode, vnode)</code> </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> sameVnode <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    a<span class=\"token punctuation\">.</span>key <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>key <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token punctuation\">(</span>\n        a<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">&amp;&amp;</span>\n        a<span class=\"token punctuation\">.</span>isComment <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>isComment <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token function\">sameInputType</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>isAsyncPlaceholder<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        a<span class=\"token punctuation\">.</span>asyncFactory <span class=\"token operator\">===</span> b<span class=\"token punctuation\">.</span>asyncFactory <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>asyncFactory<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>根据 vnode 的 key 进行判断是否是相同的，再继续根据 isComment、data、sameInputType 的类型是否相同来判断同步组件，对于异步组件则通过判断 asyncFactory 是否相同，所以是根据判断它们是否是相同的 vnode 来区分不同的更新逻辑</p>\n<h3 id=\"新旧节点不同\"><a href=\"#新旧节点不同\" class=\"headerlink\" title=\"新旧节点不同\"></a>新旧节点不同<hr></h3><p>如果新旧节点不同,那么就是替换已经存在的节点大致流程为</p>\n<ul>\n<li>创建新节点</li>\n<li>更新父的占位符节点</li>\n<li>删除旧节点</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> oldElm <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>elm\n<span class=\"token keyword\">const</span> parentElm <span class=\"token operator\">=</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">parentNode</span><span class=\"token punctuation\">(</span>oldElm<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">// create new node</span>\n<span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>\n  vnode<span class=\"token punctuation\">,</span>\n  insertedVnodeQueue<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// extremely rare edge case: do not insert if old element is in a</span>\n  <span class=\"token comment\" spellcheck=\"true\">// leaving transition. Only happens when combining  transition +</span>\n  <span class=\"token comment\" spellcheck=\"true\">// keep-alive + HOCs. (#4590)</span>\n  oldElm<span class=\"token punctuation\">.</span>_leaveCb <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> parentElm<span class=\"token punctuation\">,</span>\n  nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">nextSibling</span><span class=\"token punctuation\">(</span>oldElm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>创建新节点调用的是 createElm 方法， 以当前旧节点为参考，创建新的节点，并插入到 DOM 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// update parent placeholder node element, recursively</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> ancestor <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>parent\n  <span class=\"token keyword\">const</span> patchable <span class=\"token operator\">=</span> <span class=\"token function\">isPatchable</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    ancestor<span class=\"token punctuation\">.</span>elm <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>elm\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>patchable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cbs<span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>emptyNode<span class=\"token punctuation\">,</span> ancestor<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// #6513</span>\n      <span class=\"token comment\" spellcheck=\"true\">// invoke insert hooks that may have been merged by create hooks.</span>\n      <span class=\"token comment\" spellcheck=\"true\">// e.g. for directives that uses the \"inserted\" hook.</span>\n      <span class=\"token keyword\">const</span> insert <span class=\"token operator\">=</span> ancestor<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">.</span>insert\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>insert<span class=\"token punctuation\">.</span>merged<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// start at index 1 to avoid re-invoking component mounted hook</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> insert<span class=\"token punctuation\">.</span>fns<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          insert<span class=\"token punctuation\">.</span>fns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">registerRef</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    ancestor <span class=\"token operator\">=</span> ancestor<span class=\"token punctuation\">.</span>parent\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>找到当前的 vnode 的 父的占位符节点，先执行 cbs.destroy 钩子函数，如果当前占位符是一个可挂载的节点，则执行 cbs.create 钩子函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// destroy old node</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>oldVnode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将 oldVnode 从当前 DOM 树中删除，如果存在父节点，执行 removeVnodes 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> removeVnodes <span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> vnodes<span class=\"token punctuation\">,</span> startIdx<span class=\"token punctuation\">,</span> endIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> startIdx <span class=\"token operator\">&lt;=</span> endIdx<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>startIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> ch <span class=\"token operator\">=</span> vnodes<span class=\"token punctuation\">[</span>startIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">removeAndInvokeRemoveHook</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Text node</span>\n        <span class=\"token function\">removeNode</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> removeAndInvokeRemoveHook <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> rm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>rm<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> i\n    <span class=\"token keyword\">const</span> listeners <span class=\"token operator\">=</span> cbs<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>rm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// we have a recursively passed down rm callback</span>\n      <span class=\"token comment\" spellcheck=\"true\">// increase the listeners count</span>\n      rm<span class=\"token punctuation\">.</span>listeners <span class=\"token operator\">+</span><span class=\"token operator\">=</span> listeners\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// directly removing</span>\n      rm <span class=\"token operator\">=</span> <span class=\"token function\">createRmCb</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> listeners<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// recursively invoke hooks on child component root node</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>componentInstance<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>_vnode<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">removeAndInvokeRemoveHook</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> rm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      cbs<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> rm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> rm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">rm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">removeNode</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> invokeDestroyHook <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i<span class=\"token punctuation\">,</span> j\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>data\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> vnode<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>遍历待删除的 vnodes 做删除，</li>\n<li>调用 removeAndInvokeRemoveHook 执行 cbs.remove 钩子进行删除。如果存在子节点则进行递归调用 removeAndInvokeRemoveHook</li>\n<li>调用 invokeDestroyHook 执行 cbs.destroy 钩子，进行销毁。如果存在子节点则进行递归调用 invokeDestroyHook</li>\n<li>执行 removeNode 调用平台的 DOM API 删除真正的 DOM 节点</li>\n</ul>\n<h3 id=\"新旧节点相同\"><a href=\"#新旧节点相同\" class=\"headerlink\" title=\"新旧节点相同\"></a>新旧节点相同<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isRealElement <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// patch existing root node</span>\n    <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当新旧节点相同的时候,会调用 patchVnode 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> patchVnode <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldVnode <span class=\"token operator\">===</span> vnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> elm <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>elm <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>elm\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>isAsyncPlaceholder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>asyncFactory<span class=\"token punctuation\">.</span>resolved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">hydrate</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      vnode<span class=\"token punctuation\">.</span>isAsyncPlaceholder <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// reuse element for static trees.</span>\n  <span class=\"token comment\" spellcheck=\"true\">// note we only do this if the vnode is cloned -</span>\n  <span class=\"token comment\" spellcheck=\"true\">// if the new node is not cloned it means the render functions have been</span>\n  <span class=\"token comment\" spellcheck=\"true\">// reset by the hot-reload-api and we need to do a proper re-render.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>isStatic<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>isStatic<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    vnode<span class=\"token punctuation\">.</span>key <span class=\"token operator\">===</span> oldVnode<span class=\"token punctuation\">.</span>key <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>isCloned<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>isOnce<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vnode<span class=\"token punctuation\">.</span>componentInstance <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>componentInstance\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">let</span> i\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>data\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>prepatch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> oldCh <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>children\n  <span class=\"token keyword\">const</span> ch <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>children\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isPatchable</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> cbs<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldCh<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCh <span class=\"token operator\">!==</span> ch<span class=\"token punctuation\">)</span> <span class=\"token function\">updateChildren</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">setTextContent</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n      <span class=\"token function\">addVnodes</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldCh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">setTextContent</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>text <span class=\"token operator\">!==</span> vnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">setTextContent</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> i<span class=\"token punctuation\">.</span>postpatch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">i</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>patchVnode 将 vnode patch 到旧的 vnode 上将执行以下主要过程</p>\n<ul>\n<li>如果两个vnode相等，不需要 patch</li>\n<li>如果是异步占位，执行 hydrate 方法或者定义 isAsyncPlaceholder 为 true</li>\n<li>当更新的 vnode 是组件 vnode 的时候， 执行 i.prepatch 钩子函数，拿到最新的 vnode 组件配置以及组件的实例后，执行 updateChildComponent 方法更新 vm 实例上一系列的属性和方法</li>\n<li>执行 cbs.update 钩子函数</li>\n<li>完成 patch 过程</li>\n<li>执行 postpatch 钩子函数</li>\n</ul>\n<p>上面执行的步骤我们重点关注一下完成 patch 的过程，这也是 vnode diff 最复杂的地方</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldCh<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCh <span class=\"token operator\">!==</span> ch<span class=\"token punctuation\">)</span> <span class=\"token function\">updateChildren</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">setTextContent</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n      <span class=\"token function\">addVnodes</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldCh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">setTextContent</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>text <span class=\"token operator\">!==</span> vnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">setTextContent</span><span class=\"token punctuation\">(</span>elm<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>如果 vnode 是个文本节点且新旧文本不相同，则直接替换文本内容，否则根据不同情况处理逻辑</li>\n<li>oldCh 与 ch 都存在且不相同时，调用 updateChildren 来更新子节点</li>\n<li>当只有 ch 存在，判断旧的节点是文本节点则先将节点的文本清除，然后通过 addVnodes 将 ch 批量插入到新节点 elm 下，表示不需要旧节点了</li>\n<li>当只有 oldCh 存在，将旧的节点通过 removeVnodes 全部清除，表示更新的是空节点</li>\n<li>当只有旧节点是文本节点的时候，则清除其节点文本内容</li>\n</ul>\n<h3 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren \"></a>updateChildren <hr></h3><p>上面在判断 oldCh 与 ch 都存在且不相同时调用 updateChildren 来更新子节点，接下来我们看看这个函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> updateChildren <span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> newCh<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> oldStartIdx <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> newStartIdx <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> oldEndIdx <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">let</span> oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">let</span> oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span>oldEndIdx<span class=\"token punctuation\">]</span> \n  <span class=\"token keyword\">let</span> newEndIdx <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> \n  <span class=\"token keyword\">let</span> newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">let</span> newEndVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span>newEndIdx<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">let</span> oldKeyToIdx<span class=\"token punctuation\">,</span> idxInOld<span class=\"token punctuation\">,</span> vnodeToMove<span class=\"token punctuation\">,</span> refElm\n\n\n  <span class=\"token comment\" spellcheck=\"true\">// removeOnly 是一个只用于 &lt;transition-group> 的特殊标签，</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 确保移除元素过程中保持一个正确的相对位置。</span>\n  <span class=\"token keyword\">const</span> canMove <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>removeOnly\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">checkDuplicateKeys</span><span class=\"token punctuation\">(</span>newCh<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>oldStartIdx <span class=\"token operator\">&lt;=</span> oldEndIdx <span class=\"token operator\">&amp;&amp;</span> newStartIdx <span class=\"token operator\">&lt;=</span> newEndIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 开始老 vnode 向右一位</span>\n      oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>oldStartIdx<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// Vnode has been moved left</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 结束老 vnode 向左一位</span>\n      oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>oldEndIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 新旧开始 vnode 相似，进行pacth。开始 vnode 向右一位</span>\n      <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n      oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>oldStartIdx<span class=\"token punctuation\">]</span>\n      newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>newStartIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 新旧结束 vnode 相似，进行patch。结束 vnode 向左一位</span>\n      <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n      oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>oldEndIdx<span class=\"token punctuation\">]</span>\n      newEndVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>newEndIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Vnode moved right</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 新结束 vnode 和老开始 vnode 相似，进行patch。</span>\n      <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 老开始 vnode 插入到真实 DOM 中，老开始 vnode 向右一位，新结束 vnode 向左一位</span>\n      canMove <span class=\"token operator\">&amp;&amp;</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">nextSibling</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>oldStartIdx<span class=\"token punctuation\">]</span>\n      newEndVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>newEndIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Vnode moved left</span>\n     <span class=\"token comment\" spellcheck=\"true\">// 老结束 vnode 和新开始 vnode 相似，进行 patch。</span>\n      <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 老结束 vnode 插入到真实 DOM 中，老结束 vnode 向左一位，新开始 vnode 向右一位</span>\n      canMove <span class=\"token operator\">&amp;&amp;</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldEndVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n      oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>oldEndIdx<span class=\"token punctuation\">]</span>\n      newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>newStartIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 获取老 Idx 的 key</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldKeyToIdx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> oldKeyToIdx <span class=\"token operator\">=</span> <span class=\"token function\">createKeyToOldIdx</span><span class=\"token punctuation\">(</span>oldCh<span class=\"token punctuation\">,</span> oldStartIdx<span class=\"token punctuation\">,</span> oldEndIdx<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 给老 idx 赋值</span>\n      idxInOld <span class=\"token operator\">=</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">?</span> oldKeyToIdx<span class=\"token punctuation\">[</span>newStartVnode<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">:</span> <span class=\"token function\">findIdxInOld</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> oldStartIdx<span class=\"token punctuation\">,</span> oldEndIdx<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>idxInOld<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// New element</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果老 idx 为 undefined，说明没有这个元素，创建新 DOM 元素。</span>\n        <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> newCh<span class=\"token punctuation\">,</span> newStartIdx<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 获取 vnode</span>\n        vnodeToMove <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span>idxInOld<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>vnodeToMove<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 如果生成的 vnode 和新开始 vnode 相似，执行 patch。</span>\n          <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>vnodeToMove<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 赋值 undefined，插入 vnodeToMove 元素</span>\n          oldCh<span class=\"token punctuation\">[</span>idxInOld<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> undefined\n          canMove <span class=\"token operator\">&amp;&amp;</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> vnodeToMove<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 相同的key不同的元素，视为新元素</span>\n          <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> newCh<span class=\"token punctuation\">,</span> newStartIdx<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 新开始 vnode 向右一位</span>\n      newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>newStartIdx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果老开始 idx 大于老结束 idx，如果是有效数据则添加 vnode 到新 vnode 中。</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldStartIdx <span class=\"token operator\">></span> oldEndIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    refElm <span class=\"token operator\">=</span> <span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>newCh<span class=\"token punctuation\">[</span>newEndIdx <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> newCh<span class=\"token punctuation\">[</span>newEndIdx <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>elm\n    <span class=\"token function\">addVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">,</span> newCh<span class=\"token punctuation\">,</span> newStartIdx<span class=\"token punctuation\">,</span> newEndIdx<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newStartIdx <span class=\"token operator\">></span> newEndIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> oldStartIdx<span class=\"token punctuation\">,</span> oldEndIdx<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的逻辑比较复杂，我们通过一个简单的例子先来看一下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>div id<span class=\"token operator\">=</span><span class=\"token string\">\"app\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>li v<span class=\"token operator\">-</span><span class=\"token keyword\">for</span><span class=\"token operator\">=</span><span class=\"token string\">\"item in items\"</span> <span class=\"token punctuation\">:</span>key<span class=\"token operator\">=</span><span class=\"token string\">\"item.id\"</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> item<span class=\"token punctuation\">.</span>val <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>button @click<span class=\"token operator\">=</span><span class=\"token string\">\"change\"</span><span class=\"token operator\">></span>点击我<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n  <span class=\"token keyword\">var</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    el<span class=\"token punctuation\">:</span> <span class=\"token string\">'#app'</span><span class=\"token punctuation\">,</span>\n    data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      items<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token string\">'A'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token string\">'B'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token string\">'C'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token string\">'D'</span> <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">change</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">:</span> <span class=\"token string\">'E'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的代码很简单就是初始化的时候渲染列表为 A、B、C、D，当点击的时候将数据中 push 一个 E 并且进行反转，结果为 D、C、B、A、E 那么具体怎么更新的呢，看一下下面的流程</p>\n<p>第一步:<br><img src=\"/images/vue-dom-diff01.png\"></p>\n<p>第二步:<br><img src=\"/images/vue-dom-diff02.png\"></p>\n<p>第三步:<br><img src=\"/images/vue-dom-diff03.png\"></p>\n<p>第四步:<br><img src=\"/images/vue-dom-diff04.png\"></p>\n<p>第五步:<br><img src=\"/images/vue-dom-diff05.png\"></p>\n<p>第六步:<br><img src=\"/images/vue-dom-diff06.png\"></p>\n<p>通过上面流程图，我们很清晰的知道实际上就是新旧节点对比移动的过程那么我们拆分 updateChildren 函数</p>\n<blockquote>\n<p>初始化全局变量</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">let</span> oldStartIdx <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\" spellcheck=\"true\">// 旧节点索引开始位置</span>\n  <span class=\"token keyword\">let</span> newStartIdx <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\" spellcheck=\"true\">// 新节点索引开始位置</span>\n  <span class=\"token keyword\">let</span> oldEndIdx <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token comment\" spellcheck=\"true\">// 旧节点索引终点位置</span>\n  <span class=\"token keyword\">let</span> oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//  旧节点开始值</span>\n  <span class=\"token keyword\">let</span> oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span>oldEndIdx<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// 旧节点最后一位的值</span>\n  <span class=\"token keyword\">let</span> newEndIdx <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token comment\" spellcheck=\"true\">// 新节点索引结束位置</span>\n  <span class=\"token keyword\">let</span> newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// 新节点开始值</span>\n  <span class=\"token keyword\">let</span> newEndVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span>newEndIdx<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// 新节点结束的值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>定义循环，在遍历过程中，oldStartIdx 和 newStartIdx 递增，oldEndIdx 和 newEndIdx 递减。当条件不符合跳出遍历循环</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>oldStartIdx <span class=\"token operator\">&lt;=</span> oldEndIdx <span class=\"token operator\">&amp;&amp;</span> newStartIdx <span class=\"token operator\">&lt;=</span> newEndIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>检测 oldStartVnode、oldEndVnode。如果 oldStartVnode 不存在，oldCh 起始点向后移动。如果 oldEndVnode 不存在，oldCh 终止点向前移动。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>oldStartIdx<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>oldEndIdx<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>对比 oldStartVnode 和 newStartVnode 如果为真则执行 patchVnode 同时彼此向后移动一位</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>oldStartIdx<span class=\"token punctuation\">]</span>\n  newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>newStartIdx<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p> 对比 oldEndVnode 和 newEndVnode 如果为真则执行 patchVnode 同时彼此向前移动一位</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>oldEndIdx<span class=\"token punctuation\">]</span>\n  newEndVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>newEndIdx<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>对比 oldStartVnode 和 newEndVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组最后一位</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Vnode moved right</span>\n  <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldStartVnode<span class=\"token punctuation\">,</span> newEndVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  canMove <span class=\"token operator\">&amp;&amp;</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">nextSibling</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  oldStartVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>oldStartIdx<span class=\"token punctuation\">]</span>\n  newEndVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>newEndIdx<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>对比 oldEndVnode 和 newStartVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组第一位</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Vnode moved left</span>\n  <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldEndVnode<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  canMove <span class=\"token operator\">&amp;&amp;</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldEndVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n  oldEndVnode <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>oldEndIdx<span class=\"token punctuation\">]</span>\n  newStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>newStartIdx<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>对比 idx 如果没有相同的 idx 则执行 createElm 创建元素。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldKeyToIdx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> oldKeyToIdx <span class=\"token operator\">=</span> <span class=\"token function\">createKeyToOldIdx</span><span class=\"token punctuation\">(</span>oldCh<span class=\"token punctuation\">,</span> oldStartIdx<span class=\"token punctuation\">,</span> oldEndIdx<span class=\"token punctuation\">)</span>\nidxInOld <span class=\"token operator\">=</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">?</span> oldKeyToIdx<span class=\"token punctuation\">[</span>newStartVnode<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">:</span> <span class=\"token function\">findIdxInOld</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> oldStartIdx<span class=\"token punctuation\">,</span> oldEndIdx<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>idxInOld<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// New element</span>\n  <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p> 对比 idx 如果两个 vnode 相似，则先执行 patchVnode，节点移动到 vnode 数组第一位。如果两个 vnode 不相似，视为新元素，执行 createElm 创建</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">vnodeToMove <span class=\"token operator\">=</span> oldCh<span class=\"token punctuation\">[</span>idxInOld<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>vnodeToMove<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>vnodeToMove<span class=\"token punctuation\">,</span> newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n  oldCh<span class=\"token punctuation\">[</span>idxInOld<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> undefined\n  canMove <span class=\"token operator\">&amp;&amp;</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> vnodeToMove<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n <span class=\"token comment\" spellcheck=\"true\">// same key but different element. treat as new element</span>\n <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>newStartVnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> parentElm<span class=\"token punctuation\">,</span> oldStartVnode<span class=\"token punctuation\">.</span>elm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nnewStartVnode <span class=\"token operator\">=</span> newCh<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>newStartIdx<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p> 如果老 vnode 数组的开始索引大于结束索引，说明新 node 数组长度大于老 vnode 数组，执行 addVnodes 方法添加这些新 vnode 到 DOM 中</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldStartIdx <span class=\"token operator\">></span> oldEndIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  refElm <span class=\"token operator\">=</span> <span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>newCh<span class=\"token punctuation\">[</span>newEndIdx <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> newCh<span class=\"token punctuation\">[</span>newEndIdx <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>elm\n  <span class=\"token function\">addVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> refElm<span class=\"token punctuation\">,</span> newCh<span class=\"token punctuation\">,</span> newStartIdx<span class=\"token punctuation\">,</span> newEndIdx<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>如果老 vnode 数组的开始索引小于结束索引，说明老 node 数组长度大于新 vnode 数组，执行 removeVnodes 方法从 DOM 中移除老 vnode 数组中多余的 vnode</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newStartIdx <span class=\"token operator\">></span> newEndIdx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> oldCh<span class=\"token punctuation\">,</span> oldStartIdx<span class=\"token punctuation\">,</span> oldEndIdx<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过上面的代码解析我们知道 vue 的 diff 对默认的 diff 执行了优化，查找的同一级的节点通过唯一的 key 去区分。如果节点类型相同重新设置该节点的属性，直接更新。如果不同，直接干掉前面的节点，创建并插入新的节点，不再比较这个节点以后的子节点。而不是同一级别每一个去比较并更新替换。如下图<br><img src=\"/images/vue-dom-diff08.png\"></p>\n<p>如上图我们希望在 A 和 B 之间加一个 F，那默认的 diff 算法是这样的<br><img src=\"/images/vue-dom-diff09.png\"></p>\n<p>vue 通过每一个节点的 key 标识符是这样的<br><img src=\"/images/vue-dom-diff10.png\"></p>\n<p>下面我们通过 一张图来大致总结 patchVnode 的流程<br><img src=\"/images/vue-dom-diff11.png\"></p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>上一篇文章我们对响应式原理进行了梳理，知道了当数据发生变化会触发 watcher 的回调，进行组件更新，那么接下来我们看看更新的操作是怎么进行了。<code>src/core/instance/lifecycle.js</code> 中 <code>vm._update</code> 方法</p>\n<h3 id=\"vm-update\"><a href=\"#vm-update\" class=\"headerlink\" title=\"vm._update \"></a>vm._update <hr></h3><pre><code class=\"js\">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  // ...\n  const prevVnode = vm._vnode\n  if (!prevVnode) {\n     // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  // ...\n}</code></pre>\n<h3 id=\"vm-patch\"><a href=\"#vm-patch\" class=\"headerlink\" title=\"vm.patch \"></a>vm.<strong>patch</strong> <hr></h3><p><code>vm._update</code> 方法主要通过节点来判断传入的参数，但是执行的方法都是 <code>vm.__patch__</code>,接下我们看一下 <code>src/core/vdom/patch.js</code> 中 patch 函数</p>\n<pre><code class=\"js\">return function patch (oldVnode, vnode, hydrating, removeOnly) {\n  if (isUndef(vnode)) {\n    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n    return\n  }\n\n  let isInitialPatch = false\n  const insertedVnodeQueue = []\n\n  if (isUndef(oldVnode)) {\n    // empty mount (likely as component), create new root element\n    isInitialPatch = true\n    createElm(vnode, insertedVnodeQueue)\n  } else {\n    const isRealElement = isDef(oldVnode.nodeType)\n    if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {\n      // patch existing root node\n      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n    } else {\n      if (isRealElement) {\n         // ...\n      }\n\n      // replacing existing element\n      const oldElm = oldVnode.elm\n      const parentElm = nodeOps.parentNode(oldElm)\n\n      // create new node\n      createElm(\n        vnode,\n        insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm,\n        nodeOps.nextSibling(oldElm)\n      )\n\n      // update parent placeholder node element, recursively\n      if (isDef(vnode.parent)) {\n        let ancestor = vnode.parent\n        const patchable = isPatchable(vnode)\n        while (ancestor) {\n          for (let i = 0; i &lt; cbs.destroy.length; ++i) {\n            cbs.destroy[i](ancestor)\n          }\n          ancestor.elm = vnode.elm\n          if (patchable) {\n            for (let i = 0; i &lt; cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, ancestor)\n            }\n            // #6513\n            // invoke insert hooks that may have been merged by create hooks.\n            // e.g. for directives that uses the &quot;inserted&quot; hook.\n            const insert = ancestor.data.hook.insert\n            if (insert.merged) {\n              // start at index 1 to avoid re-invoking component mounted hook\n              for (let i = 1; i &lt; insert.fns.length; i++) {\n                insert.fns[i]()\n              }\n            }\n          } else {\n            registerRef(ancestor)\n          }\n          ancestor = ancestor.parent\n        }\n      }\n\n      // destroy old node\n      if (isDef(parentElm)) {\n        removeVnodes(parentElm, [oldVnode], 0, 0)\n      } else if (isDef(oldVnode.tag)) {\n        invokeDestroyHook(oldVnode)\n      }\n    }\n  }\n\n  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n  return vnode.elm\n}</code></pre>\n<p> 可以看到 patch 的逻辑进来通过判断是否有 oldVnode 来区分是否是首次渲染，进行不同的逻辑，接下来我们通过  <code>sameVNode(oldVnode, vnode)</code> </p>\n<pre><code class=\"js\">function sameVnode (a, b) {\n  return (\n    a.key === b.key &amp;&amp; (\n      (\n        a.tag === b.tag &amp;&amp;\n        a.isComment === b.isComment &amp;&amp;\n        isDef(a.data) === isDef(b.data) &amp;&amp;\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &amp;&amp;\n        a.asyncFactory === b.asyncFactory &amp;&amp;\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}</code></pre>\n<p>根据 vnode 的 key 进行判断是否是相同的，再继续根据 isComment、data、sameInputType 的类型是否相同来判断同步组件，对于异步组件则通过判断 asyncFactory 是否相同，所以是根据判断它们是否是相同的 vnode 来区分不同的更新逻辑</p>\n<h3 id=\"新旧节点不同\"><a href=\"#新旧节点不同\" class=\"headerlink\" title=\"新旧节点不同\"></a>新旧节点不同<hr></h3><p>如果新旧节点不同,那么就是替换已经存在的节点大致流程为</p>\n<ul>\n<li>创建新节点</li>\n<li>更新父的占位符节点</li>\n<li>删除旧节点</li>\n</ul>\n<pre><code class=\"js\">const oldElm = oldVnode.elm\nconst parentElm = nodeOps.parentNode(oldElm)\n// create new node\ncreateElm(\n  vnode,\n  insertedVnodeQueue,\n  // extremely rare edge case: do not insert if old element is in a\n  // leaving transition. Only happens when combining  transition +\n  // keep-alive + HOCs. (#4590)\n  oldElm._leaveCb ? null : parentElm,\n  nodeOps.nextSibling(oldElm)\n)</code></pre>\n<p>创建新节点调用的是 createElm 方法， 以当前旧节点为参考，创建新的节点，并插入到 DOM 中</p>\n<pre><code class=\"js\">// update parent placeholder node element, recursively\nif (isDef(vnode.parent)) {\n  let ancestor = vnode.parent\n  const patchable = isPatchable(vnode)\n  while (ancestor) {\n    for (let i = 0; i &lt; cbs.destroy.length; ++i) {\n      cbs.destroy[i](ancestor)\n    }\n    ancestor.elm = vnode.elm\n    if (patchable) {\n      for (let i = 0; i &lt; cbs.create.length; ++i) {\n        cbs.create[i](emptyNode, ancestor)\n      }\n      // #6513\n      // invoke insert hooks that may have been merged by create hooks.\n      // e.g. for directives that uses the &quot;inserted&quot; hook.\n      const insert = ancestor.data.hook.insert\n      if (insert.merged) {\n        // start at index 1 to avoid re-invoking component mounted hook\n        for (let i = 1; i &lt; insert.fns.length; i++) {\n          insert.fns[i]()\n        }\n      }\n    } else {\n      registerRef(ancestor)\n    }\n    ancestor = ancestor.parent\n  }\n}</code></pre>\n<p>找到当前的 vnode 的 父的占位符节点，先执行 cbs.destroy 钩子函数，如果当前占位符是一个可挂载的节点，则执行 cbs.create 钩子函数</p>\n<pre><code class=\"js\">// destroy old node\nif (isDef(parentElm)) {\n  removeVnodes(parentElm, [oldVnode], 0, 0)\n} else if (isDef(oldVnode.tag)) {\n  invokeDestroyHook(oldVnode)\n}</code></pre>\n<p>将 oldVnode 从当前 DOM 树中删除，如果存在父节点，执行 removeVnodes 方法</p>\n<pre><code class=\"js\">function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx &lt;= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]\n    if (isDef(ch)) {\n      if (isDef(ch.tag)) {\n        removeAndInvokeRemoveHook(ch)\n        invokeDestroyHook(ch)\n      } else { // Text node\n        removeNode(ch.elm)\n      }\n    }\n  }\n}\n\nfunction removeAndInvokeRemoveHook (vnode, rm) {\n  if (isDef(rm) || isDef(vnode.data)) {\n    let i\n    const listeners = cbs.remove.length + 1\n    if (isDef(rm)) {\n      // we have a recursively passed down rm callback\n      // increase the listeners count\n      rm.listeners += listeners\n    } else {\n      // directly removing\n      rm = createRmCb(vnode.elm, listeners)\n    }\n    // recursively invoke hooks on child component root node\n    if (isDef(i = vnode.componentInstance) &amp;&amp; isDef(i = i._vnode) &amp;&amp; isDef(i.data)) {\n      removeAndInvokeRemoveHook(i, rm)\n    }\n    for (i = 0; i &lt; cbs.remove.length; ++i) {\n      cbs.remove[i](vnode, rm)\n    }\n    if (isDef(i = vnode.data.hook) &amp;&amp; isDef(i = i.remove)) {\n      i(vnode, rm)\n    } else {\n      rm()\n    }\n  } else {\n    removeNode(vnode.elm)\n  }\n}\n\nfunction invokeDestroyHook (vnode) {\n  let i, j\n  const data = vnode.data\n  if (isDef(data)) {\n    if (isDef(i = data.hook) &amp;&amp; isDef(i = i.destroy)) i(vnode)\n    for (i = 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode)\n  }\n  if (isDef(i = vnode.children)) {\n    for (j = 0; j &lt; vnode.children.length; ++j) {\n      invokeDestroyHook(vnode.children[j])\n    }\n  }\n}</code></pre>\n<ul>\n<li>遍历待删除的 vnodes 做删除，</li>\n<li>调用 removeAndInvokeRemoveHook 执行 cbs.remove 钩子进行删除。如果存在子节点则进行递归调用 removeAndInvokeRemoveHook</li>\n<li>调用 invokeDestroyHook 执行 cbs.destroy 钩子，进行销毁。如果存在子节点则进行递归调用 invokeDestroyHook</li>\n<li>执行 removeNode 调用平台的 DOM API 删除真正的 DOM 节点</li>\n</ul>\n<h3 id=\"新旧节点相同\"><a href=\"#新旧节点相同\" class=\"headerlink\" title=\"新旧节点相同\"></a>新旧节点相同<hr></h3><pre><code class=\"js\"> if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {\n    // patch existing root node\n    patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n  } else {\n    // ...\n  }</code></pre>\n<p>当新旧节点相同的时候,会调用 patchVnode 方法</p>\n<pre><code class=\"js\">function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n  if (oldVnode === vnode) {\n    return\n  }\n\n  const elm = vnode.elm = oldVnode.elm\n\n  if (isTrue(oldVnode.isAsyncPlaceholder)) {\n    if (isDef(vnode.asyncFactory.resolved)) {\n      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n    } else {\n      vnode.isAsyncPlaceholder = true\n    }\n    return\n  }\n\n  // reuse element for static trees.\n  // note we only do this if the vnode is cloned -\n  // if the new node is not cloned it means the render functions have been\n  // reset by the hot-reload-api and we need to do a proper re-render.\n  if (isTrue(vnode.isStatic) &amp;&amp;\n    isTrue(oldVnode.isStatic) &amp;&amp;\n    vnode.key === oldVnode.key &amp;&amp;\n    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n  ) {\n    vnode.componentInstance = oldVnode.componentInstance\n    return\n  }\n\n  let i\n  const data = vnode.data\n  if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {\n    i(oldVnode, vnode)\n  }\n\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  if (isDef(data) &amp;&amp; isPatchable(vnode)) {\n    for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n    if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)\n  }\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) &amp;&amp; isDef(ch)) {\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {\n      nodeOps.setTextContent(elm, &#39;&#39;)\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n  if (isDef(data)) {\n    if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)\n  }\n}</code></pre>\n<p>patchVnode 将 vnode patch 到旧的 vnode 上将执行以下主要过程</p>\n<ul>\n<li>如果两个vnode相等，不需要 patch</li>\n<li>如果是异步占位，执行 hydrate 方法或者定义 isAsyncPlaceholder 为 true</li>\n<li>当更新的 vnode 是组件 vnode 的时候， 执行 i.prepatch 钩子函数，拿到最新的 vnode 组件配置以及组件的实例后，执行 updateChildComponent 方法更新 vm 实例上一系列的属性和方法</li>\n<li>执行 cbs.update 钩子函数</li>\n<li>完成 patch 过程</li>\n<li>执行 postpatch 钩子函数</li>\n</ul>\n<p>上面执行的步骤我们重点关注一下完成 patch 的过程，这也是 vnode diff 最复杂的地方</p>\n<pre><code class=\"js\">  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) &amp;&amp; isDef(ch)) {\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {\n      nodeOps.setTextContent(elm, &#39;&#39;)\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }</code></pre>\n<ul>\n<li>如果 vnode 是个文本节点且新旧文本不相同，则直接替换文本内容，否则根据不同情况处理逻辑</li>\n<li>oldCh 与 ch 都存在且不相同时，调用 updateChildren 来更新子节点</li>\n<li>当只有 ch 存在，判断旧的节点是文本节点则先将节点的文本清除，然后通过 addVnodes 将 ch 批量插入到新节点 elm 下，表示不需要旧节点了</li>\n<li>当只有 oldCh 存在，将旧的节点通过 removeVnodes 全部清除，表示更新的是空节点</li>\n<li>当只有旧节点是文本节点的时候，则清除其节点文本内容</li>\n</ul>\n<h3 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren \"></a>updateChildren <hr></h3><p>上面在判断 oldCh 与 ch 都存在且不相同时调用 updateChildren 来更新子节点，接下来我们看看这个函数</p>\n<pre><code class=\"js\">function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n  let oldStartIdx = 0\n  let newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0] \n  let oldEndVnode = oldCh[oldEndIdx] \n  let newEndIdx = newCh.length - 1 \n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n\n  // removeOnly 是一个只用于 &lt;transition-group&gt; 的特殊标签，\n  // 确保移除元素过程中保持一个正确的相对位置。\n  const canMove = !removeOnly\n\n  if (process.env.NODE_ENV !== &#39;production&#39;) {\n    checkDuplicateKeys(newCh)\n  }\n\n  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {\n    if (isUndef(oldStartVnode)) {\n      // 开始老 vnode 向右一位\n      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n    } else if (isUndef(oldEndVnode)) {\n      // 结束老 vnode 向左一位\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      // 新旧开始 vnode 相似，进行pacth。开始 vnode 向右一位\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      // 新旧结束 vnode 相似，进行patch。结束 vnode 向左一位\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n      // 新结束 vnode 和老开始 vnode 相似，进行patch。\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      // 老开始 vnode 插入到真实 DOM 中，老开始 vnode 向右一位，新结束 vnode 向左一位\n      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n     // 老结束 vnode 和新开始 vnode 相似，进行 patch。\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      // 老结束 vnode 插入到真实 DOM 中，老结束 vnode 向左一位，新开始 vnode 向右一位\n      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      // 获取老 Idx 的 key\n      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n      // 给老 idx 赋值\n      idxInOld = isDef(newStartVnode.key)\n        ? oldKeyToIdx[newStartVnode.key]\n        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n      if (isUndef(idxInOld)) { // New element\n        // 如果老 idx 为 undefined，说明没有这个元素，创建新 DOM 元素。\n        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n      } else {\n        // 获取 vnode\n        vnodeToMove = oldCh[idxInOld]\n        if (sameVnode(vnodeToMove, newStartVnode)) {\n          // 如果生成的 vnode 和新开始 vnode 相似，执行 patch。\n          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n          // 赋值 undefined，插入 vnodeToMove 元素\n          oldCh[idxInOld] = undefined\n          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n        } else {\n          // 相同的key不同的元素，视为新元素\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        }\n      }\n      // 新开始 vnode 向右一位\n      newStartVnode = newCh[++newStartIdx]\n    }\n  }\n  // 如果老开始 idx 大于老结束 idx，如果是有效数据则添加 vnode 到新 vnode 中。\n  if (oldStartIdx &gt; oldEndIdx) {\n    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n  } else if (newStartIdx &gt; newEndIdx) {\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}</code></pre>\n<p>上面的逻辑比较复杂，我们通过一个简单的例子先来看一下</p>\n<pre><code class=\"js\">&lt;div id=&quot;app&quot;&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;{{ item.val }}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;button @click=&quot;change&quot;&gt;点击我&lt;/button&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  var app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n      items: [\n        { id: 0, val: &#39;A&#39; },\n        { id: 1, val: &#39;B&#39; },\n        { id: 2, val: &#39;C&#39; },\n        { id: 3, val: &#39;D&#39; }\n      ]\n    },\n    methods: {\n      change() {\n        this.items.reverse().push({ id: 4, val: &#39;E&#39; })\n      }\n    }\n  })\n&lt;/script&gt;</code></pre>\n<p>上面的代码很简单就是初始化的时候渲染列表为 A、B、C、D，当点击的时候将数据中 push 一个 E 并且进行反转，结果为 D、C、B、A、E 那么具体怎么更新的呢，看一下下面的流程</p>\n<p>第一步:<br><img src=\"/images/vue-dom-diff01.png\"></p>\n<p>第二步:<br><img src=\"/images/vue-dom-diff02.png\"></p>\n<p>第三步:<br><img src=\"/images/vue-dom-diff03.png\"></p>\n<p>第四步:<br><img src=\"/images/vue-dom-diff04.png\"></p>\n<p>第五步:<br><img src=\"/images/vue-dom-diff05.png\"></p>\n<p>第六步:<br><img src=\"/images/vue-dom-diff06.png\"></p>\n<p>通过上面流程图，我们很清晰的知道实际上就是新旧节点对比移动的过程那么我们拆分 updateChildren 函数</p>\n<blockquote>\n<p>初始化全局变量</p>\n</blockquote>\n<pre><code class=\"js\">  let oldStartIdx = 0  // 旧节点索引开始位置\n  let newStartIdx = 0 // 新节点索引开始位置\n  let oldEndIdx = oldCh.length - 1 // 旧节点索引终点位置\n  let oldStartVnode = oldCh[0] //  旧节点开始值\n  let oldEndVnode = oldCh[oldEndIdx] // 旧节点最后一位的值\n  let newEndIdx = newCh.length - 1 // 新节点索引结束位置\n  let newStartVnode = newCh[0] // 新节点开始值\n  let newEndVnode = newCh[newEndIdx] // 新节点结束的值</code></pre>\n<blockquote>\n<p>定义循环，在遍历过程中，oldStartIdx 和 newStartIdx 递增，oldEndIdx 和 newEndIdx 递减。当条件不符合跳出遍历循环</p>\n</blockquote>\n<pre><code class=\"js\">while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {\n  // ...\n}</code></pre>\n<blockquote>\n<p>检测 oldStartVnode、oldEndVnode。如果 oldStartVnode 不存在，oldCh 起始点向后移动。如果 oldEndVnode 不存在，oldCh 终止点向前移动。</p>\n</blockquote>\n<pre><code class=\"js\">if (isUndef(oldStartVnode)) {\n  oldStartVnode = oldCh[++oldStartIdx]\n} else if (isUndef(oldEndVnode)) {\n  oldEndVnode = oldCh[--oldEndIdx]\n}</code></pre>\n<blockquote>\n<p>对比 oldStartVnode 和 newStartVnode 如果为真则执行 patchVnode 同时彼此向后移动一位</p>\n</blockquote>\n<pre><code class=\"js\">else if (sameVnode(oldStartVnode, newStartVnode)) {\n  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n  oldStartVnode = oldCh[++oldStartIdx]\n  newStartVnode = newCh[++newStartIdx]\n}</code></pre>\n<blockquote>\n<p> 对比 oldEndVnode 和 newEndVnode 如果为真则执行 patchVnode 同时彼此向前移动一位</p>\n</blockquote>\n<pre><code class=\"js\">else if (sameVnode(oldEndVnode, newEndVnode)) {\n  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newEndVnode = newCh[--newEndIdx]\n}</code></pre>\n<blockquote>\n<p>对比 oldStartVnode 和 newEndVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组最后一位</p>\n</blockquote>\n<pre><code class=\"js\">else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n  canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n  oldStartVnode = oldCh[++oldStartIdx]\n  newEndVnode = newCh[--newEndIdx]\n}</code></pre>\n<blockquote>\n<p>对比 oldEndVnode 和 newStartVnode 如果为真则执行 patchVnode，然后将该节点移动到 vnode 数组第一位</p>\n</blockquote>\n<pre><code class=\"js\">else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n  patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n  canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n  oldEndVnode = oldCh[--oldEndIdx]\n  newStartVnode = newCh[++newStartIdx]\n}</code></pre>\n<blockquote>\n<p>对比 idx 如果没有相同的 idx 则执行 createElm 创建元素。</p>\n</blockquote>\n<pre><code class=\"js\">if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\nidxInOld = isDef(newStartVnode.key)\n  ? oldKeyToIdx[newStartVnode.key]\n  : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\nif (isUndef(idxInOld)) { // New element\n  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n}</code></pre>\n<blockquote>\n<p> 对比 idx 如果两个 vnode 相似，则先执行 patchVnode，节点移动到 vnode 数组第一位。如果两个 vnode 不相似，视为新元素，执行 createElm 创建</p>\n</blockquote>\n<pre><code class=\"js\">vnodeToMove = oldCh[idxInOld]\nif (sameVnode(vnodeToMove, newStartVnode)) {\n  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n  oldCh[idxInOld] = undefined\n  canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n} else {\n // same key but different element. treat as new element\n createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n}\nnewStartVnode = newCh[++newStartIdx]</code></pre>\n<blockquote>\n<p> 如果老 vnode 数组的开始索引大于结束索引，说明新 node 数组长度大于老 vnode 数组，执行 addVnodes 方法添加这些新 vnode 到 DOM 中</p>\n</blockquote>\n<pre><code class=\"js\">if (oldStartIdx &gt; oldEndIdx) {\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n}</code></pre>\n<blockquote>\n<p>如果老 vnode 数组的开始索引小于结束索引，说明老 node 数组长度大于新 vnode 数组，执行 removeVnodes 方法从 DOM 中移除老 vnode 数组中多余的 vnode</p>\n</blockquote>\n<pre><code class=\"js\">else if (newStartIdx &gt; newEndIdx) {\n  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n}</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过上面的代码解析我们知道 vue 的 diff 对默认的 diff 执行了优化，查找的同一级的节点通过唯一的 key 去区分。如果节点类型相同重新设置该节点的属性，直接更新。如果不同，直接干掉前面的节点，创建并插入新的节点，不再比较这个节点以后的子节点。而不是同一级别每一个去比较并更新替换。如下图<br><img src=\"/images/vue-dom-diff08.png\"></p>\n<p>如上图我们希望在 A 和 B 之间加一个 F，那默认的 diff 算法是这样的<br><img src=\"/images/vue-dom-diff09.png\"></p>\n<p>vue 通过每一个节点的 key 标识符是这样的<br><img src=\"/images/vue-dom-diff10.png\"></p>\n<p>下面我们通过 一张图来大致总结 patchVnode 的流程<br><img src=\"/images/vue-dom-diff11.png\"></p>\n"},{"title":"操作数组API方法","date":"2019-03-20T04:32:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":"介绍Array对象中的作用，属性、常规方法等","_content":"\n### Array对象的作用\n\nArray 对象用于在单个的变量中存储多个值\n\n### 创建Array对象的方法\n\n`var arrayObj = new Array()；`<br/>\n`var arrayObj = []; //本人习惯用这种`<br/>\n返回值：返回新创建并被初始化了的数组。如果调用arrayObj时没有参数或者没有指定 值，那么返回的值为空，数组的length为0。<br/>\n\n### Array对象的三个属性 \n\n`constructor` //返回数组函数的引用。<br/>\n`length` //返回数组元素的长度（最常用）<br/>\n`prototype` //可以向数组对象添加属性和方法。<br/>\n\n### concat()\n\n该方法用于连接或者合并数组，并且不会改变原数组，返回一个新数组的副本\n\n```js\nvar arrObj = [1,2,3,4];\nvar arrObj1 = [5,6,7,8];\narrObj.concat(arrObj1); //[1,2,3,4,5,6,7,8]\n```\n\n### join()\n\n该方法用于把数组中的所有元素用指定的分隔符分割，返回一个字符串\n\n```js\nnewArray.join() //\"1,2,3,4,5,6,7,8\"\n```\n\n### pop()\n\n该方法用于删除并返回数组的最后一个元素,并将原数组的length -1\n\n```\narrObj.pop()//4\nconsole.log(arrObj); //[1,2,3]\n```\n\n### push()\n\n该方法可向数组的末尾添加一个或多个元素，并返回新的长度\n\n```js\narrObj.push(4);\nconsole.log(arrObj); //[1,2,3,4]\n```\n\n### shift()\n\n该方法用于删除并返回数组的第一个元素,并将原数组的length -1\n\n```\narrObj.shift() //1\nconsole.log(arrObj) //[2,3,4]\n```\n\n### unshift()\n\n该方法可向数组的开头添加一个或多个元素，并返回新的长度\n\n```js\narrObj.unshift(1);\nconsole.log(arrObj); //[1,2,3,4]\n```\n\n### slice()\n\n该方法可从已有的数组中返回选定的元素,形成一个新的数组\n\n```js\narrObj.slice(1,2); //[2]\nconsole.log(arrObj) //[1,2,3,4]\n```\n\n### splice()\n\n该法向数组中添加/删除元素，然后返回被删除的元素。该方法会改变原数组\n\n```js\narrObj.splice(1,2,5); //[2,3]\nconsole.log(arrObj); //[1,5,4]\n```\n\n### reverse()\n\n该方法用于颠倒数组中元素的顺序，并且改变原来的数组，而不会创建新的数组\n\n```js\narrObj.reverse(); //[4,5,1]\n```\n\n### sort()\n\n该方法用于对数组的元素进行排序\n\n注意：该方法是按照字符编码顺序进行排序，如果想要实现业务逻辑排序需要自定义比较函数\n\n```js\nvar arrObjSort = [1,5,4,2,3];\nvar arrObjSort1 = [1,2,10,3,20,4,30,50,5];\narrObjSort.sort(); //[1,2,3,4,5]\narrObjSort1.sort(); //[1, 10, 2, 20, 3, 30, 4, 5, 50]\n```\n\n自定义排序\n\n```js\nfunction __sortNumber(a,b){\n   return a-b;\n}\narrObjSort1.sort(__sortNumber); //[1, 2, 3, 4, 5, 10, 20, 30, 50]\n```\n\n### toString()\n\n该方法可把数组转换为字符串，并返回结果，与不带参数的join相同\n\n```js\narrObjSort1.toString(); //\"1,2,3,4,5,10,20,30,50\"\n```\n\ntoLocaleString-该方法可数组转换为本地字符串。和toString基本相同，但toLocaleString调用的是地区特定的分隔符把生成的字符串连接起来。<br/>\n\n如果你开发的脚本在世界范围都有人使用,那么将对象转换成字符串时请使用toString()方法<br/>\n\n因为LocaleString()会根据你机器的本地环境来返回字符串,它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化<br/>\n\n如果是为了返回时间类型的数据,推荐使用LocaleString().若是在后台处理字符串,请务必使用toString()<br/>\n\n```js\nvar date = new Date();\nvar myArr = [date,'go home'];\nmyArr.toLocaleString(); //\"2017/11/7 下午4:35:43,go home\"\nmyArr.toString(); //\"Tue Nov 07 2017 16:36:25 GMT+0800 (CST),go home\"\n```\n\n### indexOf()\n\n该方法可确定某个元素在数组实例中第一次出现的索引位置。如果没找到返回-1,可用索引值进行逻辑判断\n\n```js\nvar arr = [1,2,3,4,5];\narr.indexOf(2);  //1\narr.indexOf(2,1); //1\narr.indexOf(2,2); //-1\narr.indexOf(6);  //-1\n\n```\n\n查找元素出现的位置索引<br/>\n\n```js\nvar indices = [];\nvar arr = [1,2,3,2,5,2,7];\nvar index = arr.indexOf(2);\nwhile(index != -1){\n  indices.push(index);\n  index = arr.indexOf(2,index + 1);\n}\nconsole.log(indices)\n```\n\n判断一个元素是否在数组里，不在则向数组中添加元素<br/>\n\n```js\nvar arr = [1,2,3,4,5,6,7];\nfunction __upDataCollection(arrCollection,indicesEle){\n  var matchIndex =  arrCollection.indexOf(indicesEle);\n  if(matchIndex === -1){\n     arr.push(indicesEle);        \n  }else{\n    console.log('元素中存在相同的值');\n  }\n}\n__upDataCollection(arr,8); //[1, 2, 3, 4, 5, 6, 7, 8]\n__upDataCollection(arr,2); //'元素中存在相同的值'\n```\n\n### forEach()\n\n该方法按升序为数组中含有效值的每一项执行一次callback 函数（遍历数组）\n\n`forEach()` 为每个数组元素执行callback函数；不像`map()` 或者`reduce()` ，它总是返回 `undefined`值，也没有办法终止或跳出正在运行循环的`forEach`。如果常规的遍历想要检测条件返回bool , 并且可以终止循环，可使用`Array.some,Ayyay.every`.或者es6新方法`Array.find()`等等\n\n```js\nvar arrayObj = [1,2,3,,5];\narrayObj.forEach(function(element, index, array){\n   console.log(\"value[\" + index + \"] = \" + element) \n},this);\n//value[0] = 1\n//value[1] = 2\n//value[2] = 3\n//value[4] = 5\n//可以观察到以上遍历并没有出现undefind\n```\n\n### map()\n\n该方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组，并且不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）\n\n```js\n//常用的有些业务场景需要重新重组数组对象\nvar arrayObj = [\n    {name: 'zhangsan', age: 20}, \n    {name: 'lisi', age: 30}, \n    {name: 'wangwu', age: 26}\n  ];\nvar newArrayObj = arrayObj.map(function(obj, index, array) { \n   var newObj = {};\n   newObj[obj.name] = obj.age;\n   return newObj;\n});\nconsole.log(newArrayObj);\n//[{'zhangsan':20},{'lisi':30},{'wangwu':26}]\n```\n\n### filter()\n\n该方法创建一个新数组,通过次函数方法会返回相应的过滤后的数据,并且不会改变原数组\n\n```js\nvar arrayObj = [3,1,3,2,4,5,6];\nvar newArrayObj = arrayObj.filter(function(value,index,array){\n   return value > 3\n});\nconsole.log(newArrayObj);//[4, 5, 6]\n```\n\n### reduce()\n\n为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素,返回函数累计处理的结果\n\n`callback`执行数组中每个值的函数，包含四个参数：<br/>\n\n`accumulator`累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br/>\n\n`currentValue`数组中正在处理的元素。<br/>\n\n`currentIndex`数组中正在处理的当前元素的索引。<br/>\n\n如果提供了initialValue，则索引号为0，否则为索引为1。array调用reduce的数组initialValue[可选] 用作第一个调用 callback的第一个参数的值。<br/>\n\n如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br/>\n\n```js\nvar totalValue = [0, 1, 2, 3].reduce(function(sum, value) {\n  return sum + value;\n}, 0); \n// totalValue  6\n\n//将二维数组转化为一维数组\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(\n    function(a, b) {\n      return a.concat(b);\n    },[]);\n  // flattened is [0, 1, 2, 3, 4, 5] \n```\n\n### some()\n\n该方法用于检测数组中的某些元素是否通过callback函数实现的方法。返回bool值\n\n```js\nvar arrayObj = [1,2,3,4,5,6];\nvar flag = arrayObj.some(function(element,index,array){\n  return element > 2;\n});\nconsole.log(flag);//true\n```\n\n### every()\n\n该方法用于检测数组中的所有元素是否通过callback函数实现的方法。返回bool值\n\n```js\nvar arrayObj = [1,2,3,4,5,6];\nvar flag = arrayObj.some(function(element,index,array){\n  return element > 2;\n});\nconsole.log(flag);//false\n```\n\n### 扩展运算符(...)\n\n该运算符将一个数组转为用逗号分隔的参数序列\n\n扩展运算符即可以复制，合并数组，操作分割字符串与结构赋值结合还可以当函数的形参<br/>\n```js\nconsole.log(...[1,2,3,4,5]);//1 2 3 4 5\n```\n\n合并数组：<br/>\n\n```js\nlet arrayObj = [1,2,3,4,5,6];\nlet arrayObj1 = [7,8,9];\nlet newArray = [...arrayObj,...arrayObj1];\nconsole.log(newArray) //[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n复制数组：<br/>\n```js\nlet arrayObj = [1,2,3,4,5];\nlet arrayObjNew = [...arrayObj];\nconsole.log(arrayObjNew) //[1,2,3,4,5];\n```\n\n与结构赋值结合：<br/>\n```js\nconst [variable, ...array] = [1, 2, 3, 4, 5];\nconsole.log(variable); //1\nconsole.log(array); //[2,3,4,5]\n```\n\n函数形参：\n```js\n//例子1:\nlet _arrayObj = [1];\nlet _arrayObj1 = [1,2,3,4,5];\nvar __operationArr = (array,items)=>{ \n   array.push(...items);\n   console.log(array); //[1,1,2,3,4,5]\n}\n__operationArr(_arrayObj,_arrayObj1);\n//例子2:\nvar __add = (a,b,c,d,e) =>{\n  return a + b + c +d + e;\n}\n__add(..._arrayObj1); //15\n```\n\n求出数组最大元素：<br/>\n```js\nlet arrayObj = [2,3,4,5,3,2,8];\nMath.max(...arrayObj) //8\n```\n\n### form()\n\n该法从一个类似数组或可迭代对象中创建一个新的数组实例，相当于相当于[].slice.call()\n\n```js\n//例子1:\nlet arrayItems = {\n    '0': 'zhangsan',\n    '1': 'lisi',\n    '2': 'wangwu',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayItems); // ['zhangsan', 'lisi', 'wangwu']\n// ES6的写法\nlet arr2 = Array.from(arrayItems); // ['zhangsan', 'lisi', 'wangwu']\n\n例子2:\n// 常见的DOM NodeList对象\nlet ps = document.querySelectorAll('p');\nlet pElementArr = Array.from(ps);\npElementArr.forEach((p)=> {\n  console.log(p);\n});\n```\n将字符串分割字后变为数组<br/>\n```js\nArray.from('foo');//['f','o','o']\n```\n\n\n### of()\n\n该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型\n\nArray.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br/>\n\n```js\nArray.of(7);       // [7] \nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]\n```\n\n\n### copyWithin()\n\n该方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小\n\narr.copyWithin(target)<br/>\n\narr.copyWithin(target, start)<br/>\n\narr.copyWithin(target, start, end)<br/>\n\narr.copyWithin(目标索引, [源开始索引], [结束源索引])<br/>\n```js\n[1, 2, 3, 4, 5].copyWithin(-2);\n// [1, 2, 3, 1, 2]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3);\n// [4, 5, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\n// [4, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(-2, -3, -1);\n// [1, 2, 3, 3, 4]\n\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);\n// {0: 1, 3: 1, length: 5}\n```\n\n### find()\n\n该方法返回数组中满足提供的callback的第一个元素的值。否则返回 undefined\n\n如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用`Array.prototype.indexOf()` 或 `Array.prototype.includes()`。\n\n如果你需要找到元素的索引，而不是其值`Array.prototype.findIndex() `;\n```js\nlet arrayObj = [2,4,5,60,39];\nlet backValue = arrayObj.find((element)=>{return element > 20});\nconsole.log(backValue); //60\n```\n\n\n### fill()\n\n该方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素\n\n语法：<br/>\narr.fill(value) <br/>\narr.fill(value, start) <br/>\narr.fill(value, start, end)<br/>\n```js\n[1, 2, 3].fill(4)            // [4, 4, 4]\n[1, 2, 3].fill(4, 1)         // [1, 4, 4]\n[1, 2, 3].fill(4, 1, 2)      // [1, 4, 3]\n[1, 2, 3].fill(4, 1, 1)      // [1, 2, 3]\n[1, 2, 3].fill(4, -3, -2)    // [4, 2, 3]\n[1, 2, 3].fill(4, NaN, NaN)  // [1, 2, 3]\nArray(3).fill(4);            // [4, 4, 4]\n[].fill.call({length: 3}, 4) // {0: 4, 1: 4, 2: 4, length: 3}\n```\n\n### entries()\n\n该方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对\n\n```js\nvar arr = [\"a\", \"b\", \"c\"];\nvar iterator = arr.entries();\n// undefined\n\nconsole.log(iterator);\n// Array Iterator {}\n\nconsole.log(iterator.next().value); \n// [0, \"a\"]\nconsole.log(iterator.next().value); \n// [1, \"b\"]\nconsole.log(iterator.next().value); \n// [2, \"c\"]\n```\n\n### includes()\n\n该方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false\n\n语法：<br/>\narr.includes(searchElement)<br/>\narr.includes(searchElement, fromIndex)<br/>\n```js\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n[1, 2, NaN].includes(NaN); // true\n```\n\n\n","source":"_posts/javascript/api.md","raw":"---\ntitle: 操作数组API方法\ndate: 2019-3-20 12:32:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: 介绍Array对象中的作用，属性、常规方法等\ntags:\n- JavaScript\ncategories:\n- JavaScript\n---\n\n### Array对象的作用\n\nArray 对象用于在单个的变量中存储多个值\n\n### 创建Array对象的方法\n\n`var arrayObj = new Array()；`<br/>\n`var arrayObj = []; //本人习惯用这种`<br/>\n返回值：返回新创建并被初始化了的数组。如果调用arrayObj时没有参数或者没有指定 值，那么返回的值为空，数组的length为0。<br/>\n\n### Array对象的三个属性 \n\n`constructor` //返回数组函数的引用。<br/>\n`length` //返回数组元素的长度（最常用）<br/>\n`prototype` //可以向数组对象添加属性和方法。<br/>\n\n### concat()\n\n该方法用于连接或者合并数组，并且不会改变原数组，返回一个新数组的副本\n\n```js\nvar arrObj = [1,2,3,4];\nvar arrObj1 = [5,6,7,8];\narrObj.concat(arrObj1); //[1,2,3,4,5,6,7,8]\n```\n\n### join()\n\n该方法用于把数组中的所有元素用指定的分隔符分割，返回一个字符串\n\n```js\nnewArray.join() //\"1,2,3,4,5,6,7,8\"\n```\n\n### pop()\n\n该方法用于删除并返回数组的最后一个元素,并将原数组的length -1\n\n```\narrObj.pop()//4\nconsole.log(arrObj); //[1,2,3]\n```\n\n### push()\n\n该方法可向数组的末尾添加一个或多个元素，并返回新的长度\n\n```js\narrObj.push(4);\nconsole.log(arrObj); //[1,2,3,4]\n```\n\n### shift()\n\n该方法用于删除并返回数组的第一个元素,并将原数组的length -1\n\n```\narrObj.shift() //1\nconsole.log(arrObj) //[2,3,4]\n```\n\n### unshift()\n\n该方法可向数组的开头添加一个或多个元素，并返回新的长度\n\n```js\narrObj.unshift(1);\nconsole.log(arrObj); //[1,2,3,4]\n```\n\n### slice()\n\n该方法可从已有的数组中返回选定的元素,形成一个新的数组\n\n```js\narrObj.slice(1,2); //[2]\nconsole.log(arrObj) //[1,2,3,4]\n```\n\n### splice()\n\n该法向数组中添加/删除元素，然后返回被删除的元素。该方法会改变原数组\n\n```js\narrObj.splice(1,2,5); //[2,3]\nconsole.log(arrObj); //[1,5,4]\n```\n\n### reverse()\n\n该方法用于颠倒数组中元素的顺序，并且改变原来的数组，而不会创建新的数组\n\n```js\narrObj.reverse(); //[4,5,1]\n```\n\n### sort()\n\n该方法用于对数组的元素进行排序\n\n注意：该方法是按照字符编码顺序进行排序，如果想要实现业务逻辑排序需要自定义比较函数\n\n```js\nvar arrObjSort = [1,5,4,2,3];\nvar arrObjSort1 = [1,2,10,3,20,4,30,50,5];\narrObjSort.sort(); //[1,2,3,4,5]\narrObjSort1.sort(); //[1, 10, 2, 20, 3, 30, 4, 5, 50]\n```\n\n自定义排序\n\n```js\nfunction __sortNumber(a,b){\n   return a-b;\n}\narrObjSort1.sort(__sortNumber); //[1, 2, 3, 4, 5, 10, 20, 30, 50]\n```\n\n### toString()\n\n该方法可把数组转换为字符串，并返回结果，与不带参数的join相同\n\n```js\narrObjSort1.toString(); //\"1,2,3,4,5,10,20,30,50\"\n```\n\ntoLocaleString-该方法可数组转换为本地字符串。和toString基本相同，但toLocaleString调用的是地区特定的分隔符把生成的字符串连接起来。<br/>\n\n如果你开发的脚本在世界范围都有人使用,那么将对象转换成字符串时请使用toString()方法<br/>\n\n因为LocaleString()会根据你机器的本地环境来返回字符串,它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化<br/>\n\n如果是为了返回时间类型的数据,推荐使用LocaleString().若是在后台处理字符串,请务必使用toString()<br/>\n\n```js\nvar date = new Date();\nvar myArr = [date,'go home'];\nmyArr.toLocaleString(); //\"2017/11/7 下午4:35:43,go home\"\nmyArr.toString(); //\"Tue Nov 07 2017 16:36:25 GMT+0800 (CST),go home\"\n```\n\n### indexOf()\n\n该方法可确定某个元素在数组实例中第一次出现的索引位置。如果没找到返回-1,可用索引值进行逻辑判断\n\n```js\nvar arr = [1,2,3,4,5];\narr.indexOf(2);  //1\narr.indexOf(2,1); //1\narr.indexOf(2,2); //-1\narr.indexOf(6);  //-1\n\n```\n\n查找元素出现的位置索引<br/>\n\n```js\nvar indices = [];\nvar arr = [1,2,3,2,5,2,7];\nvar index = arr.indexOf(2);\nwhile(index != -1){\n  indices.push(index);\n  index = arr.indexOf(2,index + 1);\n}\nconsole.log(indices)\n```\n\n判断一个元素是否在数组里，不在则向数组中添加元素<br/>\n\n```js\nvar arr = [1,2,3,4,5,6,7];\nfunction __upDataCollection(arrCollection,indicesEle){\n  var matchIndex =  arrCollection.indexOf(indicesEle);\n  if(matchIndex === -1){\n     arr.push(indicesEle);        \n  }else{\n    console.log('元素中存在相同的值');\n  }\n}\n__upDataCollection(arr,8); //[1, 2, 3, 4, 5, 6, 7, 8]\n__upDataCollection(arr,2); //'元素中存在相同的值'\n```\n\n### forEach()\n\n该方法按升序为数组中含有效值的每一项执行一次callback 函数（遍历数组）\n\n`forEach()` 为每个数组元素执行callback函数；不像`map()` 或者`reduce()` ，它总是返回 `undefined`值，也没有办法终止或跳出正在运行循环的`forEach`。如果常规的遍历想要检测条件返回bool , 并且可以终止循环，可使用`Array.some,Ayyay.every`.或者es6新方法`Array.find()`等等\n\n```js\nvar arrayObj = [1,2,3,,5];\narrayObj.forEach(function(element, index, array){\n   console.log(\"value[\" + index + \"] = \" + element) \n},this);\n//value[0] = 1\n//value[1] = 2\n//value[2] = 3\n//value[4] = 5\n//可以观察到以上遍历并没有出现undefind\n```\n\n### map()\n\n该方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组，并且不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）\n\n```js\n//常用的有些业务场景需要重新重组数组对象\nvar arrayObj = [\n    {name: 'zhangsan', age: 20}, \n    {name: 'lisi', age: 30}, \n    {name: 'wangwu', age: 26}\n  ];\nvar newArrayObj = arrayObj.map(function(obj, index, array) { \n   var newObj = {};\n   newObj[obj.name] = obj.age;\n   return newObj;\n});\nconsole.log(newArrayObj);\n//[{'zhangsan':20},{'lisi':30},{'wangwu':26}]\n```\n\n### filter()\n\n该方法创建一个新数组,通过次函数方法会返回相应的过滤后的数据,并且不会改变原数组\n\n```js\nvar arrayObj = [3,1,3,2,4,5,6];\nvar newArrayObj = arrayObj.filter(function(value,index,array){\n   return value > 3\n});\nconsole.log(newArrayObj);//[4, 5, 6]\n```\n\n### reduce()\n\n为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素,返回函数累计处理的结果\n\n`callback`执行数组中每个值的函数，包含四个参数：<br/>\n\n`accumulator`累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br/>\n\n`currentValue`数组中正在处理的元素。<br/>\n\n`currentIndex`数组中正在处理的当前元素的索引。<br/>\n\n如果提供了initialValue，则索引号为0，否则为索引为1。array调用reduce的数组initialValue[可选] 用作第一个调用 callback的第一个参数的值。<br/>\n\n如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br/>\n\n```js\nvar totalValue = [0, 1, 2, 3].reduce(function(sum, value) {\n  return sum + value;\n}, 0); \n// totalValue  6\n\n//将二维数组转化为一维数组\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(\n    function(a, b) {\n      return a.concat(b);\n    },[]);\n  // flattened is [0, 1, 2, 3, 4, 5] \n```\n\n### some()\n\n该方法用于检测数组中的某些元素是否通过callback函数实现的方法。返回bool值\n\n```js\nvar arrayObj = [1,2,3,4,5,6];\nvar flag = arrayObj.some(function(element,index,array){\n  return element > 2;\n});\nconsole.log(flag);//true\n```\n\n### every()\n\n该方法用于检测数组中的所有元素是否通过callback函数实现的方法。返回bool值\n\n```js\nvar arrayObj = [1,2,3,4,5,6];\nvar flag = arrayObj.some(function(element,index,array){\n  return element > 2;\n});\nconsole.log(flag);//false\n```\n\n### 扩展运算符(...)\n\n该运算符将一个数组转为用逗号分隔的参数序列\n\n扩展运算符即可以复制，合并数组，操作分割字符串与结构赋值结合还可以当函数的形参<br/>\n```js\nconsole.log(...[1,2,3,4,5]);//1 2 3 4 5\n```\n\n合并数组：<br/>\n\n```js\nlet arrayObj = [1,2,3,4,5,6];\nlet arrayObj1 = [7,8,9];\nlet newArray = [...arrayObj,...arrayObj1];\nconsole.log(newArray) //[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n复制数组：<br/>\n```js\nlet arrayObj = [1,2,3,4,5];\nlet arrayObjNew = [...arrayObj];\nconsole.log(arrayObjNew) //[1,2,3,4,5];\n```\n\n与结构赋值结合：<br/>\n```js\nconst [variable, ...array] = [1, 2, 3, 4, 5];\nconsole.log(variable); //1\nconsole.log(array); //[2,3,4,5]\n```\n\n函数形参：\n```js\n//例子1:\nlet _arrayObj = [1];\nlet _arrayObj1 = [1,2,3,4,5];\nvar __operationArr = (array,items)=>{ \n   array.push(...items);\n   console.log(array); //[1,1,2,3,4,5]\n}\n__operationArr(_arrayObj,_arrayObj1);\n//例子2:\nvar __add = (a,b,c,d,e) =>{\n  return a + b + c +d + e;\n}\n__add(..._arrayObj1); //15\n```\n\n求出数组最大元素：<br/>\n```js\nlet arrayObj = [2,3,4,5,3,2,8];\nMath.max(...arrayObj) //8\n```\n\n### form()\n\n该法从一个类似数组或可迭代对象中创建一个新的数组实例，相当于相当于[].slice.call()\n\n```js\n//例子1:\nlet arrayItems = {\n    '0': 'zhangsan',\n    '1': 'lisi',\n    '2': 'wangwu',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayItems); // ['zhangsan', 'lisi', 'wangwu']\n// ES6的写法\nlet arr2 = Array.from(arrayItems); // ['zhangsan', 'lisi', 'wangwu']\n\n例子2:\n// 常见的DOM NodeList对象\nlet ps = document.querySelectorAll('p');\nlet pElementArr = Array.from(ps);\npElementArr.forEach((p)=> {\n  console.log(p);\n});\n```\n将字符串分割字后变为数组<br/>\n```js\nArray.from('foo');//['f','o','o']\n```\n\n\n### of()\n\n该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型\n\nArray.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br/>\n\n```js\nArray.of(7);       // [7] \nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]\n```\n\n\n### copyWithin()\n\n该方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小\n\narr.copyWithin(target)<br/>\n\narr.copyWithin(target, start)<br/>\n\narr.copyWithin(target, start, end)<br/>\n\narr.copyWithin(目标索引, [源开始索引], [结束源索引])<br/>\n```js\n[1, 2, 3, 4, 5].copyWithin(-2);\n// [1, 2, 3, 1, 2]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3);\n// [4, 5, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\n// [4, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(-2, -3, -1);\n// [1, 2, 3, 3, 4]\n\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);\n// {0: 1, 3: 1, length: 5}\n```\n\n### find()\n\n该方法返回数组中满足提供的callback的第一个元素的值。否则返回 undefined\n\n如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用`Array.prototype.indexOf()` 或 `Array.prototype.includes()`。\n\n如果你需要找到元素的索引，而不是其值`Array.prototype.findIndex() `;\n```js\nlet arrayObj = [2,4,5,60,39];\nlet backValue = arrayObj.find((element)=>{return element > 20});\nconsole.log(backValue); //60\n```\n\n\n### fill()\n\n该方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素\n\n语法：<br/>\narr.fill(value) <br/>\narr.fill(value, start) <br/>\narr.fill(value, start, end)<br/>\n```js\n[1, 2, 3].fill(4)            // [4, 4, 4]\n[1, 2, 3].fill(4, 1)         // [1, 4, 4]\n[1, 2, 3].fill(4, 1, 2)      // [1, 4, 3]\n[1, 2, 3].fill(4, 1, 1)      // [1, 2, 3]\n[1, 2, 3].fill(4, -3, -2)    // [4, 2, 3]\n[1, 2, 3].fill(4, NaN, NaN)  // [1, 2, 3]\nArray(3).fill(4);            // [4, 4, 4]\n[].fill.call({length: 3}, 4) // {0: 4, 1: 4, 2: 4, length: 3}\n```\n\n### entries()\n\n该方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对\n\n```js\nvar arr = [\"a\", \"b\", \"c\"];\nvar iterator = arr.entries();\n// undefined\n\nconsole.log(iterator);\n// Array Iterator {}\n\nconsole.log(iterator.next().value); \n// [0, \"a\"]\nconsole.log(iterator.next().value); \n// [1, \"b\"]\nconsole.log(iterator.next().value); \n// [2, \"c\"]\n```\n\n### includes()\n\n该方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false\n\n语法：<br/>\narr.includes(searchElement)<br/>\narr.includes(searchElement, fromIndex)<br/>\n```js\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n[1, 2, NaN].includes(NaN); // true\n```\n\n\n","slug":"javascript/api","published":1,"updated":"2019-10-15T01:29:42.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8oww009kb0u6c70rfbzv","content":"<h3 id=\"Array对象的作用\"><a href=\"#Array对象的作用\" class=\"headerlink\" title=\"Array对象的作用\"></a>Array对象的作用</h3><p>Array 对象用于在单个的变量中存储多个值</p>\n<h3 id=\"创建Array对象的方法\"><a href=\"#创建Array对象的方法\" class=\"headerlink\" title=\"创建Array对象的方法\"></a>创建Array对象的方法</h3><p><code>var arrayObj = new Array()；</code><br><br><code>var arrayObj = []; //本人习惯用这种</code><br><br>返回值：返回新创建并被初始化了的数组。如果调用arrayObj时没有参数或者没有指定 值，那么返回的值为空，数组的length为0。<br></p>\n<h3 id=\"Array对象的三个属性\"><a href=\"#Array对象的三个属性\" class=\"headerlink\" title=\"Array对象的三个属性\"></a>Array对象的三个属性</h3><p><code>constructor</code> //返回数组函数的引用。<br><br><code>length</code> //返回数组元素的长度（最常用）<br><br><code>prototype</code> //可以向数组对象添加属性和方法。<br></p>\n<h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h3><p>该方法用于连接或者合并数组，并且不会改变原数组，返回一个新数组的副本</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arrObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arrObj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\narrObj<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>arrObj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5,6,7,8]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><p>该方法用于把数组中的所有元素用指定的分隔符分割，返回一个字符串</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">newArray<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//\"1,2,3,4,5,6,7,8\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop()\"></a>pop()</h3><p>该方法用于删除并返回数组的最后一个元素,并将原数组的length -1</p>\n<pre><code>arrObj.pop()//4\nconsole.log(arrObj); //[1,2,3]</code></pre><h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h3><p>该方法可向数组的末尾添加一个或多个元素，并返回新的长度</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">arrObj<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arrObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift()\"></a>shift()</h3><p>该方法用于删除并返回数组的第一个元素,并将原数组的length -1</p>\n<pre><code>arrObj.shift() //1\nconsole.log(arrObj) //[2,3,4]</code></pre><h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift()\"></a>unshift()</h3><p>该方法可向数组的开头添加一个或多个元素，并返回新的长度</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">arrObj<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arrObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p>该方法可从已有的数组中返回选定的元素,形成一个新的数组</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">arrObj<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[2]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arrObj<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p>该法向数组中添加/删除元素，然后返回被删除的元素。该方法会改变原数组</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">arrObj<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[2,3]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arrObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,5,4]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse()\"></a>reverse()</h3><p>该方法用于颠倒数组中元素的顺序，并且改变原来的数组，而不会创建新的数组</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">arrObj<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[4,5,1]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p>该方法用于对数组的元素进行排序</p>\n<p>注意：该方法是按照字符编码顺序进行排序，如果想要实现业务逻辑排序需要自定义比较函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arrObjSort <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arrObjSort1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\narrObjSort<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5]</span>\narrObjSort1<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1, 10, 2, 20, 3, 30, 4, 5, 50]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>自定义排序</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">__sortNumber</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> a<span class=\"token operator\">-</span>b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\narrObjSort1<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>__sortNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1, 2, 3, 4, 5, 10, 20, 30, 50]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>该方法可把数组转换为字符串，并返回结果，与不带参数的join相同</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">arrObjSort1<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"1,2,3,4,5,10,20,30,50\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>toLocaleString-该方法可数组转换为本地字符串。和toString基本相同，但toLocaleString调用的是地区特定的分隔符把生成的字符串连接起来。<br></p>\n<p>如果你开发的脚本在世界范围都有人使用,那么将对象转换成字符串时请使用toString()方法<br></p>\n<p>因为LocaleString()会根据你机器的本地环境来返回字符串,它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化<br></p>\n<p>如果是为了返回时间类型的数据,推荐使用LocaleString().若是在后台处理字符串,请务必使用toString()<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> date <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> myArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>date<span class=\"token punctuation\">,</span><span class=\"token string\">'go home'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmyArr<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"2017/11/7 下午4:35:43,go home\"</span>\nmyArr<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"Tue Nov 07 2017 16:36:25 GMT+0800 (CST),go home\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a>indexOf()</h3><p>该方法可确定某个元素在数组实例中第一次出现的索引位置。如果没找到返回-1,可用索引值进行逻辑判断</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//1</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//-1</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//-1</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>查找元素出现的位置索引<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> indices <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> index <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  indices<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  index <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>indices<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>判断一个元素是否在数组里，不在则向数组中添加元素<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">__upDataCollection</span><span class=\"token punctuation\">(</span>arrCollection<span class=\"token punctuation\">,</span>indicesEle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> matchIndex <span class=\"token operator\">=</span>  arrCollection<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>indicesEle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>matchIndex <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>indicesEle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'元素中存在相同的值'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">__upDataCollection</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1, 2, 3, 4, 5, 6, 7, 8]</span>\n<span class=\"token function\">__upDataCollection</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'元素中存在相同的值'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><p>该方法按升序为数组中含有效值的每一项执行一次callback 函数（遍历数组）</p>\n<p><code>forEach()</code> 为每个数组元素执行callback函数；不像<code>map()</code> 或者<code>reduce()</code> ，它总是返回 <code>undefined</code>值，也没有办法终止或跳出正在运行循环的<code>forEach</code>。如果常规的遍历想要检测条件返回bool , 并且可以终止循环，可使用<code>Array.some,Ayyay.every</code>.或者es6新方法<code>Array.find()</code>等等</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\narrayObj<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value[\"</span> <span class=\"token operator\">+</span> index <span class=\"token operator\">+</span> <span class=\"token string\">\"] = \"</span> <span class=\"token operator\">+</span> element<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//value[0] = 1</span>\n<span class=\"token comment\" spellcheck=\"true\">//value[1] = 2</span>\n<span class=\"token comment\" spellcheck=\"true\">//value[2] = 3</span>\n<span class=\"token comment\" spellcheck=\"true\">//value[4] = 5</span>\n<span class=\"token comment\" spellcheck=\"true\">//可以观察到以上遍历并没有出现undefind</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h3><p>该方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组，并且不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//常用的有些业务场景需要重新重组数组对象</span>\n<span class=\"token keyword\">var</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> \n    <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'lisi'</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> \n    <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'wangwu'</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">26</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> newArrayObj <span class=\"token operator\">=</span> arrayObj<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n   <span class=\"token keyword\">var</span> newObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n   newObj<span class=\"token punctuation\">[</span>obj<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> newObj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newArrayObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//[{'zhangsan':20},{'lisi':30},{'wangwu':26}]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><p>该方法创建一个新数组,通过次函数方法会返回相应的过滤后的数据,并且不会改变原数组</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> newArrayObj <span class=\"token operator\">=</span> arrayObj<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> value <span class=\"token operator\">></span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newArrayObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//[4, 5, 6]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p>为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素,返回函数累计处理的结果</p>\n<p><code>callback</code>执行数组中每个值的函数，包含四个参数：<br></p>\n<p><code>accumulator</code>累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br></p>\n<p><code>currentValue</code>数组中正在处理的元素。<br></p>\n<p><code>currentIndex</code>数组中正在处理的当前元素的索引。<br></p>\n<p>如果提供了initialValue，则索引号为0，否则为索引为1。array调用reduce的数组initialValue[可选] 用作第一个调用 callback的第一个参数的值。<br></p>\n<p>如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> totalValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> sum <span class=\"token operator\">+</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// totalValue  6</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//将二维数组转化为一维数组</span>\n<span class=\"token keyword\">var</span> flattened <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// flattened is [0, 1, 2, 3, 4, 5] </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some()\"></a>some()</h3><p>该方法用于检测数组中的某些元素是否通过callback函数实现的方法。返回bool值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> flag <span class=\"token operator\">=</span> arrayObj<span class=\"token punctuation\">.</span><span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> element <span class=\"token operator\">></span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every()\"></a>every()</h3><p>该方法用于检测数组中的所有元素是否通过callback函数实现的方法。返回bool值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> flag <span class=\"token operator\">=</span> arrayObj<span class=\"token punctuation\">.</span><span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> element <span class=\"token operator\">></span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"扩展运算符-…\"><a href=\"#扩展运算符-…\" class=\"headerlink\" title=\"扩展运算符(…)\"></a>扩展运算符(…)</h3><p>该运算符将一个数组转为用逗号分隔的参数序列</p>\n<p>扩展运算符即可以复制，合并数组，操作分割字符串与结构赋值结合还可以当函数的形参<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//1 2 3 4 5</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>合并数组：<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> arrayObj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> newArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arrayObj<span class=\"token punctuation\">,</span><span class=\"token operator\">...</span>arrayObj1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newArray<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>复制数组：<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> arrayObjNew <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arrayObj<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arrayObjNew<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5];</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>与结构赋值结合：<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>variable<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>array<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>variable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[2,3,4,5]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>函数形参：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//例子1:</span>\n<span class=\"token keyword\">let</span> _arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> _arrayObj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> __operationArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span>items<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span> \n   array<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>items<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,1,2,3,4,5]</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">__operationArr</span><span class=\"token punctuation\">(</span>_arrayObj<span class=\"token punctuation\">,</span>_arrayObj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//例子2:</span>\n<span class=\"token keyword\">var</span> __add <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">,</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> c <span class=\"token operator\">+</span>d <span class=\"token operator\">+</span> e<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">__add</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>_arrayObj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//15</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>求出数组最大元素：<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nMath<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>arrayObj<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//8</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"form\"><a href=\"#form\" class=\"headerlink\" title=\"form()\"></a>form()</h3><p>该法从一个类似数组或可迭代对象中创建一个新的数组实例，相当于相当于[].slice.call()</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//例子1:</span>\n<span class=\"token keyword\">let</span> arrayItems <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'0'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'1'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'lisi'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'2'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'wangwu'</span><span class=\"token punctuation\">,</span>\n    length<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ES5的写法</span>\n<span class=\"token keyword\">var</span> arr1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arrayItems<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ['zhangsan', 'lisi', 'wangwu']</span>\n<span class=\"token comment\" spellcheck=\"true\">// ES6的写法</span>\n<span class=\"token keyword\">let</span> arr2 <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>arrayItems<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ['zhangsan', 'lisi', 'wangwu']</span>\n\n例子<span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n<span class=\"token comment\" spellcheck=\"true\">// 常见的DOM NodeList对象</span>\n<span class=\"token keyword\">let</span> ps <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelectorAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> pElementArr <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>ps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\npElementArr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将字符串分割字后变为数组<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//['f','o','o']</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of()\"></a>of()</h3><p>该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p>\n<p>Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\" spellcheck=\"true\">// [7] </span>\nArray<span class=\"token punctuation\">.</span><span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3]</span>\n\n<span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">// [ , , , , , , ]</span>\n<span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h3><p>该方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小</p>\n<p>arr.copyWithin(target)<br></p>\n<p>arr.copyWithin(target, start)<br></p>\n<p>arr.copyWithin(target, start, end)<br></p>\n<p>arr.copyWithin(目标索引, [源开始索引], [结束源索引])<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyWithin</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3, 1, 2]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyWithin</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// [4, 5, 3, 4, 5]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyWithin</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// [4, 2, 3, 4, 5]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyWithin</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3, 3, 4]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>copyWithin<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>length<span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// {0: 1, 3: 1, length: 5}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find()\"></a>find()</h3><p>该方法返回数组中满足提供的callback的第一个元素的值。否则返回 undefined</p>\n<p>如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用<code>Array.prototype.indexOf()</code> 或 <code>Array.prototype.includes()</code>。</p>\n<p>如果你需要找到元素的索引，而不是其值<code>Array.prototype.findIndex()</code>;</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arrayObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">60</span><span class=\"token punctuation\">,</span><span class=\"token number\">39</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> backValue <span class=\"token operator\">=</span> arrayObj<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> element <span class=\"token operator\">></span> <span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>backValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//60</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h3><p>该方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素</p>\n<p>语法：<br><br>arr.fill(value) <br><br>arr.fill(value, start) <br><br>arr.fill(value, start, end)<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>            <span class=\"token comment\" spellcheck=\"true\">// [4, 4, 4]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>         <span class=\"token comment\" spellcheck=\"true\">// [1, 4, 4]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>      <span class=\"token comment\" spellcheck=\"true\">// [1, 4, 3]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>      <span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\" spellcheck=\"true\">// [4, 2, 3]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">NaN</span><span class=\"token punctuation\">,</span> <span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// [1, 2, 3]</span>\n<span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\" spellcheck=\"true\">// [4, 4, 4]</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fill<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>length<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// {0: 4, 1: 4, 2: 4, length: 3}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"entries\"><a href=\"#entries\" class=\"headerlink\" title=\"entries()\"></a>entries()</h3><p>该方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> iterator <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// undefined</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Array Iterator {}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// [0, \"a\"]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// [1, \"b\"]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">// [2, \"c\"]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes()\"></a>includes()</h3><p>该方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false</p>\n<p>语法：<br><br>arr.includes(searchElement)<br><br>arr.includes(searchElement, fromIndex)<br></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">NaN</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h3 id=\"Array对象的作用\"><a href=\"#Array对象的作用\" class=\"headerlink\" title=\"Array对象的作用\"></a>Array对象的作用</h3><p>Array 对象用于在单个的变量中存储多个值</p>\n<h3 id=\"创建Array对象的方法\"><a href=\"#创建Array对象的方法\" class=\"headerlink\" title=\"创建Array对象的方法\"></a>创建Array对象的方法</h3><p><code>var arrayObj = new Array()；</code><br><br><code>var arrayObj = []; //本人习惯用这种</code><br><br>返回值：返回新创建并被初始化了的数组。如果调用arrayObj时没有参数或者没有指定 值，那么返回的值为空，数组的length为0。<br></p>\n<h3 id=\"Array对象的三个属性\"><a href=\"#Array对象的三个属性\" class=\"headerlink\" title=\"Array对象的三个属性\"></a>Array对象的三个属性</h3><p><code>constructor</code> //返回数组函数的引用。<br><br><code>length</code> //返回数组元素的长度（最常用）<br><br><code>prototype</code> //可以向数组对象添加属性和方法。<br></p>\n<h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h3><p>该方法用于连接或者合并数组，并且不会改变原数组，返回一个新数组的副本</p>\n<pre><code class=\"js\">var arrObj = [1,2,3,4];\nvar arrObj1 = [5,6,7,8];\narrObj.concat(arrObj1); //[1,2,3,4,5,6,7,8]</code></pre>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><p>该方法用于把数组中的所有元素用指定的分隔符分割，返回一个字符串</p>\n<pre><code class=\"js\">newArray.join() //&quot;1,2,3,4,5,6,7,8&quot;</code></pre>\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop()\"></a>pop()</h3><p>该方法用于删除并返回数组的最后一个元素,并将原数组的length -1</p>\n<pre><code>arrObj.pop()//4\nconsole.log(arrObj); //[1,2,3]</code></pre><h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h3><p>该方法可向数组的末尾添加一个或多个元素，并返回新的长度</p>\n<pre><code class=\"js\">arrObj.push(4);\nconsole.log(arrObj); //[1,2,3,4]</code></pre>\n<h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift()\"></a>shift()</h3><p>该方法用于删除并返回数组的第一个元素,并将原数组的length -1</p>\n<pre><code>arrObj.shift() //1\nconsole.log(arrObj) //[2,3,4]</code></pre><h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift()\"></a>unshift()</h3><p>该方法可向数组的开头添加一个或多个元素，并返回新的长度</p>\n<pre><code class=\"js\">arrObj.unshift(1);\nconsole.log(arrObj); //[1,2,3,4]</code></pre>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p>该方法可从已有的数组中返回选定的元素,形成一个新的数组</p>\n<pre><code class=\"js\">arrObj.slice(1,2); //[2]\nconsole.log(arrObj) //[1,2,3,4]</code></pre>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p>该法向数组中添加/删除元素，然后返回被删除的元素。该方法会改变原数组</p>\n<pre><code class=\"js\">arrObj.splice(1,2,5); //[2,3]\nconsole.log(arrObj); //[1,5,4]</code></pre>\n<h3 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse()\"></a>reverse()</h3><p>该方法用于颠倒数组中元素的顺序，并且改变原来的数组，而不会创建新的数组</p>\n<pre><code class=\"js\">arrObj.reverse(); //[4,5,1]</code></pre>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p>该方法用于对数组的元素进行排序</p>\n<p>注意：该方法是按照字符编码顺序进行排序，如果想要实现业务逻辑排序需要自定义比较函数</p>\n<pre><code class=\"js\">var arrObjSort = [1,5,4,2,3];\nvar arrObjSort1 = [1,2,10,3,20,4,30,50,5];\narrObjSort.sort(); //[1,2,3,4,5]\narrObjSort1.sort(); //[1, 10, 2, 20, 3, 30, 4, 5, 50]</code></pre>\n<p>自定义排序</p>\n<pre><code class=\"js\">function __sortNumber(a,b){\n   return a-b;\n}\narrObjSort1.sort(__sortNumber); //[1, 2, 3, 4, 5, 10, 20, 30, 50]</code></pre>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>该方法可把数组转换为字符串，并返回结果，与不带参数的join相同</p>\n<pre><code class=\"js\">arrObjSort1.toString(); //&quot;1,2,3,4,5,10,20,30,50&quot;</code></pre>\n<p>toLocaleString-该方法可数组转换为本地字符串。和toString基本相同，但toLocaleString调用的是地区特定的分隔符把生成的字符串连接起来。<br></p>\n<p>如果你开发的脚本在世界范围都有人使用,那么将对象转换成字符串时请使用toString()方法<br></p>\n<p>因为LocaleString()会根据你机器的本地环境来返回字符串,它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化<br></p>\n<p>如果是为了返回时间类型的数据,推荐使用LocaleString().若是在后台处理字符串,请务必使用toString()<br></p>\n<pre><code class=\"js\">var date = new Date();\nvar myArr = [date,&#39;go home&#39;];\nmyArr.toLocaleString(); //&quot;2017/11/7 下午4:35:43,go home&quot;\nmyArr.toString(); //&quot;Tue Nov 07 2017 16:36:25 GMT+0800 (CST),go home&quot;</code></pre>\n<h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a>indexOf()</h3><p>该方法可确定某个元素在数组实例中第一次出现的索引位置。如果没找到返回-1,可用索引值进行逻辑判断</p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5];\narr.indexOf(2);  //1\narr.indexOf(2,1); //1\narr.indexOf(2,2); //-1\narr.indexOf(6);  //-1\n</code></pre>\n<p>查找元素出现的位置索引<br></p>\n<pre><code class=\"js\">var indices = [];\nvar arr = [1,2,3,2,5,2,7];\nvar index = arr.indexOf(2);\nwhile(index != -1){\n  indices.push(index);\n  index = arr.indexOf(2,index + 1);\n}\nconsole.log(indices)</code></pre>\n<p>判断一个元素是否在数组里，不在则向数组中添加元素<br></p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5,6,7];\nfunction __upDataCollection(arrCollection,indicesEle){\n  var matchIndex =  arrCollection.indexOf(indicesEle);\n  if(matchIndex === -1){\n     arr.push(indicesEle);        \n  }else{\n    console.log(&#39;元素中存在相同的值&#39;);\n  }\n}\n__upDataCollection(arr,8); //[1, 2, 3, 4, 5, 6, 7, 8]\n__upDataCollection(arr,2); //&#39;元素中存在相同的值&#39;</code></pre>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><p>该方法按升序为数组中含有效值的每一项执行一次callback 函数（遍历数组）</p>\n<p><code>forEach()</code> 为每个数组元素执行callback函数；不像<code>map()</code> 或者<code>reduce()</code> ，它总是返回 <code>undefined</code>值，也没有办法终止或跳出正在运行循环的<code>forEach</code>。如果常规的遍历想要检测条件返回bool , 并且可以终止循环，可使用<code>Array.some,Ayyay.every</code>.或者es6新方法<code>Array.find()</code>等等</p>\n<pre><code class=\"js\">var arrayObj = [1,2,3,,5];\narrayObj.forEach(function(element, index, array){\n   console.log(&quot;value[&quot; + index + &quot;] = &quot; + element) \n},this);\n//value[0] = 1\n//value[1] = 2\n//value[2] = 3\n//value[4] = 5\n//可以观察到以上遍历并没有出现undefind</code></pre>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h3><p>该方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组，并且不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）</p>\n<pre><code class=\"js\">//常用的有些业务场景需要重新重组数组对象\nvar arrayObj = [\n    {name: &#39;zhangsan&#39;, age: 20}, \n    {name: &#39;lisi&#39;, age: 30}, \n    {name: &#39;wangwu&#39;, age: 26}\n  ];\nvar newArrayObj = arrayObj.map(function(obj, index, array) { \n   var newObj = {};\n   newObj[obj.name] = obj.age;\n   return newObj;\n});\nconsole.log(newArrayObj);\n//[{&#39;zhangsan&#39;:20},{&#39;lisi&#39;:30},{&#39;wangwu&#39;:26}]</code></pre>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><p>该方法创建一个新数组,通过次函数方法会返回相应的过滤后的数据,并且不会改变原数组</p>\n<pre><code class=\"js\">var arrayObj = [3,1,3,2,4,5,6];\nvar newArrayObj = arrayObj.filter(function(value,index,array){\n   return value &gt; 3\n});\nconsole.log(newArrayObj);//[4, 5, 6]</code></pre>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p>为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素,返回函数累计处理的结果</p>\n<p><code>callback</code>执行数组中每个值的函数，包含四个参数：<br></p>\n<p><code>accumulator</code>累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br></p>\n<p><code>currentValue</code>数组中正在处理的元素。<br></p>\n<p><code>currentIndex</code>数组中正在处理的当前元素的索引。<br></p>\n<p>如果提供了initialValue，则索引号为0，否则为索引为1。array调用reduce的数组initialValue[可选] 用作第一个调用 callback的第一个参数的值。<br></p>\n<p>如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br></p>\n<pre><code class=\"js\">var totalValue = [0, 1, 2, 3].reduce(function(sum, value) {\n  return sum + value;\n}, 0); \n// totalValue  6\n\n//将二维数组转化为一维数组\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(\n    function(a, b) {\n      return a.concat(b);\n    },[]);\n  // flattened is [0, 1, 2, 3, 4, 5] </code></pre>\n<h3 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some()\"></a>some()</h3><p>该方法用于检测数组中的某些元素是否通过callback函数实现的方法。返回bool值</p>\n<pre><code class=\"js\">var arrayObj = [1,2,3,4,5,6];\nvar flag = arrayObj.some(function(element,index,array){\n  return element &gt; 2;\n});\nconsole.log(flag);//true</code></pre>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every()\"></a>every()</h3><p>该方法用于检测数组中的所有元素是否通过callback函数实现的方法。返回bool值</p>\n<pre><code class=\"js\">var arrayObj = [1,2,3,4,5,6];\nvar flag = arrayObj.some(function(element,index,array){\n  return element &gt; 2;\n});\nconsole.log(flag);//false</code></pre>\n<h3 id=\"扩展运算符-…\"><a href=\"#扩展运算符-…\" class=\"headerlink\" title=\"扩展运算符(…)\"></a>扩展运算符(…)</h3><p>该运算符将一个数组转为用逗号分隔的参数序列</p>\n<p>扩展运算符即可以复制，合并数组，操作分割字符串与结构赋值结合还可以当函数的形参<br></p>\n<pre><code class=\"js\">console.log(...[1,2,3,4,5]);//1 2 3 4 5</code></pre>\n<p>合并数组：<br></p>\n<pre><code class=\"js\">let arrayObj = [1,2,3,4,5,6];\nlet arrayObj1 = [7,8,9];\nlet newArray = [...arrayObj,...arrayObj1];\nconsole.log(newArray) //[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>\n<p>复制数组：<br></p>\n<pre><code class=\"js\">let arrayObj = [1,2,3,4,5];\nlet arrayObjNew = [...arrayObj];\nconsole.log(arrayObjNew) //[1,2,3,4,5];</code></pre>\n<p>与结构赋值结合：<br></p>\n<pre><code class=\"js\">const [variable, ...array] = [1, 2, 3, 4, 5];\nconsole.log(variable); //1\nconsole.log(array); //[2,3,4,5]</code></pre>\n<p>函数形参：</p>\n<pre><code class=\"js\">//例子1:\nlet _arrayObj = [1];\nlet _arrayObj1 = [1,2,3,4,5];\nvar __operationArr = (array,items)=&gt;{ \n   array.push(...items);\n   console.log(array); //[1,1,2,3,4,5]\n}\n__operationArr(_arrayObj,_arrayObj1);\n//例子2:\nvar __add = (a,b,c,d,e) =&gt;{\n  return a + b + c +d + e;\n}\n__add(..._arrayObj1); //15</code></pre>\n<p>求出数组最大元素：<br></p>\n<pre><code class=\"js\">let arrayObj = [2,3,4,5,3,2,8];\nMath.max(...arrayObj) //8</code></pre>\n<h3 id=\"form\"><a href=\"#form\" class=\"headerlink\" title=\"form()\"></a>form()</h3><p>该法从一个类似数组或可迭代对象中创建一个新的数组实例，相当于相当于[].slice.call()</p>\n<pre><code class=\"js\">//例子1:\nlet arrayItems = {\n    &#39;0&#39;: &#39;zhangsan&#39;,\n    &#39;1&#39;: &#39;lisi&#39;,\n    &#39;2&#39;: &#39;wangwu&#39;,\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayItems); // [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]\n// ES6的写法\nlet arr2 = Array.from(arrayItems); // [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]\n\n例子2:\n// 常见的DOM NodeList对象\nlet ps = document.querySelectorAll(&#39;p&#39;);\nlet pElementArr = Array.from(ps);\npElementArr.forEach((p)=&gt; {\n  console.log(p);\n});</code></pre>\n<p>将字符串分割字后变为数组<br></p>\n<pre><code class=\"js\">Array.from(&#39;foo&#39;);//[&#39;f&#39;,&#39;o&#39;,&#39;o&#39;]</code></pre>\n<h3 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of()\"></a>of()</h3><p>该方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p>\n<p>Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br></p>\n<pre><code class=\"js\">Array.of(7);       // [7] \nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]</code></pre>\n<h3 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h3><p>该方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小</p>\n<p>arr.copyWithin(target)<br></p>\n<p>arr.copyWithin(target, start)<br></p>\n<p>arr.copyWithin(target, start, end)<br></p>\n<p>arr.copyWithin(目标索引, [源开始索引], [结束源索引])<br></p>\n<pre><code class=\"js\">[1, 2, 3, 4, 5].copyWithin(-2);\n// [1, 2, 3, 1, 2]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3);\n// [4, 5, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\n// [4, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(-2, -3, -1);\n// [1, 2, 3, 3, 4]\n\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);\n// {0: 1, 3: 1, length: 5}</code></pre>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find()\"></a>find()</h3><p>该方法返回数组中满足提供的callback的第一个元素的值。否则返回 undefined</p>\n<p>如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用<code>Array.prototype.indexOf()</code> 或 <code>Array.prototype.includes()</code>。</p>\n<p>如果你需要找到元素的索引，而不是其值<code>Array.prototype.findIndex()</code>;</p>\n<pre><code class=\"js\">let arrayObj = [2,4,5,60,39];\nlet backValue = arrayObj.find((element)=&gt;{return element &gt; 20});\nconsole.log(backValue); //60</code></pre>\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h3><p>该方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素</p>\n<p>语法：<br><br>arr.fill(value) <br><br>arr.fill(value, start) <br><br>arr.fill(value, start, end)<br></p>\n<pre><code class=\"js\">[1, 2, 3].fill(4)            // [4, 4, 4]\n[1, 2, 3].fill(4, 1)         // [1, 4, 4]\n[1, 2, 3].fill(4, 1, 2)      // [1, 4, 3]\n[1, 2, 3].fill(4, 1, 1)      // [1, 2, 3]\n[1, 2, 3].fill(4, -3, -2)    // [4, 2, 3]\n[1, 2, 3].fill(4, NaN, NaN)  // [1, 2, 3]\nArray(3).fill(4);            // [4, 4, 4]\n[].fill.call({length: 3}, 4) // {0: 4, 1: 4, 2: 4, length: 3}</code></pre>\n<h3 id=\"entries\"><a href=\"#entries\" class=\"headerlink\" title=\"entries()\"></a>entries()</h3><p>该方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对</p>\n<pre><code class=\"js\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\nvar iterator = arr.entries();\n// undefined\n\nconsole.log(iterator);\n// Array Iterator {}\n\nconsole.log(iterator.next().value); \n// [0, &quot;a&quot;]\nconsole.log(iterator.next().value); \n// [1, &quot;b&quot;]\nconsole.log(iterator.next().value); \n// [2, &quot;c&quot;]</code></pre>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes()\"></a>includes()</h3><p>该方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false</p>\n<p>语法：<br><br>arr.includes(searchElement)<br><br>arr.includes(searchElement, fromIndex)<br></p>\n<pre><code class=\"js\">[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n[1, 2, NaN].includes(NaN); // true</code></pre>\n"},{"title":"vue 原理解析之响应式","date":"2019-09-05T08:45:09.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n## 响应式对象\n\n提到 vue 的双向数据绑定原理，我们都知道是利用了 `Object.defineProperty` 给数据添加 getter 和 setter，来进行依赖收集和数据派发更新，首先我们再来熟悉一下这个方法\n\n### Object.defineProperty <hr>\n\nMDN 中写到 `Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象\n\n```js\n\nfunction Person () {}\n\nObject.defineProperty(Person.prototype, 'sayHello', {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return `my name is ${this.name}`\n  },\n  set:function (value) {\n    this.name = value\n  }\n})\nlet p = new Person()\np.name = 'renbo'\nconsole.log(p.sayHello) // my name is renbo\n```\n我们在实现一个极简版双向绑定\n\n```html\n\n<div>请输入:</div>\n<input type=\"text\" id=\"input\">\n<div id=\"content\"></div>\n\n```\n\n```js\n  \nlet obj = {}\n\nObject.definePerperty(obj,'text', {\n\n  get:function () {\n    console.log('获得的值')\n  },\n  set:function (newVal) {\n    console.log('设置的值')\n    document.getElementById('input').value = newVal\n    document.getElementById('content').innerHTML = newVal;\n  }\n})\n\nconst input = document.getElementById('input');\ninput.addEventListener('keyup', function(e){\n  obj.text = e.target.value;\n})\n\n```\n\nset 提供 setter 方法，当我们对 p.name 做修改的时候会触发 setter 方法， 我们访问 sayHello 的时候会触发 getter 方法，取到对应的值，那么一旦对象拥有了 getter 和 setter，就把这个对象变为自动存取的响应对象\n\n### initState <hr>\n\n在 vue _init 阶段我们还执行了 initState(vm) 方法，我们上篇文章写到这个方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作,在 `src/core/instance/state.js 中定义`\n\n```js\nexport function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n\n```\n\n### initProps <hr>\n\n```js\nfunction initProps (vm: Component, propsOptions: Object) {\n  const propsData = vm.$options.propsData || {}\n  const props = vm._props = {}\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false)\n  }\n  for (const key in propsOptions) {\n    keys.push(key)\n    const value = validateProp(key, propsOptions, propsData, vm)\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      const hyphenatedKey = hyphenate(key)\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          `\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`,\n          vm\n        )\n      }\n      defineReactive(props, key, value, () => {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            `Avoid mutating a prop directly since the value will be ` +\n            `overwritten whenever the parent component re-renders. ` +\n            `Instead, use a data or computed property based on the prop's ` +\n            `value. Prop being mutated: \"${key}\"`,\n            vm\n          )\n        }\n      })\n    } else {\n      defineReactive(props, key, value)\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  toggleObserving(true)\n}\n```\n\n从上面代码中我们看到 props 过程，主要就是遍历 propsOptions ，调用 defineReactive 方法和 proxy，但是上面在开发环境中调用 defineReactive 给一个警告，平时我们通过 props 方法来接受父组件所传过来的值，但是这个过程是单项的，父组件可以改变传给子组件的值，但是如果子组件想改变所接受的值并传给父组件是不可以的，会收到这个警告\n\n这个错误告诉我们避免去直接更改 props 因为当父组件重新渲染时，该值就会被覆盖。这个时候就需要用到计算属性或者侦听属性了。\n\ndefineReactive 方法和 proxy 具体作用我们在后面介绍。\n\n### initData<hr>\n\n```js\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */)\n}\n```\n\ninitData 主要是遍历data，取到对应的key 调用 proxy ；另一个是调用 observe 方法\n\n### proxy<hr>\n\n平时我们写 vue 的时候我们可以直接在方法中访问 props 和 data，看下面例子\n\n```js\n\nprops: {\n  name: {\n    type: String,\n    default () {\n      return 'renbo'\n    }\n  }\n},\ndata:{\n  return {\n     age: 26\n  }\n},\nmethods: {\n  sayHello () {\n    console.log(this.name, this.age)\n  }\n}\n```\n\n这就是通过 proxy 将 props 和 data 上的属性代理到 vm 实例上，所以我们可以直接通过 this 访问到\n\n那么我们看看 proxy 是如何定义的呢\n\n```js\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n通过 Object.defineProperty 把 target[sourceKey][key] 的读写变成了对 target[key] 的读写，所以对于 props 和 data 而言就是\n\n```js\nvm._props.xxx -> vm.xxx\nvm._data.xxx -> vm.xxx\n```\n\n### observe<hr>\n\n上面在 initData中调用了 observe 函数，进入文件 `src/core/observer/index.js` 中\n\n```js\n**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob: Observer | void\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n    ob.vmCount++\n  }\n  return ob\n}\n```\n\nobserve 就是给除了 vnode 的对象类型的数据添加一个观察者实例\n\n如果已经添加过则直接返回，否则在满足一定条件下去 new Observer\n\n接下来我们来看一下 Observer 的作用\n\n```js\nexport class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that have this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n\n```\n\nObserver 是一个构造函数\n- 在constructor 中实例化了 Dep 对象\n- 执行了 `def(value, '__ob__', this)`\n- 对 value 进行判断，如果是数组调用 observeArray，如果是纯对象调用 walk \n- observeArray 方法中遍历数组再次调用 observer，而 walk 遍历对象的 key 调用 defineReactive\n\nDep 主要的作用就是进行依赖收集，是整个 getter 的核心，在后面会介绍，def 函数是通过 Object.defineProperty 的封装的，作用是将自身实例添加到数据对象 value 的 `__ob__` 属性上，这样我们在开发中就会看到 data 上对象类型的数据多了一个 `__ob__ `的属性\n\n### defineReactive<hr> \n\ndefineReactive 的作用就是定义一个响应式对象，给对象动态添加 getter 和 setter\n\n```js\n\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n\n```\n\ndefineReactive 函数\n\n-  new Dep()\n-  通过 Object.getOwnPropertyDescriptor 拿到 obj 的属性描述符\n-  对子对象递归调用 observe 方法，把所有子属性变成响应式对象\n-  利用 Object.defineProperty 给 obj 的属性 key 添加 getter 和 setter\n\n\n下面我们通过上面的逻辑步骤整理下面一张图\n\n<img src=\"/images/vue-observer.png\" />\n\n通过上面的逻辑和总结发现响应式对象的核心其实就是利用 Object.defineProperty 给数据添加了 getter 和 setter，来进行依赖收集`dep.depend()` 和派发更新 `dep.notify()`\n\n## 依赖收集\n\n通过响应式对象我们知道在 defineReactive 函数内的 Object.defineProperty 定义的 get 内部实例了 Dep\n\n### dep<hr>\n\n```js\nconst dep = new Dep()\ndep.depend()\n```\n\n前文说过 Dep 是整个 getter 依赖收集的核心，打开文件在 `src/core/observer/dep.js`\n\n```js\n\n// ...\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    if (process.env.NODE_ENV !== 'production' && !config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort((a, b) => a.id - b.id)\n    }\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n\n```\n\n### watcher<hr>\n\n我们来看一下 Dep 中主要就是对 Watcher 的一种管理，其中 `subs: Array<Watcher>;` 就是订阅者列表,在Watcher 中进行定义\n\n查看 `src/core/observer/watcher.js`\n\n```js\nlet uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  computed: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  dep: Dep;\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;\n  depIds: SimpleSet;\n  newDepIds: SimpleSet;\n  before: ?Function;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.computed = !!options.computed\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.computed = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.computed // for computed watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    if (this.computed) {\n      this.value = undefined\n      this.dep = new Dep()\n    } else {\n      this.value = this.get()\n    }\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n  // ...\n}\n```\n\n### 依赖收集过程<hr>\n\n当我们在 mount 过程中调用 mountComponent 函数的时候实例化了 `new Watcher`, 然后执行了 `this.get()` 方法\n进入 get 函数 会执行 `pushTarget(this)`\n\n打开文件 `src/core/observer/dep.js` \n\n```js\nexport function pushTarget (target: ?Watcher) {\n  targetStack.push(target)\n  Dep.target = target\n}\n```\npushTarget 主要两个作用 \n- 把 Dep.target 赋值为当前的 Watcher\n- 将 target 进行压栈操作\n\n接着执行\n\n```js\nvalue = this.getter.call(vm, vm)\n```\nthis.getter 对应就是 updateComponent 函数，这实际上就是在执行：\n\n```js\nvm._update(vm._render(), hydrating)\n```\n\n它会先执行 vm._render() 方法，生成渲染 VNode，访问 vm 上的数据，这样就触发了数据对象的 getter。\n每个getter 上都有一个 dep ，这样就是调用 dep.depend() 进行依赖收集\n\n```js\naddDep (dep: Dep) {\n  const id = dep.id\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id)\n    this.newDeps.push(dep)\n    if (!this.depIds.has(id)) {\n      dep.addSub(this)\n    }\n  }\n}\n\n```\n\n在保证添加的数据的唯一性 后执行 `dep.addSub(this)`\n\n也就是执行了`this.subs.push(sub)`\n\n通过上面的执行顺序，当前的 watcher 已经订阅到了数据 dep 的 subs 数组中，当数据放生改变在进行 dep.notify\n\n接下来执行递归去访问 value，触发它所有子项的 getter\n\n```js\nif (this.deep) {\n  traverse(value)\n}\n```\n\n之后执行 popTarget(),打开文件 `src/core/observer/dep.js`\n\n```js\nexport function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n\n```\n这个时候 vm 的数据依赖收集已经完成需要将 Dep.target 改变成上一个状态，完成  Dep.target 渲染，最后执行`this.cleanupDeps()` 进行依赖清空\n\n\n```js\ncleanupDeps () {\n  let i = this.deps.length\n  while (i--) {\n    const dep = this.deps[i]\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this)\n    }\n  }\n  let tmp = this.depIds\n  this.depIds = this.newDepIds\n  this.newDepIds = tmp\n  this.newDepIds.clear()\n  tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n  this.newDeps.length = 0\n}\n```\n\n在执行 cleanupDeps 函数，首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空，因为 newDeps 是新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组，所以每次订阅，在subs 中都是最新的，这样就完成了整个依赖收集\n\n\n## 派发更新\n通过 sub 这个数组，当我们修改数据的时候，就可以更新 sub 数组 进行派发更新，下面在进行代码分析这个过程\n### setter 逻辑<hr>\n\n通过 `defineReactive` 函数中，定义响应式的 setter 调用了 `dep.notify()` 来通知所有订阅者，我们要更新了。\n\n```js\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    // ...\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n```\n\n### 派发更新过程<hr>\n\n当我们修改了数据，触发了 setter ，调用 `dep.notify()` ,遍历所有 subs，调用 watcher 的 update 方法\n\n```js\n// src/core/observer/dep.js\nclass Dep {\n  // ...\n  notify () {\n  // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n```\n\n```js\n// src/core/observer/watcher.js\nclass Watcher {\n  // ...\n  update () {\n    /* istanbul ignore else */\n    if (this.computed) {\n      // A computed property watcher has two modes: lazy and activated.\n      // It initializes as lazy by default, and only becomes activated when\n      // it is depended on by at least one subscriber, which is typically\n      // another computed property or a component's render function.\n      if (this.dep.subs.length === 0) {\n        // In lazy mode, we don't want to perform computations until necessary,\n        // so we simply mark the watcher as dirty. The actual computation is\n        // performed just-in-time in this.evaluate() when the computed property\n        // is accessed.\n        this.dirty = true\n      } else {\n        // In activated mode, we want to proactively perform the computation\n        // but only notify our subscribers when the value has indeed changed.\n        this.getAndInvoke(() => {\n          this.dep.notify()\n        })\n      }\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n}  \n```\n\n在进行 update 的时候会根据不同场景去派发更新，computed 与 sync 我们放在后面来说，这两个状态也就是我们的计算属性（computed）和侦听属性（watch），先看一下 queueWatcher \n\n```js\n// src/core/observer/scheduler.js\n\nconst queue: Array<Watcher> = []\nlet has: { [key: number]: ?true } = {}\nlet waiting = false\nlet flushing = false\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n```\n\n用 has 保证在同一个 watcher 只添加一次，并且在派发更新的时候每次数据改变并不会都触发\b watcher ，而是把watcher添加到队列里面通过执行 nextTick，下面来看一下 `flushSchedulerQueue`\n\n```js\n\n// src/core/observer/scheduler.js\n\nlet flushing = false\nlet index = 0\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true\n  let watcher, id\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort((a, b) => a.id - b.id)\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? `in watcher with expression \"${watcher.expression}\"`\n              : `in a component render function.`\n          ),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  const activatedQueue = activatedChildren.slice()\n  const updatedQueue = queue.slice()\n\n  resetSchedulerState()\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue)\n  callUpdatedHooks(updatedQueue)\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush')\n  }\n}\n```\n\n\n首先执行对队列做了从小到大的排序\n\n1. 组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。\n\n2. 用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。\n\n3. 如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。\n\n其次进行队列遍历\n\n拿到对应的 watcher，执行 watcher.run()。如果在遍历的时候，用户有再添加新的 watcher 动作， 那么就在队列中从后往前找，找到第一个没有插入的 watcher 的 id 比当前队列中 watcher 的 id 的大的位置，放到队列中\n\n```js\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // ...\n  }\n}\n```\n\n这样在执行 `watcher.run()` 时候，通过 `this.get()` 就能得到 watcher 当前的值，然后通过判断 新旧值不等、新值是对象类型、deep 模式中的任何一个条件成立都会触发 watcher 回调，传入新的 value 和 旧的 value，这样我们在我们自定义 watcher 的时候就可以在回调函数中拿到两个值。\n\n当我们数据发生改变的时候，触发setter ，因为 watcher 是一个队列，通过调度进行了优化 在 nextTick 后执行所有 `watcher` 的 run 然后触发所有 watcher 的 update 进行进行 patch\n\n### 总结 <hr>\n\n<img src=\"/images/vue-dep.png\">\n\n通过上面几个模块的分析我们基本知道了 vue 的响应式过程，在生成响应对象的时候需要注意的是，vue 更新对象数组必须用他的全局方法也就是 `vue.set,vue.get,vue.del` 等，否则是不会触发setter，导致视图更新失败。\n\n\n","source":"_posts/vue/vueObserve.md","raw":"---\ntitle: vue 原理解析之响应式\ndate: 2019-09-5 16:45:09\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n## 响应式对象\n\n提到 vue 的双向数据绑定原理，我们都知道是利用了 `Object.defineProperty` 给数据添加 getter 和 setter，来进行依赖收集和数据派发更新，首先我们再来熟悉一下这个方法\n\n### Object.defineProperty <hr>\n\nMDN 中写到 `Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象\n\n```js\n\nfunction Person () {}\n\nObject.defineProperty(Person.prototype, 'sayHello', {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return `my name is ${this.name}`\n  },\n  set:function (value) {\n    this.name = value\n  }\n})\nlet p = new Person()\np.name = 'renbo'\nconsole.log(p.sayHello) // my name is renbo\n```\n我们在实现一个极简版双向绑定\n\n```html\n\n<div>请输入:</div>\n<input type=\"text\" id=\"input\">\n<div id=\"content\"></div>\n\n```\n\n```js\n  \nlet obj = {}\n\nObject.definePerperty(obj,'text', {\n\n  get:function () {\n    console.log('获得的值')\n  },\n  set:function (newVal) {\n    console.log('设置的值')\n    document.getElementById('input').value = newVal\n    document.getElementById('content').innerHTML = newVal;\n  }\n})\n\nconst input = document.getElementById('input');\ninput.addEventListener('keyup', function(e){\n  obj.text = e.target.value;\n})\n\n```\n\nset 提供 setter 方法，当我们对 p.name 做修改的时候会触发 setter 方法， 我们访问 sayHello 的时候会触发 getter 方法，取到对应的值，那么一旦对象拥有了 getter 和 setter，就把这个对象变为自动存取的响应对象\n\n### initState <hr>\n\n在 vue _init 阶段我们还执行了 initState(vm) 方法，我们上篇文章写到这个方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作,在 `src/core/instance/state.js 中定义`\n\n```js\nexport function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n\n```\n\n### initProps <hr>\n\n```js\nfunction initProps (vm: Component, propsOptions: Object) {\n  const propsData = vm.$options.propsData || {}\n  const props = vm._props = {}\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false)\n  }\n  for (const key in propsOptions) {\n    keys.push(key)\n    const value = validateProp(key, propsOptions, propsData, vm)\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      const hyphenatedKey = hyphenate(key)\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          `\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`,\n          vm\n        )\n      }\n      defineReactive(props, key, value, () => {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            `Avoid mutating a prop directly since the value will be ` +\n            `overwritten whenever the parent component re-renders. ` +\n            `Instead, use a data or computed property based on the prop's ` +\n            `value. Prop being mutated: \"${key}\"`,\n            vm\n          )\n        }\n      })\n    } else {\n      defineReactive(props, key, value)\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  toggleObserving(true)\n}\n```\n\n从上面代码中我们看到 props 过程，主要就是遍历 propsOptions ，调用 defineReactive 方法和 proxy，但是上面在开发环境中调用 defineReactive 给一个警告，平时我们通过 props 方法来接受父组件所传过来的值，但是这个过程是单项的，父组件可以改变传给子组件的值，但是如果子组件想改变所接受的值并传给父组件是不可以的，会收到这个警告\n\n这个错误告诉我们避免去直接更改 props 因为当父组件重新渲染时，该值就会被覆盖。这个时候就需要用到计算属性或者侦听属性了。\n\ndefineReactive 方法和 proxy 具体作用我们在后面介绍。\n\n### initData<hr>\n\n```js\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */)\n}\n```\n\ninitData 主要是遍历data，取到对应的key 调用 proxy ；另一个是调用 observe 方法\n\n### proxy<hr>\n\n平时我们写 vue 的时候我们可以直接在方法中访问 props 和 data，看下面例子\n\n```js\n\nprops: {\n  name: {\n    type: String,\n    default () {\n      return 'renbo'\n    }\n  }\n},\ndata:{\n  return {\n     age: 26\n  }\n},\nmethods: {\n  sayHello () {\n    console.log(this.name, this.age)\n  }\n}\n```\n\n这就是通过 proxy 将 props 和 data 上的属性代理到 vm 实例上，所以我们可以直接通过 this 访问到\n\n那么我们看看 proxy 是如何定义的呢\n\n```js\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n通过 Object.defineProperty 把 target[sourceKey][key] 的读写变成了对 target[key] 的读写，所以对于 props 和 data 而言就是\n\n```js\nvm._props.xxx -> vm.xxx\nvm._data.xxx -> vm.xxx\n```\n\n### observe<hr>\n\n上面在 initData中调用了 observe 函数，进入文件 `src/core/observer/index.js` 中\n\n```js\n**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob: Observer | void\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n    ob.vmCount++\n  }\n  return ob\n}\n```\n\nobserve 就是给除了 vnode 的对象类型的数据添加一个观察者实例\n\n如果已经添加过则直接返回，否则在满足一定条件下去 new Observer\n\n接下来我们来看一下 Observer 的作用\n\n```js\nexport class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that have this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n\n```\n\nObserver 是一个构造函数\n- 在constructor 中实例化了 Dep 对象\n- 执行了 `def(value, '__ob__', this)`\n- 对 value 进行判断，如果是数组调用 observeArray，如果是纯对象调用 walk \n- observeArray 方法中遍历数组再次调用 observer，而 walk 遍历对象的 key 调用 defineReactive\n\nDep 主要的作用就是进行依赖收集，是整个 getter 的核心，在后面会介绍，def 函数是通过 Object.defineProperty 的封装的，作用是将自身实例添加到数据对象 value 的 `__ob__` 属性上，这样我们在开发中就会看到 data 上对象类型的数据多了一个 `__ob__ `的属性\n\n### defineReactive<hr> \n\ndefineReactive 的作用就是定义一个响应式对象，给对象动态添加 getter 和 setter\n\n```js\n\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n\n```\n\ndefineReactive 函数\n\n-  new Dep()\n-  通过 Object.getOwnPropertyDescriptor 拿到 obj 的属性描述符\n-  对子对象递归调用 observe 方法，把所有子属性变成响应式对象\n-  利用 Object.defineProperty 给 obj 的属性 key 添加 getter 和 setter\n\n\n下面我们通过上面的逻辑步骤整理下面一张图\n\n<img src=\"/images/vue-observer.png\" />\n\n通过上面的逻辑和总结发现响应式对象的核心其实就是利用 Object.defineProperty 给数据添加了 getter 和 setter，来进行依赖收集`dep.depend()` 和派发更新 `dep.notify()`\n\n## 依赖收集\n\n通过响应式对象我们知道在 defineReactive 函数内的 Object.defineProperty 定义的 get 内部实例了 Dep\n\n### dep<hr>\n\n```js\nconst dep = new Dep()\ndep.depend()\n```\n\n前文说过 Dep 是整个 getter 依赖收集的核心，打开文件在 `src/core/observer/dep.js`\n\n```js\n\n// ...\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    if (process.env.NODE_ENV !== 'production' && !config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort((a, b) => a.id - b.id)\n    }\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n\n```\n\n### watcher<hr>\n\n我们来看一下 Dep 中主要就是对 Watcher 的一种管理，其中 `subs: Array<Watcher>;` 就是订阅者列表,在Watcher 中进行定义\n\n查看 `src/core/observer/watcher.js`\n\n```js\nlet uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  computed: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  dep: Dep;\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;\n  depIds: SimpleSet;\n  newDepIds: SimpleSet;\n  before: ?Function;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.computed = !!options.computed\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.computed = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.computed // for computed watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    if (this.computed) {\n      this.value = undefined\n      this.dep = new Dep()\n    } else {\n      this.value = this.get()\n    }\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n  // ...\n}\n```\n\n### 依赖收集过程<hr>\n\n当我们在 mount 过程中调用 mountComponent 函数的时候实例化了 `new Watcher`, 然后执行了 `this.get()` 方法\n进入 get 函数 会执行 `pushTarget(this)`\n\n打开文件 `src/core/observer/dep.js` \n\n```js\nexport function pushTarget (target: ?Watcher) {\n  targetStack.push(target)\n  Dep.target = target\n}\n```\npushTarget 主要两个作用 \n- 把 Dep.target 赋值为当前的 Watcher\n- 将 target 进行压栈操作\n\n接着执行\n\n```js\nvalue = this.getter.call(vm, vm)\n```\nthis.getter 对应就是 updateComponent 函数，这实际上就是在执行：\n\n```js\nvm._update(vm._render(), hydrating)\n```\n\n它会先执行 vm._render() 方法，生成渲染 VNode，访问 vm 上的数据，这样就触发了数据对象的 getter。\n每个getter 上都有一个 dep ，这样就是调用 dep.depend() 进行依赖收集\n\n```js\naddDep (dep: Dep) {\n  const id = dep.id\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id)\n    this.newDeps.push(dep)\n    if (!this.depIds.has(id)) {\n      dep.addSub(this)\n    }\n  }\n}\n\n```\n\n在保证添加的数据的唯一性 后执行 `dep.addSub(this)`\n\n也就是执行了`this.subs.push(sub)`\n\n通过上面的执行顺序，当前的 watcher 已经订阅到了数据 dep 的 subs 数组中，当数据放生改变在进行 dep.notify\n\n接下来执行递归去访问 value，触发它所有子项的 getter\n\n```js\nif (this.deep) {\n  traverse(value)\n}\n```\n\n之后执行 popTarget(),打开文件 `src/core/observer/dep.js`\n\n```js\nexport function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n\n```\n这个时候 vm 的数据依赖收集已经完成需要将 Dep.target 改变成上一个状态，完成  Dep.target 渲染，最后执行`this.cleanupDeps()` 进行依赖清空\n\n\n```js\ncleanupDeps () {\n  let i = this.deps.length\n  while (i--) {\n    const dep = this.deps[i]\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this)\n    }\n  }\n  let tmp = this.depIds\n  this.depIds = this.newDepIds\n  this.newDepIds = tmp\n  this.newDepIds.clear()\n  tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n  this.newDeps.length = 0\n}\n```\n\n在执行 cleanupDeps 函数，首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空，因为 newDeps 是新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组，所以每次订阅，在subs 中都是最新的，这样就完成了整个依赖收集\n\n\n## 派发更新\n通过 sub 这个数组，当我们修改数据的时候，就可以更新 sub 数组 进行派发更新，下面在进行代码分析这个过程\n### setter 逻辑<hr>\n\n通过 `defineReactive` 函数中，定义响应式的 setter 调用了 `dep.notify()` 来通知所有订阅者，我们要更新了。\n\n```js\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    // ...\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n```\n\n### 派发更新过程<hr>\n\n当我们修改了数据，触发了 setter ，调用 `dep.notify()` ,遍历所有 subs，调用 watcher 的 update 方法\n\n```js\n// src/core/observer/dep.js\nclass Dep {\n  // ...\n  notify () {\n  // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n```\n\n```js\n// src/core/observer/watcher.js\nclass Watcher {\n  // ...\n  update () {\n    /* istanbul ignore else */\n    if (this.computed) {\n      // A computed property watcher has two modes: lazy and activated.\n      // It initializes as lazy by default, and only becomes activated when\n      // it is depended on by at least one subscriber, which is typically\n      // another computed property or a component's render function.\n      if (this.dep.subs.length === 0) {\n        // In lazy mode, we don't want to perform computations until necessary,\n        // so we simply mark the watcher as dirty. The actual computation is\n        // performed just-in-time in this.evaluate() when the computed property\n        // is accessed.\n        this.dirty = true\n      } else {\n        // In activated mode, we want to proactively perform the computation\n        // but only notify our subscribers when the value has indeed changed.\n        this.getAndInvoke(() => {\n          this.dep.notify()\n        })\n      }\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n}  \n```\n\n在进行 update 的时候会根据不同场景去派发更新，computed 与 sync 我们放在后面来说，这两个状态也就是我们的计算属性（computed）和侦听属性（watch），先看一下 queueWatcher \n\n```js\n// src/core/observer/scheduler.js\n\nconst queue: Array<Watcher> = []\nlet has: { [key: number]: ?true } = {}\nlet waiting = false\nlet flushing = false\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n```\n\n用 has 保证在同一个 watcher 只添加一次，并且在派发更新的时候每次数据改变并不会都触发\b watcher ，而是把watcher添加到队列里面通过执行 nextTick，下面来看一下 `flushSchedulerQueue`\n\n```js\n\n// src/core/observer/scheduler.js\n\nlet flushing = false\nlet index = 0\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true\n  let watcher, id\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort((a, b) => a.id - b.id)\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? `in watcher with expression \"${watcher.expression}\"`\n              : `in a component render function.`\n          ),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  const activatedQueue = activatedChildren.slice()\n  const updatedQueue = queue.slice()\n\n  resetSchedulerState()\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue)\n  callUpdatedHooks(updatedQueue)\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush')\n  }\n}\n```\n\n\n首先执行对队列做了从小到大的排序\n\n1. 组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。\n\n2. 用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。\n\n3. 如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。\n\n其次进行队列遍历\n\n拿到对应的 watcher，执行 watcher.run()。如果在遍历的时候，用户有再添加新的 watcher 动作， 那么就在队列中从后往前找，找到第一个没有插入的 watcher 的 id 比当前队列中 watcher 的 id 的大的位置，放到队列中\n\n```js\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // ...\n  }\n}\n```\n\n这样在执行 `watcher.run()` 时候，通过 `this.get()` 就能得到 watcher 当前的值，然后通过判断 新旧值不等、新值是对象类型、deep 模式中的任何一个条件成立都会触发 watcher 回调，传入新的 value 和 旧的 value，这样我们在我们自定义 watcher 的时候就可以在回调函数中拿到两个值。\n\n当我们数据发生改变的时候，触发setter ，因为 watcher 是一个队列，通过调度进行了优化 在 nextTick 后执行所有 `watcher` 的 run 然后触发所有 watcher 的 update 进行进行 patch\n\n### 总结 <hr>\n\n<img src=\"/images/vue-dep.png\">\n\n通过上面几个模块的分析我们基本知道了 vue 的响应式过程，在生成响应对象的时候需要注意的是，vue 更新对象数组必须用他的全局方法也就是 `vue.set,vue.get,vue.del` 等，否则是不会触发setter，导致视图更新失败。\n\n\n","slug":"vue/vueObserve","published":1,"updated":"2019-10-15T01:29:42.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ox2009qb0u6rv67qi18","content":"<h2 id=\"响应式对象\"><a href=\"#响应式对象\" class=\"headerlink\" title=\"响应式对象\"></a>响应式对象</h2><p>提到 vue 的双向数据绑定原理，我们都知道是利用了 <code>Object.defineProperty</code> 给数据添加 getter 和 setter，来进行依赖收集和数据派发更新，首先我们再来熟悉一下这个方法</p>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty \"></a>Object.defineProperty <hr></h3><p>MDN 中写到 <code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">function</span> Person <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token string\">'sayHello'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  configurable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token string\">`my name is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> value\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'renbo'</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>sayHello<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// my name is renbo</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们在实现一个极简版双向绑定</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\">\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>请输入:<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>input<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>content<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">definePerperty</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span><span class=\"token string\">'text'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'获得的值'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'设置的值'</span><span class=\"token punctuation\">)</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> newVal\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> newVal<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> input <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninput<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keyup'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  obj<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>set 提供 setter 方法，当我们对 p.name 做修改的时候会触发 setter 方法， 我们访问 sayHello 的时候会触发 getter 方法，取到对应的值，那么一旦对象拥有了 getter 和 setter，就把这个对象变为自动存取的响应对象</p>\n<h3 id=\"initState\"><a href=\"#initState\" class=\"headerlink\" title=\"initState \"></a>initState <hr></h3><p>在 vue _init 阶段我们还执行了 initState(vm) 方法，我们上篇文章写到这个方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作,在 <code>src/core/instance/state.js 中定义</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initState <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  vm<span class=\"token punctuation\">.</span>_watchers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> opts <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span> <span class=\"token function\">initProps</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>methods<span class=\"token punctuation\">)</span> <span class=\"token function\">initMethods</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>methods<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">initData</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_data <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* asRootData */</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span> <span class=\"token function\">initComputed</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>watch <span class=\"token operator\">&amp;&amp;</span> opts<span class=\"token punctuation\">.</span>watch <span class=\"token operator\">!==</span> nativeWatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">initWatch</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"initProps\"><a href=\"#initProps\" class=\"headerlink\" title=\"initProps \"></a>initProps <hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> initProps <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span> propsOptions<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> propsData <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>propsData <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// cache prop keys so that future props updates can iterate using Array</span>\n  <span class=\"token comment\" spellcheck=\"true\">// instead of dynamic object key enumeration.</span>\n  <span class=\"token keyword\">const</span> keys <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>_propKeys <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> isRoot <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>$parent\n  <span class=\"token comment\" spellcheck=\"true\">// root instance props should be converted</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isRoot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">toggleObserving</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> propsOptions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    keys<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token function\">validateProp</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> propsOptions<span class=\"token punctuation\">,</span> propsData<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore else */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> hyphenatedKey <span class=\"token operator\">=</span> <span class=\"token function\">hyphenate</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isReservedAttribute</span><span class=\"token punctuation\">(</span>hyphenatedKey<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n          config<span class=\"token punctuation\">.</span><span class=\"token function\">isReservedAttr</span><span class=\"token punctuation\">(</span>hyphenatedKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token template-string\"><span class=\"token string\">`\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>hyphenatedKey<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" is a reserved attribute and cannot be used as component prop.`</span></span><span class=\"token punctuation\">,</span>\n          vm\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">defineReactive</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isRoot <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>isUpdatingChildComponent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n            <span class=\"token template-string\"><span class=\"token string\">`Avoid mutating a prop directly since the value will be `</span></span> <span class=\"token operator\">+</span>\n            <span class=\"token template-string\"><span class=\"token string\">`overwritten whenever the parent component re-renders. `</span></span> <span class=\"token operator\">+</span>\n            <span class=\"token template-string\"><span class=\"token string\">`Instead, use a data or computed property based on the prop's `</span></span> <span class=\"token operator\">+</span>\n            <span class=\"token template-string\"><span class=\"token string\">`value. Prop being mutated: \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"`</span></span><span class=\"token punctuation\">,</span>\n            vm\n          <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">defineReactive</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// static props are already proxied on the component's prototype</span>\n    <span class=\"token comment\" spellcheck=\"true\">// during Vue.extend(). We only need to proxy props defined at</span>\n    <span class=\"token comment\" spellcheck=\"true\">// instantiation here.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">in</span> vm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">proxy</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`_props`</span></span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">toggleObserving</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从上面代码中我们看到 props 过程，主要就是遍历 propsOptions ，调用 defineReactive 方法和 proxy，但是上面在开发环境中调用 defineReactive 给一个警告，平时我们通过 props 方法来接受父组件所传过来的值，但是这个过程是单项的，父组件可以改变传给子组件的值，但是如果子组件想改变所接受的值并传给父组件是不可以的，会收到这个警告</p>\n<p>这个错误告诉我们避免去直接更改 props 因为当父组件重新渲染时，该值就会被覆盖。这个时候就需要用到计算属性或者侦听属性了。</p>\n<p>defineReactive 方法和 proxy 具体作用我们在后面介绍。</p>\n<h3 id=\"initData\"><a href=\"#initData\" class=\"headerlink\" title=\"initData\"></a>initData<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> initData <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>data\n  data <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_data <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> data <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span>\n    <span class=\"token operator\">?</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">:</span> data <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isPlainObject</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    data <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'data functions should return an object:\\n'</span> <span class=\"token operator\">+</span>\n      <span class=\"token string\">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span class=\"token punctuation\">,</span>\n      vm\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// proxy data on instance</span>\n  <span class=\"token keyword\">const</span> keys <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>props\n  <span class=\"token keyword\">const</span> methods <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>methods\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> keys<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>methods <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">hasOwn</span><span class=\"token punctuation\">(</span>methods<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token template-string\"><span class=\"token string\">`Method \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" has already been defined as a data property.`</span></span><span class=\"token punctuation\">,</span>\n          vm\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>props <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">hasOwn</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n        <span class=\"token template-string\"><span class=\"token string\">`The data property \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" is already declared as a prop. `</span></span> <span class=\"token operator\">+</span>\n        <span class=\"token template-string\"><span class=\"token string\">`Use prop default value instead.`</span></span><span class=\"token punctuation\">,</span>\n        vm\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isReserved</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">proxy</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`_data`</span></span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// observe data</span>\n  <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* asRootData */</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>initData 主要是遍历data，取到对应的key 调用 proxy ；另一个是调用 observe 方法</p>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy<hr></h3><p>平时我们写 vue 的时候我们可以直接在方法中访问 props 和 data，看下面例子</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\nprops<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">default</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">'renbo'</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\ndata<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n     age<span class=\"token punctuation\">:</span> <span class=\"token number\">26</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\nmethods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  sayHello <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这就是通过 proxy 将 props 和 data 上的属性代理到 vm 实例上，所以我们可以直接通过 this 访问到</p>\n<p>那么我们看看 proxy 是如何定义的呢</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> proxy <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">,</span> sourceKey<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  sharedPropertyDefinition<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> proxyGetter <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>sourceKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n  sharedPropertyDefinition<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> proxySetter <span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>sourceKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> val\n  <span class=\"token punctuation\">}</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> sharedPropertyDefinition<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过 Object.defineProperty 把 target[sourceKey][key] 的读写变成了对 target[key] 的读写，所以对于 props 和 data 而言就是</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">vm<span class=\"token punctuation\">.</span>_props<span class=\"token punctuation\">.</span>xxx <span class=\"token operator\">-</span><span class=\"token operator\">></span> vm<span class=\"token punctuation\">.</span>xxx\nvm<span class=\"token punctuation\">.</span>_data<span class=\"token punctuation\">.</span>xxx <span class=\"token operator\">-</span><span class=\"token operator\">></span> vm<span class=\"token punctuation\">.</span>xxx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"observe\"><a href=\"#observe\" class=\"headerlink\" title=\"observe\"></a>observe<hr></h3><p>上面在 initData中调用了 observe 函数，进入文件 <code>src/core/observer/index.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">**</span>\n <span class=\"token operator\">*</span> Attempt to create an observer instance <span class=\"token keyword\">for</span> a value<span class=\"token punctuation\">,</span>\n <span class=\"token operator\">*</span> returns the <span class=\"token keyword\">new</span> <span class=\"token class-name\">observer</span> <span class=\"token keyword\">if</span> successfully observed<span class=\"token punctuation\">,</span>\n <span class=\"token operator\">*</span> or the existing observer <span class=\"token keyword\">if</span> the value already has one<span class=\"token punctuation\">.</span>\n <span class=\"token operator\">*</span><span class=\"token operator\">/</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> observe <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span> asRootData<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>boolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Observer <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isObject</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> value <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">VNode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> ob<span class=\"token punctuation\">:</span> Observer <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasOwn</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> <span class=\"token string\">'__ob__'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> value<span class=\"token punctuation\">.</span>__ob__ <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Observer</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ob <span class=\"token operator\">=</span> value<span class=\"token punctuation\">.</span>__ob__\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    shouldObserve <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span><span class=\"token function\">isServerRendering</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">isPlainObject</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span>value<span class=\"token punctuation\">.</span>_isVue\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ob <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Observer</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>asRootData <span class=\"token operator\">&amp;&amp;</span> ob<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ob<span class=\"token punctuation\">.</span>vmCount<span class=\"token operator\">++</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> ob\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>observe 就是给除了 vnode 的对象类型的数据添加一个观察者实例</p>\n<p>如果已经添加过则直接返回，否则在满足一定条件下去 new Observer</p>\n<p>接下来我们来看一下 Observer 的作用</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Observer</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">;</span>\n  dep<span class=\"token punctuation\">:</span> Dep<span class=\"token punctuation\">;</span>\n  vmCount<span class=\"token punctuation\">:</span> number<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// number of vms that have this object as root $data</span>\n\n  constructor <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>vmCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token function\">def</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> <span class=\"token string\">'__ob__'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasProto<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">protoAugment</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> arrayMethods<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">copyAugment</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> arrayMethods<span class=\"token punctuation\">,</span> arrayKeys<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">observeArray</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">walk</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */</span>\n  walk <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> keys <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> keys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">defineReactive</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> keys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Observe a list of Array items.\n   */</span>\n  observeArray <span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Observer 是一个构造函数</p>\n<ul>\n<li>在constructor 中实例化了 Dep 对象</li>\n<li>执行了 <code>def(value, &#39;__ob__&#39;, this)</code></li>\n<li>对 value 进行判断，如果是数组调用 observeArray，如果是纯对象调用 walk </li>\n<li>observeArray 方法中遍历数组再次调用 observer，而 walk 遍历对象的 key 调用 defineReactive</li>\n</ul>\n<p>Dep 主要的作用就是进行依赖收集，是整个 getter 的核心，在后面会介绍，def 函数是通过 Object.defineProperty 的封装的，作用是将自身实例添加到数据对象 value 的 <code>__ob__</code> 属性上，这样我们在开发中就会看到 data 上对象类型的数据多了一个 <code>__ob__</code>的属性</p>\n<h3 id=\"defineReactive\"><a href=\"#defineReactive\" class=\"headerlink\" title=\"defineReactive\"></a>defineReactive<hr></h3><p>defineReactive 的作用就是定义一个响应式对象，给对象动态添加 getter 和 setter</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Define a reactive property on an Object.\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> defineReactive <span class=\"token punctuation\">(</span>\n  obj<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">,</span>\n  key<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  val<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  customSetter<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Function<span class=\"token punctuation\">,</span>\n  shallow<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> property <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>property <span class=\"token operator\">&amp;&amp;</span> property<span class=\"token punctuation\">.</span>configurable <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// cater for pre-defined getter/setters</span>\n  <span class=\"token keyword\">const</span> getter <span class=\"token operator\">=</span> property <span class=\"token operator\">&amp;&amp;</span> property<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span>\n  <span class=\"token keyword\">const</span> setter <span class=\"token operator\">=</span> property <span class=\"token operator\">&amp;&amp;</span> property<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>getter <span class=\"token operator\">||</span> setter<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    val <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">let</span> childOb <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>shallow <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    configurable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> reactiveGetter <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> getter <span class=\"token operator\">?</span> getter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> val\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Dep<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        dep<span class=\"token punctuation\">.</span><span class=\"token function\">depend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childOb<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          childOb<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">.</span><span class=\"token function\">depend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">dependArray</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> value\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> reactiveSetter <span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> getter <span class=\"token operator\">?</span> getter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> val\n      <span class=\"token comment\" spellcheck=\"true\">/* eslint-disable no-self-compare */</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newVal <span class=\"token operator\">===</span> value <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>newVal <span class=\"token operator\">!==</span> newVal <span class=\"token operator\">&amp;&amp;</span> value <span class=\"token operator\">!==</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">/* eslint-enable no-self-compare */</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> customSetter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">customSetter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// #7981: for accessor properties without setter</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>getter <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>setter<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>setter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        setter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> newVal<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        val <span class=\"token operator\">=</span> newVal\n      <span class=\"token punctuation\">}</span>\n      childOb <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>shallow <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span>\n      dep<span class=\"token punctuation\">.</span><span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>defineReactive 函数</p>\n<ul>\n<li>new Dep()</li>\n<li>通过 Object.getOwnPropertyDescriptor 拿到 obj 的属性描述符</li>\n<li>对子对象递归调用 observe 方法，把所有子属性变成响应式对象</li>\n<li>利用 Object.defineProperty 给 obj 的属性 key 添加 getter 和 setter</li>\n</ul>\n<p>下面我们通过上面的逻辑步骤整理下面一张图</p>\n<img src=\"/images/vue-observer.png\">\n\n<p>通过上面的逻辑和总结发现响应式对象的核心其实就是利用 Object.defineProperty 给数据添加了 getter 和 setter，来进行依赖收集<code>dep.depend()</code> 和派发更新 <code>dep.notify()</code></p>\n<h2 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h2><p>通过响应式对象我们知道在 defineReactive 函数内的 Object.defineProperty 定义的 get 内部实例了 Dep</p>\n<h3 id=\"dep\"><a href=\"#dep\" class=\"headerlink\" title=\"dep\"></a>dep<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ndep<span class=\"token punctuation\">.</span><span class=\"token function\">depend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>前文说过 Dep 是整个 getter 依赖收集的核心，打开文件在 <code>src/core/observer/dep.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Dep</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> target<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Watcher<span class=\"token punctuation\">;</span>\n  id<span class=\"token punctuation\">:</span> number<span class=\"token punctuation\">;</span>\n  subs<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>Watcher<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n  constructor <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> uid<span class=\"token operator\">++</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n\n  addSub <span class=\"token punctuation\">(</span>sub<span class=\"token punctuation\">:</span> Watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>sub<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  removeSub <span class=\"token punctuation\">(</span>sub<span class=\"token punctuation\">:</span> Watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">,</span> sub<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  depend <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Dep<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Dep<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">addDep</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  notify <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// stabilize the subscriber list first</span>\n    <span class=\"token keyword\">const</span> subs <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>config<span class=\"token punctuation\">.</span><span class=\"token keyword\">async</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// subs aren't sorted in scheduler if not running async</span>\n      <span class=\"token comment\" spellcheck=\"true\">// we need to sort them now to make sure they fire in correct</span>\n      <span class=\"token comment\" spellcheck=\"true\">// order</span>\n      subs<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">.</span>id <span class=\"token operator\">-</span> b<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> subs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      subs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// the current target watcher being evaluated.</span>\n<span class=\"token comment\" spellcheck=\"true\">// this is globally unique because there could be only one</span>\n<span class=\"token comment\" spellcheck=\"true\">// watcher being evaluated at any time.</span>\nDep<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"token keyword\">const</span> targetStack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> pushTarget <span class=\"token punctuation\">(</span>_target<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Dep<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span> targetStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Dep<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span>\n  Dep<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> _target\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> popTarget <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Dep<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> targetStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"watcher\"><a href=\"#watcher\" class=\"headerlink\" title=\"watcher\"></a>watcher<hr></h3><p>我们来看一下 Dep 中主要就是对 Watcher 的一种管理，其中 <code>subs: Array&lt;Watcher&gt;;</code> 就是订阅者列表,在Watcher 中进行定义</p>\n<p>查看 <code>src/core/observer/watcher.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> uid <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Watcher</span> <span class=\"token punctuation\">{</span>\n  vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">;</span>\n  expression<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">;</span>\n  cb<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">;</span>\n  id<span class=\"token punctuation\">:</span> number<span class=\"token punctuation\">;</span>\n  deep<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">;</span>\n  user<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">;</span>\n  computed<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">;</span>\n  sync<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">;</span>\n  dirty<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">;</span>\n  active<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">;</span>\n  dep<span class=\"token punctuation\">:</span> Dep<span class=\"token punctuation\">;</span>\n  deps<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>Dep<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  newDeps<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>Dep<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  depIds<span class=\"token punctuation\">:</span> SimpleSet<span class=\"token punctuation\">;</span>\n  newDepIds<span class=\"token punctuation\">:</span> SimpleSet<span class=\"token punctuation\">;</span>\n  before<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Function<span class=\"token punctuation\">;</span>\n  getter<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">;</span>\n  value<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">;</span>\n\n  constructor <span class=\"token punctuation\">(</span>\n    vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n    expOrFn<span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Function<span class=\"token punctuation\">,</span>\n    cb<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span>\n    options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Object<span class=\"token punctuation\">,</span>\n    isRenderWatcher<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>vm <span class=\"token operator\">=</span> vm\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isRenderWatcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>_watcher <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token punctuation\">}</span>\n    vm<span class=\"token punctuation\">.</span>_watchers<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// options</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>deep\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>user\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>computed <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>computed\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sync <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>sync\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>before <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>before\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>computed <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sync <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>cb <span class=\"token operator\">=</span> cb\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>uid <span class=\"token comment\" spellcheck=\"true\">// uid for batching</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>active <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>computed <span class=\"token comment\" spellcheck=\"true\">// for computed watchers</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>expression <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span>\n      <span class=\"token operator\">?</span> expOrFn<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>\n    <span class=\"token comment\" spellcheck=\"true\">// parse expression for getter</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> expOrFn <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter <span class=\"token operator\">=</span> expOrFn\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter <span class=\"token operator\">=</span> <span class=\"token function\">parsePath</span><span class=\"token punctuation\">(</span>expOrFn<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token template-string\"><span class=\"token string\">`Failed watching path: \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>expOrFn<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\" `</span></span> <span class=\"token operator\">+</span>\n          <span class=\"token string\">'Watcher only accepts simple dot-delimited paths. '</span> <span class=\"token operator\">+</span>\n          <span class=\"token string\">'For full control, use a function instead.'</span><span class=\"token punctuation\">,</span>\n          vm\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> undefined\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Evaluate the getter, and re-collect dependencies.\n   */</span>\n  <span class=\"token keyword\">get</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">pushTarget</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">let</span> value\n    <span class=\"token keyword\">const</span> vm <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>vm\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">handleError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`getter for watcher \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>expression<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"`</span></span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> e\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// \"touch\" every property so they are all tracked as</span>\n      <span class=\"token comment\" spellcheck=\"true\">// dependencies for deep watching</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">popTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">cleanupDeps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> value\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Add a dependency to this directive.\n   */</span>\n  addDep <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">:</span> Dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> dep<span class=\"token punctuation\">.</span>id\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        dep<span class=\"token punctuation\">.</span><span class=\"token function\">addSub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/**\n   * Clean up for dependency collection.\n   */</span>\n  cleanupDeps <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">.</span>length\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        dep<span class=\"token punctuation\">.</span><span class=\"token function\">removeSub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds <span class=\"token operator\">=</span> tmp\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps <span class=\"token operator\">=</span> tmp\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"依赖收集过程\"><a href=\"#依赖收集过程\" class=\"headerlink\" title=\"依赖收集过程\"></a>依赖收集过程<hr></h3><p>当我们在 mount 过程中调用 mountComponent 函数的时候实例化了 <code>new Watcher</code>, 然后执行了 <code>this.get()</code> 方法<br>进入 get 函数 会执行 <code>pushTarget(this)</code></p>\n<p>打开文件 <code>src/core/observer/dep.js</code> </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> pushTarget <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  targetStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span>\n  Dep<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> target\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>pushTarget 主要两个作用 </p>\n<ul>\n<li>把 Dep.target 赋值为当前的 Watcher</li>\n<li>将 target 进行压栈操作</li>\n</ul>\n<p>接着执行</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>getter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>this.getter 对应就是 updateComponent 函数，这实际上就是在执行：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">vm<span class=\"token punctuation\">.</span><span class=\"token function\">_update</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">_render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>它会先执行 vm._render() 方法，生成渲染 VNode，访问 vm 上的数据，这样就触发了数据对象的 getter。<br>每个getter 上都有一个 dep ，这样就是调用 dep.depend() 进行依赖收集</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">addDep <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">:</span> Dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> dep<span class=\"token punctuation\">.</span>id\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      dep<span class=\"token punctuation\">.</span><span class=\"token function\">addSub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在保证添加的数据的唯一性 后执行 <code>dep.addSub(this)</code></p>\n<p>也就是执行了<code>this.subs.push(sub)</code></p>\n<p>通过上面的执行顺序，当前的 watcher 已经订阅到了数据 dep 的 subs 数组中，当数据放生改变在进行 dep.notify</p>\n<p>接下来执行递归去访问 value，触发它所有子项的 getter</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">traverse</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>之后执行 popTarget(),打开文件 <code>src/core/observer/dep.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> popTarget <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  targetStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  Dep<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> targetStack<span class=\"token punctuation\">[</span>targetStack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个时候 vm 的数据依赖收集已经完成需要将 Dep.target 改变成上一个状态，完成  Dep.target 渲染，最后执行<code>this.cleanupDeps()</code> 进行依赖清空</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">cleanupDeps <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      dep<span class=\"token punctuation\">.</span><span class=\"token function\">removeSub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>depIds <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds <span class=\"token operator\">=</span> tmp\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDepIds<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>deps <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps <span class=\"token operator\">=</span> tmp\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>newDeps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在执行 cleanupDeps 函数，首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空，因为 newDeps 是新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组，所以每次订阅，在subs 中都是最新的，这样就完成了整个依赖收集</p>\n<h2 id=\"派发更新\"><a href=\"#派发更新\" class=\"headerlink\" title=\"派发更新\"></a>派发更新</h2><p>通过 sub 这个数组，当我们修改数据的时候，就可以更新 sub 数组 进行派发更新，下面在进行代码分析这个过程</p>\n<h3 id=\"setter-逻辑\"><a href=\"#setter-逻辑\" class=\"headerlink\" title=\"setter 逻辑\"></a>setter 逻辑<hr></h3><p>通过 <code>defineReactive</code> 函数中，定义响应式的 setter 调用了 <code>dep.notify()</code> 来通知所有订阅者，我们要更新了。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> defineReactive <span class=\"token punctuation\">(</span>\n  obj<span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">,</span>\n  key<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  val<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  customSetter<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Function<span class=\"token punctuation\">,</span>\n  shallow<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> property <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>property <span class=\"token operator\">&amp;&amp;</span> property<span class=\"token punctuation\">.</span>configurable <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// cater for pre-defined getter/setters</span>\n  <span class=\"token keyword\">const</span> getter <span class=\"token operator\">=</span> property <span class=\"token operator\">&amp;&amp;</span> property<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span>\n  <span class=\"token keyword\">const</span> setter <span class=\"token operator\">=</span> property <span class=\"token operator\">&amp;&amp;</span> property<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>getter <span class=\"token operator\">||</span> setter<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    val <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">let</span> childOb <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>shallow <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    configurable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> reactiveSetter <span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> getter <span class=\"token operator\">?</span> getter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> val\n      <span class=\"token comment\" spellcheck=\"true\">/* eslint-disable no-self-compare */</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newVal <span class=\"token operator\">===</span> value <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>newVal <span class=\"token operator\">!==</span> newVal <span class=\"token operator\">&amp;&amp;</span> value <span class=\"token operator\">!==</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">/* eslint-enable no-self-compare */</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> customSetter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">customSetter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>setter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        setter<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> newVal<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        val <span class=\"token operator\">=</span> newVal\n      <span class=\"token punctuation\">}</span>\n      childOb <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>shallow <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span>\n      dep<span class=\"token punctuation\">.</span><span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"派发更新过程\"><a href=\"#派发更新过程\" class=\"headerlink\" title=\"派发更新过程\"></a>派发更新过程<hr></h3><p>当我们修改了数据，触发了 setter ，调用 <code>dep.notify()</code> ,遍历所有 subs，调用 watcher 的 update 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// src/core/observer/dep.js</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Dep</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  notify <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// stabilize the subscriber list first</span>\n    <span class=\"token keyword\">const</span> subs <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> subs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      subs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// src/core/observer/watcher.js</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Watcher</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  update <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore else */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// A computed property watcher has two modes: lazy and activated.</span>\n      <span class=\"token comment\" spellcheck=\"true\">// It initializes as lazy by default, and only becomes activated when</span>\n      <span class=\"token comment\" spellcheck=\"true\">// it is depended on by at least one subscriber, which is typically</span>\n      <span class=\"token comment\" spellcheck=\"true\">// another computed property or a component's render function.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// In lazy mode, we don't want to perform computations until necessary,</span>\n        <span class=\"token comment\" spellcheck=\"true\">// so we simply mark the watcher as dirty. The actual computation is</span>\n        <span class=\"token comment\" spellcheck=\"true\">// performed just-in-time in this.evaluate() when the computed property</span>\n        <span class=\"token comment\" spellcheck=\"true\">// is accessed.</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// In activated mode, we want to proactively perform the computation</span>\n        <span class=\"token comment\" spellcheck=\"true\">// but only notify our subscribers when the value has indeed changed.</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAndInvoke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">.</span><span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">queueWatcher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在进行 update 的时候会根据不同场景去派发更新，computed 与 sync 我们放在后面来说，这两个状态也就是我们的计算属性（computed）和侦听属性（watch），先看一下 queueWatcher </p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// src/core/observer/scheduler.js</span>\n\n<span class=\"token keyword\">const</span> queue<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>Watcher<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">let</span> has<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">:</span> number<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span><span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> waiting <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token keyword\">let</span> flushing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> queueWatcher <span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">:</span> Watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> watcher<span class=\"token punctuation\">.</span>id\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>has<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    has<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flushing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// if already flushing, splice the watcher based on its id</span>\n      <span class=\"token comment\" spellcheck=\"true\">// if already past its id, it will be run next immediately.</span>\n      <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> index <span class=\"token operator\">&amp;&amp;</span> queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">></span> watcher<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        i<span class=\"token operator\">--</span>\n      <span class=\"token punctuation\">}</span>\n      queue<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> watcher<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// queue the flush</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>waiting<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      waiting <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>flushSchedulerQueue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>用 has 保证在同一个 watcher 只添加一次，并且在派发更新的时候每次数据改变并不会都触发\b watcher ，而是把watcher添加到队列里面通过执行 nextTick，下面来看一下 <code>flushSchedulerQueue</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// src/core/observer/scheduler.js</span>\n\n<span class=\"token keyword\">let</span> flushing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Flush both queues and run the watchers.\n */</span>\n<span class=\"token keyword\">function</span> flushSchedulerQueue <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  flushing <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token keyword\">let</span> watcher<span class=\"token punctuation\">,</span> id\n\n  <span class=\"token comment\" spellcheck=\"true\">// Sort queue before flush.</span>\n  <span class=\"token comment\" spellcheck=\"true\">// This ensures that:</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 1. Components are updated from parent to child. (because parent is always</span>\n  <span class=\"token comment\" spellcheck=\"true\">//    created before the child)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 2. A component's user watchers are run before its render watcher (because</span>\n  <span class=\"token comment\" spellcheck=\"true\">//    user watchers are created before the render watcher)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 3. If a component is destroyed during a parent component's watcher run,</span>\n  <span class=\"token comment\" spellcheck=\"true\">//    its watchers can be skipped.</span>\n  queue<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">.</span>id <span class=\"token operator\">-</span> b<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// do not cache length because more watchers might be pushed</span>\n  <span class=\"token comment\" spellcheck=\"true\">// as we run existing watchers</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    watcher <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">.</span>before<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      watcher<span class=\"token punctuation\">.</span><span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    id <span class=\"token operator\">=</span> watcher<span class=\"token punctuation\">.</span>id\n    has<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    watcher<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// in dev build, check and stop circular updates.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> has<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      circular<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>circular<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>circular<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> MAX_UPDATE_COUNT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token string\">'You may have an infinite update loop '</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>\n            watcher<span class=\"token punctuation\">.</span>user\n              <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token string\">`in watcher with expression \"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>watcher<span class=\"token punctuation\">.</span>expression<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"`</span></span>\n              <span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`in a component render function.`</span></span>\n          <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n          watcher<span class=\"token punctuation\">.</span>vm\n        <span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">break</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// keep copies of post queues before resetting state</span>\n  <span class=\"token keyword\">const</span> activatedQueue <span class=\"token operator\">=</span> activatedChildren<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> updatedQueue <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token function\">resetSchedulerState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// call component updated and activated hooks</span>\n  <span class=\"token function\">callActivatedHooks</span><span class=\"token punctuation\">(</span>activatedQueue<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">callUpdatedHooks</span><span class=\"token punctuation\">(</span>updatedQueue<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// devtool hook</span>\n  <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>devtools <span class=\"token operator\">&amp;&amp;</span> config<span class=\"token punctuation\">.</span>devtools<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    devtools<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'flush'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先执行对队列做了从小到大的排序</p>\n<ol>\n<li><p>组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。</p>\n</li>\n<li><p>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。</p>\n</li>\n<li><p>如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。</p>\n</li>\n</ol>\n<p>其次进行队列遍历</p>\n<p>拿到对应的 watcher，执行 watcher.run()。如果在遍历的时候，用户有再添加新的 watcher 动作， 那么就在队列中从后往前找，找到第一个没有插入的 watcher 的 id 比当前队列中 watcher 的 id 的大的位置，放到队列中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> queueWatcher <span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">:</span> Watcher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> watcher<span class=\"token punctuation\">.</span>id\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>has<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    has<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flushing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>watcher<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// if already flushing, splice the watcher based on its id</span>\n      <span class=\"token comment\" spellcheck=\"true\">// if already past its id, it will be run next immediately.</span>\n      <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> index <span class=\"token operator\">&amp;&amp;</span> queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">></span> watcher<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        i<span class=\"token operator\">--</span>\n      <span class=\"token punctuation\">}</span>\n      queue<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> watcher<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样在执行 <code>watcher.run()</code> 时候，通过 <code>this.get()</code> 就能得到 watcher 当前的值，然后通过判断 新旧值不等、新值是对象类型、deep 模式中的任何一个条件成立都会触发 watcher 回调，传入新的 value 和 旧的 value，这样我们在我们自定义 watcher 的时候就可以在回调函数中拿到两个值。</p>\n<p>当我们数据发生改变的时候，触发setter ，因为 watcher 是一个队列，通过调度进行了优化 在 nextTick 后执行所有 <code>watcher</code> 的 run 然后触发所有 watcher 的 update 进行进行 patch</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结 \"></a>总结 <hr></h3><img src=\"/images/vue-dep.png\">\n\n<p>通过上面几个模块的分析我们基本知道了 vue 的响应式过程，在生成响应对象的时候需要注意的是，vue 更新对象数组必须用他的全局方法也就是 <code>vue.set,vue.get,vue.del</code> 等，否则是不会触发setter，导致视图更新失败。</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<h2 id=\"响应式对象\"><a href=\"#响应式对象\" class=\"headerlink\" title=\"响应式对象\"></a>响应式对象</h2><p>提到 vue 的双向数据绑定原理，我们都知道是利用了 <code>Object.defineProperty</code> 给数据添加 getter 和 setter，来进行依赖收集和数据派发更新，首先我们再来熟悉一下这个方法</p>\n<h3 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty \"></a>Object.defineProperty <hr></h3><p>MDN 中写到 <code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</p>\n<pre><code class=\"js\">\nfunction Person () {}\n\nObject.defineProperty(Person.prototype, &#39;sayHello&#39;, {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return `my name is ${this.name}`\n  },\n  set:function (value) {\n    this.name = value\n  }\n})\nlet p = new Person()\np.name = &#39;renbo&#39;\nconsole.log(p.sayHello) // my name is renbo</code></pre>\n<p>我们在实现一个极简版双向绑定</p>\n<pre><code class=\"html\">\n&lt;div&gt;请输入:&lt;/div&gt;\n&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;\n&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class=\"js\">\nlet obj = {}\n\nObject.definePerperty(obj,&#39;text&#39;, {\n\n  get:function () {\n    console.log(&#39;获得的值&#39;)\n  },\n  set:function (newVal) {\n    console.log(&#39;设置的值&#39;)\n    document.getElementById(&#39;input&#39;).value = newVal\n    document.getElementById(&#39;content&#39;).innerHTML = newVal;\n  }\n})\n\nconst input = document.getElementById(&#39;input&#39;);\ninput.addEventListener(&#39;keyup&#39;, function(e){\n  obj.text = e.target.value;\n})\n</code></pre>\n<p>set 提供 setter 方法，当我们对 p.name 做修改的时候会触发 setter 方法， 我们访问 sayHello 的时候会触发 getter 方法，取到对应的值，那么一旦对象拥有了 getter 和 setter，就把这个对象变为自动存取的响应对象</p>\n<h3 id=\"initState\"><a href=\"#initState\" class=\"headerlink\" title=\"initState \"></a>initState <hr></h3><p>在 vue _init 阶段我们还执行了 initState(vm) 方法，我们上篇文章写到这个方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作,在 <code>src/core/instance/state.js 中定义</code></p>\n<pre><code class=\"js\">export function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n</code></pre>\n<h3 id=\"initProps\"><a href=\"#initProps\" class=\"headerlink\" title=\"initProps \"></a>initProps <hr></h3><pre><code class=\"js\">function initProps (vm: Component, propsOptions: Object) {\n  const propsData = vm.$options.propsData || {}\n  const props = vm._props = {}\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false)\n  }\n  for (const key in propsOptions) {\n    keys.push(key)\n    const value = validateProp(key, propsOptions, propsData, vm)\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      const hyphenatedKey = hyphenate(key)\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          `&quot;${hyphenatedKey}&quot; is a reserved attribute and cannot be used as component prop.`,\n          vm\n        )\n      }\n      defineReactive(props, key, value, () =&gt; {\n        if (!isRoot &amp;&amp; !isUpdatingChildComponent) {\n          warn(\n            `Avoid mutating a prop directly since the value will be ` +\n            `overwritten whenever the parent component re-renders. ` +\n            `Instead, use a data or computed property based on the prop&#39;s ` +\n            `value. Prop being mutated: &quot;${key}&quot;`,\n            vm\n          )\n        }\n      })\n    } else {\n      defineReactive(props, key, value)\n    }\n    // static props are already proxied on the component&#39;s prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  toggleObserving(true)\n}</code></pre>\n<p>从上面代码中我们看到 props 过程，主要就是遍历 propsOptions ，调用 defineReactive 方法和 proxy，但是上面在开发环境中调用 defineReactive 给一个警告，平时我们通过 props 方法来接受父组件所传过来的值，但是这个过程是单项的，父组件可以改变传给子组件的值，但是如果子组件想改变所接受的值并传给父组件是不可以的，会收到这个警告</p>\n<p>这个错误告诉我们避免去直接更改 props 因为当父组件重新渲染时，该值就会被覆盖。这个时候就需要用到计算属性或者侦听属性了。</p>\n<p>defineReactive 方法和 proxy 具体作用我们在后面介绍。</p>\n<h3 id=\"initData\"><a href=\"#initData\" class=\"headerlink\" title=\"initData\"></a>initData<hr></h3><pre><code class=\"js\">function initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === &#39;function&#39;\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      &#39;data functions should return an object:\\n&#39; +\n      &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      if (methods &amp;&amp; hasOwn(methods, key)) {\n        warn(\n          `Method &quot;${key}&quot; has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props &amp;&amp; hasOwn(props, key)) {\n      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n        `The data property &quot;${key}&quot; is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */)\n}</code></pre>\n<p>initData 主要是遍历data，取到对应的key 调用 proxy ；另一个是调用 observe 方法</p>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy<hr></h3><p>平时我们写 vue 的时候我们可以直接在方法中访问 props 和 data，看下面例子</p>\n<pre><code class=\"js\">\nprops: {\n  name: {\n    type: String,\n    default () {\n      return &#39;renbo&#39;\n    }\n  }\n},\ndata:{\n  return {\n     age: 26\n  }\n},\nmethods: {\n  sayHello () {\n    console.log(this.name, this.age)\n  }\n}</code></pre>\n<p>这就是通过 proxy 将 props 和 data 上的属性代理到 vm 实例上，所以我们可以直接通过 this 访问到</p>\n<p>那么我们看看 proxy 是如何定义的呢</p>\n<pre><code class=\"js\">export function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}</code></pre>\n<p>通过 Object.defineProperty 把 target[sourceKey][key] 的读写变成了对 target[key] 的读写，所以对于 props 和 data 而言就是</p>\n<pre><code class=\"js\">vm._props.xxx -&gt; vm.xxx\nvm._data.xxx -&gt; vm.xxx</code></pre>\n<h3 id=\"observe\"><a href=\"#observe\" class=\"headerlink\" title=\"observe\"></a>observe<hr></h3><p>上面在 initData中调用了 observe 函数，进入文件 <code>src/core/observer/index.js</code> 中</p>\n<pre><code class=\"js\">**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob: Observer | void\n  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &amp;&amp;\n    !isServerRendering() &amp;&amp;\n    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;\n    Object.isExtensible(value) &amp;&amp;\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData &amp;&amp; ob) {\n    ob.vmCount++\n  }\n  return ob\n}</code></pre>\n<p>observe 就是给除了 vnode 的对象类型的数据添加一个观察者实例</p>\n<p>如果已经添加过则直接返回，否则在满足一定条件下去 new Observer</p>\n<p>接下来我们来看一下 Observer 的作用</p>\n<pre><code class=\"js\">export class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that have this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n    def(value, &#39;__ob__&#39;, this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i &lt; keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array&lt;any&gt;) {\n    for (let i = 0, l = items.length; i &lt; l; i++) {\n      observe(items[i])\n    }\n  }\n}\n</code></pre>\n<p>Observer 是一个构造函数</p>\n<ul>\n<li>在constructor 中实例化了 Dep 对象</li>\n<li>执行了 <code>def(value, &#39;__ob__&#39;, this)</code></li>\n<li>对 value 进行判断，如果是数组调用 observeArray，如果是纯对象调用 walk </li>\n<li>observeArray 方法中遍历数组再次调用 observer，而 walk 遍历对象的 key 调用 defineReactive</li>\n</ul>\n<p>Dep 主要的作用就是进行依赖收集，是整个 getter 的核心，在后面会介绍，def 函数是通过 Object.defineProperty 的封装的，作用是将自身实例添加到数据对象 value 的 <code>__ob__</code> 属性上，这样我们在开发中就会看到 data 上对象类型的数据多了一个 <code>__ob__</code>的属性</p>\n<h3 id=\"defineReactive\"><a href=\"#defineReactive\" class=\"headerlink\" title=\"defineReactive\"></a>defineReactive<hr></h3><p>defineReactive 的作用就是定义一个响应式对象，给对象动态添加 getter 和 setter</p>\n<pre><code class=\"js\">\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property &amp;&amp; property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property &amp;&amp; property.get\n  const setter = property &amp;&amp; property.set\n  if ((!getter || setter) &amp;&amp; arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow &amp;&amp; observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter &amp;&amp; !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow &amp;&amp; observe(newVal)\n      dep.notify()\n    }\n  })\n}\n</code></pre>\n<p>defineReactive 函数</p>\n<ul>\n<li>new Dep()</li>\n<li>通过 Object.getOwnPropertyDescriptor 拿到 obj 的属性描述符</li>\n<li>对子对象递归调用 observe 方法，把所有子属性变成响应式对象</li>\n<li>利用 Object.defineProperty 给 obj 的属性 key 添加 getter 和 setter</li>\n</ul>\n<p>下面我们通过上面的逻辑步骤整理下面一张图</p>\n<img src=\"/images/vue-observer.png\">\n\n<p>通过上面的逻辑和总结发现响应式对象的核心其实就是利用 Object.defineProperty 给数据添加了 getter 和 setter，来进行依赖收集<code>dep.depend()</code> 和派发更新 <code>dep.notify()</code></p>\n<h2 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h2><p>通过响应式对象我们知道在 defineReactive 函数内的 Object.defineProperty 定义的 get 内部实例了 Dep</p>\n<h3 id=\"dep\"><a href=\"#dep\" class=\"headerlink\" title=\"dep\"></a>dep<hr></h3><pre><code class=\"js\">const dep = new Dep()\ndep.depend()</code></pre>\n<p>前文说过 Dep 是整个 getter 依赖收集的核心，打开文件在 <code>src/core/observer/dep.js</code></p>\n<pre><code class=\"js\">\n// ...\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array&lt;Watcher&gt;;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {\n      // subs aren&#39;t sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort((a, b) =&gt; a.id - b.id)\n    }\n    for (let i = 0, l = subs.length; i &lt; l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n</code></pre>\n<h3 id=\"watcher\"><a href=\"#watcher\" class=\"headerlink\" title=\"watcher\"></a>watcher<hr></h3><p>我们来看一下 Dep 中主要就是对 Watcher 的一种管理，其中 <code>subs: Array&lt;Watcher&gt;;</code> 就是订阅者列表,在Watcher 中进行定义</p>\n<p>查看 <code>src/core/observer/watcher.js</code></p>\n<pre><code class=\"js\">let uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  computed: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  dep: Dep;\n  deps: Array&lt;Dep&gt;;\n  newDeps: Array&lt;Dep&gt;;\n  depIds: SimpleSet;\n  newDepIds: SimpleSet;\n  before: ?Function;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.computed = !!options.computed\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.computed = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.computed // for computed watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== &#39;production&#39;\n      ? expOrFn.toString()\n      : &#39;&#39;\n    // parse expression for getter\n    if (typeof expOrFn === &#39;function&#39;) {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n          `Failed watching path: &quot;${expOrFn}&quot; ` +\n          &#39;Watcher only accepts simple dot-delimited paths. &#39; +\n          &#39;For full control, use a function instead.&#39;,\n          vm\n        )\n      }\n    }\n    if (this.computed) {\n      this.value = undefined\n      this.dep = new Dep()\n    } else {\n      this.value = this.get()\n    }\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)\n      } else {\n        throw e\n      }\n    } finally {\n      // &quot;touch&quot; every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n  // ...\n}</code></pre>\n<h3 id=\"依赖收集过程\"><a href=\"#依赖收集过程\" class=\"headerlink\" title=\"依赖收集过程\"></a>依赖收集过程<hr></h3><p>当我们在 mount 过程中调用 mountComponent 函数的时候实例化了 <code>new Watcher</code>, 然后执行了 <code>this.get()</code> 方法<br>进入 get 函数 会执行 <code>pushTarget(this)</code></p>\n<p>打开文件 <code>src/core/observer/dep.js</code> </p>\n<pre><code class=\"js\">export function pushTarget (target: ?Watcher) {\n  targetStack.push(target)\n  Dep.target = target\n}</code></pre>\n<p>pushTarget 主要两个作用 </p>\n<ul>\n<li>把 Dep.target 赋值为当前的 Watcher</li>\n<li>将 target 进行压栈操作</li>\n</ul>\n<p>接着执行</p>\n<pre><code class=\"js\">value = this.getter.call(vm, vm)</code></pre>\n<p>this.getter 对应就是 updateComponent 函数，这实际上就是在执行：</p>\n<pre><code class=\"js\">vm._update(vm._render(), hydrating)</code></pre>\n<p>它会先执行 vm._render() 方法，生成渲染 VNode，访问 vm 上的数据，这样就触发了数据对象的 getter。<br>每个getter 上都有一个 dep ，这样就是调用 dep.depend() 进行依赖收集</p>\n<pre><code class=\"js\">addDep (dep: Dep) {\n  const id = dep.id\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id)\n    this.newDeps.push(dep)\n    if (!this.depIds.has(id)) {\n      dep.addSub(this)\n    }\n  }\n}\n</code></pre>\n<p>在保证添加的数据的唯一性 后执行 <code>dep.addSub(this)</code></p>\n<p>也就是执行了<code>this.subs.push(sub)</code></p>\n<p>通过上面的执行顺序，当前的 watcher 已经订阅到了数据 dep 的 subs 数组中，当数据放生改变在进行 dep.notify</p>\n<p>接下来执行递归去访问 value，触发它所有子项的 getter</p>\n<pre><code class=\"js\">if (this.deep) {\n  traverse(value)\n}</code></pre>\n<p>之后执行 popTarget(),打开文件 <code>src/core/observer/dep.js</code></p>\n<pre><code class=\"js\">export function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n</code></pre>\n<p>这个时候 vm 的数据依赖收集已经完成需要将 Dep.target 改变成上一个状态，完成  Dep.target 渲染，最后执行<code>this.cleanupDeps()</code> 进行依赖清空</p>\n<pre><code class=\"js\">cleanupDeps () {\n  let i = this.deps.length\n  while (i--) {\n    const dep = this.deps[i]\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this)\n    }\n  }\n  let tmp = this.depIds\n  this.depIds = this.newDepIds\n  this.newDepIds = tmp\n  this.newDepIds.clear()\n  tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n  this.newDeps.length = 0\n}</code></pre>\n<p>在执行 cleanupDeps 函数，首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空，因为 newDeps 是新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组，所以每次订阅，在subs 中都是最新的，这样就完成了整个依赖收集</p>\n<h2 id=\"派发更新\"><a href=\"#派发更新\" class=\"headerlink\" title=\"派发更新\"></a>派发更新</h2><p>通过 sub 这个数组，当我们修改数据的时候，就可以更新 sub 数组 进行派发更新，下面在进行代码分析这个过程</p>\n<h3 id=\"setter-逻辑\"><a href=\"#setter-逻辑\" class=\"headerlink\" title=\"setter 逻辑\"></a>setter 逻辑<hr></h3><p>通过 <code>defineReactive</code> 函数中，定义响应式的 setter 调用了 <code>dep.notify()</code> 来通知所有订阅者，我们要更新了。</p>\n<pre><code class=\"js\">export function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property &amp;&amp; property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property &amp;&amp; property.get\n  const setter = property &amp;&amp; property.set\n  if ((!getter || setter) &amp;&amp; arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow &amp;&amp; observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    // ...\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; customSetter) {\n        customSetter()\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow &amp;&amp; observe(newVal)\n      dep.notify()\n    }\n  })\n}</code></pre>\n<h3 id=\"派发更新过程\"><a href=\"#派发更新过程\" class=\"headerlink\" title=\"派发更新过程\"></a>派发更新过程<hr></h3><p>当我们修改了数据，触发了 setter ，调用 <code>dep.notify()</code> ,遍历所有 subs，调用 watcher 的 update 方法</p>\n<pre><code class=\"js\">// src/core/observer/dep.js\nclass Dep {\n  // ...\n  notify () {\n  // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i &lt; l; i++) {\n      subs[i].update()\n    }\n  }\n}</code></pre>\n<pre><code class=\"js\">// src/core/observer/watcher.js\nclass Watcher {\n  // ...\n  update () {\n    /* istanbul ignore else */\n    if (this.computed) {\n      // A computed property watcher has two modes: lazy and activated.\n      // It initializes as lazy by default, and only becomes activated when\n      // it is depended on by at least one subscriber, which is typically\n      // another computed property or a component&#39;s render function.\n      if (this.dep.subs.length === 0) {\n        // In lazy mode, we don&#39;t want to perform computations until necessary,\n        // so we simply mark the watcher as dirty. The actual computation is\n        // performed just-in-time in this.evaluate() when the computed property\n        // is accessed.\n        this.dirty = true\n      } else {\n        // In activated mode, we want to proactively perform the computation\n        // but only notify our subscribers when the value has indeed changed.\n        this.getAndInvoke(() =&gt; {\n          this.dep.notify()\n        })\n      }\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n}  </code></pre>\n<p>在进行 update 的时候会根据不同场景去派发更新，computed 与 sync 我们放在后面来说，这两个状态也就是我们的计算属性（computed）和侦听属性（watch），先看一下 queueWatcher </p>\n<pre><code class=\"js\">// src/core/observer/scheduler.js\n\nconst queue: Array&lt;Watcher&gt; = []\nlet has: { [key: number]: ?true } = {}\nlet waiting = false\nlet flushing = false\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it&#39;s\n * pushed when the queue is being flushed.\n */\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}</code></pre>\n<p>用 has 保证在同一个 watcher 只添加一次，并且在派发更新的时候每次数据改变并不会都触发\b watcher ，而是把watcher添加到队列里面通过执行 nextTick，下面来看一下 <code>flushSchedulerQueue</code></p>\n<pre><code class=\"js\">\n// src/core/observer/scheduler.js\n\nlet flushing = false\nlet index = 0\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true\n  let watcher, id\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component&#39;s user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component&#39;s watcher run,\n  //    its watchers can be skipped.\n  queue.sort((a, b) =&gt; a.id - b.id)\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index &lt; queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] &gt; MAX_UPDATE_COUNT) {\n        warn(\n          &#39;You may have an infinite update loop &#39; + (\n            watcher.user\n              ? `in watcher with expression &quot;${watcher.expression}&quot;`\n              : `in a component render function.`\n          ),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  const activatedQueue = activatedChildren.slice()\n  const updatedQueue = queue.slice()\n\n  resetSchedulerState()\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue)\n  callUpdatedHooks(updatedQueue)\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools &amp;&amp; config.devtools) {\n    devtools.emit(&#39;flush&#39;)\n  }\n}</code></pre>\n<p>首先执行对队列做了从小到大的排序</p>\n<ol>\n<li><p>组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。</p>\n</li>\n<li><p>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。</p>\n</li>\n<li><p>如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。</p>\n</li>\n</ol>\n<p>其次进行队列遍历</p>\n<p>拿到对应的 watcher，执行 watcher.run()。如果在遍历的时候，用户有再添加新的 watcher 动作， 那么就在队列中从后往前找，找到第一个没有插入的 watcher 的 id 比当前队列中 watcher 的 id 的大的位置，放到队列中</p>\n<pre><code class=\"js\">export function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // ...\n  }\n}</code></pre>\n<p>这样在执行 <code>watcher.run()</code> 时候，通过 <code>this.get()</code> 就能得到 watcher 当前的值，然后通过判断 新旧值不等、新值是对象类型、deep 模式中的任何一个条件成立都会触发 watcher 回调，传入新的 value 和 旧的 value，这样我们在我们自定义 watcher 的时候就可以在回调函数中拿到两个值。</p>\n<p>当我们数据发生改变的时候，触发setter ，因为 watcher 是一个队列，通过调度进行了优化 在 nextTick 后执行所有 <code>watcher</code> 的 run 然后触发所有 watcher 的 update 进行进行 patch</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结 \"></a>总结 <hr></h3><img src=\"/images/vue-dep.png\">\n\n<p>通过上面几个模块的分析我们基本知道了 vue 的响应式过程，在生成响应对象的时候需要注意的是，vue 更新对象数组必须用他的全局方法也就是 <code>vue.set,vue.get,vue.del</code> 等，否则是不会触发setter，导致视图更新失败。</p>\n"},{"title":"vue-router 原理","date":"2018-08-10T14:01:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n路由的概念，在现在的前端领域其实不算陌生。它的作用就是根据不用的路径去映射到不同的视图。\n\n## 后端路由\n\n路由的概念实际上是从后端开始由来的，后端根据不同的路径去匹配不同的资源例如\n\n```js\nhttps://www.studyfe.cn/login\n```\n大致流程可以分为以下几个阶段\n\n- 浏览器发送请求\n- 服务器监听到请求，解析 url 路径\n- 根据路由配置，返回资源信息\n- 浏览器通过解析资源信息，呈现到前端页面\n\n## 前端路由\n\n### hash 模式<hr>\n\n在 HTML5 的 history 没有出来之前，要实现前端路由机制而不请求后端资源就应用到了 hash 模式，hash 是指 url 尾巴后的 # 号及后面的字符。也被常称为锚点。hash 改变会触发 hashchange 事件，也能对浏览器的前进后退进行控制\n\n```js\nwindow.location.hash = '#toc-heading-1'\nwindow.addEventListener('hashchange', function(){ \n  // 根据业务场景进行控制\n})\n```\n\n### history 模式<hr>\n\nHTML5标准发布。多了两个 API，history.pushState 和 history.replaceState 来进行路由控制。通过这两个方法可以改变 url 且不向服务器发送请求。比较两种方法\n\n- history 比 hash 更美观，url 后面不会多一个 #，\n- history API 可以是更灵活的控制前端路由，例如前进后退等等\n- history 模式在用户刷新的时候需要服务端支持进行重定向，避免出现错误\n- hash 传参是基于 url 的如果要传递复杂数据会有体积限制\n- hash 兼容到 IE8， history 兼容到 IE10\n\n```js\n/**\n * @param state：状态对象，通过pushState () 创建新的历史记录条目。大小不能超过640k\n * @param title：标题，基本没用，一般传 null。Firefox 目前忽略这个参数\n * @param url：该参数定义了新的历史URL记录。新的 url 与当前 url 的 origin 必须一样，否则会抛出错误\n */\nwindow.history.pushState(state, title, url) \n// 示例\nwindow.history.pushState('https://www.studyfe.cn/2018/08/10/vue/vueroute', null, \"/2019/08/27/vue/vueprinciple/\") \n\n// 修改当前历史记录与 pushState 类似\nwindow.history.replaceState(state, title, url) \n\n // 监听浏览器前进后退事件\nwindow.addEventListener(\"popstate\", function(e) {\n  console.log(e)            \n});\n\nwindow.history.back() // 后退\nwindow.history.forward() // 前进\nwindow.history.go(1) // 前进一步\nwindow.history.length // 查看当前记录的栈的数量\n```\n## vue-router\n\nvue-router 在开发中 vue 项目中起到了非常大的作用，它支持 hash、history、abstract 3 种路由方式，提供了提供了 <router-link> 和 <router-view> 2 种组件和一系列的路由配置\n\n使用 <router-link> 和 <router-view> 组件进行路由操作\n\n```html\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n使用 vue-cli 我们经常会在入口文件进行配置\n\n```js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport App from './App'\n\n// 1. 定义（路由）组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // （缩写）相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  el: '#app',\n  render(h) {\n    return h(App)\n  },\n  router\n})\n```\n\n通过上面的例子可以看到 vue-router 是通过 Vue.use 的方法被注入进 Vue 实例中，那么接下来我们就通过 Vue.use 来了解整个 vue-router\n\n### vue-router 实现之 install<hr>\n\nVue.use 定义在 `vue/src/core/global-api/use.js` 中\n\n```js\nVue.use = function (plugin: Function | Object) {\n  const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n  if (installedPlugins.indexOf(plugin) > -1) {\n    return this\n  }\n\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else if (typeof plugin === 'function') {\n    plugin.apply(null, args)\n  }\n  installedPlugins.push(plugin)\n  return this\n}\n```\n通过上面方法很清晰的看到 Vue.use 实际上就是执行这个 install 方法，并且在这个 install 方法的第一个参数我们可以拿到 Vue 对象。Vue-Router 的入口文件是 `src/index.js`，其中定义了 VueRouter 类，也实现了 install 的静态方法\n\n```js\nVueRouter.install = install\n```\n它的定义在 src/install.js 中\n\n```js\n// ...\nexport function install (Vue) {\n // ...\n  // 混入 beforeCreate 钩子\n  Vue.mixin({\n    beforeCreate () {\n      // 在option上面存在router则代表是根组件 \n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        // 执行_router实例的 init 方法\n        this._router.init(this)\n        // 为 vue 实例定义数据劫持\n        Vue.util.defineReactive(this, '_route', this._router.history.current)\n      } else {\n        // 非根组件则直接从父组件中获取\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n \n  // 设置代理，当访问 this.$router 的时候，代理到 this._routerRoot._router\n  Object.defineProperty(Vue.prototype, '$router', {\n    get () { return this._routerRoot._router }\n  })\n  // 设置代理，当访问 this.$route 的时候，代理到 this._routerRoot._route\n  Object.defineProperty(Vue.prototype, '$route', {\n    get () { return this._routerRoot._route }\n  })\n \n  // 注册 router-view 和 router-link 组件\n  Vue.component('RouterView', View)\n  Vue.component('RouterLink', Link)\n\n  // Vue钩子合并策略\n  const strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n  // ...\n}\n```\n\n通过上面的伪代码我们看到 Vue-Router 的 install 方法 实际上就是初始化的过程\n- 混入了 beforeCreate，在执行 `new Vue({router})` 的时候传入 router 对象，挂在到 vue 的根组件上\n- 执行 `this._router.init(this)` \n- 调用了 `Vue.util.defineReactive` 方法来进行响应式数据定义，主要是为了路由的变化能够即使响应页面的更新\n- 通过 registerInstance(this, this) 这个方法来实现对 router-view 的挂载操作\n- 通过 Object.defineProperty 在 Vue 的原型上定义了 $router 和 $route 2 个属性的 get 方法\n- 进行组件的注册钩子合并等操作\n\n### vue-router 实现之 new VueRouter<hr>\n\n 为了构造出 router 实例对象，VueRouter 定义了一些属性和方法，当我们进行 new VueRouter 的时候，如下\n\n```js\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [\n    { path: '/', name: 'home', component: Home },\n    { path: '/foo', name: 'foo', component: Foo },\n    { path: '/bar/:id', name: 'bar', component: Bar }\n  ]\n})\n```\n那么接下来我们看看 new VueRouter 的时候做了什么\n\n```js\nexport default class VueRouter {\n \n  // ...\n  constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || 'hash'\n    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    if (!inBrowser) {\n      mode = 'abstract'\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n\n  match (\n    raw: RawLocation,\n    current?: Route,\n    redirectedFrom?: Location\n  ): Route {\n    return this.matcher.match(raw, current, redirectedFrom)\n  }\n\n  get currentRoute (): ?Route {\n    return this.history && this.history.current\n  }\n\n  init () {}\n  // ...\n```\n\n通过上面我们可以看得出 constructor 中 主要是通过参数 mode 来指定路由模式，在最初阶段还进行了兼容判断。如果当前环境不支持 history 模式，会强制切换到 hash 模式。如果当前环境不是浏览器环境，会切换到abstract模式下。然后再根据不同模式来生成不同的 history 操作对象。\n\n实例化 VueRouter 后会返回它的实例 router，我们在 new Vue 的时候会把 router 作为配置的属性传入，在混入 beforCreate 钩子的时候执行了\n\n```js\nthis._router.init(this)\n```\n接下来我们看看 init 方法\n\n```js\ninit (app: any) {\n  // ...\n  this.apps.push(app)\n\n  if (this.app) {\n    return\n  }\n\n  this.app = app\n\n  const history = this.history\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } else if (history instanceof HashHistory) {\n    const setupHashListener = () => {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n\n  history.listen(route => {\n    this.apps.forEach((app) => {\n      app._route = route\n    })\n  })\n}\n```\n\ninit 主要是通过 history 不同执行 history.transitionTo 切换路由。最后通过 history.listen 来注册路由变化的响应回调。\n\n### vue-router 实现之 HashHistory<hr>\n\n在上面代码中如果 mode 为 hash 则执行 new HashHistory 函数\n\n```js\nexport class HashHistory extends History {\n  constructor (router: Router, base: ?string, fallback: boolean) {\n    super(router, base)\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    // 保证 hash 是以 / 开头，而不是 #/，如果是 #/就会触发 hashchange 事件 这样执行 beforeEnter 钩子时候会触发两次\n    ensureSlash()\n  }\n  // ...\n}\n\nfunction checkFallback (base) {\n  const location = getLocation(base)\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location))\n    return true\n  }\n}\n\nfunction ensureSlash (): boolean {\n  const path = getHash()\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path)\n  return false\n}\n\nexport function getHash (): string {\n\n  // 主要是取 hash，因为兼容性问题所以没有直接使用 window.location.hash\n  let href = window.location.href\n  const index = href.indexOf('#')\n  if (index < 0) return ''\n\n  href = href.slice(index + 1)\n  const searchIndex = href.indexOf('?')\n  if (searchIndex < 0) {\n    const hashIndex = href.indexOf('#')\n    if (hashIndex > -1) {\n      href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex)\n    } else href = decodeURI(href)\n  } else {\n    if (searchIndex > -1) {\n      href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex)\n    }\n  }\n\n  return href\n}\n// ...\n```\n\n在 init 的时候如果是 HashHistory 则会执行 history.transitionTo\n\n```js\nhistory.transitionTo(\n  history.getCurrentLocation(),\n  setupHashListener,\n  setupHashListener\n)\n```\n\n```js\ntransitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n   // 通过 match 匹配 URL 的 router 对象 \n    const route = this.router.match(location, this.current)\n    this.confirmTransition(route, () => {\n      this.updateRoute(route)\n      onComplete && onComplete(route)\n      this.ensureURL()\n\n      // fire ready cbs once\n      if (!this.ready) {\n        this.ready = true\n        this.readyCbs.forEach(cb => { cb(route) })\n      }\n    }, err => {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err && !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb => { cb(err) })\n      }\n    })\n  }\n```\n\ntransitionTo 首先根据目标 location 和当前路径 this.current 执行 this.router.match 方法去匹配到目标的路径。这里 this.current 是 history 维护的当前路径，它的初始值是在 history 的构造函数中初始化的：\n\n```js\nthis.current = START\n```\nSTART 的定义在 src/util/route.js 中：\n\n```js\n// ...\nexport const START = createRoute(null, {\n  path: '/'\n})\n```\n\n这样我们就创建了初始的 Route，那么接下来会执行 confirmTransition 做真正的切换处理\n\n```js\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n  const current = this.current\n  const abort = err => {\n    // ...\n    onAbort && onAbort(err)\n  }\n  // 如果是相同的路由并且 matched.length 相同，那么进行跳转 / 且记进行中断处理\n  if (\n    isSameRoute(route, current) &&\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n\n  const {\n    updated,\n    deactivated,\n    activated\n  } = resolveQueue(this.current.matched, route.matched)\n\n  // 整个切换周期的队列\n  const queue: Array<?NavigationGuard> = [].concat(\n    // 得到即将被销毁组建的 beforeRouteLeave 钩子函数\n    extractLeaveGuards(deactivated),\n    // 全局 router before hooks\n    this.router.beforeHooks,\n    // 得到组件 updated 钩子\n    extractUpdateHooks(updated),\n    // 将要更新的路由的 beforeEnter 钩子\n    activated.map(m => m.beforeEnter),\n    // 异步组件的执行\n    resolveAsyncComponents(activated)\n  )\n\n  this.pending = route\n  // 每一个队列执行的 iterator 函数\n  const iterator = (hook: NavigationGuard, next) => {\n    // ...\n  }\n  // 执行队列 leave 和 beforeEnter 相关钩子\n  runQueue(queue, iterator, () => {\n    // ...\n  })\n}\n```\n\n上面函数的内部实现我们就略过通过注释我们知道它的作用就可以了，现在我们屡一下上面的流程\n\n- 执行 transitionTo 函数，通过 match 函数的匹配得到 router 对象\n- 执行 confirmTransition 函数，判断是否需要跳转，如果不需要则进行中断处理，否则先得到钩子函数的任务队列 queue\n- 通过 runQueue 函数来批次执行任务队列中的每个方法\n- 执行 queue 的钩子函数的时候，通过 iterator 来构造迭代器由用户传入 next 方法，确定执行的过程\n- 整个队列执行完毕后，开始处理完成后的回调函数。\n\n> 导航守卫\n\n导航守卫，实际上就是发生在路由路径切换的时候，执行的一系列钩子函数。\n\n我们先从整体上看一下这些钩子函数执行的逻辑，首先构造一个队列 queue，它实际上是一个数组；然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法来执行这个队列。我们先来看一下 runQueue 的定义，在 `src/util/async.js` 中：\n\n```js\nexport function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {\n  const step = index => { \n    if (index >= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        fn(queue[index], () => {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}\n```\n这是非常经典的异步函数队列执行模式，fn 就是我们传入的 iterator 函数\n\n```js\nconst iterator = (hook: NavigationGuard, next) => {\n  if (this.pending !== route) {\n    return abort()\n  }\n  try {\n    hook(route, current, (to: any) => {\n      if (to === false || isError(to)) {\n        this.ensureURL(true)\n        abort(to)\n      } else if (\n        typeof to === 'string' ||\n        (typeof to === 'object' && (\n          typeof to.path === 'string' ||\n          typeof to.name === 'string'\n        ))\n      ) {\n        abort()\n        if (typeof to === 'object' && to.replace) {\n          this.replace(to)\n        } else {\n          this.push(to)\n        }\n      } else {\n        next(to)\n      }\n    })\n  } catch (e) {\n    abort(e)\n  }\n}\n```\niterator 函数就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数分别对应得到是文档中的 to、from、next 当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法来 resolve 这个钩子函数。\n\n最后我们来看一下 queue 是怎么构造的\n\n```js\nconst queue: Array<?NavigationGuard> = [].concat(\n  extractLeaveGuards(deactivated),\n  this.router.beforeHooks,\n  extractUpdateHooks(updated),\n  activated.map(m => m.beforeEnter),\n  resolveAsyncComponents(activated)\n)\n```\n\n按照顺序如下：\n\n1. 在失活的组件里调用离开守卫。\n\n2. 调用全局的 beforeEach 守卫。\n\n3. 在重用的组件里调用 beforeRouteUpdate 守卫\n\n3. 在激活的路由配置里调用 beforeEnter。\n\n4. 解析异步路由组件。\n\n\n接下来我们来分别介绍这 5 步的实现\n\n第一步执行 extractLeaveGuards(deactivated)，先来看一下 extractLeaveGuards 的定义\n\n```js\nfunction extractLeaveGuards (deactivated: Array<RouteRecord>): Array<?Function> {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n```\n\n它内部调用了 extractGuards 的通用方法，可以从 RouteRecord 数组中提取各个阶段的守卫\n\n```js\nfunction extractGuards (\n  records: Array<RouteRecord>,\n  name: string,\n  bind: Function,\n  reverse?: boolean\n): Array<?Function> {\n  const guards = flatMapComponents(records, (def, instance, match, key) => {\n    const guard = extractGuard(def, name)\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(guard => bind(guard, instance, match, key))\n        : bind(guard, instance, match, key)\n    }\n  })\n  return flatten(reverse ? guards.reverse() : guards)\n}\n```\n\n这里用到了 flatMapComponents 方法去从 records 中获取所有的导航，它的定义在 `src/util/resolve-components.js` 中\n\n```js\nexport function flatMapComponents (\n  matched: Array<RouteRecord>,\n  fn: Function\n): Array<?Function> {\n  return flatten(matched.map(m => {\n    return Object.keys(m.components).map(key => fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ))\n  }))\n}\n\nexport function flatten (arr: Array<any>): Array<any> {\n  return Array.prototype.concat.apply([], arr)\n}\n```\nflatMapComponents 的作用就是返回一个数组，数组的元素是从 matched 里获取到所有组件的 key，然后返回 fn 函数执行的结果，flatten 作用是把二维数组拍平成一维数组。\n\n那么对于 extractGuards 中 flatMapComponents 的调用，执行每个 fn 的时候，通过 extractGuard(def, name) 获取到组件中对应 name 的导航守卫\n\n```js\nfunction extractGuard (\n  def: Object | Function,\n  key: string\n): NavigationGuard | Array<NavigationGuard> {\n  if (typeof def !== 'function') {\n    def = _Vue.extend(def)\n  }\n  return def.options[key]\n}\n```\n\n获取到 guard 后，还会调用 bind 方法把组件的实例 instance 作为函数执行的上下文绑定到 guard 上，bind 方法的对应的是 bindGuard\n\n```js\nfunction bindGuard (guard: NavigationGuard, instance: ?_Vue): ?NavigationGuard {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n```\n\n那么对于 extractLeaveGuards(deactivated) 而言，获取到的就是所有失活组件中定义的 beforeRouteLeave 钩子函数。\n\n第二步是 `this.router.beforeHooks`，在我们的 VueRouter 类中定义了 beforeEach 方法，在 `src/index.js` 中：\n\n```js\nbeforeEach (fn: Function): Function {\n  return registerHook(this.beforeHooks, fn)\n}\n\nfunction registerHook (list: Array<any>, fn: Function): Function {\n  list.push(fn)\n  return () => {\n    const i = list.indexOf(fn)\n    if (i > -1) list.splice(i, 1)\n  }\n}\n```\n当用户使用 router.beforeEach 注册了一个全局守卫，就会往 router.beforeHooks 添加一个钩子函数，这样 this.router.beforeHooks 获取的就是用户注册的全局 beforeEach 守卫。\n\n第三步执行了 extractUpdateHooks(updated)，来看一下 extractUpdateHooks 的定义：\n\n```js\nfunction extractUpdateHooks (updated: Array<RouteRecord>): Array<?Function> {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n```\n和 extractLeaveGuards(deactivated) 类似，extractUpdateHooks(updated) 获取到的就是所有重用的组件中定义的 beforeRouteUpdate 钩子函数\n\n第四步是执行 activated.map(m => m.beforeEnter)，获取的是在激活的路由配置中定义的 beforeEnter 函数。\n\n第五步是执行 resolveAsyncComponents(activated) 解析异步组件，先来看一下 resolveAsyncComponents 的定义，在 `src/util/resolve-components.js` 中\n\n```js\nexport function resolveAsyncComponents (matched: Array<RouteRecord>): Function {\n  return (to, from, next) => {\n    let hasAsync = false\n    let pending = 0\n    let error = null\n\n    flatMapComponents(matched, (def, _, match, key) => {\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true\n        pending++\n\n        const resolve = once(resolvedDef => {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default\n          }\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef)\n          match.components[key] = resolvedDef\n          pending--\n          if (pending <= 0) {\n            next()\n          }\n        })\n\n        const reject = once(reason => {\n          const msg = `Failed to resolve async component ${key}: ${reason}`\n          process.env.NODE_ENV !== 'production' && warn(false, msg)\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg)\n            next(error)\n          }\n        })\n\n        let res\n        try {\n          res = def(resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject)\n          } else {\n            const comp = res.component\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject)\n            }\n          }\n        }\n      }\n    })\n\n    if (!hasAsync) next()\n  }\n}\n```\n\nresolveAsyncComponents 返回的是一个导航守卫函数，有标准的 to、from、next 参数。它的内部实现很简单，利用了 flatMapComponents 方法从 matched 中获取到每个组件的定义，判断如果是异步组件，则执行异步组件加载逻辑，加载成功后会执行 match.components[key] = resolvedDef 把解析好的异步组件放到对应的 components 上，并且执行 next 函数。\n\n这样在 resolveAsyncComponents(activated) 解析完所有激活的异步组件后，我们就可以拿到这一次所有激活的组件。这样我们在做完这 5 步后又做了一些事情\n\n```js\nrunQueue(queue, iterator, () => {\n  const postEnterCbs = []\n  const isValid = () => this.current === route\n  const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n  const queue = enterGuards.concat(this.router.resolveHooks)\n  runQueue(queue, iterator, () => {\n    if (this.pending !== route) {\n      return abort()\n    }\n    this.pending = null\n    onComplete(route)\n    if (this.router.app) {\n      this.router.app.$nextTick(() => {\n        postEnterCbs.forEach(cb => { cb() })\n      })\n    }\n  })\n})\n```\n\n6. 在被激活的组件里调用 beforeRouteEnter。\n\n7. 调用全局的 beforeResolve 守卫。\n\n8. 调用全局的 afterEach 钩子。\n\n\n可以看到，当处理完任务队列之后的回调主要是接入路由组件后期的钩子函数 beforeRouteEnter 和 beforeResolve，并进行队列执行。最后执行回调函数 onComplete\n\n到这里，已经完成了对当前 route 的切换动作，在完成路由切换后执行了 `onComplete && onComplete(route)` ，那么主要会引起 url 和 组件的变化我们来看看\n\n当我们点击 router-link 的时候，实际上最终会执行 router.push，如下\n\n```js\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.history.push(location, onComplete, onAbort)\n}\n```\nthis.history.push 函数，这个函数是子类实现的，不同模式下该函数的实现略有不同，我们来看一下平时使用比较多的 hash 模式该函数的实现，在 `src/history/hash.js` 中\n\n```js\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const { current: fromRoute } = this\n  this.transitionTo(location, route => {\n    pushHash(route.fullPath)\n    handleScroll(this.router, route, fromRoute, false)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n```\n\npush 函数会先执行 this.transitionTo 做路径切换，在切换完成的回调函数中，执行 pushHash 函数\n\n```js\nfunction pushHash (path) {\n  if (supportsPushState) {\n    pushState(getUrl(path))\n  } else {\n    window.location.hash = path\n  }\n}\n```\n\nsupportsPushState 的定义在 `src/util/push-state.js` 中\n\n```js\nexport const supportsPushState = inBrowser && (function () {\n  const ua = window.navigator.userAgent\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})()\n```\n\n如果支持的话，则获取当前完整的 url，执行 pushState 方法\n\n```js\nexport function pushState (url?: string, replace?: boolean) {\n  saveScrollPosition()\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, '', url)\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url)\n  }\n}\n```\n\npushState 会调用浏览器原生的 history 的 pushState 接口或者 replaceState 接口，更新浏览器的 url 地址，并把当前 url 压入历史栈中。\n\n然后在 history 的初始化中，会设置一个监听器，监听历史栈的变化\n\n```js\nsetupListeners () {\n  const router = this.router\n  // 处理滚动\n  const expectScroll = router.options.scrollBehavior\n  const supportsScroll = supportsPushState && expectScroll\n\n  if (supportsScroll) {\n    setupScroll()\n  }\n  // 通过 supportsPushState 判断监听popstate 还是 hashchange\n  window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', () => {\n    const current = this.current\n    // 判断路由格式\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route => {\n      if (supportsScroll) {\n        handleScroll(this.router, route, current, true)\n      }\n      // 如果不支持 history 模式，则换成 hash 模式\n      if (!supportsPushState) {\n        replaceHash(route.fullPath)\n      }\n    })\n  })\n}\n```\n\n当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。\n\n可以看到 setupListeners 这里主要做了 2 件事情，一个是对路由切换滚动位置的处理，另一个是对路由变动做了一次监听。这样我们就完成了对真个 hash 的分析过程\n\n### vue-router 实现之 HTML5History<hr>\n\n当初始化的时候 mode 等于 history 模式的时候，就会执行 HTML5History，然后会执行 history 对象上的 transitionTo 方法\n\n在vue-router实例化过程中，执行对 HTML5History 的实例化\n\n```js\nthis.history = new HTML5History(this, options.base)\n```\n\n看一下 HTML5History 函数的构造\n\n```js\n  constructor (router: Router, base: ?string) {\n    // 实现 base 基类中的构造函数\n    super(router, base)\n    \n    // 滚动信息处理\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    const initLocation = getLocation(this.base)\n    window.addEventListener('popstate', e => {\n      const current = this.current\n\n      // 避免在有的浏览器中第一次加载路由就会触发 `popstate` 事件\n      const location = getLocation(this.base)\n      if (this.current === START && location === initLocation) {\n        return\n      }\n      // 执行跳转动作\n      this.transitionTo(location, route => {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true)\n        }\n      })\n    })\n  }\n```\n\n可以看到，只是调用基类构造函数以及初始化监听事件。由于在上面已经介绍了 transitionTo 和 confirmTransition。这里不再过多介绍了。那么我们来看几个之前没介绍的一下 API 吧\n\n```js\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.push(location, onComplete, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.replace(location, onComplete, onAbort)\n  }\n\n  go (n: number) {\n    this.history.go(n)\n  }\n\n  back () {\n    this.go(-1)\n  }\n\n  forward () {\n    this.go(1)\n  }\n```\n可以看到 vue-router 这个 API 实际上都是效仿 window.history API 的，所以也不用多说。这样我们就完成了对 HTML5History 的介绍\n\n### 总结<hr>\n\n从上面我们看到路径变化是路由中最重要的功能，在路由记性切换的时候会把当前的路线切换到目标路线，切换过程中会执行一系列的导航守卫钩子函数，更改 url，同时渲染组件。其实最重要的几个函数就是\n\n- match 进行匹配路由得到路由对象\n- transitionTo 做路径切换\n- confirmTransition 处理队列的钩子函数，在处理钩子函数的时候会按照上面介绍的执行 8 个小步骤的顺序\n- setupListeners 监听导航等功能\n\n\n\n\n","source":"_posts/vue/vueRouter.md","raw":"---\ntitle: vue-router 原理\ndate: 2018-08-10 22:01:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n路由的概念，在现在的前端领域其实不算陌生。它的作用就是根据不用的路径去映射到不同的视图。\n\n## 后端路由\n\n路由的概念实际上是从后端开始由来的，后端根据不同的路径去匹配不同的资源例如\n\n```js\nhttps://www.studyfe.cn/login\n```\n大致流程可以分为以下几个阶段\n\n- 浏览器发送请求\n- 服务器监听到请求，解析 url 路径\n- 根据路由配置，返回资源信息\n- 浏览器通过解析资源信息，呈现到前端页面\n\n## 前端路由\n\n### hash 模式<hr>\n\n在 HTML5 的 history 没有出来之前，要实现前端路由机制而不请求后端资源就应用到了 hash 模式，hash 是指 url 尾巴后的 # 号及后面的字符。也被常称为锚点。hash 改变会触发 hashchange 事件，也能对浏览器的前进后退进行控制\n\n```js\nwindow.location.hash = '#toc-heading-1'\nwindow.addEventListener('hashchange', function(){ \n  // 根据业务场景进行控制\n})\n```\n\n### history 模式<hr>\n\nHTML5标准发布。多了两个 API，history.pushState 和 history.replaceState 来进行路由控制。通过这两个方法可以改变 url 且不向服务器发送请求。比较两种方法\n\n- history 比 hash 更美观，url 后面不会多一个 #，\n- history API 可以是更灵活的控制前端路由，例如前进后退等等\n- history 模式在用户刷新的时候需要服务端支持进行重定向，避免出现错误\n- hash 传参是基于 url 的如果要传递复杂数据会有体积限制\n- hash 兼容到 IE8， history 兼容到 IE10\n\n```js\n/**\n * @param state：状态对象，通过pushState () 创建新的历史记录条目。大小不能超过640k\n * @param title：标题，基本没用，一般传 null。Firefox 目前忽略这个参数\n * @param url：该参数定义了新的历史URL记录。新的 url 与当前 url 的 origin 必须一样，否则会抛出错误\n */\nwindow.history.pushState(state, title, url) \n// 示例\nwindow.history.pushState('https://www.studyfe.cn/2018/08/10/vue/vueroute', null, \"/2019/08/27/vue/vueprinciple/\") \n\n// 修改当前历史记录与 pushState 类似\nwindow.history.replaceState(state, title, url) \n\n // 监听浏览器前进后退事件\nwindow.addEventListener(\"popstate\", function(e) {\n  console.log(e)            \n});\n\nwindow.history.back() // 后退\nwindow.history.forward() // 前进\nwindow.history.go(1) // 前进一步\nwindow.history.length // 查看当前记录的栈的数量\n```\n## vue-router\n\nvue-router 在开发中 vue 项目中起到了非常大的作用，它支持 hash、history、abstract 3 种路由方式，提供了提供了 <router-link> 和 <router-view> 2 种组件和一系列的路由配置\n\n使用 <router-link> 和 <router-view> 组件进行路由操作\n\n```html\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n使用 vue-cli 我们经常会在入口文件进行配置\n\n```js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport App from './App'\n\n// 1. 定义（路由）组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // （缩写）相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  el: '#app',\n  render(h) {\n    return h(App)\n  },\n  router\n})\n```\n\n通过上面的例子可以看到 vue-router 是通过 Vue.use 的方法被注入进 Vue 实例中，那么接下来我们就通过 Vue.use 来了解整个 vue-router\n\n### vue-router 实现之 install<hr>\n\nVue.use 定义在 `vue/src/core/global-api/use.js` 中\n\n```js\nVue.use = function (plugin: Function | Object) {\n  const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n  if (installedPlugins.indexOf(plugin) > -1) {\n    return this\n  }\n\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else if (typeof plugin === 'function') {\n    plugin.apply(null, args)\n  }\n  installedPlugins.push(plugin)\n  return this\n}\n```\n通过上面方法很清晰的看到 Vue.use 实际上就是执行这个 install 方法，并且在这个 install 方法的第一个参数我们可以拿到 Vue 对象。Vue-Router 的入口文件是 `src/index.js`，其中定义了 VueRouter 类，也实现了 install 的静态方法\n\n```js\nVueRouter.install = install\n```\n它的定义在 src/install.js 中\n\n```js\n// ...\nexport function install (Vue) {\n // ...\n  // 混入 beforeCreate 钩子\n  Vue.mixin({\n    beforeCreate () {\n      // 在option上面存在router则代表是根组件 \n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        // 执行_router实例的 init 方法\n        this._router.init(this)\n        // 为 vue 实例定义数据劫持\n        Vue.util.defineReactive(this, '_route', this._router.history.current)\n      } else {\n        // 非根组件则直接从父组件中获取\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n \n  // 设置代理，当访问 this.$router 的时候，代理到 this._routerRoot._router\n  Object.defineProperty(Vue.prototype, '$router', {\n    get () { return this._routerRoot._router }\n  })\n  // 设置代理，当访问 this.$route 的时候，代理到 this._routerRoot._route\n  Object.defineProperty(Vue.prototype, '$route', {\n    get () { return this._routerRoot._route }\n  })\n \n  // 注册 router-view 和 router-link 组件\n  Vue.component('RouterView', View)\n  Vue.component('RouterLink', Link)\n\n  // Vue钩子合并策略\n  const strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n  // ...\n}\n```\n\n通过上面的伪代码我们看到 Vue-Router 的 install 方法 实际上就是初始化的过程\n- 混入了 beforeCreate，在执行 `new Vue({router})` 的时候传入 router 对象，挂在到 vue 的根组件上\n- 执行 `this._router.init(this)` \n- 调用了 `Vue.util.defineReactive` 方法来进行响应式数据定义，主要是为了路由的变化能够即使响应页面的更新\n- 通过 registerInstance(this, this) 这个方法来实现对 router-view 的挂载操作\n- 通过 Object.defineProperty 在 Vue 的原型上定义了 $router 和 $route 2 个属性的 get 方法\n- 进行组件的注册钩子合并等操作\n\n### vue-router 实现之 new VueRouter<hr>\n\n 为了构造出 router 实例对象，VueRouter 定义了一些属性和方法，当我们进行 new VueRouter 的时候，如下\n\n```js\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [\n    { path: '/', name: 'home', component: Home },\n    { path: '/foo', name: 'foo', component: Foo },\n    { path: '/bar/:id', name: 'bar', component: Bar }\n  ]\n})\n```\n那么接下来我们看看 new VueRouter 的时候做了什么\n\n```js\nexport default class VueRouter {\n \n  // ...\n  constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || 'hash'\n    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    if (!inBrowser) {\n      mode = 'abstract'\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n\n  match (\n    raw: RawLocation,\n    current?: Route,\n    redirectedFrom?: Location\n  ): Route {\n    return this.matcher.match(raw, current, redirectedFrom)\n  }\n\n  get currentRoute (): ?Route {\n    return this.history && this.history.current\n  }\n\n  init () {}\n  // ...\n```\n\n通过上面我们可以看得出 constructor 中 主要是通过参数 mode 来指定路由模式，在最初阶段还进行了兼容判断。如果当前环境不支持 history 模式，会强制切换到 hash 模式。如果当前环境不是浏览器环境，会切换到abstract模式下。然后再根据不同模式来生成不同的 history 操作对象。\n\n实例化 VueRouter 后会返回它的实例 router，我们在 new Vue 的时候会把 router 作为配置的属性传入，在混入 beforCreate 钩子的时候执行了\n\n```js\nthis._router.init(this)\n```\n接下来我们看看 init 方法\n\n```js\ninit (app: any) {\n  // ...\n  this.apps.push(app)\n\n  if (this.app) {\n    return\n  }\n\n  this.app = app\n\n  const history = this.history\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } else if (history instanceof HashHistory) {\n    const setupHashListener = () => {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n\n  history.listen(route => {\n    this.apps.forEach((app) => {\n      app._route = route\n    })\n  })\n}\n```\n\ninit 主要是通过 history 不同执行 history.transitionTo 切换路由。最后通过 history.listen 来注册路由变化的响应回调。\n\n### vue-router 实现之 HashHistory<hr>\n\n在上面代码中如果 mode 为 hash 则执行 new HashHistory 函数\n\n```js\nexport class HashHistory extends History {\n  constructor (router: Router, base: ?string, fallback: boolean) {\n    super(router, base)\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    // 保证 hash 是以 / 开头，而不是 #/，如果是 #/就会触发 hashchange 事件 这样执行 beforeEnter 钩子时候会触发两次\n    ensureSlash()\n  }\n  // ...\n}\n\nfunction checkFallback (base) {\n  const location = getLocation(base)\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location))\n    return true\n  }\n}\n\nfunction ensureSlash (): boolean {\n  const path = getHash()\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path)\n  return false\n}\n\nexport function getHash (): string {\n\n  // 主要是取 hash，因为兼容性问题所以没有直接使用 window.location.hash\n  let href = window.location.href\n  const index = href.indexOf('#')\n  if (index < 0) return ''\n\n  href = href.slice(index + 1)\n  const searchIndex = href.indexOf('?')\n  if (searchIndex < 0) {\n    const hashIndex = href.indexOf('#')\n    if (hashIndex > -1) {\n      href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex)\n    } else href = decodeURI(href)\n  } else {\n    if (searchIndex > -1) {\n      href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex)\n    }\n  }\n\n  return href\n}\n// ...\n```\n\n在 init 的时候如果是 HashHistory 则会执行 history.transitionTo\n\n```js\nhistory.transitionTo(\n  history.getCurrentLocation(),\n  setupHashListener,\n  setupHashListener\n)\n```\n\n```js\ntransitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n   // 通过 match 匹配 URL 的 router 对象 \n    const route = this.router.match(location, this.current)\n    this.confirmTransition(route, () => {\n      this.updateRoute(route)\n      onComplete && onComplete(route)\n      this.ensureURL()\n\n      // fire ready cbs once\n      if (!this.ready) {\n        this.ready = true\n        this.readyCbs.forEach(cb => { cb(route) })\n      }\n    }, err => {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err && !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb => { cb(err) })\n      }\n    })\n  }\n```\n\ntransitionTo 首先根据目标 location 和当前路径 this.current 执行 this.router.match 方法去匹配到目标的路径。这里 this.current 是 history 维护的当前路径，它的初始值是在 history 的构造函数中初始化的：\n\n```js\nthis.current = START\n```\nSTART 的定义在 src/util/route.js 中：\n\n```js\n// ...\nexport const START = createRoute(null, {\n  path: '/'\n})\n```\n\n这样我们就创建了初始的 Route，那么接下来会执行 confirmTransition 做真正的切换处理\n\n```js\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n  const current = this.current\n  const abort = err => {\n    // ...\n    onAbort && onAbort(err)\n  }\n  // 如果是相同的路由并且 matched.length 相同，那么进行跳转 / 且记进行中断处理\n  if (\n    isSameRoute(route, current) &&\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n\n  const {\n    updated,\n    deactivated,\n    activated\n  } = resolveQueue(this.current.matched, route.matched)\n\n  // 整个切换周期的队列\n  const queue: Array<?NavigationGuard> = [].concat(\n    // 得到即将被销毁组建的 beforeRouteLeave 钩子函数\n    extractLeaveGuards(deactivated),\n    // 全局 router before hooks\n    this.router.beforeHooks,\n    // 得到组件 updated 钩子\n    extractUpdateHooks(updated),\n    // 将要更新的路由的 beforeEnter 钩子\n    activated.map(m => m.beforeEnter),\n    // 异步组件的执行\n    resolveAsyncComponents(activated)\n  )\n\n  this.pending = route\n  // 每一个队列执行的 iterator 函数\n  const iterator = (hook: NavigationGuard, next) => {\n    // ...\n  }\n  // 执行队列 leave 和 beforeEnter 相关钩子\n  runQueue(queue, iterator, () => {\n    // ...\n  })\n}\n```\n\n上面函数的内部实现我们就略过通过注释我们知道它的作用就可以了，现在我们屡一下上面的流程\n\n- 执行 transitionTo 函数，通过 match 函数的匹配得到 router 对象\n- 执行 confirmTransition 函数，判断是否需要跳转，如果不需要则进行中断处理，否则先得到钩子函数的任务队列 queue\n- 通过 runQueue 函数来批次执行任务队列中的每个方法\n- 执行 queue 的钩子函数的时候，通过 iterator 来构造迭代器由用户传入 next 方法，确定执行的过程\n- 整个队列执行完毕后，开始处理完成后的回调函数。\n\n> 导航守卫\n\n导航守卫，实际上就是发生在路由路径切换的时候，执行的一系列钩子函数。\n\n我们先从整体上看一下这些钩子函数执行的逻辑，首先构造一个队列 queue，它实际上是一个数组；然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法来执行这个队列。我们先来看一下 runQueue 的定义，在 `src/util/async.js` 中：\n\n```js\nexport function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {\n  const step = index => { \n    if (index >= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        fn(queue[index], () => {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}\n```\n这是非常经典的异步函数队列执行模式，fn 就是我们传入的 iterator 函数\n\n```js\nconst iterator = (hook: NavigationGuard, next) => {\n  if (this.pending !== route) {\n    return abort()\n  }\n  try {\n    hook(route, current, (to: any) => {\n      if (to === false || isError(to)) {\n        this.ensureURL(true)\n        abort(to)\n      } else if (\n        typeof to === 'string' ||\n        (typeof to === 'object' && (\n          typeof to.path === 'string' ||\n          typeof to.name === 'string'\n        ))\n      ) {\n        abort()\n        if (typeof to === 'object' && to.replace) {\n          this.replace(to)\n        } else {\n          this.push(to)\n        }\n      } else {\n        next(to)\n      }\n    })\n  } catch (e) {\n    abort(e)\n  }\n}\n```\niterator 函数就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数分别对应得到是文档中的 to、from、next 当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法来 resolve 这个钩子函数。\n\n最后我们来看一下 queue 是怎么构造的\n\n```js\nconst queue: Array<?NavigationGuard> = [].concat(\n  extractLeaveGuards(deactivated),\n  this.router.beforeHooks,\n  extractUpdateHooks(updated),\n  activated.map(m => m.beforeEnter),\n  resolveAsyncComponents(activated)\n)\n```\n\n按照顺序如下：\n\n1. 在失活的组件里调用离开守卫。\n\n2. 调用全局的 beforeEach 守卫。\n\n3. 在重用的组件里调用 beforeRouteUpdate 守卫\n\n3. 在激活的路由配置里调用 beforeEnter。\n\n4. 解析异步路由组件。\n\n\n接下来我们来分别介绍这 5 步的实现\n\n第一步执行 extractLeaveGuards(deactivated)，先来看一下 extractLeaveGuards 的定义\n\n```js\nfunction extractLeaveGuards (deactivated: Array<RouteRecord>): Array<?Function> {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n```\n\n它内部调用了 extractGuards 的通用方法，可以从 RouteRecord 数组中提取各个阶段的守卫\n\n```js\nfunction extractGuards (\n  records: Array<RouteRecord>,\n  name: string,\n  bind: Function,\n  reverse?: boolean\n): Array<?Function> {\n  const guards = flatMapComponents(records, (def, instance, match, key) => {\n    const guard = extractGuard(def, name)\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(guard => bind(guard, instance, match, key))\n        : bind(guard, instance, match, key)\n    }\n  })\n  return flatten(reverse ? guards.reverse() : guards)\n}\n```\n\n这里用到了 flatMapComponents 方法去从 records 中获取所有的导航，它的定义在 `src/util/resolve-components.js` 中\n\n```js\nexport function flatMapComponents (\n  matched: Array<RouteRecord>,\n  fn: Function\n): Array<?Function> {\n  return flatten(matched.map(m => {\n    return Object.keys(m.components).map(key => fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ))\n  }))\n}\n\nexport function flatten (arr: Array<any>): Array<any> {\n  return Array.prototype.concat.apply([], arr)\n}\n```\nflatMapComponents 的作用就是返回一个数组，数组的元素是从 matched 里获取到所有组件的 key，然后返回 fn 函数执行的结果，flatten 作用是把二维数组拍平成一维数组。\n\n那么对于 extractGuards 中 flatMapComponents 的调用，执行每个 fn 的时候，通过 extractGuard(def, name) 获取到组件中对应 name 的导航守卫\n\n```js\nfunction extractGuard (\n  def: Object | Function,\n  key: string\n): NavigationGuard | Array<NavigationGuard> {\n  if (typeof def !== 'function') {\n    def = _Vue.extend(def)\n  }\n  return def.options[key]\n}\n```\n\n获取到 guard 后，还会调用 bind 方法把组件的实例 instance 作为函数执行的上下文绑定到 guard 上，bind 方法的对应的是 bindGuard\n\n```js\nfunction bindGuard (guard: NavigationGuard, instance: ?_Vue): ?NavigationGuard {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n```\n\n那么对于 extractLeaveGuards(deactivated) 而言，获取到的就是所有失活组件中定义的 beforeRouteLeave 钩子函数。\n\n第二步是 `this.router.beforeHooks`，在我们的 VueRouter 类中定义了 beforeEach 方法，在 `src/index.js` 中：\n\n```js\nbeforeEach (fn: Function): Function {\n  return registerHook(this.beforeHooks, fn)\n}\n\nfunction registerHook (list: Array<any>, fn: Function): Function {\n  list.push(fn)\n  return () => {\n    const i = list.indexOf(fn)\n    if (i > -1) list.splice(i, 1)\n  }\n}\n```\n当用户使用 router.beforeEach 注册了一个全局守卫，就会往 router.beforeHooks 添加一个钩子函数，这样 this.router.beforeHooks 获取的就是用户注册的全局 beforeEach 守卫。\n\n第三步执行了 extractUpdateHooks(updated)，来看一下 extractUpdateHooks 的定义：\n\n```js\nfunction extractUpdateHooks (updated: Array<RouteRecord>): Array<?Function> {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n```\n和 extractLeaveGuards(deactivated) 类似，extractUpdateHooks(updated) 获取到的就是所有重用的组件中定义的 beforeRouteUpdate 钩子函数\n\n第四步是执行 activated.map(m => m.beforeEnter)，获取的是在激活的路由配置中定义的 beforeEnter 函数。\n\n第五步是执行 resolveAsyncComponents(activated) 解析异步组件，先来看一下 resolveAsyncComponents 的定义，在 `src/util/resolve-components.js` 中\n\n```js\nexport function resolveAsyncComponents (matched: Array<RouteRecord>): Function {\n  return (to, from, next) => {\n    let hasAsync = false\n    let pending = 0\n    let error = null\n\n    flatMapComponents(matched, (def, _, match, key) => {\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true\n        pending++\n\n        const resolve = once(resolvedDef => {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default\n          }\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef)\n          match.components[key] = resolvedDef\n          pending--\n          if (pending <= 0) {\n            next()\n          }\n        })\n\n        const reject = once(reason => {\n          const msg = `Failed to resolve async component ${key}: ${reason}`\n          process.env.NODE_ENV !== 'production' && warn(false, msg)\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg)\n            next(error)\n          }\n        })\n\n        let res\n        try {\n          res = def(resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject)\n          } else {\n            const comp = res.component\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject)\n            }\n          }\n        }\n      }\n    })\n\n    if (!hasAsync) next()\n  }\n}\n```\n\nresolveAsyncComponents 返回的是一个导航守卫函数，有标准的 to、from、next 参数。它的内部实现很简单，利用了 flatMapComponents 方法从 matched 中获取到每个组件的定义，判断如果是异步组件，则执行异步组件加载逻辑，加载成功后会执行 match.components[key] = resolvedDef 把解析好的异步组件放到对应的 components 上，并且执行 next 函数。\n\n这样在 resolveAsyncComponents(activated) 解析完所有激活的异步组件后，我们就可以拿到这一次所有激活的组件。这样我们在做完这 5 步后又做了一些事情\n\n```js\nrunQueue(queue, iterator, () => {\n  const postEnterCbs = []\n  const isValid = () => this.current === route\n  const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n  const queue = enterGuards.concat(this.router.resolveHooks)\n  runQueue(queue, iterator, () => {\n    if (this.pending !== route) {\n      return abort()\n    }\n    this.pending = null\n    onComplete(route)\n    if (this.router.app) {\n      this.router.app.$nextTick(() => {\n        postEnterCbs.forEach(cb => { cb() })\n      })\n    }\n  })\n})\n```\n\n6. 在被激活的组件里调用 beforeRouteEnter。\n\n7. 调用全局的 beforeResolve 守卫。\n\n8. 调用全局的 afterEach 钩子。\n\n\n可以看到，当处理完任务队列之后的回调主要是接入路由组件后期的钩子函数 beforeRouteEnter 和 beforeResolve，并进行队列执行。最后执行回调函数 onComplete\n\n到这里，已经完成了对当前 route 的切换动作，在完成路由切换后执行了 `onComplete && onComplete(route)` ，那么主要会引起 url 和 组件的变化我们来看看\n\n当我们点击 router-link 的时候，实际上最终会执行 router.push，如下\n\n```js\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.history.push(location, onComplete, onAbort)\n}\n```\nthis.history.push 函数，这个函数是子类实现的，不同模式下该函数的实现略有不同，我们来看一下平时使用比较多的 hash 模式该函数的实现，在 `src/history/hash.js` 中\n\n```js\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const { current: fromRoute } = this\n  this.transitionTo(location, route => {\n    pushHash(route.fullPath)\n    handleScroll(this.router, route, fromRoute, false)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n```\n\npush 函数会先执行 this.transitionTo 做路径切换，在切换完成的回调函数中，执行 pushHash 函数\n\n```js\nfunction pushHash (path) {\n  if (supportsPushState) {\n    pushState(getUrl(path))\n  } else {\n    window.location.hash = path\n  }\n}\n```\n\nsupportsPushState 的定义在 `src/util/push-state.js` 中\n\n```js\nexport const supportsPushState = inBrowser && (function () {\n  const ua = window.navigator.userAgent\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})()\n```\n\n如果支持的话，则获取当前完整的 url，执行 pushState 方法\n\n```js\nexport function pushState (url?: string, replace?: boolean) {\n  saveScrollPosition()\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, '', url)\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url)\n  }\n}\n```\n\npushState 会调用浏览器原生的 history 的 pushState 接口或者 replaceState 接口，更新浏览器的 url 地址，并把当前 url 压入历史栈中。\n\n然后在 history 的初始化中，会设置一个监听器，监听历史栈的变化\n\n```js\nsetupListeners () {\n  const router = this.router\n  // 处理滚动\n  const expectScroll = router.options.scrollBehavior\n  const supportsScroll = supportsPushState && expectScroll\n\n  if (supportsScroll) {\n    setupScroll()\n  }\n  // 通过 supportsPushState 判断监听popstate 还是 hashchange\n  window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', () => {\n    const current = this.current\n    // 判断路由格式\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route => {\n      if (supportsScroll) {\n        handleScroll(this.router, route, current, true)\n      }\n      // 如果不支持 history 模式，则换成 hash 模式\n      if (!supportsPushState) {\n        replaceHash(route.fullPath)\n      }\n    })\n  })\n}\n```\n\n当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。\n\n可以看到 setupListeners 这里主要做了 2 件事情，一个是对路由切换滚动位置的处理，另一个是对路由变动做了一次监听。这样我们就完成了对真个 hash 的分析过程\n\n### vue-router 实现之 HTML5History<hr>\n\n当初始化的时候 mode 等于 history 模式的时候，就会执行 HTML5History，然后会执行 history 对象上的 transitionTo 方法\n\n在vue-router实例化过程中，执行对 HTML5History 的实例化\n\n```js\nthis.history = new HTML5History(this, options.base)\n```\n\n看一下 HTML5History 函数的构造\n\n```js\n  constructor (router: Router, base: ?string) {\n    // 实现 base 基类中的构造函数\n    super(router, base)\n    \n    // 滚动信息处理\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    const initLocation = getLocation(this.base)\n    window.addEventListener('popstate', e => {\n      const current = this.current\n\n      // 避免在有的浏览器中第一次加载路由就会触发 `popstate` 事件\n      const location = getLocation(this.base)\n      if (this.current === START && location === initLocation) {\n        return\n      }\n      // 执行跳转动作\n      this.transitionTo(location, route => {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true)\n        }\n      })\n    })\n  }\n```\n\n可以看到，只是调用基类构造函数以及初始化监听事件。由于在上面已经介绍了 transitionTo 和 confirmTransition。这里不再过多介绍了。那么我们来看几个之前没介绍的一下 API 吧\n\n```js\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.push(location, onComplete, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.replace(location, onComplete, onAbort)\n  }\n\n  go (n: number) {\n    this.history.go(n)\n  }\n\n  back () {\n    this.go(-1)\n  }\n\n  forward () {\n    this.go(1)\n  }\n```\n可以看到 vue-router 这个 API 实际上都是效仿 window.history API 的，所以也不用多说。这样我们就完成了对 HTML5History 的介绍\n\n### 总结<hr>\n\n从上面我们看到路径变化是路由中最重要的功能，在路由记性切换的时候会把当前的路线切换到目标路线，切换过程中会执行一系列的导航守卫钩子函数，更改 url，同时渲染组件。其实最重要的几个函数就是\n\n- match 进行匹配路由得到路由对象\n- transitionTo 做路径切换\n- confirmTransition 处理队列的钩子函数，在处理钩子函数的时候会按照上面介绍的执行 8 个小步骤的顺序\n- setupListeners 监听导航等功能\n\n\n\n\n","slug":"vue/vueRouter","published":1,"updated":"2019-10-15T01:29:42.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ox3009rb0u6bze14zlm","content":"<p>路由的概念，在现在的前端领域其实不算陌生。它的作用就是根据不用的路径去映射到不同的视图。</p>\n<h2 id=\"后端路由\"><a href=\"#后端路由\" class=\"headerlink\" title=\"后端路由\"></a>后端路由</h2><p>路由的概念实际上是从后端开始由来的，后端根据不同的路径去匹配不同的资源例如</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">https<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>studyfe<span class=\"token punctuation\">.</span>cn<span class=\"token operator\">/</span>login<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>大致流程可以分为以下几个阶段</p>\n<ul>\n<li>浏览器发送请求</li>\n<li>服务器监听到请求，解析 url 路径</li>\n<li>根据路由配置，返回资源信息</li>\n<li>浏览器通过解析资源信息，呈现到前端页面</li>\n</ul>\n<h2 id=\"前端路由\"><a href=\"#前端路由\" class=\"headerlink\" title=\"前端路由\"></a>前端路由</h2><h3 id=\"hash-模式\"><a href=\"#hash-模式\" class=\"headerlink\" title=\"hash 模式\"></a>hash 模式<hr></h3><p>在 HTML5 的 history 没有出来之前，要实现前端路由机制而不请求后端资源就应用到了 hash 模式，hash 是指 url 尾巴后的 # 号及后面的字符。也被常称为锚点。hash 改变会触发 hashchange 事件，也能对浏览器的前进后退进行控制</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> <span class=\"token string\">'#toc-heading-1'</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hashchange'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n  <span class=\"token comment\" spellcheck=\"true\">// 根据业务场景进行控制</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"history-模式\"><a href=\"#history-模式\" class=\"headerlink\" title=\"history 模式\"></a>history 模式<hr></h3><p>HTML5标准发布。多了两个 API，history.pushState 和 history.replaceState 来进行路由控制。通过这两个方法可以改变 url 且不向服务器发送请求。比较两种方法</p>\n<ul>\n<li>history 比 hash 更美观，url 后面不会多一个 #，</li>\n<li>history API 可以是更灵活的控制前端路由，例如前进后退等等</li>\n<li>history 模式在用户刷新的时候需要服务端支持进行重定向，避免出现错误</li>\n<li>hash 传参是基于 url 的如果要传递复杂数据会有体积限制</li>\n<li>hash 兼容到 IE8， history 兼容到 IE10</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * @param state：状态对象，通过pushState () 创建新的历史记录条目。大小不能超过640k\n * @param title：标题，基本没用，一般传 null。Firefox 目前忽略这个参数\n * @param url：该参数定义了新的历史URL记录。新的 url 与当前 url 的 origin 必须一样，否则会抛出错误\n */</span>\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">pushState</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> title<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span> \n<span class=\"token comment\" spellcheck=\"true\">// 示例</span>\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">pushState</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://www.studyfe.cn/2018/08/10/vue/vueroute'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/2019/08/27/vue/vueprinciple/\"</span><span class=\"token punctuation\">)</span> \n\n<span class=\"token comment\" spellcheck=\"true\">// 修改当前历史记录与 pushState 类似</span>\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">replaceState</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> title<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span> \n\n <span class=\"token comment\" spellcheck=\"true\">// 监听浏览器前进后退事件</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"popstate\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>            \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 后退</span>\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">forward</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 前进</span>\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 前进一步</span>\nwindow<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>length <span class=\"token comment\" spellcheck=\"true\">// 查看当前记录的栈的数量</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h2><p>vue-router 在开发中 vue 项目中起到了非常大的作用，它支持 hash、history、abstract 3 种路由方式，提供了提供了 <router-link> 和 <router-view> 2 种组件和一系列的路由配置</router-view></router-link></p>\n<p>使用 <router-link> 和 <router-view> 组件进行路由操作</router-view></router-link></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>app<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Hello App!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 使用 router-link 组件来导航. --></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 通过传入 `to` 属性指定链接. --></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- &lt;router-link> 默认会被渲染成一个 `&lt;a>` 标签 --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/foo<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Go to Foo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-link</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/bar<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Go to Bar<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-link</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 路由出口 --></span>\n  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 路由匹配到的组件将渲染在这里 --></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-view</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-view</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用 vue-cli 我们经常会在入口文件进行配置</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span>\n<span class=\"token keyword\">import</span> VueRouter <span class=\"token keyword\">from</span> <span class=\"token string\">'vue-router'</span>\n<span class=\"token keyword\">import</span> App <span class=\"token keyword\">from</span> <span class=\"token string\">'./App'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 1. 定义（路由）组件。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 可以从其他文件 import 进来</span>\n<span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;div>foo&lt;/div>'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> Bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;div>bar&lt;/div>'</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 2. 定义路由</span>\n<span class=\"token comment\" spellcheck=\"true\">// 每个路由应该映射一个组件。 其中\"component\" 可以是</span>\n<span class=\"token comment\" spellcheck=\"true\">// 通过 Vue.extend() 创建的组件构造器，</span>\n<span class=\"token comment\" spellcheck=\"true\">// 或者，只是一个组件配置对象。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 我们晚点再讨论嵌套路由。</span>\n<span class=\"token keyword\">const</span> routes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/foo'</span><span class=\"token punctuation\">,</span> component<span class=\"token punctuation\">:</span> Foo <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/bar'</span><span class=\"token punctuation\">,</span> component<span class=\"token punctuation\">:</span> Bar <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 3. 创建 router 实例，然后传 `routes` 配置</span>\n<span class=\"token comment\" spellcheck=\"true\">// 你还可以传别的配置参数, 不过先这么简单着吧。</span>\n<span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">VueRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  routes <span class=\"token comment\" spellcheck=\"true\">// （缩写）相当于 routes: routes</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 4. 创建和挂载根实例。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 记得要通过 router 配置参数注入路由，</span>\n<span class=\"token comment\" spellcheck=\"true\">// 从而让整个应用都有路由功能</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token string\">'#app'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">h</span><span class=\"token punctuation\">(</span>App<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  router\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的例子可以看到 vue-router 是通过 Vue.use 的方法被注入进 Vue 实例中，那么接下来我们就通过 Vue.use 来了解整个 vue-router</p>\n<h3 id=\"vue-router-实现之-install\"><a href=\"#vue-router-实现之-install\" class=\"headerlink\" title=\"vue-router 实现之 install\"></a>vue-router 实现之 install<hr></h3><p>Vue.use 定义在 <code>vue/src/core/global-api/use.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span>use <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">:</span> Function <span class=\"token operator\">|</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> installedPlugins <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_installedPlugins <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_installedPlugins <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>installedPlugins<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> args <span class=\"token operator\">=</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  args<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> plugin<span class=\"token punctuation\">.</span>install <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    plugin<span class=\"token punctuation\">.</span>install<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> plugin <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    plugin<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  installedPlugins<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>plugin<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面方法很清晰的看到 Vue.use 实际上就是执行这个 install 方法，并且在这个 install 方法的第一个参数我们可以拿到 Vue 对象。Vue-Router 的入口文件是 <code>src/index.js</code>，其中定义了 VueRouter 类，也实现了 install 的静态方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">VueRouter<span class=\"token punctuation\">.</span>install <span class=\"token operator\">=</span> install<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>它的定义在 src/install.js 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> install <span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 混入 beforeCreate 钩子</span>\n  Vue<span class=\"token punctuation\">.</span><span class=\"token function\">mixin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    beforeCreate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 在option上面存在router则代表是根组件 </span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_routerRoot <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_router <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>router\n        <span class=\"token comment\" spellcheck=\"true\">// 执行_router实例的 init 方法</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_router<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 为 vue 实例定义数据劫持</span>\n        Vue<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span><span class=\"token function\">defineReactive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'_route'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_router<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 非根组件则直接从父组件中获取</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_routerRoot <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$parent <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$parent<span class=\"token punctuation\">.</span>_routerRoot<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">this</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">registerInstance</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    destroyed <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">registerInstance</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 设置代理，当访问 this.$router 的时候，代理到 this._routerRoot._router</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token string\">'$router'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_routerRoot<span class=\"token punctuation\">.</span>_router <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 设置代理，当访问 this.$route 的时候，代理到 this._routerRoot._route</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token string\">'$route'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_routerRoot<span class=\"token punctuation\">.</span>_route <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 注册 router-view 和 router-link 组件</span>\n  Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span><span class=\"token string\">'RouterView'</span><span class=\"token punctuation\">,</span> View<span class=\"token punctuation\">)</span>\n  Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span><span class=\"token string\">'RouterLink'</span><span class=\"token punctuation\">,</span> Link<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// Vue钩子合并策略</span>\n  <span class=\"token keyword\">const</span> strats <span class=\"token operator\">=</span> Vue<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>optionMergeStrategies\n  <span class=\"token comment\" spellcheck=\"true\">// use the same hook merging strategy for route hooks</span>\n  strats<span class=\"token punctuation\">.</span>beforeRouteEnter <span class=\"token operator\">=</span> strats<span class=\"token punctuation\">.</span>beforeRouteLeave <span class=\"token operator\">=</span> strats<span class=\"token punctuation\">.</span>beforeRouteUpdate <span class=\"token operator\">=</span> strats<span class=\"token punctuation\">.</span>created\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的伪代码我们看到 Vue-Router 的 install 方法 实际上就是初始化的过程</p>\n<ul>\n<li>混入了 beforeCreate，在执行 <code>new Vue({router})</code> 的时候传入 router 对象，挂在到 vue 的根组件上</li>\n<li>执行 <code>this._router.init(this)</code> </li>\n<li>调用了 <code>Vue.util.defineReactive</code> 方法来进行响应式数据定义，主要是为了路由的变化能够即使响应页面的更新</li>\n<li>通过 registerInstance(this, this) 这个方法来实现对 router-view 的挂载操作</li>\n<li>通过 Object.defineProperty 在 Vue 的原型上定义了 $router 和 $route 2 个属性的 get 方法</li>\n<li>进行组件的注册钩子合并等操作</li>\n</ul>\n<h3 id=\"vue-router-实现之-new-VueRouter\"><a href=\"#vue-router-实现之-new-VueRouter\" class=\"headerlink\" title=\"vue-router 实现之 new VueRouter\"></a>vue-router 实现之 new VueRouter<hr></h3><p> 为了构造出 router 实例对象，VueRouter 定义了一些属性和方法，当我们进行 new VueRouter 的时候，如下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">VueRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  mode<span class=\"token punctuation\">:</span> <span class=\"token string\">'history'</span><span class=\"token punctuation\">,</span>\n  routes<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'home'</span><span class=\"token punctuation\">,</span> component<span class=\"token punctuation\">:</span> Home <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/foo'</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> component<span class=\"token punctuation\">:</span> Foo <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/bar/:id'</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">,</span> component<span class=\"token punctuation\">:</span> Bar <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>那么接下来我们看看 new VueRouter 的时候做了什么</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">VueRouter</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  constructor <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">:</span> RouterOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>app <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>apps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options <span class=\"token operator\">=</span> options\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beforeHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolveHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>afterHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>matcher <span class=\"token operator\">=</span> <span class=\"token function\">createMatcher</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>routes <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">let</span> mode <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>mode <span class=\"token operator\">||</span> <span class=\"token string\">'hash'</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fallback <span class=\"token operator\">=</span> mode <span class=\"token operator\">===</span> <span class=\"token string\">'history'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>supportsPushState <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>fallback <span class=\"token operator\">!==</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fallback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      mode <span class=\"token operator\">=</span> <span class=\"token string\">'hash'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>inBrowser<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      mode <span class=\"token operator\">=</span> <span class=\"token string\">'abstract'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mode <span class=\"token operator\">=</span> mode\n\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">'history'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HTML5History</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">break</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">'hash'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashHistory</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fallback<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">break</span>\n      <span class=\"token keyword\">case</span> <span class=\"token string\">'abstract'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AbstractHistory</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">break</span>\n      <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`invalid mode: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>mode<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  match <span class=\"token punctuation\">(</span>\n    raw<span class=\"token punctuation\">:</span> RawLocation<span class=\"token punctuation\">,</span>\n    current<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Route<span class=\"token punctuation\">,</span>\n    redirectedFrom<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Location\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Route <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>matcher<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">,</span> redirectedFrom<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">get</span> currentRoute <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Route <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>current\n  <span class=\"token punctuation\">}</span>\n\n  init <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面我们可以看得出 constructor 中 主要是通过参数 mode 来指定路由模式，在最初阶段还进行了兼容判断。如果当前环境不支持 history 模式，会强制切换到 hash 模式。如果当前环境不是浏览器环境，会切换到abstract模式下。然后再根据不同模式来生成不同的 history 操作对象。</p>\n<p>实例化 VueRouter 后会返回它的实例 router，我们在 new Vue 的时候会把 router 作为配置的属性传入，在混入 beforCreate 钩子的时候执行了</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_router<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>接下来我们看看 init 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">init <span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>apps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>app <span class=\"token operator\">=</span> app\n\n  <span class=\"token keyword\">const</span> history <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>history <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">HTML5History</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    history<span class=\"token punctuation\">.</span><span class=\"token function\">transitionTo</span><span class=\"token punctuation\">(</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentLocation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>history <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">HashHistory</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> setupHashListener <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      history<span class=\"token punctuation\">.</span><span class=\"token function\">setupListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    history<span class=\"token punctuation\">.</span><span class=\"token function\">transitionTo</span><span class=\"token punctuation\">(</span>\n      history<span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentLocation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      setupHashListener<span class=\"token punctuation\">,</span>\n      setupHashListener\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  history<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>route <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>apps<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      app<span class=\"token punctuation\">.</span>_route <span class=\"token operator\">=</span> route\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>init 主要是通过 history 不同执行 history.transitionTo 切换路由。最后通过 history.listen 来注册路由变化的响应回调。</p>\n<h3 id=\"vue-router-实现之-HashHistory\"><a href=\"#vue-router-实现之-HashHistory\" class=\"headerlink\" title=\"vue-router 实现之 HashHistory\"></a>vue-router 实现之 HashHistory<hr></h3><p>在上面代码中如果 mode 为 hash 则执行 new HashHistory 函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HashHistory</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">History</span> <span class=\"token punctuation\">{</span>\n  constructor <span class=\"token punctuation\">(</span>router<span class=\"token punctuation\">:</span> Router<span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>string<span class=\"token punctuation\">,</span> fallback<span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>router<span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// check history fallback deeplinking</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fallback <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">checkFallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 保证 hash 是以 / 开头，而不是 #/，如果是 #/就会触发 hashchange 事件 这样执行 beforeEnter 钩子时候会触发两次</span>\n    <span class=\"token function\">ensureSlash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> checkFallback <span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> location <span class=\"token operator\">=</span> <span class=\"token function\">getLocation</span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token regex\">/^\\/#/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token function\">cleanPath</span><span class=\"token punctuation\">(</span>base <span class=\"token operator\">+</span> <span class=\"token string\">'/#'</span> <span class=\"token operator\">+</span> location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> ensureSlash <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> boolean <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">getHash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">replaceHash</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span> <span class=\"token operator\">+</span> path<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> getHash <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> string <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 主要是取 hash，因为兼容性问题所以没有直接使用 window.location.hash</span>\n  <span class=\"token keyword\">let</span> href <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href\n  <span class=\"token keyword\">const</span> index <span class=\"token operator\">=</span> href<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">''</span>\n\n  href <span class=\"token operator\">=</span> href<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> searchIndex <span class=\"token operator\">=</span> href<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>searchIndex <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> hashIndex <span class=\"token operator\">=</span> href<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hashIndex <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      href <span class=\"token operator\">=</span> <span class=\"token function\">decodeURI</span><span class=\"token punctuation\">(</span>href<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> hashIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> href<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>hashIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> href <span class=\"token operator\">=</span> <span class=\"token function\">decodeURI</span><span class=\"token punctuation\">(</span>href<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>searchIndex <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      href <span class=\"token operator\">=</span> <span class=\"token function\">decodeURI</span><span class=\"token punctuation\">(</span>href<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> searchIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> href<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>searchIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> href\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在 init 的时候如果是 HashHistory 则会执行 history.transitionTo</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">history<span class=\"token punctuation\">.</span><span class=\"token function\">transitionTo</span><span class=\"token punctuation\">(</span>\n  history<span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentLocation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  setupHashListener<span class=\"token punctuation\">,</span>\n  setupHashListener\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">transitionTo <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">:</span> RawLocation<span class=\"token punctuation\">,</span> onComplete<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> onAbort<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\" spellcheck=\"true\">// 通过 match 匹配 URL 的 router 对象 </span>\n    <span class=\"token keyword\">const</span> route <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">confirmTransition</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">updateRoute</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span>\n      onComplete <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onComplete</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">ensureURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// fire ready cbs once</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ready<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ready <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>readyCbs<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>cb <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>onAbort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">onAbort</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ready<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ready <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>readyErrorCbs<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>cb <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>transitionTo 首先根据目标 location 和当前路径 this.current 执行 this.router.match 方法去匹配到目标的路径。这里 this.current 是 history 维护的当前路径，它的初始值是在 history 的构造函数中初始化的：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> START<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>START 的定义在 src/util/route.js 中：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> START <span class=\"token operator\">=</span> <span class=\"token function\">createRoute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样我们就创建了初始的 Route，那么接下来会执行 confirmTransition 做真正的切换处理</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">confirmTransition <span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">:</span> Route<span class=\"token punctuation\">,</span> onComplete<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> onAbort<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current\n  <span class=\"token keyword\">const</span> abort <span class=\"token operator\">=</span> err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    onAbort <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onAbort</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果是相同的路由并且 matched.length 相同，那么进行跳转 / 且记进行中断处理</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token function\">isSameRoute</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    route<span class=\"token punctuation\">.</span>matched<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> current<span class=\"token punctuation\">.</span>matched<span class=\"token punctuation\">.</span>length\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">ensureURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n    updated<span class=\"token punctuation\">,</span>\n    deactivated<span class=\"token punctuation\">,</span>\n    activated\n  <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">resolveQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span>matched<span class=\"token punctuation\">,</span> route<span class=\"token punctuation\">.</span>matched<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 整个切换周期的队列</span>\n  <span class=\"token keyword\">const</span> queue<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>NavigationGuard<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 得到即将被销毁组建的 beforeRouteLeave 钩子函数</span>\n    <span class=\"token function\">extractLeaveGuards</span><span class=\"token punctuation\">(</span>deactivated<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 全局 router before hooks</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span>beforeHooks<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 得到组件 updated 钩子</span>\n    <span class=\"token function\">extractUpdateHooks</span><span class=\"token punctuation\">(</span>updated<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将要更新的路由的 beforeEnter 钩子</span>\n    activated<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">=</span><span class=\"token operator\">></span> m<span class=\"token punctuation\">.</span>beforeEnter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 异步组件的执行</span>\n    <span class=\"token function\">resolveAsyncComponents</span><span class=\"token punctuation\">(</span>activated<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pending <span class=\"token operator\">=</span> route\n  <span class=\"token comment\" spellcheck=\"true\">// 每一个队列执行的 iterator 函数</span>\n  <span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">:</span> NavigationGuard<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 执行队列 leave 和 beforeEnter 相关钩子</span>\n  <span class=\"token function\">runQueue</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面函数的内部实现我们就略过通过注释我们知道它的作用就可以了，现在我们屡一下上面的流程</p>\n<ul>\n<li>执行 transitionTo 函数，通过 match 函数的匹配得到 router 对象</li>\n<li>执行 confirmTransition 函数，判断是否需要跳转，如果不需要则进行中断处理，否则先得到钩子函数的任务队列 queue</li>\n<li>通过 runQueue 函数来批次执行任务队列中的每个方法</li>\n<li>执行 queue 的钩子函数的时候，通过 iterator 来构造迭代器由用户传入 next 方法，确定执行的过程</li>\n<li>整个队列执行完毕后，开始处理完成后的回调函数。</li>\n</ul>\n<blockquote>\n<p>导航守卫</p>\n</blockquote>\n<p>导航守卫，实际上就是发生在路由路径切换的时候，执行的一系列钩子函数。</p>\n<p>我们先从整体上看一下这些钩子函数执行的逻辑，首先构造一个队列 queue，它实际上是一个数组；然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法来执行这个队列。我们先来看一下 runQueue 的定义，在 <code>src/util/async.js</code> 中：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> runQueue <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>NavigationGuard<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> step <span class=\"token operator\">=</span> index <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">>=</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">step</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">step</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这是非常经典的异步函数队列执行模式，fn 就是我们传入的 iterator 函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">:</span> NavigationGuard<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pending <span class=\"token operator\">!==</span> route<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">hook</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>to <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">||</span> <span class=\"token function\">isError</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">ensureURL</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">abort</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">typeof</span> to <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span> <span class=\"token operator\">||</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> to <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>\n          <span class=\"token keyword\">typeof</span> to<span class=\"token punctuation\">.</span>path <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span> <span class=\"token operator\">||</span>\n          <span class=\"token keyword\">typeof</span> to<span class=\"token punctuation\">.</span>name <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> to <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> to<span class=\"token punctuation\">.</span>replace<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">abort</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>iterator 函数就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数分别对应得到是文档中的 to、from、next 当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法来 resolve 这个钩子函数。</p>\n<p>最后我们来看一下 queue 是怎么构造的</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> queue<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>NavigationGuard<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">extractLeaveGuards</span><span class=\"token punctuation\">(</span>deactivated<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span>beforeHooks<span class=\"token punctuation\">,</span>\n  <span class=\"token function\">extractUpdateHooks</span><span class=\"token punctuation\">(</span>updated<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  activated<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">=</span><span class=\"token operator\">></span> m<span class=\"token punctuation\">.</span>beforeEnter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">resolveAsyncComponents</span><span class=\"token punctuation\">(</span>activated<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>按照顺序如下：</p>\n<ol>\n<li><p>在失活的组件里调用离开守卫。</p>\n</li>\n<li><p>调用全局的 beforeEach 守卫。</p>\n</li>\n<li><p>在重用的组件里调用 beforeRouteUpdate 守卫</p>\n</li>\n<li><p>在激活的路由配置里调用 beforeEnter。</p>\n</li>\n<li><p>解析异步路由组件。</p>\n</li>\n</ol>\n<p>接下来我们来分别介绍这 5 步的实现</p>\n<p>第一步执行 extractLeaveGuards(deactivated)，先来看一下 extractLeaveGuards 的定义</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> extractLeaveGuards <span class=\"token punctuation\">(</span>deactivated<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>RouteRecord<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>Function<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">extractGuards</span><span class=\"token punctuation\">(</span>deactivated<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeRouteLeave'</span><span class=\"token punctuation\">,</span> bindGuard<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>它内部调用了 extractGuards 的通用方法，可以从 RouteRecord 数组中提取各个阶段的守卫</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> extractGuards <span class=\"token punctuation\">(</span>\n  records<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>RouteRecord<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  name<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  bind<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span>\n  reverse<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>Function<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> guards <span class=\"token operator\">=</span> <span class=\"token function\">flatMapComponents</span><span class=\"token punctuation\">(</span>records<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>def<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">,</span> match<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> guard <span class=\"token operator\">=</span> <span class=\"token function\">extractGuard</span><span class=\"token punctuation\">(</span>def<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>guard<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>guard<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">?</span> guard<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>guard <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>guard<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">,</span> match<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">:</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>guard<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">,</span> match<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span>reverse <span class=\"token operator\">?</span> guards<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> guards<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里用到了 flatMapComponents 方法去从 records 中获取所有的导航，它的定义在 <code>src/util/resolve-components.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> flatMapComponents <span class=\"token punctuation\">(</span>\n  matched<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>RouteRecord<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  fn<span class=\"token punctuation\">:</span> Function\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>Function<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span>matched<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>components<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>\n      m<span class=\"token punctuation\">.</span>components<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      m<span class=\"token punctuation\">.</span>instances<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      m<span class=\"token punctuation\">,</span> key\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> flatten <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>concat<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>flatMapComponents 的作用就是返回一个数组，数组的元素是从 matched 里获取到所有组件的 key，然后返回 fn 函数执行的结果，flatten 作用是把二维数组拍平成一维数组。</p>\n<p>那么对于 extractGuards 中 flatMapComponents 的调用，执行每个 fn 的时候，通过 extractGuard(def, name) 获取到组件中对应 name 的导航守卫</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> extractGuard <span class=\"token punctuation\">(</span>\n  def<span class=\"token punctuation\">:</span> Object <span class=\"token operator\">|</span> Function<span class=\"token punctuation\">,</span>\n  key<span class=\"token punctuation\">:</span> string\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> NavigationGuard <span class=\"token operator\">|</span> Array<span class=\"token operator\">&lt;</span>NavigationGuard<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> def <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    def <span class=\"token operator\">=</span> _Vue<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>def<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> def<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>获取到 guard 后，还会调用 bind 方法把组件的实例 instance 作为函数执行的上下文绑定到 guard 上，bind 方法的对应的是 bindGuard</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> bindGuard <span class=\"token punctuation\">(</span>guard<span class=\"token punctuation\">:</span> NavigationGuard<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>_Vue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>NavigationGuard <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> boundRouteGuard <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> guard<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>那么对于 extractLeaveGuards(deactivated) 而言，获取到的就是所有失活组件中定义的 beforeRouteLeave 钩子函数。</p>\n<p>第二步是 <code>this.router.beforeHooks</code>，在我们的 VueRouter 类中定义了 beforeEach 方法，在 <code>src/index.js</code> 中：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">beforeEach <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">registerHook</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beforeHooks<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> registerHook <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n  list<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> i <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当用户使用 router.beforeEach 注册了一个全局守卫，就会往 router.beforeHooks 添加一个钩子函数，这样 this.router.beforeHooks 获取的就是用户注册的全局 beforeEach 守卫。</p>\n<p>第三步执行了 extractUpdateHooks(updated)，来看一下 extractUpdateHooks 的定义：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> extractUpdateHooks <span class=\"token punctuation\">(</span>updated<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>RouteRecord<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>Function<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">extractGuards</span><span class=\"token punctuation\">(</span>updated<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeRouteUpdate'</span><span class=\"token punctuation\">,</span> bindGuard<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>和 extractLeaveGuards(deactivated) 类似，extractUpdateHooks(updated) 获取到的就是所有重用的组件中定义的 beforeRouteUpdate 钩子函数</p>\n<p>第四步是执行 activated.map(m =&gt; m.beforeEnter)，获取的是在激活的路由配置中定义的 beforeEnter 函数。</p>\n<p>第五步是执行 resolveAsyncComponents(activated) 解析异步组件，先来看一下 resolveAsyncComponents 的定义，在 <code>src/util/resolve-components.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> resolveAsyncComponents <span class=\"token punctuation\">(</span>matched<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>RouteRecord<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Function <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> hasAsync <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">let</span> pending <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">let</span> error <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n\n    <span class=\"token function\">flatMapComponents</span><span class=\"token punctuation\">(</span>matched<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>def<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">,</span> match<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> def <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">&amp;&amp;</span> def<span class=\"token punctuation\">.</span>cid <span class=\"token operator\">===</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        hasAsync <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        pending<span class=\"token operator\">++</span>\n\n        <span class=\"token keyword\">const</span> resolve <span class=\"token operator\">=</span> <span class=\"token function\">once</span><span class=\"token punctuation\">(</span>resolvedDef <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isESModule</span><span class=\"token punctuation\">(</span>resolvedDef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            resolvedDef <span class=\"token operator\">=</span> resolvedDef<span class=\"token punctuation\">.</span><span class=\"token keyword\">default</span>\n          <span class=\"token punctuation\">}</span>\n          def<span class=\"token punctuation\">.</span>resolved <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> resolvedDef <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span>\n            <span class=\"token operator\">?</span> resolvedDef\n            <span class=\"token punctuation\">:</span> _Vue<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>resolvedDef<span class=\"token punctuation\">)</span>\n          match<span class=\"token punctuation\">.</span>components<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> resolvedDef\n          pending<span class=\"token operator\">--</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pending <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">const</span> reject <span class=\"token operator\">=</span> <span class=\"token function\">once</span><span class=\"token punctuation\">(</span>reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> msg <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`Failed to resolve async component </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>reason<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span>\n          process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            error <span class=\"token operator\">=</span> <span class=\"token function\">isError</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span>\n              <span class=\"token operator\">?</span> reason\n              <span class=\"token punctuation\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">let</span> res\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n          res <span class=\"token operator\">=</span> <span class=\"token function\">def</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> res<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            res<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> comp <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>component\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>comp <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> comp<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              comp<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasAsync<span class=\"token punctuation\">)</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>resolveAsyncComponents 返回的是一个导航守卫函数，有标准的 to、from、next 参数。它的内部实现很简单，利用了 flatMapComponents 方法从 matched 中获取到每个组件的定义，判断如果是异步组件，则执行异步组件加载逻辑，加载成功后会执行 match.components[key] = resolvedDef 把解析好的异步组件放到对应的 components 上，并且执行 next 函数。</p>\n<p>这样在 resolveAsyncComponents(activated) 解析完所有激活的异步组件后，我们就可以拿到这一次所有激活的组件。这样我们在做完这 5 步后又做了一些事情</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">runQueue</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> postEnterCbs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">===</span> route\n  <span class=\"token keyword\">const</span> enterGuards <span class=\"token operator\">=</span> <span class=\"token function\">extractEnterGuards</span><span class=\"token punctuation\">(</span>activated<span class=\"token punctuation\">,</span> postEnterCbs<span class=\"token punctuation\">,</span> isValid<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> enterGuards<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span>resolveHooks<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">runQueue</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pending <span class=\"token operator\">!==</span> route<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pending <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token function\">onComplete</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span><span class=\"token function\">$nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        postEnterCbs<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>cb <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"6\">\n<li><p>在被激活的组件里调用 beforeRouteEnter。</p>\n</li>\n<li><p>调用全局的 beforeResolve 守卫。</p>\n</li>\n<li><p>调用全局的 afterEach 钩子。</p>\n</li>\n</ol>\n<p>可以看到，当处理完任务队列之后的回调主要是接入路由组件后期的钩子函数 beforeRouteEnter 和 beforeResolve，并进行队列执行。最后执行回调函数 onComplete</p>\n<p>到这里，已经完成了对当前 route 的切换动作，在完成路由切换后执行了 <code>onComplete &amp;&amp; onComplete(route)</code> ，那么主要会引起 url 和 组件的变化我们来看看</p>\n<p>当我们点击 router-link 的时候，实际上最终会执行 router.push，如下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">push <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">:</span> RawLocation<span class=\"token punctuation\">,</span> onComplete<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> onAbort<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span> onComplete<span class=\"token punctuation\">,</span> onAbort<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>this.history.push 函数，这个函数是子类实现的，不同模式下该函数的实现略有不同，我们来看一下平时使用比较多的 hash 模式该函数的实现，在 <code>src/history/hash.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">push <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">:</span> RawLocation<span class=\"token punctuation\">,</span> onComplete<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> onAbort<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> current<span class=\"token punctuation\">:</span> fromRoute <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">transitionTo</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span> route <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">pushHash</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">.</span>fullPath<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">handleScroll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">,</span> route<span class=\"token punctuation\">,</span> fromRoute<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    onComplete <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">onComplete</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> onAbort<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>push 函数会先执行 this.transitionTo 做路径切换，在切换完成的回调函数中，执行 pushHash 函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> pushHash <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>supportsPushState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">pushState</span><span class=\"token punctuation\">(</span><span class=\"token function\">getUrl</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> path\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>supportsPushState 的定义在 <code>src/util/push-state.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> supportsPushState <span class=\"token operator\">=</span> inBrowser <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> ua <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>navigator<span class=\"token punctuation\">.</span>userAgent\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span>ua<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Android 2.'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> ua<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Android 4.0'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    ua<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Mobile Safari'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    ua<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Chrome'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span>\n    ua<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Windows Phone'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> window<span class=\"token punctuation\">.</span>history <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">'pushState'</span> <span class=\"token keyword\">in</span> window<span class=\"token punctuation\">.</span>history\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果支持的话，则获取当前完整的 url，执行 pushState 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> pushState <span class=\"token punctuation\">(</span>url<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span> replace<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">saveScrollPosition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> history <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>history\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>replace<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      history<span class=\"token punctuation\">.</span><span class=\"token function\">replaceState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> key<span class=\"token punctuation\">:</span> _key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      _key <span class=\"token operator\">=</span> <span class=\"token function\">genKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      history<span class=\"token punctuation\">.</span><span class=\"token function\">pushState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> key<span class=\"token punctuation\">:</span> _key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">[</span>replace <span class=\"token operator\">?</span> <span class=\"token string\">'replace'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'assign'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>pushState 会调用浏览器原生的 history 的 pushState 接口或者 replaceState 接口，更新浏览器的 url 地址，并把当前 url 压入历史栈中。</p>\n<p>然后在 history 的初始化中，会设置一个监听器，监听历史栈的变化</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">setupListeners <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router\n  <span class=\"token comment\" spellcheck=\"true\">// 处理滚动</span>\n  <span class=\"token keyword\">const</span> expectScroll <span class=\"token operator\">=</span> router<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>scrollBehavior\n  <span class=\"token keyword\">const</span> supportsScroll <span class=\"token operator\">=</span> supportsPushState <span class=\"token operator\">&amp;&amp;</span> expectScroll\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>supportsScroll<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setupScroll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 通过 supportsPushState 判断监听popstate 还是 hashchange</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>supportsPushState <span class=\"token operator\">?</span> <span class=\"token string\">'popstate'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'hashchange'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current\n    <span class=\"token comment\" spellcheck=\"true\">// 判断路由格式</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">ensureSlash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">transitionTo</span><span class=\"token punctuation\">(</span><span class=\"token function\">getHash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> route <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>supportsScroll<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">handleScroll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>router<span class=\"token punctuation\">,</span> route<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果不支持 history 模式，则换成 hash 模式</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>supportsPushState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">replaceHash</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">.</span>fullPath<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。</p>\n<p>可以看到 setupListeners 这里主要做了 2 件事情，一个是对路由切换滚动位置的处理，另一个是对路由变动做了一次监听。这样我们就完成了对真个 hash 的分析过程</p>\n<h3 id=\"vue-router-实现之-HTML5History\"><a href=\"#vue-router-实现之-HTML5History\" class=\"headerlink\" title=\"vue-router 实现之 HTML5History\"></a>vue-router 实现之 HTML5History<hr></h3><p>当初始化的时候 mode 等于 history 模式的时候，就会执行 HTML5History，然后会执行 history 对象上的 transitionTo 方法</p>\n<p>在vue-router实例化过程中，执行对 HTML5History 的实例化</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HTML5History</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>看一下 HTML5History 函数的构造</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  constructor <span class=\"token punctuation\">(</span>router<span class=\"token punctuation\">:</span> Router<span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>string<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 实现 base 基类中的构造函数</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>router<span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 滚动信息处理</span>\n    <span class=\"token keyword\">const</span> expectScroll <span class=\"token operator\">=</span> router<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>scrollBehavior\n    <span class=\"token keyword\">const</span> supportsScroll <span class=\"token operator\">=</span> supportsPushState <span class=\"token operator\">&amp;&amp;</span> expectScroll\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>supportsScroll<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setupScroll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">const</span> initLocation <span class=\"token operator\">=</span> <span class=\"token function\">getLocation</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">)</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'popstate'</span><span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current\n\n      <span class=\"token comment\" spellcheck=\"true\">// 避免在有的浏览器中第一次加载路由就会触发 `popstate` 事件</span>\n      <span class=\"token keyword\">const</span> location <span class=\"token operator\">=</span> <span class=\"token function\">getLocation</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>current <span class=\"token operator\">===</span> START <span class=\"token operator\">&amp;&amp;</span> location <span class=\"token operator\">===</span> initLocation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 执行跳转动作</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">transitionTo</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span> route <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>supportsScroll<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">handleScroll</span><span class=\"token punctuation\">(</span>router<span class=\"token punctuation\">,</span> route<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到，只是调用基类构造函数以及初始化监听事件。由于在上面已经介绍了 transitionTo 和 confirmTransition。这里不再过多介绍了。那么我们来看几个之前没介绍的一下 API 吧</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  push <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">:</span> RawLocation<span class=\"token punctuation\">,</span> onComplete<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> onAbort<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span> onComplete<span class=\"token punctuation\">,</span> onAbort<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  replace <span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">:</span> RawLocation<span class=\"token punctuation\">,</span> onComplete<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">,</span> onAbort<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Function<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">,</span> onComplete<span class=\"token punctuation\">,</span> onAbort<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  go <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  back <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  forward <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到 vue-router 这个 API 实际上都是效仿 window.history API 的，所以也不用多说。这样我们就完成了对 HTML5History 的介绍</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结<hr></h3><p>从上面我们看到路径变化是路由中最重要的功能，在路由记性切换的时候会把当前的路线切换到目标路线，切换过程中会执行一系列的导航守卫钩子函数，更改 url，同时渲染组件。其实最重要的几个函数就是</p>\n<ul>\n<li>match 进行匹配路由得到路由对象</li>\n<li>transitionTo 做路径切换</li>\n<li>confirmTransition 处理队列的钩子函数，在处理钩子函数的时候会按照上面介绍的执行 8 个小步骤的顺序</li>\n<li>setupListeners 监听导航等功能</li>\n</ul>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>路由的概念，在现在的前端领域其实不算陌生。它的作用就是根据不用的路径去映射到不同的视图。</p>\n<h2 id=\"后端路由\"><a href=\"#后端路由\" class=\"headerlink\" title=\"后端路由\"></a>后端路由</h2><p>路由的概念实际上是从后端开始由来的，后端根据不同的路径去匹配不同的资源例如</p>\n<pre><code class=\"js\">https://www.studyfe.cn/login</code></pre>\n<p>大致流程可以分为以下几个阶段</p>\n<ul>\n<li>浏览器发送请求</li>\n<li>服务器监听到请求，解析 url 路径</li>\n<li>根据路由配置，返回资源信息</li>\n<li>浏览器通过解析资源信息，呈现到前端页面</li>\n</ul>\n<h2 id=\"前端路由\"><a href=\"#前端路由\" class=\"headerlink\" title=\"前端路由\"></a>前端路由</h2><h3 id=\"hash-模式\"><a href=\"#hash-模式\" class=\"headerlink\" title=\"hash 模式\"></a>hash 模式<hr></h3><p>在 HTML5 的 history 没有出来之前，要实现前端路由机制而不请求后端资源就应用到了 hash 模式，hash 是指 url 尾巴后的 # 号及后面的字符。也被常称为锚点。hash 改变会触发 hashchange 事件，也能对浏览器的前进后退进行控制</p>\n<pre><code class=\"js\">window.location.hash = &#39;#toc-heading-1&#39;\nwindow.addEventListener(&#39;hashchange&#39;, function(){ \n  // 根据业务场景进行控制\n})</code></pre>\n<h3 id=\"history-模式\"><a href=\"#history-模式\" class=\"headerlink\" title=\"history 模式\"></a>history 模式<hr></h3><p>HTML5标准发布。多了两个 API，history.pushState 和 history.replaceState 来进行路由控制。通过这两个方法可以改变 url 且不向服务器发送请求。比较两种方法</p>\n<ul>\n<li>history 比 hash 更美观，url 后面不会多一个 #，</li>\n<li>history API 可以是更灵活的控制前端路由，例如前进后退等等</li>\n<li>history 模式在用户刷新的时候需要服务端支持进行重定向，避免出现错误</li>\n<li>hash 传参是基于 url 的如果要传递复杂数据会有体积限制</li>\n<li>hash 兼容到 IE8， history 兼容到 IE10</li>\n</ul>\n<pre><code class=\"js\">/**\n * @param state：状态对象，通过pushState () 创建新的历史记录条目。大小不能超过640k\n * @param title：标题，基本没用，一般传 null。Firefox 目前忽略这个参数\n * @param url：该参数定义了新的历史URL记录。新的 url 与当前 url 的 origin 必须一样，否则会抛出错误\n */\nwindow.history.pushState(state, title, url) \n// 示例\nwindow.history.pushState(&#39;https://www.studyfe.cn/2018/08/10/vue/vueroute&#39;, null, &quot;/2019/08/27/vue/vueprinciple/&quot;) \n\n// 修改当前历史记录与 pushState 类似\nwindow.history.replaceState(state, title, url) \n\n // 监听浏览器前进后退事件\nwindow.addEventListener(&quot;popstate&quot;, function(e) {\n  console.log(e)            \n});\n\nwindow.history.back() // 后退\nwindow.history.forward() // 前进\nwindow.history.go(1) // 前进一步\nwindow.history.length // 查看当前记录的栈的数量</code></pre>\n<h2 id=\"vue-router\"><a href=\"#vue-router\" class=\"headerlink\" title=\"vue-router\"></a>vue-router</h2><p>vue-router 在开发中 vue 项目中起到了非常大的作用，它支持 hash、history、abstract 3 种路由方式，提供了提供了 <router-link> 和 <router-view> 2 种组件和一系列的路由配置</router-view></router-link></p>\n<p>使用 <router-link> 和 <router-view> 组件进行路由操作</router-view></router-link></p>\n<pre><code class=\"html\">&lt;div id=&quot;app&quot;&gt;\n  &lt;h1&gt;Hello App!&lt;/h1&gt;\n  &lt;p&gt;\n    &lt;!-- 使用 router-link 组件来导航. --&gt;\n    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;\n    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;\n    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;\n    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;\n  &lt;/p&gt;\n  &lt;!-- 路由出口 --&gt;\n  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;</code></pre>\n<p>使用 vue-cli 我们经常会在入口文件进行配置</p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\nimport App from &#39;./App&#39;\n\n// 1. 定义（路由）组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }\nconst Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: &#39;/foo&#39;, component: Foo },\n  { path: &#39;/bar&#39;, component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // （缩写）相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  el: &#39;#app&#39;,\n  render(h) {\n    return h(App)\n  },\n  router\n})</code></pre>\n<p>通过上面的例子可以看到 vue-router 是通过 Vue.use 的方法被注入进 Vue 实例中，那么接下来我们就通过 Vue.use 来了解整个 vue-router</p>\n<h3 id=\"vue-router-实现之-install\"><a href=\"#vue-router-实现之-install\" class=\"headerlink\" title=\"vue-router 实现之 install\"></a>vue-router 实现之 install<hr></h3><p>Vue.use 定义在 <code>vue/src/core/global-api/use.js</code> 中</p>\n<pre><code class=\"js\">Vue.use = function (plugin: Function | Object) {\n  const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n  if (installedPlugins.indexOf(plugin) &gt; -1) {\n    return this\n  }\n\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === &#39;function&#39;) {\n    plugin.install.apply(plugin, args)\n  } else if (typeof plugin === &#39;function&#39;) {\n    plugin.apply(null, args)\n  }\n  installedPlugins.push(plugin)\n  return this\n}</code></pre>\n<p>通过上面方法很清晰的看到 Vue.use 实际上就是执行这个 install 方法，并且在这个 install 方法的第一个参数我们可以拿到 Vue 对象。Vue-Router 的入口文件是 <code>src/index.js</code>，其中定义了 VueRouter 类，也实现了 install 的静态方法</p>\n<pre><code class=\"js\">VueRouter.install = install</code></pre>\n<p>它的定义在 src/install.js 中</p>\n<pre><code class=\"js\">// ...\nexport function install (Vue) {\n // ...\n  // 混入 beforeCreate 钩子\n  Vue.mixin({\n    beforeCreate () {\n      // 在option上面存在router则代表是根组件 \n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        // 执行_router实例的 init 方法\n        this._router.init(this)\n        // 为 vue 实例定义数据劫持\n        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)\n      } else {\n        // 非根组件则直接从父组件中获取\n        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n\n  // 设置代理，当访问 this.$router 的时候，代理到 this._routerRoot._router\n  Object.defineProperty(Vue.prototype, &#39;$router&#39;, {\n    get () { return this._routerRoot._router }\n  })\n  // 设置代理，当访问 this.$route 的时候，代理到 this._routerRoot._route\n  Object.defineProperty(Vue.prototype, &#39;$route&#39;, {\n    get () { return this._routerRoot._route }\n  })\n\n  // 注册 router-view 和 router-link 组件\n  Vue.component(&#39;RouterView&#39;, View)\n  Vue.component(&#39;RouterLink&#39;, Link)\n\n  // Vue钩子合并策略\n  const strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n  // ...\n}</code></pre>\n<p>通过上面的伪代码我们看到 Vue-Router 的 install 方法 实际上就是初始化的过程</p>\n<ul>\n<li>混入了 beforeCreate，在执行 <code>new Vue({router})</code> 的时候传入 router 对象，挂在到 vue 的根组件上</li>\n<li>执行 <code>this._router.init(this)</code> </li>\n<li>调用了 <code>Vue.util.defineReactive</code> 方法来进行响应式数据定义，主要是为了路由的变化能够即使响应页面的更新</li>\n<li>通过 registerInstance(this, this) 这个方法来实现对 router-view 的挂载操作</li>\n<li>通过 Object.defineProperty 在 Vue 的原型上定义了 $router 和 $route 2 个属性的 get 方法</li>\n<li>进行组件的注册钩子合并等操作</li>\n</ul>\n<h3 id=\"vue-router-实现之-new-VueRouter\"><a href=\"#vue-router-实现之-new-VueRouter\" class=\"headerlink\" title=\"vue-router 实现之 new VueRouter\"></a>vue-router 实现之 new VueRouter<hr></h3><p> 为了构造出 router 实例对象，VueRouter 定义了一些属性和方法，当我们进行 new VueRouter 的时候，如下</p>\n<pre><code class=\"js\">const router = new VueRouter({\n  mode: &#39;history&#39;,\n  routes: [\n    { path: &#39;/&#39;, name: &#39;home&#39;, component: Home },\n    { path: &#39;/foo&#39;, name: &#39;foo&#39;, component: Foo },\n    { path: &#39;/bar/:id&#39;, name: &#39;bar&#39;, component: Bar }\n  ]\n})</code></pre>\n<p>那么接下来我们看看 new VueRouter 的时候做了什么</p>\n<pre><code class=\"js\">export default class VueRouter {\n\n  // ...\n  constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || &#39;hash&#39;\n    this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n    if (this.fallback) {\n      mode = &#39;hash&#39;\n    }\n    if (!inBrowser) {\n      mode = &#39;abstract&#39;\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case &#39;history&#39;:\n        this.history = new HTML5History(this, options.base)\n        break\n      case &#39;hash&#39;:\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case &#39;abstract&#39;:\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n\n  match (\n    raw: RawLocation,\n    current?: Route,\n    redirectedFrom?: Location\n  ): Route {\n    return this.matcher.match(raw, current, redirectedFrom)\n  }\n\n  get currentRoute (): ?Route {\n    return this.history &amp;&amp; this.history.current\n  }\n\n  init () {}\n  // ...</code></pre>\n<p>通过上面我们可以看得出 constructor 中 主要是通过参数 mode 来指定路由模式，在最初阶段还进行了兼容判断。如果当前环境不支持 history 模式，会强制切换到 hash 模式。如果当前环境不是浏览器环境，会切换到abstract模式下。然后再根据不同模式来生成不同的 history 操作对象。</p>\n<p>实例化 VueRouter 后会返回它的实例 router，我们在 new Vue 的时候会把 router 作为配置的属性传入，在混入 beforCreate 钩子的时候执行了</p>\n<pre><code class=\"js\">this._router.init(this)</code></pre>\n<p>接下来我们看看 init 方法</p>\n<pre><code class=\"js\">init (app: any) {\n  // ...\n  this.apps.push(app)\n\n  if (this.app) {\n    return\n  }\n\n  this.app = app\n\n  const history = this.history\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } else if (history instanceof HashHistory) {\n    const setupHashListener = () =&gt; {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n\n  history.listen(route =&gt; {\n    this.apps.forEach((app) =&gt; {\n      app._route = route\n    })\n  })\n}</code></pre>\n<p>init 主要是通过 history 不同执行 history.transitionTo 切换路由。最后通过 history.listen 来注册路由变化的响应回调。</p>\n<h3 id=\"vue-router-实现之-HashHistory\"><a href=\"#vue-router-实现之-HashHistory\" class=\"headerlink\" title=\"vue-router 实现之 HashHistory\"></a>vue-router 实现之 HashHistory<hr></h3><p>在上面代码中如果 mode 为 hash 则执行 new HashHistory 函数</p>\n<pre><code class=\"js\">export class HashHistory extends History {\n  constructor (router: Router, base: ?string, fallback: boolean) {\n    super(router, base)\n    // check history fallback deeplinking\n    if (fallback &amp;&amp; checkFallback(this.base)) {\n      return\n    }\n    // 保证 hash 是以 / 开头，而不是 #/，如果是 #/就会触发 hashchange 事件 这样执行 beforeEnter 钩子时候会触发两次\n    ensureSlash()\n  }\n  // ...\n}\n\nfunction checkFallback (base) {\n  const location = getLocation(base)\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + &#39;/#&#39; + location))\n    return true\n  }\n}\n\nfunction ensureSlash (): boolean {\n  const path = getHash()\n  if (path.charAt(0) === &#39;/&#39;) {\n    return true\n  }\n  replaceHash(&#39;/&#39; + path)\n  return false\n}\n\nexport function getHash (): string {\n\n  // 主要是取 hash，因为兼容性问题所以没有直接使用 window.location.hash\n  let href = window.location.href\n  const index = href.indexOf(&#39;#&#39;)\n  if (index &lt; 0) return &#39;&#39;\n\n  href = href.slice(index + 1)\n  const searchIndex = href.indexOf(&#39;?&#39;)\n  if (searchIndex &lt; 0) {\n    const hashIndex = href.indexOf(&#39;#&#39;)\n    if (hashIndex &gt; -1) {\n      href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex)\n    } else href = decodeURI(href)\n  } else {\n    if (searchIndex &gt; -1) {\n      href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex)\n    }\n  }\n\n  return href\n}\n// ...</code></pre>\n<p>在 init 的时候如果是 HashHistory 则会执行 history.transitionTo</p>\n<pre><code class=\"js\">history.transitionTo(\n  history.getCurrentLocation(),\n  setupHashListener,\n  setupHashListener\n)</code></pre>\n<pre><code class=\"js\">transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n   // 通过 match 匹配 URL 的 router 对象 \n    const route = this.router.match(location, this.current)\n    this.confirmTransition(route, () =&gt; {\n      this.updateRoute(route)\n      onComplete &amp;&amp; onComplete(route)\n      this.ensureURL()\n\n      // fire ready cbs once\n      if (!this.ready) {\n        this.ready = true\n        this.readyCbs.forEach(cb =&gt; { cb(route) })\n      }\n    }, err =&gt; {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err &amp;&amp; !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb =&gt; { cb(err) })\n      }\n    })\n  }</code></pre>\n<p>transitionTo 首先根据目标 location 和当前路径 this.current 执行 this.router.match 方法去匹配到目标的路径。这里 this.current 是 history 维护的当前路径，它的初始值是在 history 的构造函数中初始化的：</p>\n<pre><code class=\"js\">this.current = START</code></pre>\n<p>START 的定义在 src/util/route.js 中：</p>\n<pre><code class=\"js\">// ...\nexport const START = createRoute(null, {\n  path: &#39;/&#39;\n})</code></pre>\n<p>这样我们就创建了初始的 Route，那么接下来会执行 confirmTransition 做真正的切换处理</p>\n<pre><code class=\"js\">confirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n  const current = this.current\n  const abort = err =&gt; {\n    // ...\n    onAbort &amp;&amp; onAbort(err)\n  }\n  // 如果是相同的路由并且 matched.length 相同，那么进行跳转 / 且记进行中断处理\n  if (\n    isSameRoute(route, current) &amp;&amp;\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n\n  const {\n    updated,\n    deactivated,\n    activated\n  } = resolveQueue(this.current.matched, route.matched)\n\n  // 整个切换周期的队列\n  const queue: Array&lt;?NavigationGuard&gt; = [].concat(\n    // 得到即将被销毁组建的 beforeRouteLeave 钩子函数\n    extractLeaveGuards(deactivated),\n    // 全局 router before hooks\n    this.router.beforeHooks,\n    // 得到组件 updated 钩子\n    extractUpdateHooks(updated),\n    // 将要更新的路由的 beforeEnter 钩子\n    activated.map(m =&gt; m.beforeEnter),\n    // 异步组件的执行\n    resolveAsyncComponents(activated)\n  )\n\n  this.pending = route\n  // 每一个队列执行的 iterator 函数\n  const iterator = (hook: NavigationGuard, next) =&gt; {\n    // ...\n  }\n  // 执行队列 leave 和 beforeEnter 相关钩子\n  runQueue(queue, iterator, () =&gt; {\n    // ...\n  })\n}</code></pre>\n<p>上面函数的内部实现我们就略过通过注释我们知道它的作用就可以了，现在我们屡一下上面的流程</p>\n<ul>\n<li>执行 transitionTo 函数，通过 match 函数的匹配得到 router 对象</li>\n<li>执行 confirmTransition 函数，判断是否需要跳转，如果不需要则进行中断处理，否则先得到钩子函数的任务队列 queue</li>\n<li>通过 runQueue 函数来批次执行任务队列中的每个方法</li>\n<li>执行 queue 的钩子函数的时候，通过 iterator 来构造迭代器由用户传入 next 方法，确定执行的过程</li>\n<li>整个队列执行完毕后，开始处理完成后的回调函数。</li>\n</ul>\n<blockquote>\n<p>导航守卫</p>\n</blockquote>\n<p>导航守卫，实际上就是发生在路由路径切换的时候，执行的一系列钩子函数。</p>\n<p>我们先从整体上看一下这些钩子函数执行的逻辑，首先构造一个队列 queue，它实际上是一个数组；然后再定义一个迭代器函数 iterator；最后再执行 runQueue 方法来执行这个队列。我们先来看一下 runQueue 的定义，在 <code>src/util/async.js</code> 中：</p>\n<pre><code class=\"js\">export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function) {\n  const step = index =&gt; { \n    if (index &gt;= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        fn(queue[index], () =&gt; {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}</code></pre>\n<p>这是非常经典的异步函数队列执行模式，fn 就是我们传入的 iterator 函数</p>\n<pre><code class=\"js\">const iterator = (hook: NavigationGuard, next) =&gt; {\n  if (this.pending !== route) {\n    return abort()\n  }\n  try {\n    hook(route, current, (to: any) =&gt; {\n      if (to === false || isError(to)) {\n        this.ensureURL(true)\n        abort(to)\n      } else if (\n        typeof to === &#39;string&#39; ||\n        (typeof to === &#39;object&#39; &amp;&amp; (\n          typeof to.path === &#39;string&#39; ||\n          typeof to.name === &#39;string&#39;\n        ))\n      ) {\n        abort()\n        if (typeof to === &#39;object&#39; &amp;&amp; to.replace) {\n          this.replace(to)\n        } else {\n          this.push(to)\n        }\n      } else {\n        next(to)\n      }\n    })\n  } catch (e) {\n    abort(e)\n  }\n}</code></pre>\n<p>iterator 函数就是去执行每一个导航守卫 hook，并传入 route、current 和匿名函数，这些参数分别对应得到是文档中的 to、from、next 当执行了匿名函数，会根据一些条件执行 abort 或 next，只有执行 next 的时候，才会前进到下一个导航守卫钩子函数中，这也就是为什么官方文档会说只有执行 next 方法来 resolve 这个钩子函数。</p>\n<p>最后我们来看一下 queue 是怎么构造的</p>\n<pre><code class=\"js\">const queue: Array&lt;?NavigationGuard&gt; = [].concat(\n  extractLeaveGuards(deactivated),\n  this.router.beforeHooks,\n  extractUpdateHooks(updated),\n  activated.map(m =&gt; m.beforeEnter),\n  resolveAsyncComponents(activated)\n)</code></pre>\n<p>按照顺序如下：</p>\n<ol>\n<li><p>在失活的组件里调用离开守卫。</p>\n</li>\n<li><p>调用全局的 beforeEach 守卫。</p>\n</li>\n<li><p>在重用的组件里调用 beforeRouteUpdate 守卫</p>\n</li>\n<li><p>在激活的路由配置里调用 beforeEnter。</p>\n</li>\n<li><p>解析异步路由组件。</p>\n</li>\n</ol>\n<p>接下来我们来分别介绍这 5 步的实现</p>\n<p>第一步执行 extractLeaveGuards(deactivated)，先来看一下 extractLeaveGuards 的定义</p>\n<pre><code class=\"js\">function extractLeaveGuards (deactivated: Array&lt;RouteRecord&gt;): Array&lt;?Function&gt; {\n  return extractGuards(deactivated, &#39;beforeRouteLeave&#39;, bindGuard, true)\n}</code></pre>\n<p>它内部调用了 extractGuards 的通用方法，可以从 RouteRecord 数组中提取各个阶段的守卫</p>\n<pre><code class=\"js\">function extractGuards (\n  records: Array&lt;RouteRecord&gt;,\n  name: string,\n  bind: Function,\n  reverse?: boolean\n): Array&lt;?Function&gt; {\n  const guards = flatMapComponents(records, (def, instance, match, key) =&gt; {\n    const guard = extractGuard(def, name)\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(guard =&gt; bind(guard, instance, match, key))\n        : bind(guard, instance, match, key)\n    }\n  })\n  return flatten(reverse ? guards.reverse() : guards)\n}</code></pre>\n<p>这里用到了 flatMapComponents 方法去从 records 中获取所有的导航，它的定义在 <code>src/util/resolve-components.js</code> 中</p>\n<pre><code class=\"js\">export function flatMapComponents (\n  matched: Array&lt;RouteRecord&gt;,\n  fn: Function\n): Array&lt;?Function&gt; {\n  return flatten(matched.map(m =&gt; {\n    return Object.keys(m.components).map(key =&gt; fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ))\n  }))\n}\n\nexport function flatten (arr: Array&lt;any&gt;): Array&lt;any&gt; {\n  return Array.prototype.concat.apply([], arr)\n}</code></pre>\n<p>flatMapComponents 的作用就是返回一个数组，数组的元素是从 matched 里获取到所有组件的 key，然后返回 fn 函数执行的结果，flatten 作用是把二维数组拍平成一维数组。</p>\n<p>那么对于 extractGuards 中 flatMapComponents 的调用，执行每个 fn 的时候，通过 extractGuard(def, name) 获取到组件中对应 name 的导航守卫</p>\n<pre><code class=\"js\">function extractGuard (\n  def: Object | Function,\n  key: string\n): NavigationGuard | Array&lt;NavigationGuard&gt; {\n  if (typeof def !== &#39;function&#39;) {\n    def = _Vue.extend(def)\n  }\n  return def.options[key]\n}</code></pre>\n<p>获取到 guard 后，还会调用 bind 方法把组件的实例 instance 作为函数执行的上下文绑定到 guard 上，bind 方法的对应的是 bindGuard</p>\n<pre><code class=\"js\">function bindGuard (guard: NavigationGuard, instance: ?_Vue): ?NavigationGuard {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}</code></pre>\n<p>那么对于 extractLeaveGuards(deactivated) 而言，获取到的就是所有失活组件中定义的 beforeRouteLeave 钩子函数。</p>\n<p>第二步是 <code>this.router.beforeHooks</code>，在我们的 VueRouter 类中定义了 beforeEach 方法，在 <code>src/index.js</code> 中：</p>\n<pre><code class=\"js\">beforeEach (fn: Function): Function {\n  return registerHook(this.beforeHooks, fn)\n}\n\nfunction registerHook (list: Array&lt;any&gt;, fn: Function): Function {\n  list.push(fn)\n  return () =&gt; {\n    const i = list.indexOf(fn)\n    if (i &gt; -1) list.splice(i, 1)\n  }\n}</code></pre>\n<p>当用户使用 router.beforeEach 注册了一个全局守卫，就会往 router.beforeHooks 添加一个钩子函数，这样 this.router.beforeHooks 获取的就是用户注册的全局 beforeEach 守卫。</p>\n<p>第三步执行了 extractUpdateHooks(updated)，来看一下 extractUpdateHooks 的定义：</p>\n<pre><code class=\"js\">function extractUpdateHooks (updated: Array&lt;RouteRecord&gt;): Array&lt;?Function&gt; {\n  return extractGuards(updated, &#39;beforeRouteUpdate&#39;, bindGuard)\n}</code></pre>\n<p>和 extractLeaveGuards(deactivated) 类似，extractUpdateHooks(updated) 获取到的就是所有重用的组件中定义的 beforeRouteUpdate 钩子函数</p>\n<p>第四步是执行 activated.map(m =&gt; m.beforeEnter)，获取的是在激活的路由配置中定义的 beforeEnter 函数。</p>\n<p>第五步是执行 resolveAsyncComponents(activated) 解析异步组件，先来看一下 resolveAsyncComponents 的定义，在 <code>src/util/resolve-components.js</code> 中</p>\n<pre><code class=\"js\">export function resolveAsyncComponents (matched: Array&lt;RouteRecord&gt;): Function {\n  return (to, from, next) =&gt; {\n    let hasAsync = false\n    let pending = 0\n    let error = null\n\n    flatMapComponents(matched, (def, _, match, key) =&gt; {\n      if (typeof def === &#39;function&#39; &amp;&amp; def.cid === undefined) {\n        hasAsync = true\n        pending++\n\n        const resolve = once(resolvedDef =&gt; {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default\n          }\n          def.resolved = typeof resolvedDef === &#39;function&#39;\n            ? resolvedDef\n            : _Vue.extend(resolvedDef)\n          match.components[key] = resolvedDef\n          pending--\n          if (pending &lt;= 0) {\n            next()\n          }\n        })\n\n        const reject = once(reason =&gt; {\n          const msg = `Failed to resolve async component ${key}: ${reason}`\n          process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(false, msg)\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg)\n            next(error)\n          }\n        })\n\n        let res\n        try {\n          res = def(resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n        if (res) {\n          if (typeof res.then === &#39;function&#39;) {\n            res.then(resolve, reject)\n          } else {\n            const comp = res.component\n            if (comp &amp;&amp; typeof comp.then === &#39;function&#39;) {\n              comp.then(resolve, reject)\n            }\n          }\n        }\n      }\n    })\n\n    if (!hasAsync) next()\n  }\n}</code></pre>\n<p>resolveAsyncComponents 返回的是一个导航守卫函数，有标准的 to、from、next 参数。它的内部实现很简单，利用了 flatMapComponents 方法从 matched 中获取到每个组件的定义，判断如果是异步组件，则执行异步组件加载逻辑，加载成功后会执行 match.components[key] = resolvedDef 把解析好的异步组件放到对应的 components 上，并且执行 next 函数。</p>\n<p>这样在 resolveAsyncComponents(activated) 解析完所有激活的异步组件后，我们就可以拿到这一次所有激活的组件。这样我们在做完这 5 步后又做了一些事情</p>\n<pre><code class=\"js\">runQueue(queue, iterator, () =&gt; {\n  const postEnterCbs = []\n  const isValid = () =&gt; this.current === route\n  const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n  const queue = enterGuards.concat(this.router.resolveHooks)\n  runQueue(queue, iterator, () =&gt; {\n    if (this.pending !== route) {\n      return abort()\n    }\n    this.pending = null\n    onComplete(route)\n    if (this.router.app) {\n      this.router.app.$nextTick(() =&gt; {\n        postEnterCbs.forEach(cb =&gt; { cb() })\n      })\n    }\n  })\n})</code></pre>\n<ol start=\"6\">\n<li><p>在被激活的组件里调用 beforeRouteEnter。</p>\n</li>\n<li><p>调用全局的 beforeResolve 守卫。</p>\n</li>\n<li><p>调用全局的 afterEach 钩子。</p>\n</li>\n</ol>\n<p>可以看到，当处理完任务队列之后的回调主要是接入路由组件后期的钩子函数 beforeRouteEnter 和 beforeResolve，并进行队列执行。最后执行回调函数 onComplete</p>\n<p>到这里，已经完成了对当前 route 的切换动作，在完成路由切换后执行了 <code>onComplete &amp;&amp; onComplete(route)</code> ，那么主要会引起 url 和 组件的变化我们来看看</p>\n<p>当我们点击 router-link 的时候，实际上最终会执行 router.push，如下</p>\n<pre><code class=\"js\">push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.history.push(location, onComplete, onAbort)\n}</code></pre>\n<p>this.history.push 函数，这个函数是子类实现的，不同模式下该函数的实现略有不同，我们来看一下平时使用比较多的 hash 模式该函数的实现，在 <code>src/history/hash.js</code> 中</p>\n<pre><code class=\"js\">push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  const { current: fromRoute } = this\n  this.transitionTo(location, route =&gt; {\n    pushHash(route.fullPath)\n    handleScroll(this.router, route, fromRoute, false)\n    onComplete &amp;&amp; onComplete(route)\n  }, onAbort)\n}</code></pre>\n<p>push 函数会先执行 this.transitionTo 做路径切换，在切换完成的回调函数中，执行 pushHash 函数</p>\n<pre><code class=\"js\">function pushHash (path) {\n  if (supportsPushState) {\n    pushState(getUrl(path))\n  } else {\n    window.location.hash = path\n  }\n}</code></pre>\n<p>supportsPushState 的定义在 <code>src/util/push-state.js</code> 中</p>\n<pre><code class=\"js\">export const supportsPushState = inBrowser &amp;&amp; (function () {\n  const ua = window.navigator.userAgent\n\n  if (\n    (ua.indexOf(&#39;Android 2.&#39;) !== -1 || ua.indexOf(&#39;Android 4.0&#39;) !== -1) &amp;&amp;\n    ua.indexOf(&#39;Mobile Safari&#39;) !== -1 &amp;&amp;\n    ua.indexOf(&#39;Chrome&#39;) === -1 &amp;&amp;\n    ua.indexOf(&#39;Windows Phone&#39;) === -1\n  ) {\n    return false\n  }\n\n  return window.history &amp;&amp; &#39;pushState&#39; in window.history\n})()</code></pre>\n<p>如果支持的话，则获取当前完整的 url，执行 pushState 方法</p>\n<pre><code class=\"js\">export function pushState (url?: string, replace?: boolean) {\n  saveScrollPosition()\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, &#39;&#39;, url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, &#39;&#39;, url)\n    }\n  } catch (e) {\n    window.location[replace ? &#39;replace&#39; : &#39;assign&#39;](url)\n  }\n}</code></pre>\n<p>pushState 会调用浏览器原生的 history 的 pushState 接口或者 replaceState 接口，更新浏览器的 url 地址，并把当前 url 压入历史栈中。</p>\n<p>然后在 history 的初始化中，会设置一个监听器，监听历史栈的变化</p>\n<pre><code class=\"js\">setupListeners () {\n  const router = this.router\n  // 处理滚动\n  const expectScroll = router.options.scrollBehavior\n  const supportsScroll = supportsPushState &amp;&amp; expectScroll\n\n  if (supportsScroll) {\n    setupScroll()\n  }\n  // 通过 supportsPushState 判断监听popstate 还是 hashchange\n  window.addEventListener(supportsPushState ? &#39;popstate&#39; : &#39;hashchange&#39;, () =&gt; {\n    const current = this.current\n    // 判断路由格式\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route =&gt; {\n      if (supportsScroll) {\n        handleScroll(this.router, route, current, true)\n      }\n      // 如果不支持 history 模式，则换成 hash 模式\n      if (!supportsPushState) {\n        replaceHash(route.fullPath)\n      }\n    })\n  })\n}</code></pre>\n<p>当点击浏览器返回按钮的时候，如果已经有 url 被压入历史栈，则会触发 popstate 事件，然后拿到当前要跳转的 hash，执行 transtionTo 方法做一次路径转换。</p>\n<p>可以看到 setupListeners 这里主要做了 2 件事情，一个是对路由切换滚动位置的处理，另一个是对路由变动做了一次监听。这样我们就完成了对真个 hash 的分析过程</p>\n<h3 id=\"vue-router-实现之-HTML5History\"><a href=\"#vue-router-实现之-HTML5History\" class=\"headerlink\" title=\"vue-router 实现之 HTML5History\"></a>vue-router 实现之 HTML5History<hr></h3><p>当初始化的时候 mode 等于 history 模式的时候，就会执行 HTML5History，然后会执行 history 对象上的 transitionTo 方法</p>\n<p>在vue-router实例化过程中，执行对 HTML5History 的实例化</p>\n<pre><code class=\"js\">this.history = new HTML5History(this, options.base)</code></pre>\n<p>看一下 HTML5History 函数的构造</p>\n<pre><code class=\"js\">  constructor (router: Router, base: ?string) {\n    // 实现 base 基类中的构造函数\n    super(router, base)\n\n    // 滚动信息处理\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState &amp;&amp; expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    const initLocation = getLocation(this.base)\n    window.addEventListener(&#39;popstate&#39;, e =&gt; {\n      const current = this.current\n\n      // 避免在有的浏览器中第一次加载路由就会触发 `popstate` 事件\n      const location = getLocation(this.base)\n      if (this.current === START &amp;&amp; location === initLocation) {\n        return\n      }\n      // 执行跳转动作\n      this.transitionTo(location, route =&gt; {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true)\n        }\n      })\n    })\n  }</code></pre>\n<p>可以看到，只是调用基类构造函数以及初始化监听事件。由于在上面已经介绍了 transitionTo 和 confirmTransition。这里不再过多介绍了。那么我们来看几个之前没介绍的一下 API 吧</p>\n<pre><code class=\"js\">  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.push(location, onComplete, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    this.history.replace(location, onComplete, onAbort)\n  }\n\n  go (n: number) {\n    this.history.go(n)\n  }\n\n  back () {\n    this.go(-1)\n  }\n\n  forward () {\n    this.go(1)\n  }</code></pre>\n<p>可以看到 vue-router 这个 API 实际上都是效仿 window.history API 的，所以也不用多说。这样我们就完成了对 HTML5History 的介绍</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结<hr></h3><p>从上面我们看到路径变化是路由中最重要的功能，在路由记性切换的时候会把当前的路线切换到目标路线，切换过程中会执行一系列的导航守卫钩子函数，更改 url，同时渲染组件。其实最重要的几个函数就是</p>\n<ul>\n<li>match 进行匹配路由得到路由对象</li>\n<li>transitionTo 做路径切换</li>\n<li>confirmTransition 处理队列的钩子函数，在处理钩子函数的时候会按照上面介绍的执行 8 个小步骤的顺序</li>\n<li>setupListeners 监听导航等功能</li>\n</ul>\n"},{"title":"Vuex 原理","date":"2018-09-10T11:05:12.000Z","top":false,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n说我 Vuex 大家也都能够耳熟能详了，它是进行状态管理的，也就是说全局数据缓存，通讯的作用。\n\n## 什么是 Vuex\n\n用 Vuex 官网的话讲 Vuex 是 Vue.js 应用程序的状态管理模式+库。它充当应用程序中所有组件的集中存储，其规则确保状态只能以可预测的方式进行更改。下面我们来看一张很熟悉的图来理解 Vuex 背后的基本思想\n\n<img src=\"/images/vuex.png\">\n\n## Vuex 的核心概念\n\n下面我们通过几个概念的解释来理解上面的图\n\n### State<hr>\n\nVuex 的唯一数据源，我们想使用的数据都定义在此处，唯一数据源确保我们的数据按照我们想要的方式去变动，可以通过 store.state 来取得内部数据\n\n### Getter<hr>\n\nstore 的计算属性，当我们需要对 state 的数据进行一些处理的时候，可以先在 getters 里进行操作，处理完的数据可以通过 store.getters 来获取。\n\n### Action<hr>\n\nAction 类似于 mutation，不同在于：\n\nAction 通过 commit 方法提交 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\nAction 通过 store.dispatch(action) 来触发事件\n\n### Mutation<hr>\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，避免我们在使用过程中覆盖 state 造成数据丢失。\n\n每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)\n\n如果我们直接通过 store.state 来修改数据，vue 会抛出警告，并无法触发 mutation 的修改。\n\n\n### Module<hr>\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。\n\n还有一些其他辅助函数的概念在这个就不一一列举了，每个名称的更全面的概念以及 demo 请查看 vuex<a href=\"https://vuex.vuejs.org/zh/\">官网</a>文档\n\n\n## vuex 的源码分析\n\n关于使用我相信大家都会bu用过多的介绍，下面我们通过对源码的分析来了解 vuex 的原理更有利于我们在日常开发中使用，出现问题能够更清楚的知道问题出在哪里\n\n### 初始化<hr>\n\n当我们在代码中通过引入如下代码的时候\n\n```js\nimport Vuex from 'vuex'\n```\n\n实际上是引用一个对象，它定义在 `src/index.js`\n\n```js\n    \nimport { Store, install } from './store'\nimport { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from './helpers'\n\nexport default {\n  Store,\n  install,\n  version: '__VERSION__',\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\n```\n通过上面代码看见在引用的时候实际上就暴露了很多方法也是我们非常熟悉并且经常用的。\n\n### 使用<hr>\n\n当我们执行以下代码的时候\n\n```js\nVue.use(Vuex)\n```\n\n和 vue-router 一样，Vue.use 方法会注入一个插件，调用这个对象的 install 方法，该方法定义在 `src/store.js` 中\n\n```js\nexport function install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n\n通过上面代码我们看到其实和vue-router 差不多也是做了几件事情\n\n- 对 vue 对象做校验防止重复安装\n- 将 vue 对象传递到本地中\n- 调用 applyMixin 方法进行初始化\n\n接下来我们看一下 applyMixin 方法，定义在 `src/mixin.js` 中\n\n```js\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // ...\n  }\n\n \n  // Vuex init钩子，注入到每个实例 init 钩子列表\n  function vuexInit () {\n    const options = this.$options\n    // 进行依赖注入\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n\n```\n\n通过上面代码我们知道在执行 applyMixin 的时候实际上就是在 Vue beforeCreate 生命周期钩子函数里执行了 vuexInit 方法，将实例化的 Store 对象挂载到 $store 上。\n\n### Store 实例化<hr>\n\n当我们执行\n\n```js\nexport default new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n  modules\n  // ...\n})\n```\n我们看到实际上 Store 对象的构造函数接收一个对象参数它包含 actions、getters、state、mutations、modules 等 Vuex 的核心概念，它定义在 `src/store.js` 中\n\n```js\nexport class Store {\n  constructor (options = {}) {\n    // 如果没有挂在成功 Vue 这里面自动在 window 上挂载 Vue\n    if (!Vue && typeof window !== 'undefined' && window.Vue) {\n      install(window.Vue)\n    }\n\n    // ...\n\n    const {\n      plugins = [],\n      strict = false\n    } = options\n\n    // store 的内部状态\n    this._committing = false\n    this._actions = Object.create(null)\n    this._actionSubscribers = []\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._modules = new ModuleCollection(options)\n    this._modulesNamespaceMap = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // 绑定、提交和分发\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // 严格模式\n    this.strict = strict\n\n    const state = this._modules.root.state\n\n    // 初始化模块，递归地注册所有的子模块，并在 this. _wrappedge 中收集所有的模块 getter\n    installModule(this, state, [], this._modules.root)\n\n    // 初始化负责响应的存储vm(也将 _wrappedgeas 登记为计算属性)\n    resetStoreVM(this, state)\n\n    // apply plugins\n    plugins.forEach(plugin => plugin(this))\n\n    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools\n    if (useDevtools) {\n      devtoolPlugin(this)\n    }\n  }\n  // ...\n}\n```\n\n通过上面代码主要是执行了以下过程\n\n- 如果没有传入 Vue，那么自动安装一下插件\n- 初始化模块、安装模块收集所有模块的 getter\n- 初始化 store._vm\n\n### 获取模块<hr>\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，这样我们可以将 store 分割成模块（module，每个模块都拥有自己的 state、mutation、action、getter，甚至是嵌套子模块。如下\n\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... },\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n我们打开 `module/module-collection.js` 文件，找到 ModuleCollection 类\n\n```js\nexport default class ModuleCollection {\n  constructor (rawRootModule) {\n    this.register([], rawRootModule, false)\n  }\n}\n```\n可以看到上面执行了 register 方法\n\n```js\nregister (path, rawModule, runtime = true) {\n  const newModule = new Module(rawModule, runtime)\n  if (path.length === 0) {\n    this.root = newModule\n  } else {\n    const parent = this.get(path.slice(0, -1))\n    parent.addChild(path[path.length - 1], newModule)\n  }\n\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, (rawChildModule, key) => {\n      this.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n}\n```\n\nregister 接收 3 个参数\n\n- path 表示路径，因为我们整体目标是要构建一颗模块树，path 是在构建树的过程中维护的路径\n- rawModule 表示定义模块的配置项\n- runtime 表示是否是一个运行时创建的模块\n\n上面实际上注册了 Module 的实例，Module 是用来描述单个模块的类，它的定义在 `src/module/module.js` 中\n\n```js\nexport default class Module {\n  constructor (rawModule, runtime) {\n    this.runtime = runtime\n    \n    this._children = Object.create(null)\n    \n    this._rawModule = rawModule\n    const rawState = rawModule.state\n\n    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}\n  }\n}\n```\n\n对于每一个模块而言，_children 是该模块的子模块，_rawModule 是该模块的配置，state 是该模块的 state。\n\n回到 register，那么在实例化一个 Module 后，判断当前的 path 的长度如果为 0，则说明它是一个根模块，所以把 newModule 赋值给了 this.root\n\n接着判断是否有 modules 项，如果有，则执行下面代码\n\n```js\nforEachValue(rawModule.modules, (rawChildModule, key) => {\n  this.register(path.concat(key), rawChildModule, runtime)\n})\n```\n这段代码主要是遍历 modules，递归调用 register 方法，将配置项里的 modules 的 key 作为路径保存到 path 中，传入子 module 和创建状态。\n\n\n如果 path 的长度不为 0，那么执行以下代码建立父子关系\n\n```js\nconst parent = this.get(path.slice(0, -1))\nparent.addChild(path[path.length - 1], newModule)\n```\n\n上面调用了 get\n\n```js\nget (path) {\n  return path.reduce((module, key) => {\n    return module.getChild(key)\n  }, this.root)\n}\n```\n首先获取父模块，这里通过 get 方法中的 reduce 方法一层层去找到对应的模块，查找的过程中，执行的是 module.getChild(key) 方法\n\n```js\ngetChild (key) {\n  return this._children[key]\n}\n```\n返回当前模块的 _children 中对应 key 的模块，那么每个模块当中的 key 是如何添加的呢\n\n```js\naddChild (key, module) {\n  this._children[key] = module\n}\n```\n\n对于 root module 的下一层 modules 来说，它们的 parent 就是 root module，那么他们就会被添加的 root module 的 _children 中。每个子模块通过路径找到它的父模块，然后通过父模块的 addChild 方法建立父子关系，递归执行这样的过程，最终就建立一颗完整的模块树。\n\n\n### 安装模块\n\n当我们构建好模块树，接下来就需要去安装这些模块了，看一下 installModule 方法代码如下\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n\n  // 注册命名空间 map\n  if (module.namespaced) {\n    if (store._modulesNamespaceMap[namespace] && process.env.NODE_ENV !== 'production') {\n      console.error(`[vuex] duplicate namespace ${namespace} for the namespaced module ${path.join('/')}`)\n    }\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // 获取父模块的 state，获取当前模块的名称，通过 Vue.set 将当前模块的 state 挂载到父模块上，key 是模块名称。\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  // 通过 makeLocalContext 方法创建本地上下文环境，接收 store（root store）、namespace（模块命名空间）、path（模块路径） 三个参数\n  const local = module.context = makeLocalContext(store, namespace, path)\n\n  // 调用 registerMutation 方法进行 Mutations 注册\n  module.forEachMutation((mutation, key) => {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n\n  // 调用 registerAction 方法进行 Actions 注册\n  module.forEachAction((action, key) => {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n  })\n  // 调用 registerGetter 方法进行 Getter 注册\n  module.forEachGetter((getter, key) => {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n  })\n  // 开始遍历模块的子模块，然后递归安装。\n  module.forEachChild((child, key) => {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\n```\n\n上面的逻辑就是初始化 state、getters、mutations、actions，这里有 5 个参数，分别代表\n\n- store：root store\n- rootState：root state\n- path：模块访问路径\n- module：当前模块\n- hot：是否热更新\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果我们希望模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\n\n```js\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n回到 installModule 方法，第一步根据 path 获取 namespace\n\n```js\nconst namespace = store._modules.getNamespace(path)\n```\n\ngetNamespace 的定义在 src/module/module-collection.js 中\n\n```js\ngetNamespace (path) {\n  let module = this.root\n  return path.reduce((namespace, key) => {\n    module = module.getChild(key)\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n}\n```\n\n从 root module 开始，通过 reduce 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串\n\n\n为了方便以后能根据 namespace 查找模块执行以下方法把 namespace 对应的模块保存下来\n\n```js\nif (module.namespaced) {\n  store._modulesNamespaceMap[namespace] = module\n}\n```\n\n第二步根据 !isRoot && !hot 来获取模块的名称、state 等\n\n从 root state 开始，通过 path.reduce 方法一层层查找子模块 state，最终找到目标模块的 state。\n\n```js\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) => state[key], state)\n    : state\n}\n```\n\n第三步通过 makeLocalContext 方法创建本地上下文环境\n\n```js\nconst local = module.context = makeLocalContext(store, namespace, path)\n```\n\n```js\nfunction makeLocalContext (store, namespace, path) {\n  const noNamespace = namespace === ''\n\n  const local = {\n    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (process.env.NODE_ENV !== 'production' && !store._actions[type]) {\n          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (process.env.NODE_ENV !== 'production' && !store._mutations[type]) {\n          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? () => store.getters\n        : () => makeLocalGetters(store, namespace)\n    },\n    state: {\n      get: () => getNestedState(store.state, path)\n    }\n  })\n\n  return local\n}\n```\n\n如果没有命名空间的情况就是直接使用 root store 上的 dispatch 和 commit 方法，否则使用新定义的方法，这个方法接收三个参数\n\n- _type：dispatch、commit 的 type\n- _payload：提交的参数\n- _options：其他选项，例如 { root: true } 这个在子模块派发到根仓库的配置项\n\n\n把 type 自动拼接上 namespace，然后执行 store 上对应的方法。\n\n对于 getters 而言，如果没有 namespace，则直接返回 root store 的 getters，否则返回 makeLocalGetters(store, namespace) 的返回值\n\n```js\nfunction makeLocalGetters (store, namespace) {\n  const gettersProxy = {}\n\n  // 获取了 namespace 的长度\n  const splitPos = namespace.length\n  // 遍历 root store 下的所有 getters\n  Object.keys(store.getters).forEach(type => {\n    \n    // 判断它的类型是否匹配 namespace,不匹配直接结束\n    if (type.slice(0, splitPos) !== namespace) return\n\n    // 获取本地 type，也就是 getNumberPlusOne\n    const localType = type.slice(splitPos)\n\n    // 用 Object.defineProperty 定义了 gettersProxy，获取 localType 实际上就是访问了 store.getters[type]\n    Object.defineProperty(gettersProxy, localType, {\n      get: () => store.getters[type],\n      enumerable: true\n    })\n  })\n\n  // 访问代理对象\n  return gettersProxy\n}\n```\n\n第四步注册 Mutations\n\n```js\nmodule.forEachMutation((mutation, key) => {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n\nfunction registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}\n```\n\n通过遍历 module 下的每一个 mutations 属性的值，然后获取带有命名空间的 type，再调用 registerMutation 方法进行注册，该方法实际上就是给 root store 上的 _mutations[types] 添加 wrappedMutationHandler 方法，从而允许我们一个 type 对应多个 mutaions。\n\n\n第五步注册 Actions\n\n```js\nmodule.forEachAction((action, key) => {\n  const type = action.root ? key : namespace + key\n  const handler = action.handler || action\n  registerAction(store, type, handler, local)\n})\n\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n```\n\n通过遍历模块中的 actions 拿到每一个 action 和 key。判断 action.root，如果否的情况把 key 拼接上 namespace，然后执行 registerAction 方法。registerAction 接收四个参数\n\n- store：store 实例\n- namespacedType：带命名空间的 type\n- handler：回调函数\n- local：上下文环境，root 为 store，module 为 local\n\n可以看到 actions 回调的第一个参数是一个对象，里面包含了 dispatch、commit、getters、state、rootGetters、rootState 字段，最后 actions 里通过 Promise 的异步过程，判断 res 的类型返回对应的值\n\n\n\n第五步注册 Getters\n\n```js\nmodule.forEachGetter((getter, key) => {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})\n\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`[vuex] duplicate getter key: ${type}`)\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n```\n\n通过遍历模块中的 getters 的定义，拿到每一个 getter 和 key，并把 key 拼接上 namespace，然后执行 registerGetter 方法。registerGetter 首先通过 store._wrappedGetters[type] 方法 判断 getter key 重复是否重复，接着在 _wrappedGetters 上以 type 为 key，挂载 wrappedGetter 函数，返回 rawGetters 函数执行的结果。\n\n\n第六步安装子模块\n\n```js\nmodule.forEachChild((child, key) => {\n  installModule(store, rootState, path.concat(key), child, hot)\n})\n```\n很简单就是递归安装的过程\n\n以上就是 installModule 函数的作用进行 state、getters、actions、mutations 等模块的初始化和安装工作，接下来我们看 Store 实例化的最后一步，就是执行初始化 store._vm 的逻辑\n\n### 初始化 store._vm<hr>\n\n入口是\n\n```js\nresetStoreVM(this, state)\n```\n\n看一下这个函数的定义\n\n```js\nfunction resetStoreVM (store, state, hot) {\n  const oldVm = store._vm\n\n  // 建立 getters 和 state 的联系\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  // 执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,...) 方法，那么就会访问到 store.state，进而访问到 store._vm._data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。\n  forEachValue(wrappedGetters, (fn, key) => {\n    //使用 computed 来利用其延迟缓存机制\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // 使用一个Vue实例来存储状态树抑制警告，以防用户添加了一些奇怪的全局混合\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  // 实例化一个 Vue 实例 store._vm，并把 computed 进去\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // 为新vm启用严格模式\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // 将所有订阅的观察者的更改发送到强制 getter 重新评估以便热重载\n      // store._vm 会添加一个 wathcer 来观测 this._data.$$state 的变化，也就是当 store.state 被修改的时候, store._committing 必须为 true，否则在开发阶段会报警告\n      store._withCommit(() => {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n这里方法的主要是将 state 与 getters 建立好关系，实例化一个 Vue 挂载到 _vm 属性上，通过 computed 属性将 getters 与 state 关联起来并缓存结果。\n\n### 辅助函数过程分析<hr>\n\n当然还有很多 API 的分析过程比如怎么执行的 commit、dispatch，mapState 和 mapGetters、mapMutations、mapActions 等辅助函数的实现\n\n我们可以看 <a href=\"https://ustbhuangyi.github.io/vue-analysis/vuex/api.html#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\">Vue 技术揭秘</a>中关于这些的讲些\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue/vuex.md","raw":"---\ntitle: Vuex 原理\ndate: 2018-09-10 19:05:12\ntop: false\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n说我 Vuex 大家也都能够耳熟能详了，它是进行状态管理的，也就是说全局数据缓存，通讯的作用。\n\n## 什么是 Vuex\n\n用 Vuex 官网的话讲 Vuex 是 Vue.js 应用程序的状态管理模式+库。它充当应用程序中所有组件的集中存储，其规则确保状态只能以可预测的方式进行更改。下面我们来看一张很熟悉的图来理解 Vuex 背后的基本思想\n\n<img src=\"/images/vuex.png\">\n\n## Vuex 的核心概念\n\n下面我们通过几个概念的解释来理解上面的图\n\n### State<hr>\n\nVuex 的唯一数据源，我们想使用的数据都定义在此处，唯一数据源确保我们的数据按照我们想要的方式去变动，可以通过 store.state 来取得内部数据\n\n### Getter<hr>\n\nstore 的计算属性，当我们需要对 state 的数据进行一些处理的时候，可以先在 getters 里进行操作，处理完的数据可以通过 store.getters 来获取。\n\n### Action<hr>\n\nAction 类似于 mutation，不同在于：\n\nAction 通过 commit 方法提交 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\nAction 通过 store.dispatch(action) 来触发事件\n\n### Mutation<hr>\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，避免我们在使用过程中覆盖 state 造成数据丢失。\n\n每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)\n\n如果我们直接通过 store.state 来修改数据，vue 会抛出警告，并无法触发 mutation 的修改。\n\n\n### Module<hr>\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。\n\n还有一些其他辅助函数的概念在这个就不一一列举了，每个名称的更全面的概念以及 demo 请查看 vuex<a href=\"https://vuex.vuejs.org/zh/\">官网</a>文档\n\n\n## vuex 的源码分析\n\n关于使用我相信大家都会bu用过多的介绍，下面我们通过对源码的分析来了解 vuex 的原理更有利于我们在日常开发中使用，出现问题能够更清楚的知道问题出在哪里\n\n### 初始化<hr>\n\n当我们在代码中通过引入如下代码的时候\n\n```js\nimport Vuex from 'vuex'\n```\n\n实际上是引用一个对象，它定义在 `src/index.js`\n\n```js\n    \nimport { Store, install } from './store'\nimport { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from './helpers'\n\nexport default {\n  Store,\n  install,\n  version: '__VERSION__',\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\n```\n通过上面代码看见在引用的时候实际上就暴露了很多方法也是我们非常熟悉并且经常用的。\n\n### 使用<hr>\n\n当我们执行以下代码的时候\n\n```js\nVue.use(Vuex)\n```\n\n和 vue-router 一样，Vue.use 方法会注入一个插件，调用这个对象的 install 方法，该方法定义在 `src/store.js` 中\n\n```js\nexport function install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n\n通过上面代码我们看到其实和vue-router 差不多也是做了几件事情\n\n- 对 vue 对象做校验防止重复安装\n- 将 vue 对象传递到本地中\n- 调用 applyMixin 方法进行初始化\n\n接下来我们看一下 applyMixin 方法，定义在 `src/mixin.js` 中\n\n```js\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // ...\n  }\n\n \n  // Vuex init钩子，注入到每个实例 init 钩子列表\n  function vuexInit () {\n    const options = this.$options\n    // 进行依赖注入\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n\n```\n\n通过上面代码我们知道在执行 applyMixin 的时候实际上就是在 Vue beforeCreate 生命周期钩子函数里执行了 vuexInit 方法，将实例化的 Store 对象挂载到 $store 上。\n\n### Store 实例化<hr>\n\n当我们执行\n\n```js\nexport default new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n  modules\n  // ...\n})\n```\n我们看到实际上 Store 对象的构造函数接收一个对象参数它包含 actions、getters、state、mutations、modules 等 Vuex 的核心概念，它定义在 `src/store.js` 中\n\n```js\nexport class Store {\n  constructor (options = {}) {\n    // 如果没有挂在成功 Vue 这里面自动在 window 上挂载 Vue\n    if (!Vue && typeof window !== 'undefined' && window.Vue) {\n      install(window.Vue)\n    }\n\n    // ...\n\n    const {\n      plugins = [],\n      strict = false\n    } = options\n\n    // store 的内部状态\n    this._committing = false\n    this._actions = Object.create(null)\n    this._actionSubscribers = []\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._modules = new ModuleCollection(options)\n    this._modulesNamespaceMap = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // 绑定、提交和分发\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // 严格模式\n    this.strict = strict\n\n    const state = this._modules.root.state\n\n    // 初始化模块，递归地注册所有的子模块，并在 this. _wrappedge 中收集所有的模块 getter\n    installModule(this, state, [], this._modules.root)\n\n    // 初始化负责响应的存储vm(也将 _wrappedgeas 登记为计算属性)\n    resetStoreVM(this, state)\n\n    // apply plugins\n    plugins.forEach(plugin => plugin(this))\n\n    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools\n    if (useDevtools) {\n      devtoolPlugin(this)\n    }\n  }\n  // ...\n}\n```\n\n通过上面代码主要是执行了以下过程\n\n- 如果没有传入 Vue，那么自动安装一下插件\n- 初始化模块、安装模块收集所有模块的 getter\n- 初始化 store._vm\n\n### 获取模块<hr>\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，这样我们可以将 store 分割成模块（module，每个模块都拥有自己的 state、mutation、action、getter，甚至是嵌套子模块。如下\n\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... },\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n我们打开 `module/module-collection.js` 文件，找到 ModuleCollection 类\n\n```js\nexport default class ModuleCollection {\n  constructor (rawRootModule) {\n    this.register([], rawRootModule, false)\n  }\n}\n```\n可以看到上面执行了 register 方法\n\n```js\nregister (path, rawModule, runtime = true) {\n  const newModule = new Module(rawModule, runtime)\n  if (path.length === 0) {\n    this.root = newModule\n  } else {\n    const parent = this.get(path.slice(0, -1))\n    parent.addChild(path[path.length - 1], newModule)\n  }\n\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, (rawChildModule, key) => {\n      this.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n}\n```\n\nregister 接收 3 个参数\n\n- path 表示路径，因为我们整体目标是要构建一颗模块树，path 是在构建树的过程中维护的路径\n- rawModule 表示定义模块的配置项\n- runtime 表示是否是一个运行时创建的模块\n\n上面实际上注册了 Module 的实例，Module 是用来描述单个模块的类，它的定义在 `src/module/module.js` 中\n\n```js\nexport default class Module {\n  constructor (rawModule, runtime) {\n    this.runtime = runtime\n    \n    this._children = Object.create(null)\n    \n    this._rawModule = rawModule\n    const rawState = rawModule.state\n\n    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}\n  }\n}\n```\n\n对于每一个模块而言，_children 是该模块的子模块，_rawModule 是该模块的配置，state 是该模块的 state。\n\n回到 register，那么在实例化一个 Module 后，判断当前的 path 的长度如果为 0，则说明它是一个根模块，所以把 newModule 赋值给了 this.root\n\n接着判断是否有 modules 项，如果有，则执行下面代码\n\n```js\nforEachValue(rawModule.modules, (rawChildModule, key) => {\n  this.register(path.concat(key), rawChildModule, runtime)\n})\n```\n这段代码主要是遍历 modules，递归调用 register 方法，将配置项里的 modules 的 key 作为路径保存到 path 中，传入子 module 和创建状态。\n\n\n如果 path 的长度不为 0，那么执行以下代码建立父子关系\n\n```js\nconst parent = this.get(path.slice(0, -1))\nparent.addChild(path[path.length - 1], newModule)\n```\n\n上面调用了 get\n\n```js\nget (path) {\n  return path.reduce((module, key) => {\n    return module.getChild(key)\n  }, this.root)\n}\n```\n首先获取父模块，这里通过 get 方法中的 reduce 方法一层层去找到对应的模块，查找的过程中，执行的是 module.getChild(key) 方法\n\n```js\ngetChild (key) {\n  return this._children[key]\n}\n```\n返回当前模块的 _children 中对应 key 的模块，那么每个模块当中的 key 是如何添加的呢\n\n```js\naddChild (key, module) {\n  this._children[key] = module\n}\n```\n\n对于 root module 的下一层 modules 来说，它们的 parent 就是 root module，那么他们就会被添加的 root module 的 _children 中。每个子模块通过路径找到它的父模块，然后通过父模块的 addChild 方法建立父子关系，递归执行这样的过程，最终就建立一颗完整的模块树。\n\n\n### 安装模块\n\n当我们构建好模块树，接下来就需要去安装这些模块了，看一下 installModule 方法代码如下\n\n```js\nfunction installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n\n  // 注册命名空间 map\n  if (module.namespaced) {\n    if (store._modulesNamespaceMap[namespace] && process.env.NODE_ENV !== 'production') {\n      console.error(`[vuex] duplicate namespace ${namespace} for the namespaced module ${path.join('/')}`)\n    }\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // 获取父模块的 state，获取当前模块的名称，通过 Vue.set 将当前模块的 state 挂载到父模块上，key 是模块名称。\n  if (!isRoot && !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() => {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  // 通过 makeLocalContext 方法创建本地上下文环境，接收 store（root store）、namespace（模块命名空间）、path（模块路径） 三个参数\n  const local = module.context = makeLocalContext(store, namespace, path)\n\n  // 调用 registerMutation 方法进行 Mutations 注册\n  module.forEachMutation((mutation, key) => {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n\n  // 调用 registerAction 方法进行 Actions 注册\n  module.forEachAction((action, key) => {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n  })\n  // 调用 registerGetter 方法进行 Getter 注册\n  module.forEachGetter((getter, key) => {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n  })\n  // 开始遍历模块的子模块，然后递归安装。\n  module.forEachChild((child, key) => {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\n```\n\n上面的逻辑就是初始化 state、getters、mutations、actions，这里有 5 个参数，分别代表\n\n- store：root store\n- rootState：root state\n- path：模块访问路径\n- module：当前模块\n- hot：是否热更新\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果我们希望模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\n\n```js\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n回到 installModule 方法，第一步根据 path 获取 namespace\n\n```js\nconst namespace = store._modules.getNamespace(path)\n```\n\ngetNamespace 的定义在 src/module/module-collection.js 中\n\n```js\ngetNamespace (path) {\n  let module = this.root\n  return path.reduce((namespace, key) => {\n    module = module.getChild(key)\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n}\n```\n\n从 root module 开始，通过 reduce 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串\n\n\n为了方便以后能根据 namespace 查找模块执行以下方法把 namespace 对应的模块保存下来\n\n```js\nif (module.namespaced) {\n  store._modulesNamespaceMap[namespace] = module\n}\n```\n\n第二步根据 !isRoot && !hot 来获取模块的名称、state 等\n\n从 root state 开始，通过 path.reduce 方法一层层查找子模块 state，最终找到目标模块的 state。\n\n```js\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) => state[key], state)\n    : state\n}\n```\n\n第三步通过 makeLocalContext 方法创建本地上下文环境\n\n```js\nconst local = module.context = makeLocalContext(store, namespace, path)\n```\n\n```js\nfunction makeLocalContext (store, namespace, path) {\n  const noNamespace = namespace === ''\n\n  const local = {\n    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (process.env.NODE_ENV !== 'production' && !store._actions[type]) {\n          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (process.env.NODE_ENV !== 'production' && !store._mutations[type]) {\n          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? () => store.getters\n        : () => makeLocalGetters(store, namespace)\n    },\n    state: {\n      get: () => getNestedState(store.state, path)\n    }\n  })\n\n  return local\n}\n```\n\n如果没有命名空间的情况就是直接使用 root store 上的 dispatch 和 commit 方法，否则使用新定义的方法，这个方法接收三个参数\n\n- _type：dispatch、commit 的 type\n- _payload：提交的参数\n- _options：其他选项，例如 { root: true } 这个在子模块派发到根仓库的配置项\n\n\n把 type 自动拼接上 namespace，然后执行 store 上对应的方法。\n\n对于 getters 而言，如果没有 namespace，则直接返回 root store 的 getters，否则返回 makeLocalGetters(store, namespace) 的返回值\n\n```js\nfunction makeLocalGetters (store, namespace) {\n  const gettersProxy = {}\n\n  // 获取了 namespace 的长度\n  const splitPos = namespace.length\n  // 遍历 root store 下的所有 getters\n  Object.keys(store.getters).forEach(type => {\n    \n    // 判断它的类型是否匹配 namespace,不匹配直接结束\n    if (type.slice(0, splitPos) !== namespace) return\n\n    // 获取本地 type，也就是 getNumberPlusOne\n    const localType = type.slice(splitPos)\n\n    // 用 Object.defineProperty 定义了 gettersProxy，获取 localType 实际上就是访问了 store.getters[type]\n    Object.defineProperty(gettersProxy, localType, {\n      get: () => store.getters[type],\n      enumerable: true\n    })\n  })\n\n  // 访问代理对象\n  return gettersProxy\n}\n```\n\n第四步注册 Mutations\n\n```js\nmodule.forEachMutation((mutation, key) => {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n\nfunction registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}\n```\n\n通过遍历 module 下的每一个 mutations 属性的值，然后获取带有命名空间的 type，再调用 registerMutation 方法进行注册，该方法实际上就是给 root store 上的 _mutations[types] 添加 wrappedMutationHandler 方法，从而允许我们一个 type 对应多个 mutaions。\n\n\n第五步注册 Actions\n\n```js\nmodule.forEachAction((action, key) => {\n  const type = action.root ? key : namespace + key\n  const handler = action.handler || action\n  registerAction(store, type, handler, local)\n})\n\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err => {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n```\n\n通过遍历模块中的 actions 拿到每一个 action 和 key。判断 action.root，如果否的情况把 key 拼接上 namespace，然后执行 registerAction 方法。registerAction 接收四个参数\n\n- store：store 实例\n- namespacedType：带命名空间的 type\n- handler：回调函数\n- local：上下文环境，root 为 store，module 为 local\n\n可以看到 actions 回调的第一个参数是一个对象，里面包含了 dispatch、commit、getters、state、rootGetters、rootState 字段，最后 actions 里通过 Promise 的异步过程，判断 res 的类型返回对应的值\n\n\n\n第五步注册 Getters\n\n```js\nmodule.forEachGetter((getter, key) => {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})\n\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`[vuex] duplicate getter key: ${type}`)\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n```\n\n通过遍历模块中的 getters 的定义，拿到每一个 getter 和 key，并把 key 拼接上 namespace，然后执行 registerGetter 方法。registerGetter 首先通过 store._wrappedGetters[type] 方法 判断 getter key 重复是否重复，接着在 _wrappedGetters 上以 type 为 key，挂载 wrappedGetter 函数，返回 rawGetters 函数执行的结果。\n\n\n第六步安装子模块\n\n```js\nmodule.forEachChild((child, key) => {\n  installModule(store, rootState, path.concat(key), child, hot)\n})\n```\n很简单就是递归安装的过程\n\n以上就是 installModule 函数的作用进行 state、getters、actions、mutations 等模块的初始化和安装工作，接下来我们看 Store 实例化的最后一步，就是执行初始化 store._vm 的逻辑\n\n### 初始化 store._vm<hr>\n\n入口是\n\n```js\nresetStoreVM(this, state)\n```\n\n看一下这个函数的定义\n\n```js\nfunction resetStoreVM (store, state, hot) {\n  const oldVm = store._vm\n\n  // 建立 getters 和 state 的联系\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  // 执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,...) 方法，那么就会访问到 store.state，进而访问到 store._vm._data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。\n  forEachValue(wrappedGetters, (fn, key) => {\n    //使用 computed 来利用其延迟缓存机制\n    computed[key] = () => fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () => store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // 使用一个Vue实例来存储状态树抑制警告，以防用户添加了一些奇怪的全局混合\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  // 实例化一个 Vue 实例 store._vm，并把 computed 进去\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // 为新vm启用严格模式\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // 将所有订阅的观察者的更改发送到强制 getter 重新评估以便热重载\n      // store._vm 会添加一个 wathcer 来观测 this._data.$$state 的变化，也就是当 store.state 被修改的时候, store._committing 必须为 true，否则在开发阶段会报警告\n      store._withCommit(() => {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() => oldVm.$destroy())\n  }\n}\n```\n\n这里方法的主要是将 state 与 getters 建立好关系，实例化一个 Vue 挂载到 _vm 属性上，通过 computed 属性将 getters 与 state 关联起来并缓存结果。\n\n### 辅助函数过程分析<hr>\n\n当然还有很多 API 的分析过程比如怎么执行的 commit、dispatch，mapState 和 mapGetters、mapMutations、mapActions 等辅助函数的实现\n\n我们可以看 <a href=\"https://ustbhuangyi.github.io/vue-analysis/vuex/api.html#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\">Vue 技术揭秘</a>中关于这些的讲些\n\n\n\n\n\n\n\n\n\n\n","slug":"vue/vuex","published":1,"updated":"2019-10-15T01:29:42.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ox5009tb0u6y6tyjhtz","content":"<p>说我 Vuex 大家也都能够耳熟能详了，它是进行状态管理的，也就是说全局数据缓存，通讯的作用。</p>\n<h2 id=\"什么是-Vuex\"><a href=\"#什么是-Vuex\" class=\"headerlink\" title=\"什么是 Vuex\"></a>什么是 Vuex</h2><p>用 Vuex 官网的话讲 Vuex 是 Vue.js 应用程序的状态管理模式+库。它充当应用程序中所有组件的集中存储，其规则确保状态只能以可预测的方式进行更改。下面我们来看一张很熟悉的图来理解 Vuex 背后的基本思想</p>\n<img src=\"/images/vuex.png\">\n\n<h2 id=\"Vuex-的核心概念\"><a href=\"#Vuex-的核心概念\" class=\"headerlink\" title=\"Vuex 的核心概念\"></a>Vuex 的核心概念</h2><p>下面我们通过几个概念的解释来理解上面的图</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State<hr></h3><p>Vuex 的唯一数据源，我们想使用的数据都定义在此处，唯一数据源确保我们的数据按照我们想要的方式去变动，可以通过 store.state 来取得内部数据</p>\n<h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter<hr></h3><p>store 的计算属性，当我们需要对 state 的数据进行一些处理的时候，可以先在 getters 里进行操作，处理完的数据可以通过 store.getters 来获取。</p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action<hr></h3><p>Action 类似于 mutation，不同在于：</p>\n<p>Action 通过 commit 方法提交 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br>Action 通过 store.dispatch(action) 来触发事件</p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation<hr></h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，避免我们在使用过程中覆盖 state 造成数据丢失。</p>\n<p>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)</p>\n<p>如果我们直接通过 store.state 来修改数据，vue 会抛出警告，并无法触发 mutation 的修改。</p>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module<hr></h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>\n<p>还有一些其他辅助函数的概念在这个就不一一列举了，每个名称的更全面的概念以及 demo 请查看 vuex<a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">官网</a>文档</p>\n<h2 id=\"vuex-的源码分析\"><a href=\"#vuex-的源码分析\" class=\"headerlink\" title=\"vuex 的源码分析\"></a>vuex 的源码分析</h2><p>关于使用我相信大家都会bu用过多的介绍，下面我们通过对源码的分析来了解 vuex 的原理更有利于我们在日常开发中使用，出现问题能够更清楚的知道问题出在哪里</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化<hr></h3><p>当我们在代码中通过引入如下代码的时候</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Vuex <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>实际上是引用一个对象，它定义在 <code>src/index.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Store<span class=\"token punctuation\">,</span> install <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./store'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapState<span class=\"token punctuation\">,</span> mapMutations<span class=\"token punctuation\">,</span> mapGetters<span class=\"token punctuation\">,</span> mapActions<span class=\"token punctuation\">,</span> createNamespacedHelpers <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./helpers'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  Store<span class=\"token punctuation\">,</span>\n  install<span class=\"token punctuation\">,</span>\n  version<span class=\"token punctuation\">:</span> <span class=\"token string\">'__VERSION__'</span><span class=\"token punctuation\">,</span>\n  mapState<span class=\"token punctuation\">,</span>\n  mapMutations<span class=\"token punctuation\">,</span>\n  mapGetters<span class=\"token punctuation\">,</span>\n  mapActions<span class=\"token punctuation\">,</span>\n  createNamespacedHelpers\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码看见在引用的时候实际上就暴露了很多方法也是我们非常熟悉并且经常用的。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用<hr></h3><p>当我们执行以下代码的时候</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Vue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Vuex<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>和 vue-router 一样，Vue.use 方法会注入一个插件，调用这个对象的 install 方法，该方法定义在 <code>src/store.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> install <span class=\"token punctuation\">(</span>_Vue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Vue <span class=\"token operator\">&amp;&amp;</span> _Vue <span class=\"token operator\">===</span> Vue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  Vue <span class=\"token operator\">=</span> _Vue\n  <span class=\"token function\">applyMixin</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码我们看到其实和vue-router 差不多也是做了几件事情</p>\n<ul>\n<li>对 vue 对象做校验防止重复安装</li>\n<li>将 vue 对象传递到本地中</li>\n<li>调用 applyMixin 方法进行初始化</li>\n</ul>\n<p>接下来我们看一下 applyMixin 方法，定义在 <code>src/mixin.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> version <span class=\"token operator\">=</span> <span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>version <span class=\"token operator\">>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Vue<span class=\"token punctuation\">.</span><span class=\"token function\">mixin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> beforeCreate<span class=\"token punctuation\">:</span> vuexInit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">// Vuex init钩子，注入到每个实例 init 钩子列表</span>\n  <span class=\"token keyword\">function</span> vuexInit <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$options\n    <span class=\"token comment\" spellcheck=\"true\">// 进行依赖注入</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>store<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> options<span class=\"token punctuation\">.</span>store <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span>\n        <span class=\"token operator\">?</span> options<span class=\"token punctuation\">.</span><span class=\"token function\">store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">:</span> options<span class=\"token punctuation\">.</span>store\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>parent <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>$store\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码我们知道在执行 applyMixin 的时候实际上就是在 Vue beforeCreate 生命周期钩子函数里执行了 vuexInit 方法，将实例化的 Store 对象挂载到 $store 上。</p>\n<h3 id=\"Store-实例化\"><a href=\"#Store-实例化\" class=\"headerlink\" title=\"Store 实例化\"></a>Store 实例化<hr></h3><p>当我们执行</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  actions<span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">,</span>\n  state<span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">,</span>\n  modules\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们看到实际上 Store 对象的构造函数接收一个对象参数它包含 actions、getters、state、mutations、modules 等 Vuex 的核心概念，它定义在 <code>src/store.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Store</span> <span class=\"token punctuation\">{</span>\n  constructor <span class=\"token punctuation\">(</span>options <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果没有挂在成功 Vue 这里面自动在 window 上挂载 Vue</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Vue <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span> <span class=\"token operator\">&amp;&amp;</span> window<span class=\"token punctuation\">.</span>Vue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">install</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>Vue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n      plugins <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      strict <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> options\n\n    <span class=\"token comment\" spellcheck=\"true\">// store 的内部状态</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_committing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_actions <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_actionSubscribers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_mutations <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_wrappedGetters <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_modules <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModuleCollection</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_modulesNamespaceMap <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_subscribers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_watcherVM <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 绑定、提交和分发</span>\n    <span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> dispatch<span class=\"token punctuation\">,</span> commit <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dispatch <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> boundDispatch <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> dispatch<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>commit <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> boundCommit <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> commit<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 严格模式</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>strict <span class=\"token operator\">=</span> strict\n\n    <span class=\"token keyword\">const</span> state <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_modules<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">.</span>state\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化模块，递归地注册所有的子模块，并在 this. _wrappedge 中收集所有的模块 getter</span>\n    <span class=\"token function\">installModule</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_modules<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化负责响应的存储vm(也将 _wrappedgeas 登记为计算属性)</span>\n    <span class=\"token function\">resetStoreVM</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// apply plugins</span>\n    plugins<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>plugin <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">plugin</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">const</span> useDevtools <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>devtools <span class=\"token operator\">!==</span> undefined <span class=\"token operator\">?</span> options<span class=\"token punctuation\">.</span>devtools <span class=\"token punctuation\">:</span> Vue<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>devtools\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>useDevtools<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">devtoolPlugin</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码主要是执行了以下过程</p>\n<ul>\n<li>如果没有传入 Vue，那么自动安装一下插件</li>\n<li>初始化模块、安装模块收集所有模块的 getter</li>\n<li>初始化 store._vm</li>\n</ul>\n<h3 id=\"获取模块\"><a href=\"#获取模块\" class=\"headerlink\" title=\"获取模块\"></a>获取模块<hr></h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，这样我们可以将 store 分割成模块（module，每个模块都拥有自己的 state、mutation、action、getter，甚至是嵌套子模块。如下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> moduleB <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> moduleA<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">:</span> moduleB\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nstore<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>a <span class=\"token comment\" spellcheck=\"true\">// -> moduleA 的状态</span>\nstore<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>b <span class=\"token comment\" spellcheck=\"true\">// -> moduleB 的状态</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们打开 <code>module/module-collection.js</code> 文件，找到 ModuleCollection 类</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ModuleCollection</span> <span class=\"token punctuation\">{</span>\n  constructor <span class=\"token punctuation\">(</span>rawRootModule<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> rawRootModule<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到上面执行了 register 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">register <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> rawModule<span class=\"token punctuation\">,</span> runtime <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> newModule <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Module</span><span class=\"token punctuation\">(</span>rawModule<span class=\"token punctuation\">,</span> runtime<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>root <span class=\"token operator\">=</span> newModule\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    parent<span class=\"token punctuation\">.</span><span class=\"token function\">addChild</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">[</span>path<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> newModule<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rawModule<span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">forEachValue</span><span class=\"token punctuation\">(</span>rawModule<span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>rawChildModule<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> rawChildModule<span class=\"token punctuation\">,</span> runtime<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>register 接收 3 个参数</p>\n<ul>\n<li>path 表示路径，因为我们整体目标是要构建一颗模块树，path 是在构建树的过程中维护的路径</li>\n<li>rawModule 表示定义模块的配置项</li>\n<li>runtime 表示是否是一个运行时创建的模块</li>\n</ul>\n<p>上面实际上注册了 Module 的实例，Module 是用来描述单个模块的类，它的定义在 <code>src/module/module.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Module</span> <span class=\"token punctuation\">{</span>\n  constructor <span class=\"token punctuation\">(</span>rawModule<span class=\"token punctuation\">,</span> runtime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>runtime <span class=\"token operator\">=</span> runtime\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_children <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_rawModule <span class=\"token operator\">=</span> rawModule\n    <span class=\"token keyword\">const</span> rawState <span class=\"token operator\">=</span> rawModule<span class=\"token punctuation\">.</span>state\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> rawState <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span> <span class=\"token function\">rawState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> rawState<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对于每一个模块而言，_children 是该模块的子模块，_rawModule 是该模块的配置，state 是该模块的 state。</p>\n<p>回到 register，那么在实例化一个 Module 后，判断当前的 path 的长度如果为 0，则说明它是一个根模块，所以把 newModule 赋值给了 this.root</p>\n<p>接着判断是否有 modules 项，如果有，则执行下面代码</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">forEachValue</span><span class=\"token punctuation\">(</span>rawModule<span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>rawChildModule<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> rawChildModule<span class=\"token punctuation\">,</span> runtime<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>这段代码主要是遍历 modules，递归调用 register 方法，将配置项里的 modules 的 key 作为路径保存到 path 中，传入子 module 和创建状态。</p>\n<p>如果 path 的长度不为 0，那么执行以下代码建立父子关系</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> parent <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent<span class=\"token punctuation\">.</span><span class=\"token function\">addChild</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">[</span>path<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> newModule<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>上面调用了 get</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">get</span> <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> module<span class=\"token punctuation\">.</span><span class=\"token function\">getChild</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先获取父模块，这里通过 get 方法中的 reduce 方法一层层去找到对应的模块，查找的过程中，执行的是 module.getChild(key) 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">getChild <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_children<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>返回当前模块的 _children 中对应 key 的模块，那么每个模块当中的 key 是如何添加的呢</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">addChild <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_children<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> module\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>对于 root module 的下一层 modules 来说，它们的 parent 就是 root module，那么他们就会被添加的 root module 的 _children 中。每个子模块通过路径找到它的父模块，然后通过父模块的 addChild 方法建立父子关系，递归执行这样的过程，最终就建立一颗完整的模块树。</p>\n<h3 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h3><p>当我们构建好模块树，接下来就需要去安装这些模块了，看一下 installModule 方法代码如下</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> installModule <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> rootState<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">,</span> hot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> isRoot <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>path<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">const</span> namespace <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>_modules<span class=\"token punctuation\">.</span><span class=\"token function\">getNamespace</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 注册命名空间 map</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">.</span>namespaced<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>_modulesNamespaceMap<span class=\"token punctuation\">[</span>namespace<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`[vuex] duplicate namespace </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>namespace<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> for the namespaced module </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    store<span class=\"token punctuation\">.</span>_modulesNamespaceMap<span class=\"token punctuation\">[</span>namespace<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> module\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 获取父模块的 state，获取当前模块的名称，通过 Vue.set 将当前模块的 state 挂载到父模块上，key 是模块名称。</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isRoot <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>hot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> parentState <span class=\"token operator\">=</span> <span class=\"token function\">getNestedState</span><span class=\"token punctuation\">(</span>rootState<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> moduleName <span class=\"token operator\">=</span> path<span class=\"token punctuation\">[</span>path<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    store<span class=\"token punctuation\">.</span><span class=\"token function\">_withCommit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      Vue<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>parentState<span class=\"token punctuation\">,</span> moduleName<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 通过 makeLocalContext 方法创建本地上下文环境，接收 store（root store）、namespace（模块命名空间）、path（模块路径） 三个参数</span>\n  <span class=\"token keyword\">const</span> local <span class=\"token operator\">=</span> module<span class=\"token punctuation\">.</span>context <span class=\"token operator\">=</span> <span class=\"token function\">makeLocalContext</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespace<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 调用 registerMutation 方法进行 Mutations 注册</span>\n  module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachMutation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>mutation<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> namespacedType <span class=\"token operator\">=</span> namespace <span class=\"token operator\">+</span> key\n    <span class=\"token function\">registerMutation</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespacedType<span class=\"token punctuation\">,</span> mutation<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 调用 registerAction 方法进行 Actions 注册</span>\n  module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> type <span class=\"token operator\">=</span> action<span class=\"token punctuation\">.</span>root <span class=\"token operator\">?</span> key <span class=\"token punctuation\">:</span> namespace <span class=\"token operator\">+</span> key\n    <span class=\"token keyword\">const</span> handler <span class=\"token operator\">=</span> action<span class=\"token punctuation\">.</span>handler <span class=\"token operator\">||</span> action\n    <span class=\"token function\">registerAction</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 调用 registerGetter 方法进行 Getter 注册</span>\n  module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachGetter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> namespacedType <span class=\"token operator\">=</span> namespace <span class=\"token operator\">+</span> key\n    <span class=\"token function\">registerGetter</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespacedType<span class=\"token punctuation\">,</span> getter<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 开始遍历模块的子模块，然后递归安装。</span>\n  module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachChild</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">installModule</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> rootState<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">,</span> hot<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的逻辑就是初始化 state、getters、mutations、actions，这里有 5 个参数，分别代表</p>\n<ul>\n<li>store：root store</li>\n<li>rootState：root state</li>\n<li>path：模块访问路径</li>\n<li>module：当前模块</li>\n<li>hot：是否热更新</li>\n</ul>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果我们希望模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    account<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      namespaced<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 模块内容（module assets）</span>\n      state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>\n      getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        isAdmin <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> getters['account/isAdmin']</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        login <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> dispatch('account/login')</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        login <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> commit('account/login')</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 嵌套模块</span>\n      modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 继承父模块的命名空间</span>\n        myPage<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            profile <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> getters['account/profile']</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 进一步嵌套命名空间</span>\n        posts<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          namespaced<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n          state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            popular <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> getters['account/posts/popular']</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>回到 installModule 方法，第一步根据 path 获取 namespace</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> namespace <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>_modules<span class=\"token punctuation\">.</span><span class=\"token function\">getNamespace</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>getNamespace 的定义在 src/module/module-collection.js 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">getNamespace <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> module <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>root\n  <span class=\"token keyword\">return</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>namespace<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    module <span class=\"token operator\">=</span> module<span class=\"token punctuation\">.</span><span class=\"token function\">getChild</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> namespace <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">.</span>namespaced <span class=\"token operator\">?</span> key <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从 root module 开始，通过 reduce 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串</p>\n<p>为了方便以后能根据 namespace 查找模块执行以下方法把 namespace 对应的模块保存下来</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">.</span>namespaced<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  store<span class=\"token punctuation\">.</span>_modulesNamespaceMap<span class=\"token punctuation\">[</span>namespace<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> module\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>第二步根据 !isRoot &amp;&amp; !hot 来获取模块的名称、state 等</p>\n<p>从 root state 开始，通过 path.reduce 方法一层层查找子模块 state，最终找到目标模块的 state。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> getNestedState <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> path<span class=\"token punctuation\">.</span>length\n    <span class=\"token operator\">?</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">:</span> state\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第三步通过 makeLocalContext 方法创建本地上下文环境</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> local <span class=\"token operator\">=</span> module<span class=\"token punctuation\">.</span>context <span class=\"token operator\">=</span> <span class=\"token function\">makeLocalContext</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespace<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> makeLocalContext <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespace<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> noNamespace <span class=\"token operator\">=</span> namespace <span class=\"token operator\">===</span> <span class=\"token string\">''</span>\n\n  <span class=\"token keyword\">const</span> local <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    dispatch<span class=\"token punctuation\">:</span> noNamespace <span class=\"token operator\">?</span> store<span class=\"token punctuation\">.</span>dispatch <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>_type<span class=\"token punctuation\">,</span> _payload<span class=\"token punctuation\">,</span> _options<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> args <span class=\"token operator\">=</span> <span class=\"token function\">unifyObjectStyle</span><span class=\"token punctuation\">(</span>_type<span class=\"token punctuation\">,</span> _payload<span class=\"token punctuation\">,</span> _options<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> payload<span class=\"token punctuation\">,</span> options <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> args\n      <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> type <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> args\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>options <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        type <span class=\"token operator\">=</span> namespace <span class=\"token operator\">+</span> type\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>store<span class=\"token punctuation\">.</span>_actions<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`[vuex] unknown local action type: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>args<span class=\"token punctuation\">.</span>type<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, global type: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>type<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">return</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n    commit<span class=\"token punctuation\">:</span> noNamespace <span class=\"token operator\">?</span> store<span class=\"token punctuation\">.</span>commit <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>_type<span class=\"token punctuation\">,</span> _payload<span class=\"token punctuation\">,</span> _options<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> args <span class=\"token operator\">=</span> <span class=\"token function\">unifyObjectStyle</span><span class=\"token punctuation\">(</span>_type<span class=\"token punctuation\">,</span> _payload<span class=\"token punctuation\">,</span> _options<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> payload<span class=\"token punctuation\">,</span> options <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> args\n      <span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> type <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> args\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>options <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        type <span class=\"token operator\">=</span> namespace <span class=\"token operator\">+</span> type\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>store<span class=\"token punctuation\">.</span>_mutations<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`[vuex] unknown local mutation type: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>args<span class=\"token punctuation\">.</span>type<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, global type: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>type<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">return</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// getters and state object must be gotten lazily</span>\n  <span class=\"token comment\" spellcheck=\"true\">// because they will be changed by vm update</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperties</span><span class=\"token punctuation\">(</span>local<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> noNamespace\n        <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> store<span class=\"token punctuation\">.</span>getters\n        <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">makeLocalGetters</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespace<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">getNestedState</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> local\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果没有命名空间的情况就是直接使用 root store 上的 dispatch 和 commit 方法，否则使用新定义的方法，这个方法接收三个参数</p>\n<ul>\n<li>_type：dispatch、commit 的 type</li>\n<li>_payload：提交的参数</li>\n<li>_options：其他选项，例如 { root: true } 这个在子模块派发到根仓库的配置项</li>\n</ul>\n<p>把 type 自动拼接上 namespace，然后执行 store 上对应的方法。</p>\n<p>对于 getters 而言，如果没有 namespace，则直接返回 root store 的 getters，否则返回 makeLocalGetters(store, namespace) 的返回值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> makeLocalGetters <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespace<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> gettersProxy <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 获取了 namespace 的长度</span>\n  <span class=\"token keyword\">const</span> splitPos <span class=\"token operator\">=</span> namespace<span class=\"token punctuation\">.</span>length\n  <span class=\"token comment\" spellcheck=\"true\">// 遍历 root store 下的所有 getters</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 判断它的类型是否匹配 namespace,不匹配直接结束</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> splitPos<span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> namespace<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取本地 type，也就是 getNumberPlusOne</span>\n    <span class=\"token keyword\">const</span> localType <span class=\"token operator\">=</span> type<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>splitPos<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 用 Object.defineProperty 定义了 gettersProxy，获取 localType 实际上就是访问了 store.getters[type]</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>gettersProxy<span class=\"token punctuation\">,</span> localType<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 访问代理对象</span>\n  <span class=\"token keyword\">return</span> gettersProxy\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第四步注册 Mutations</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachMutation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>mutation<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> namespacedType <span class=\"token operator\">=</span> namespace <span class=\"token operator\">+</span> key\n  <span class=\"token function\">registerMutation</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespacedType<span class=\"token punctuation\">,</span> mutation<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> registerMutation <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entry <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>_mutations<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>_mutations<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  entry<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> wrappedMutationHandler <span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    handler<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过遍历 module 下的每一个 mutations 属性的值，然后获取带有命名空间的 type，再调用 registerMutation 方法进行注册，该方法实际上就是给 root store 上的 _mutations[types] 添加 wrappedMutationHandler 方法，从而允许我们一个 type 对应多个 mutaions。</p>\n<p>第五步注册 Actions</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> type <span class=\"token operator\">=</span> action<span class=\"token punctuation\">.</span>root <span class=\"token operator\">?</span> key <span class=\"token punctuation\">:</span> namespace <span class=\"token operator\">+</span> key\n  <span class=\"token keyword\">const</span> handler <span class=\"token operator\">=</span> action<span class=\"token punctuation\">.</span>handler <span class=\"token operator\">||</span> action\n  <span class=\"token function\">registerAction</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> registerAction <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> entry <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>_actions<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>_actions<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  entry<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> wrappedActionHandler <span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> handler<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      dispatch<span class=\"token punctuation\">:</span> local<span class=\"token punctuation\">.</span>dispatch<span class=\"token punctuation\">,</span>\n      commit<span class=\"token punctuation\">:</span> local<span class=\"token punctuation\">.</span>commit<span class=\"token punctuation\">,</span>\n      getters<span class=\"token punctuation\">:</span> local<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">,</span>\n      state<span class=\"token punctuation\">:</span> local<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span>\n      rootGetters<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">,</span>\n      rootState<span class=\"token punctuation\">:</span> store<span class=\"token punctuation\">.</span>state\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isPromise</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      res <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>_devtoolHook<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        store<span class=\"token punctuation\">.</span>_devtoolHook<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'vuex:error'</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> err\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> res\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过遍历模块中的 actions 拿到每一个 action 和 key。判断 action.root，如果否的情况把 key 拼接上 namespace，然后执行 registerAction 方法。registerAction 接收四个参数</p>\n<ul>\n<li>store：store 实例</li>\n<li>namespacedType：带命名空间的 type</li>\n<li>handler：回调函数</li>\n<li>local：上下文环境，root 为 store，module 为 local</li>\n</ul>\n<p>可以看到 actions 回调的第一个参数是一个对象，里面包含了 dispatch、commit、getters、state、rootGetters、rootState 字段，最后 actions 里通过 Promise 的异步过程，判断 res 的类型返回对应的值</p>\n<p>第五步注册 Getters</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachGetter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> namespacedType <span class=\"token operator\">=</span> namespace <span class=\"token operator\">+</span> key\n  <span class=\"token function\">registerGetter</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> namespacedType<span class=\"token punctuation\">,</span> getter<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">function</span> registerGetter <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> rawGetter<span class=\"token punctuation\">,</span> local<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>_wrappedGetters<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`[vuex] duplicate getter key: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>type<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  store<span class=\"token punctuation\">.</span>_wrappedGetters<span class=\"token punctuation\">[</span>type<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> wrappedGetter <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">rawGetter</span><span class=\"token punctuation\">(</span>\n      local<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// local state</span>\n      local<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// local getters</span>\n      store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// root state</span>\n      store<span class=\"token punctuation\">.</span>getters <span class=\"token comment\" spellcheck=\"true\">// root getters</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过遍历模块中的 getters 的定义，拿到每一个 getter 和 key，并把 key 拼接上 namespace，然后执行 registerGetter 方法。registerGetter 首先通过 store._wrappedGetters[type] 方法 判断 getter key 重复是否重复，接着在 _wrappedGetters 上以 type 为 key，挂载 wrappedGetter 函数，返回 rawGetters 函数执行的结果。</p>\n<p>第六步安装子模块</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span><span class=\"token function\">forEachChild</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">installModule</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> rootState<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">,</span> hot<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>很简单就是递归安装的过程</p>\n<p>以上就是 installModule 函数的作用进行 state、getters、actions、mutations 等模块的初始化和安装工作，接下来我们看 Store 实例化的最后一步，就是执行初始化 store._vm 的逻辑</p>\n<h3 id=\"初始化-store-vm\"><a href=\"#初始化-store-vm\" class=\"headerlink\" title=\"初始化 store._vm\"></a>初始化 store._vm<hr></h3><p>入口是</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">resetStoreVM</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>看一下这个函数的定义</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> resetStoreVM <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> hot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> oldVm <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>_vm\n\n  <span class=\"token comment\" spellcheck=\"true\">// 建立 getters 和 state 的联系</span>\n  store<span class=\"token punctuation\">.</span>getters <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> wrappedGetters <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>_wrappedGetters\n  <span class=\"token keyword\">const</span> computed <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,...) 方法，那么就会访问到 store.state，进而访问到 store._vm._data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。</span>\n  <span class=\"token function\">forEachValue</span><span class=\"token punctuation\">(</span>wrappedGetters<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用 computed 来利用其延迟缓存机制</span>\n    computed<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> store<span class=\"token punctuation\">.</span>_vm<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">// for local getters</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 使用一个Vue实例来存储状态树抑制警告，以防用户添加了一些奇怪的全局混合</span>\n  <span class=\"token keyword\">const</span> silent <span class=\"token operator\">=</span> Vue<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>silent\n  Vue<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>silent <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 实例化一个 Vue 实例 store._vm，并把 computed 进去</span>\n  store<span class=\"token punctuation\">.</span>_vm <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      $$state<span class=\"token punctuation\">:</span> state\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    computed\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  Vue<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>silent <span class=\"token operator\">=</span> silent\n\n  <span class=\"token comment\" spellcheck=\"true\">// 为新vm启用严格模式</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span>strict<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">enableStrictMode</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldVm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 将所有订阅的观察者的更改发送到强制 getter 重新评估以便热重载</span>\n      <span class=\"token comment\" spellcheck=\"true\">// store._vm 会添加一个 wathcer 来观测 this._data.$$state 的变化，也就是当 store.state 被修改的时候, store._committing 必须为 true，否则在开发阶段会报警告</span>\n      store<span class=\"token punctuation\">.</span><span class=\"token function\">_withCommit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        oldVm<span class=\"token punctuation\">.</span>_data<span class=\"token punctuation\">.</span>$$state <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    Vue<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> oldVm<span class=\"token punctuation\">.</span><span class=\"token function\">$destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里方法的主要是将 state 与 getters 建立好关系，实例化一个 Vue 挂载到 _vm 属性上，通过 computed 属性将 getters 与 state 关联起来并缓存结果。</p>\n<h3 id=\"辅助函数过程分析\"><a href=\"#辅助函数过程分析\" class=\"headerlink\" title=\"辅助函数过程分析\"></a>辅助函数过程分析<hr></h3><p>当然还有很多 API 的分析过程比如怎么执行的 commit、dispatch，mapState 和 mapGetters、mapMutations、mapActions 等辅助函数的实现</p>\n<p>我们可以看 <a href=\"https://ustbhuangyi.github.io/vue-analysis/vuex/api.html#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\" target=\"_blank\" rel=\"noopener\">Vue 技术揭秘</a>中关于这些的讲些</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<p>说我 Vuex 大家也都能够耳熟能详了，它是进行状态管理的，也就是说全局数据缓存，通讯的作用。</p>\n<h2 id=\"什么是-Vuex\"><a href=\"#什么是-Vuex\" class=\"headerlink\" title=\"什么是 Vuex\"></a>什么是 Vuex</h2><p>用 Vuex 官网的话讲 Vuex 是 Vue.js 应用程序的状态管理模式+库。它充当应用程序中所有组件的集中存储，其规则确保状态只能以可预测的方式进行更改。下面我们来看一张很熟悉的图来理解 Vuex 背后的基本思想</p>\n<img src=\"/images/vuex.png\">\n\n<h2 id=\"Vuex-的核心概念\"><a href=\"#Vuex-的核心概念\" class=\"headerlink\" title=\"Vuex 的核心概念\"></a>Vuex 的核心概念</h2><p>下面我们通过几个概念的解释来理解上面的图</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State<hr></h3><p>Vuex 的唯一数据源，我们想使用的数据都定义在此处，唯一数据源确保我们的数据按照我们想要的方式去变动，可以通过 store.state 来取得内部数据</p>\n<h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter<hr></h3><p>store 的计算属性，当我们需要对 state 的数据进行一些处理的时候，可以先在 getters 里进行操作，处理完的数据可以通过 store.getters 来获取。</p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action<hr></h3><p>Action 类似于 mutation，不同在于：</p>\n<p>Action 通过 commit 方法提交 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br>Action 通过 store.dispatch(action) 来触发事件</p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation<hr></h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，避免我们在使用过程中覆盖 state 造成数据丢失。</p>\n<p>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)</p>\n<p>如果我们直接通过 store.state 来修改数据，vue 会抛出警告，并无法触发 mutation 的修改。</p>\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module<hr></h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>\n<p>还有一些其他辅助函数的概念在这个就不一一列举了，每个名称的更全面的概念以及 demo 请查看 vuex<a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">官网</a>文档</p>\n<h2 id=\"vuex-的源码分析\"><a href=\"#vuex-的源码分析\" class=\"headerlink\" title=\"vuex 的源码分析\"></a>vuex 的源码分析</h2><p>关于使用我相信大家都会bu用过多的介绍，下面我们通过对源码的分析来了解 vuex 的原理更有利于我们在日常开发中使用，出现问题能够更清楚的知道问题出在哪里</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化<hr></h3><p>当我们在代码中通过引入如下代码的时候</p>\n<pre><code class=\"js\">import Vuex from &#39;vuex&#39;</code></pre>\n<p>实际上是引用一个对象，它定义在 <code>src/index.js</code></p>\n<pre><code class=\"js\">\nimport { Store, install } from &#39;./store&#39;\nimport { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from &#39;./helpers&#39;\n\nexport default {\n  Store,\n  install,\n  version: &#39;__VERSION__&#39;,\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}</code></pre>\n<p>通过上面代码看见在引用的时候实际上就暴露了很多方法也是我们非常熟悉并且经常用的。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用<hr></h3><p>当我们执行以下代码的时候</p>\n<pre><code class=\"js\">Vue.use(Vuex)</code></pre>\n<p>和 vue-router 一样，Vue.use 方法会注入一个插件，调用这个对象的 install 方法，该方法定义在 <code>src/store.js</code> 中</p>\n<pre><code class=\"js\">export function install (_Vue) {\n  if (Vue &amp;&amp; _Vue === Vue) {\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      console.error(\n        &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}</code></pre>\n<p>通过上面代码我们看到其实和vue-router 差不多也是做了几件事情</p>\n<ul>\n<li>对 vue 对象做校验防止重复安装</li>\n<li>将 vue 对象传递到本地中</li>\n<li>调用 applyMixin 方法进行初始化</li>\n</ul>\n<p>接下来我们看一下 applyMixin 方法，定义在 <code>src/mixin.js</code> 中</p>\n<pre><code class=\"js\">export default function (Vue) {\n  const version = Number(Vue.version.split(&#39;.&#39;)[0])\n\n  if (version &gt;= 2) {\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // ...\n  }\n\n\n  // Vuex init钩子，注入到每个实例 init 钩子列表\n  function vuexInit () {\n    const options = this.$options\n    // 进行依赖注入\n    if (options.store) {\n      this.$store = typeof options.store === &#39;function&#39;\n        ? options.store()\n        : options.store\n    } else if (options.parent &amp;&amp; options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n</code></pre>\n<p>通过上面代码我们知道在执行 applyMixin 的时候实际上就是在 Vue beforeCreate 生命周期钩子函数里执行了 vuexInit 方法，将实例化的 Store 对象挂载到 $store 上。</p>\n<h3 id=\"Store-实例化\"><a href=\"#Store-实例化\" class=\"headerlink\" title=\"Store 实例化\"></a>Store 实例化<hr></h3><p>当我们执行</p>\n<pre><code class=\"js\">export default new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n  modules\n  // ...\n})</code></pre>\n<p>我们看到实际上 Store 对象的构造函数接收一个对象参数它包含 actions、getters、state、mutations、modules 等 Vuex 的核心概念，它定义在 <code>src/store.js</code> 中</p>\n<pre><code class=\"js\">export class Store {\n  constructor (options = {}) {\n    // 如果没有挂在成功 Vue 这里面自动在 window 上挂载 Vue\n    if (!Vue &amp;&amp; typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) {\n      install(window.Vue)\n    }\n\n    // ...\n\n    const {\n      plugins = [],\n      strict = false\n    } = options\n\n    // store 的内部状态\n    this._committing = false\n    this._actions = Object.create(null)\n    this._actionSubscribers = []\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._modules = new ModuleCollection(options)\n    this._modulesNamespaceMap = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // 绑定、提交和分发\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // 严格模式\n    this.strict = strict\n\n    const state = this._modules.root.state\n\n    // 初始化模块，递归地注册所有的子模块，并在 this. _wrappedge 中收集所有的模块 getter\n    installModule(this, state, [], this._modules.root)\n\n    // 初始化负责响应的存储vm(也将 _wrappedgeas 登记为计算属性)\n    resetStoreVM(this, state)\n\n    // apply plugins\n    plugins.forEach(plugin =&gt; plugin(this))\n\n    const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools\n    if (useDevtools) {\n      devtoolPlugin(this)\n    }\n  }\n  // ...\n}</code></pre>\n<p>通过上面代码主要是执行了以下过程</p>\n<ul>\n<li>如果没有传入 Vue，那么自动安装一下插件</li>\n<li>初始化模块、安装模块收集所有模块的 getter</li>\n<li>初始化 store._vm</li>\n</ul>\n<h3 id=\"获取模块\"><a href=\"#获取模块\" class=\"headerlink\" title=\"获取模块\"></a>获取模块<hr></h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，这样我们可以将 store 分割成模块（module，每个模块都拥有自己的 state、mutation、action、getter，甚至是嵌套子模块。如下</p>\n<pre><code class=\"js\">const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... },\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态</code></pre>\n<p>我们打开 <code>module/module-collection.js</code> 文件，找到 ModuleCollection 类</p>\n<pre><code class=\"js\">export default class ModuleCollection {\n  constructor (rawRootModule) {\n    this.register([], rawRootModule, false)\n  }\n}</code></pre>\n<p>可以看到上面执行了 register 方法</p>\n<pre><code class=\"js\">register (path, rawModule, runtime = true) {\n  const newModule = new Module(rawModule, runtime)\n  if (path.length === 0) {\n    this.root = newModule\n  } else {\n    const parent = this.get(path.slice(0, -1))\n    parent.addChild(path[path.length - 1], newModule)\n  }\n\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {\n      this.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n}</code></pre>\n<p>register 接收 3 个参数</p>\n<ul>\n<li>path 表示路径，因为我们整体目标是要构建一颗模块树，path 是在构建树的过程中维护的路径</li>\n<li>rawModule 表示定义模块的配置项</li>\n<li>runtime 表示是否是一个运行时创建的模块</li>\n</ul>\n<p>上面实际上注册了 Module 的实例，Module 是用来描述单个模块的类，它的定义在 <code>src/module/module.js</code> 中</p>\n<pre><code class=\"js\">export default class Module {\n  constructor (rawModule, runtime) {\n    this.runtime = runtime\n\n    this._children = Object.create(null)\n\n    this._rawModule = rawModule\n    const rawState = rawModule.state\n\n    this.state = (typeof rawState === &#39;function&#39; ? rawState() : rawState) || {}\n  }\n}</code></pre>\n<p>对于每一个模块而言，_children 是该模块的子模块，_rawModule 是该模块的配置，state 是该模块的 state。</p>\n<p>回到 register，那么在实例化一个 Module 后，判断当前的 path 的长度如果为 0，则说明它是一个根模块，所以把 newModule 赋值给了 this.root</p>\n<p>接着判断是否有 modules 项，如果有，则执行下面代码</p>\n<pre><code class=\"js\">forEachValue(rawModule.modules, (rawChildModule, key) =&gt; {\n  this.register(path.concat(key), rawChildModule, runtime)\n})</code></pre>\n<p>这段代码主要是遍历 modules，递归调用 register 方法，将配置项里的 modules 的 key 作为路径保存到 path 中，传入子 module 和创建状态。</p>\n<p>如果 path 的长度不为 0，那么执行以下代码建立父子关系</p>\n<pre><code class=\"js\">const parent = this.get(path.slice(0, -1))\nparent.addChild(path[path.length - 1], newModule)</code></pre>\n<p>上面调用了 get</p>\n<pre><code class=\"js\">get (path) {\n  return path.reduce((module, key) =&gt; {\n    return module.getChild(key)\n  }, this.root)\n}</code></pre>\n<p>首先获取父模块，这里通过 get 方法中的 reduce 方法一层层去找到对应的模块，查找的过程中，执行的是 module.getChild(key) 方法</p>\n<pre><code class=\"js\">getChild (key) {\n  return this._children[key]\n}</code></pre>\n<p>返回当前模块的 _children 中对应 key 的模块，那么每个模块当中的 key 是如何添加的呢</p>\n<pre><code class=\"js\">addChild (key, module) {\n  this._children[key] = module\n}</code></pre>\n<p>对于 root module 的下一层 modules 来说，它们的 parent 就是 root module，那么他们就会被添加的 root module 的 _children 中。每个子模块通过路径找到它的父模块，然后通过父模块的 addChild 方法建立父子关系，递归执行这样的过程，最终就建立一颗完整的模块树。</p>\n<h3 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h3><p>当我们构建好模块树，接下来就需要去安装这些模块了，看一下 installModule 方法代码如下</p>\n<pre><code class=\"js\">function installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n\n  // 注册命名空间 map\n  if (module.namespaced) {\n    if (store._modulesNamespaceMap[namespace] &amp;&amp; process.env.NODE_ENV !== &#39;production&#39;) {\n      console.error(`[vuex] duplicate namespace ${namespace} for the namespaced module ${path.join(&#39;/&#39;)}`)\n    }\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // 获取父模块的 state，获取当前模块的名称，通过 Vue.set 将当前模块的 state 挂载到父模块上，key 是模块名称。\n  if (!isRoot &amp;&amp; !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() =&gt; {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  // 通过 makeLocalContext 方法创建本地上下文环境，接收 store（root store）、namespace（模块命名空间）、path（模块路径） 三个参数\n  const local = module.context = makeLocalContext(store, namespace, path)\n\n  // 调用 registerMutation 方法进行 Mutations 注册\n  module.forEachMutation((mutation, key) =&gt; {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n\n  // 调用 registerAction 方法进行 Actions 注册\n  module.forEachAction((action, key) =&gt; {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n  })\n  // 调用 registerGetter 方法进行 Getter 注册\n  module.forEachGetter((getter, key) =&gt; {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n  })\n  // 开始遍历模块的子模块，然后递归安装。\n  module.forEachChild((child, key) =&gt; {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}</code></pre>\n<p>上面的逻辑就是初始化 state、getters、mutations、actions，这里有 5 个参数，分别代表</p>\n<ul>\n<li>store：root store</li>\n<li>rootState：root state</li>\n<li>path：模块访问路径</li>\n<li>module：当前模块</li>\n<li>hot：是否热更新</li>\n</ul>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果我们希望模块具有更高的封装度和复用性，可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre><code class=\"js\">const store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -&gt; getters[&#39;account/isAdmin&#39;]\n      },\n      actions: {\n        login () { ... } // -&gt; dispatch(&#39;account/login&#39;)\n      },\n      mutations: {\n        login () { ... } // -&gt; commit(&#39;account/login&#39;)\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -&gt; getters[&#39;account/profile&#39;]\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -&gt; getters[&#39;account/posts/popular&#39;]\n          }\n        }\n      }\n    }\n  }\n})</code></pre>\n<p>回到 installModule 方法，第一步根据 path 获取 namespace</p>\n<pre><code class=\"js\">const namespace = store._modules.getNamespace(path)</code></pre>\n<p>getNamespace 的定义在 src/module/module-collection.js 中</p>\n<pre><code class=\"js\">getNamespace (path) {\n  let module = this.root\n  return path.reduce((namespace, key) =&gt; {\n    module = module.getChild(key)\n    return namespace + (module.namespaced ? key + &#39;/&#39; : &#39;&#39;)\n  }, &#39;&#39;)\n}</code></pre>\n<p>从 root module 开始，通过 reduce 方法一层层找子模块，如果发现该模块配置了 namespaced 为 true，则把该模块的 key 拼到 namesapce 中，最终返回完整的 namespace 字符串</p>\n<p>为了方便以后能根据 namespace 查找模块执行以下方法把 namespace 对应的模块保存下来</p>\n<pre><code class=\"js\">if (module.namespaced) {\n  store._modulesNamespaceMap[namespace] = module\n}</code></pre>\n<p>第二步根据 !isRoot &amp;&amp; !hot 来获取模块的名称、state 等</p>\n<p>从 root state 开始，通过 path.reduce 方法一层层查找子模块 state，最终找到目标模块的 state。</p>\n<pre><code class=\"js\">function getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) =&gt; state[key], state)\n    : state\n}</code></pre>\n<p>第三步通过 makeLocalContext 方法创建本地上下文环境</p>\n<pre><code class=\"js\">const local = module.context = makeLocalContext(store, namespace, path)</code></pre>\n<pre><code class=\"js\">function makeLocalContext (store, namespace, path) {\n  const noNamespace = namespace === &#39;&#39;\n\n  const local = {\n    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !store._actions[type]) {\n          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !store._mutations[type]) {\n          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? () =&gt; store.getters\n        : () =&gt; makeLocalGetters(store, namespace)\n    },\n    state: {\n      get: () =&gt; getNestedState(store.state, path)\n    }\n  })\n\n  return local\n}</code></pre>\n<p>如果没有命名空间的情况就是直接使用 root store 上的 dispatch 和 commit 方法，否则使用新定义的方法，这个方法接收三个参数</p>\n<ul>\n<li>_type：dispatch、commit 的 type</li>\n<li>_payload：提交的参数</li>\n<li>_options：其他选项，例如 { root: true } 这个在子模块派发到根仓库的配置项</li>\n</ul>\n<p>把 type 自动拼接上 namespace，然后执行 store 上对应的方法。</p>\n<p>对于 getters 而言，如果没有 namespace，则直接返回 root store 的 getters，否则返回 makeLocalGetters(store, namespace) 的返回值</p>\n<pre><code class=\"js\">function makeLocalGetters (store, namespace) {\n  const gettersProxy = {}\n\n  // 获取了 namespace 的长度\n  const splitPos = namespace.length\n  // 遍历 root store 下的所有 getters\n  Object.keys(store.getters).forEach(type =&gt; {\n\n    // 判断它的类型是否匹配 namespace,不匹配直接结束\n    if (type.slice(0, splitPos) !== namespace) return\n\n    // 获取本地 type，也就是 getNumberPlusOne\n    const localType = type.slice(splitPos)\n\n    // 用 Object.defineProperty 定义了 gettersProxy，获取 localType 实际上就是访问了 store.getters[type]\n    Object.defineProperty(gettersProxy, localType, {\n      get: () =&gt; store.getters[type],\n      enumerable: true\n    })\n  })\n\n  // 访问代理对象\n  return gettersProxy\n}</code></pre>\n<p>第四步注册 Mutations</p>\n<pre><code class=\"js\">module.forEachMutation((mutation, key) =&gt; {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n\nfunction registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}</code></pre>\n<p>通过遍历 module 下的每一个 mutations 属性的值，然后获取带有命名空间的 type，再调用 registerMutation 方法进行注册，该方法实际上就是给 root store 上的 _mutations[types] 添加 wrappedMutationHandler 方法，从而允许我们一个 type 对应多个 mutaions。</p>\n<p>第五步注册 Actions</p>\n<pre><code class=\"js\">module.forEachAction((action, key) =&gt; {\n  const type = action.root ? key : namespace + key\n  const handler = action.handler || action\n  registerAction(store, type, handler, local)\n})\n\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err =&gt; {\n        store._devtoolHook.emit(&#39;vuex:error&#39;, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}</code></pre>\n<p>通过遍历模块中的 actions 拿到每一个 action 和 key。判断 action.root，如果否的情况把 key 拼接上 namespace，然后执行 registerAction 方法。registerAction 接收四个参数</p>\n<ul>\n<li>store：store 实例</li>\n<li>namespacedType：带命名空间的 type</li>\n<li>handler：回调函数</li>\n<li>local：上下文环境，root 为 store，module 为 local</li>\n</ul>\n<p>可以看到 actions 回调的第一个参数是一个对象，里面包含了 dispatch、commit、getters、state、rootGetters、rootState 字段，最后 actions 里通过 Promise 的异步过程，判断 res 的类型返回对应的值</p>\n<p>第五步注册 Getters</p>\n<pre><code class=\"js\">module.forEachGetter((getter, key) =&gt; {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})\n\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      console.error(`[vuex] duplicate getter key: ${type}`)\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}</code></pre>\n<p>通过遍历模块中的 getters 的定义，拿到每一个 getter 和 key，并把 key 拼接上 namespace，然后执行 registerGetter 方法。registerGetter 首先通过 store._wrappedGetters[type] 方法 判断 getter key 重复是否重复，接着在 _wrappedGetters 上以 type 为 key，挂载 wrappedGetter 函数，返回 rawGetters 函数执行的结果。</p>\n<p>第六步安装子模块</p>\n<pre><code class=\"js\">module.forEachChild((child, key) =&gt; {\n  installModule(store, rootState, path.concat(key), child, hot)\n})</code></pre>\n<p>很简单就是递归安装的过程</p>\n<p>以上就是 installModule 函数的作用进行 state、getters、actions、mutations 等模块的初始化和安装工作，接下来我们看 Store 实例化的最后一步，就是执行初始化 store._vm 的逻辑</p>\n<h3 id=\"初始化-store-vm\"><a href=\"#初始化-store-vm\" class=\"headerlink\" title=\"初始化 store._vm\"></a>初始化 store._vm<hr></h3><p>入口是</p>\n<pre><code class=\"js\">resetStoreVM(this, state)</code></pre>\n<p>看一下这个函数的定义</p>\n<pre><code class=\"js\">function resetStoreVM (store, state, hot) {\n  const oldVm = store._vm\n\n  // 建立 getters 和 state 的联系\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  // 执行 computed[key] 对应的函数的时候，会执行 rawGetter(local.state,...) 方法，那么就会访问到 store.state，进而访问到 store._vm._data.$$state，这样就建立了一个依赖关系。当 store.state 发生变化的时候，下一次再访问 store.getters 的时候会重新计算。\n  forEachValue(wrappedGetters, (fn, key) =&gt; {\n    //使用 computed 来利用其延迟缓存机制\n    computed[key] = () =&gt; fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () =&gt; store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // 使用一个Vue实例来存储状态树抑制警告，以防用户添加了一些奇怪的全局混合\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  // 实例化一个 Vue 实例 store._vm，并把 computed 进去\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // 为新vm启用严格模式\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // 将所有订阅的观察者的更改发送到强制 getter 重新评估以便热重载\n      // store._vm 会添加一个 wathcer 来观测 this._data.$$state 的变化，也就是当 store.state 被修改的时候, store._committing 必须为 true，否则在开发阶段会报警告\n      store._withCommit(() =&gt; {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() =&gt; oldVm.$destroy())\n  }\n}</code></pre>\n<p>这里方法的主要是将 state 与 getters 建立好关系，实例化一个 Vue 挂载到 _vm 属性上，通过 computed 属性将 getters 与 state 关联起来并缓存结果。</p>\n<h3 id=\"辅助函数过程分析\"><a href=\"#辅助函数过程分析\" class=\"headerlink\" title=\"辅助函数过程分析\"></a>辅助函数过程分析<hr></h3><p>当然还有很多 API 的分析过程比如怎么执行的 commit、dispatch，mapState 和 mapGetters、mapMutations、mapActions 等辅助函数的实现</p>\n<p>我们可以看 <a href=\"https://ustbhuangyi.github.io/vue-analysis/vuex/api.html#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\" target=\"_blank\" rel=\"noopener\">Vue 技术揭秘</a>中关于这些的讲些</p>\n"},{"title":"vue 原理解析之主线流程","date":"2019-08-27T15:12:09.000Z","top":true,"cover":false,"password":null,"toc":true,"mathjax":false,"summary":null,"_content":"\n\n<div align=\"middle\">\n  <iframe \n    frameborder=\"no\" \n    border=\"0\" \n    marginwidth=\"0\" \n    marginheight=\"0\" \n    width=330 \n    height=86 \n    src=\"//music.163.com/outchain/player?type=2&id=436394160&auto=1&height=66\">\n  </iframe>\n</div>\n\n\n## 源码架构\n\nvue 一直以简单，快速著称，也自称为渐进式框架今天我们来分析一下vue的源码，这样我们也能了解其中的思想，帮助我们在工作中很好的应用和解决问题。当然我们并不可能把源码很细致的分析个遍，那样没什么意义。\n附上 git 仓库<a href=\"https://github.com/vuejs/vue\">vue源码</a>地址。\n\n我们看一下 vue 源码的核心目录方便大家去对应查找\n\n``` md\nsrc\n├── compiler/        # 模版编译目录 \n├── core/            # 核心代码 \n├── platforms/       # 跨平台的支持\n├── server/          # 处理服务端渲染\n├── sfc/             # .vue 文件的解析\n├── shared/          # 全局用到的工具函数\n```\n\n### compiler<hr>\n\nvue 所有编译相关的代码。包括把模版解析成抽象语法树（AST）,编译、生成等功能\n\n### core<hr>\n\nvue 核心代码，包括内置组件，指令、全局API、Observer、虚拟DOM、全局工具函数等，这个目录也是vue的灵魂，也是我们重点关注分析的地方，compiler 会在后续文章中分析\n\n###  platform<hr>\n\n最初 vue 是跑在 web 上的mvvm架构, 后期增加了 阿里团队的 weex 入口，配合 weex 也可以运行在 native 客户端上\n\n### server <hr>\n\n服务端渲染入口，这是是vue2.0 之后更新的功能，所谓的服务端渲染是把相对应的组件渲染为服务端的 html 字符串，然后发送给客户端，客户端进行处理。这样做能提高客户体验\n\n### sfc<hr>\n\n将 .vue 文件内容解析成JavaScript的对象\n\n\n## 源码构建\n\nvue 源码是基于 <a href=\"https://rollupjs.org/guide/en/\">Rollup </a>构建的，构建的配置在 scripts 目录下\n\n``` md\nscripts\n├── git-hook/           # git-hook配置文件\n├── alias               # 混入文件目录别名配置\n├── build               # 构建的入口文件\n├── config              # 构建全局配置文件\n├── feature-flags       # weex 环境 flag\n├── gen-release-note    # 生成 Change log\n├── get-weex-version    # 生成 weexBaseVersion\n├── release-weex        # weex发布的脚本\n├── release             # 发布脚本\n├── verify-commit-msg   # 检查 Commit message 是否符合格式\n```\n\n### 构建脚本<hr>\n\n基于 npm 托管的项目都会有一个 package.json 文件，这个文件当中的 script 描述符中一般配置的基本都是启动项目、打包、测试等相关命令, 看一下 vue 项目根目录的 package.json,由于只做 build 环境中的分析，所以我们去掉 dev、test等执行命令\n\n``` json\n{\n  \"scripts\": {\n    \"build\": \"node scripts/build.js\",\n    \"build:ssr\": \"npm run build -- web-runtime-cjs,web-server-renderer\",\n    \"build:weex\": \"npm run build -- weex\",\n  } \n}\n```\n\n\n上面三个命令在执行的时候通过环境参数来区分不同的平台，当执行 `npm run build` 命令的时候就会执行 `node scripts/build.js` 这个文件\n\n### 构建过程<hr>\n\n接下来来查看一下 `node scripts/build.js` 这个文件看看执行过程\n\n```js\nlet builds = require('./config').getAllBuilds()\n// filter builds via command line arg\nif (process.argv[2]) {\n  const filters = process.argv[2].split(',')\n  builds = builds.filter(b => {\n    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)\n  })\n} else {\n  // filter out weex builds by default\n  builds = builds.filter(b => {\n    return b.output.file.indexOf('weex') === -1\n  })\n}\n\nbuild(builds)\n// ...\n\n\n```\n\n通过上面的代码片段了解到主要引用了 `./config` getAllBuilds 文件下面的方法，进入这个文件\n\n```js\nconst builds = {\n  // ...\n\n  const aliases = require('./alias')\n  const resolve = p => {\n    const base = p.split('/')[0]\n    if (aliases[base]) {\n      return path.resolve(aliases[base], p.slice(base.length + 1))\n    } else {\n      return path.resolve(__dirname, '../', p)\n    }\n  }\n\n\n  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify\n  'web-runtime-cjs-prod': {\n    entry: resolve('web/entry-runtime.js'),\n    dest: resolve('dist/vue.runtime.common.prod.js'),\n    format: 'cjs',\n    env: 'production',\n    banner\n  },\n  // runtime-only production build (Browser)\n  'web-runtime-prod': {\n    entry: resolve('web/entry-runtime.js'),\n    dest: resolve('dist/vue.runtime.min.js'),\n    format: 'umd',\n    env: 'production',\n    banner\n  },\n  // Runtime+compiler CommonJS build (CommonJS)\n  'web-full-prod': {\n    entry: resolve('web/entry-runtime-with-compiler.js'),\n    dest: resolve('dist/vue.min.js'),\n    format: 'umd',\n    env: 'production',\n    alias: { he: './entity-decoder' },\n    banner\n  },\n\n  // ...\n}\n\nfunction genConfig (name) {\n  const opts = builds[name]\n  const config = {\n    input: opts.entry,\n    external: opts.external,\n    plugins: [\n      flow(),\n      alias(Object.assign({}, aliases, opts.alias))\n    ].concat(opts.plugins || []),\n    output: {\n      file: opts.dest,\n      format: opts.format,\n      banner: opts.banner,\n      name: opts.moduleName || 'Vue'\n    }\n    // ...\n  }\n  // ...\n  Object.defineProperty(config, '_name', {\n    enumerable: false,\n    value: name\n  })\n  return config\n\n}\n\n```\n\n通过这里的代码片面大概了解到 vue 通过当前web、服务端渲染、webpack插件、weex等配置来进行打包，每一个配置都遵循 rollup 的构建规则\n\n```json\n{\n  \"entry\": \"构建的入口文件\",\n  \"dest\": \"构建后的文件地址\",\n  \"format\": \"构建规范\",\n  \"alias\": \"别名设置\" \n  // ...\n}\n\n```\n\n那么在打包的过程中进行了路径别名设置，通过别名设置能代码能够更清晰整洁。\n\n```js\nconst path = require('path')\n\nconst resolve = p => path.resolve(__dirname, '../', p)\n\nmodule.exports = {\n  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),\n  compiler: resolve('src/compiler'),\n  core: resolve('src/core'),\n  shared: resolve('src/shared'),\n  web: resolve('src/platforms/web'),\n  weex: resolve('src/platforms/weex'),\n  server: resolve('src/server'),\n  sfc: resolve('src/sfc')\n}\n```\n\n看到这个别名设置，我们就应该很清楚 vue 的核心构建文件都在 src 目录，具体作用在文章开头就已经介绍过了。那么我们主要看 web 别名下的目录，其它的目录有兴趣的同学可以了解一下实现规则\n\n```js\nimport Vue from 'core/index'\nimport config from 'core/config'\nimport { extend, noop } from 'shared/util'\nimport { mountComponent } from 'core/instance/lifecycle'\nimport { devtools, inBrowser } from 'core/util/index'\n\n// ...\n\nimport { patch } from './patch'\nimport platformDirectives from './directives/index'\nimport platformComponents from './components/index'\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives)\nextend(Vue.options.components, platformComponents)\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\n\n```\n\n终于看到了 Vue 构造函数和核心代码的入口`core/index`，并在构造函数和原型上面挂载了一些方法，通过执行的上述构建过程我们总结到\n\nVue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成(独立构建和运行时构建 只是 platforms 下 web 平台的两种选择)\n\n<img src=\"/images/vue-init.png\" width=\"50%\">\n\n\n## new Vue\n\n\n通过 vue 的核心目录，我们知道 Vue 实际上是一个构造函数，上面挂满了大大小小的各种方法我们在用的时候传一定的参数即可\n\n```js\nnew Vue({\n  el: 'xxxx',\n  data: xxxx,\n  ...\n})\n```\n\n### initGlobalAPI<hr/>\n\n那么在 vue 实例化的过程中到底发生了什么，打开核心代码 `src/core` 目录下面的 index\n\n\n```js\nsrc/core/index.js\n\n// vue初始化的核心文件--创建Vue构造函数，将构造函数传入五个方法中\nimport Vue from './instance/index'\n// 初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n// 获得一些环境判断，和是否是服务端渲染\nimport { isServerRendering } from 'core/util/env'\n// ssr 环境加载此方法\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\n\n//初始化全局API变量\ninitGlobalAPI(Vue)\n\n//为vue的原型定义$isServer属性\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\n//为vue的原型定义$ssrContext\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n//为vue原型定义当为ssr环境时加载FunctionalRenderContext方法\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\n//添加版本号\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n\n总结一下这个文件加载的方法\n\n```md\n\ncore/index\n├── Vue            # 初始化构造函数\n├── initGlobalAPI  # 初始化全局API\n├── $isServer      # 判断环境的工具函数\n├── $ssrContext    # ssr 环境加载此方法也可用于操作状态\n├── FunctionalRenderContext  # ssr 环境加载此方法\n├── 添加版本号\n```\n### new Vue <hr/>\n\n初始化文件后，进入导出 Vue 构造函数的文件 `src/core/instance/index.js `\n\n```js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n上面我们看到了 Vue 实际上就是一个用 Function 实现的类，通过 new 关键字初始化，然后会调用 this._init 方法。\n\n```js\n// ...\n Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n\n    // 对参数进行 merge 操作  \n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n\n    // 通过判断 Proxy 为 vue的实例属性赋值\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    vm._self = vm\n\n    // 初始化生命周期相关\n    initLifecycle(vm)\n\n    // 输初始化事件监听相关\n    initEvents(vm)\n\n    // 初始化编译render\n    initRender(vm)\n\n    // 调用beforeCreate钩子函数并且触发beforeCreate钩子事件\n    callHook(vm, 'beforeCreate')\n\n    initInjections(vm)\n\n    // 初始化props、methods、data、computed与watch\n    initState(vm)\n\n    initProvide(vm)\n\n    // 调用created钩子函数并且触发created钩子事件\n    callHook(vm, 'created')\n\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      // 格式化组件名\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n\n\n    // 挂载组件方法触发组件的DOM渲染\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n\n// ...\n```\n通过上面代码的注释了解到 Vue 初始化主要就干了几件事情，合并配置操作，初始化生命周期，初始化事件监听，初始化render，初始化 data、props、computed、watcher 等，在最后调用vm.$mount 方法挂载 vm ，把模版渲染成DOM。当然这里面还有很多细节需要知道例如上面初始化合并配置，生命周期初始化等，会在后面清楚的梳理 vue 整理流程之后，进入细节\n\n## vm.$mount\n\n通过 $mount 实例方法去挂载 vm ，但 $mount 方法是由于多平台编译处理不太一样，所以在多个文件中定义。我们进入 `src/platform` 这个目录可以观察到有 web 和 weex 目录，我们直接抛掉 weex，只分析 web 目录，在 vue 官网教程中介绍了vue的完整版`web/entry-runtime-with-compiler.js`和runtime版本`web/runtime/index.js`\n\n完整版\n\n- 包含编译和运行是的版本\n- html字符串 → render函数 → vnode → 真实dom节点\n\nruntime版本\n\n- 创建 Vue 实例、render、更新 DOM 等的操作的代码，没有编译器编译模版字符串代码\n- render函数 → vnode → 真实dom节点\n\n\n### 完整版 $mount<hr>\n\n```js\n// ...\n\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      \n      // ...\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      // ..\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n\n// ...\n```\n\n上面代码逻辑很清晰，将执行以下过程\n\n- 首先在原型上定义了 $mount 这个方法\n- 对传入的 el 做限制不能将节点挂载在 body 和 html 这种跟节点上\n- 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法\n- 模版或字符串转换 render 方法（调用 compileToFunctions 进行编译转换）\n\n\n### runtime 版本 $mount<hr>\n\n```js\n// ...\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\n\n```\n\n执行过程\n- 挂载的元素，可以是字符串，也可以是DOM对象，如果是字符串通过 query 方法转换成DOM\n- 执行 mountComponent 函数传入三个参数\n \n通过上面代码可以看出并没有经过 compileToFunctions方法 进行转换编译阶段，而直接是 render --> VNode 过程。\n\n接下来我们接着查看 mountComponent方法调用，打开文件`src/core/instance/lifecycle.js`\n\n```js\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    // ...\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  \n  // ...\n\n  updateComponent = () => {\n    vm._update(vm._render(), hydrating)\n  }\n\n  // ...\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n```\n\n通过上面代码很直观的看见 mountComponent 方法主要作用\n\n- 判断 render 函数是不是存在如果不存在调用创建 createEmptyVNode 方法创建一个空VNode节点\n- 检测完 render 开始挂载 beforeMount 钩子\n- 执行 new Watcher方法()\n- _isMounted状态设置true， 开始挂载mounted\n\n\nWatcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM\n\nWatcher 初始化的时候会执行回调函数，当 vm 实例中的监测的数据发生变化的时候也会执行回调函数，这就是我们说的观察者进行依赖收集的过程,当然这也是 vue 核心原理的一部分。new Watcher到底做了什么我们在后面的单独整理，先以主线程为主\n\n\n## vm._render\n\n上文中提到 Watcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM，那么就出现 私有方法 vm._render 和 vm._update 两个最核心的方法。\n \n_render 定义在 `src/core/instance/render.js` 中\n\n```js\n\n  // ...\n  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    const { render, _parentVnode } = vm.$options\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      )\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      handleError(e, vm, `render`)\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n        } catch (e) {\n          handleError(e, vm, `renderError`)\n          vnode = vm._vnode\n        }\n      } else {\n        vnode = vm._vnode\n      }\n    } finally {\n      currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        )\n      }\n      vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }\n```\n\n\n上面这段代码最关键的地方就是调用 render 方法 `render.call(vm._renderProxy, vm.$createElement)`，在上面说过在 mounted 方法中会把 template 和 string 经过 compileToFunctions 编译最后形成 render方法进行渲染，但是这是用字符串模版的形式，如果用字符串模板的代替方案 render 方法呢\n\n\n```js\nnew Vue({\n  render: function (createElement) {\n   return createElement('div', {\n     attrs: {\n        id: 'app'\n      },\n  }, this.message)\n  },\n  renderError: function(createElement, err) {\n    return createElement('pre', { style: { color: 'red' }}, err.stack)\n  }\n}).$mount('#app')\n```\n\n我们可以看出render 方法的参数 createElement 实际上就是 vm.$createElement,然而 vm.$createElement 在初始化中就已经执行过了\n\n```js\nexport function initRender (vm: Component) {\n  \n  // ...\n\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  const parentData = parentVnode && parentVnode.data\n\n  // ...\n\n}\n```\n\n所以在 initRender 方法的时候，除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，但 vm.$createElement 是我们用原生写的 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。\n\n官网中一句话说的很清楚 **Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。**\n\n通过上述总结到 render 函数最终是执行 createElement 方法 返回 vnode 节点，这是一个虚拟 node 而 vue2.0 的 另一个核心就是利用了Virtual DOM，实际上 Vue.js 中 Virtual DOM 是借鉴了开源库 <a href=\"https://github.com/snabbdom/snabbdom\">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西, 这部分源码就在 `src/core/vdom/vnode.js` 中我们暂时不去查看，待后续文章写到 Virtual DOM 的时候我们在做分析。 \n\n那么在面试中我们经常被问到是 操作 Virtual DOM 快还是真实 DOM 快\n\n答案是相对的在数据量大的情况下，肯定是 Virtual DOM 快，因为通过对比 node 减少频繁的去更新DOM， 如果数据量相对较小的情况还是直接操作 DOM 较快，因为少了编译、遍历、对比的过程\n\n## vm.$createElement\n\n上面文章提到 render 的时候内部调用了 createElement 方法，创建了vnode，该方法定义在 src/core/vdom/create-elemenet.js 中\n\n```js\n// ...\n\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n\n   /**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */   \n  if (isDef(data) && isDef((data: any).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n      'Always create fresh vnode data objects in each render!',\n      context\n    )\n    return createEmptyVNode()\n  }\n\n  // 当通过 :is 动态设置组件时\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n\n\n  // ...\n\n  // 作用域插槽\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {}\n    data.scopedSlots = { default: children[0] }\n    children.length = 0\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n  }\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {\n        warn(\n          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,\n          context\n        )\n      }\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns)\n    if (isDef(data)) registerDeepBindings(data)\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\n// ...\n\n```\n\n通过上面代码我们看到 主要调用了几个方法 createEmptyVNode 和 createComponent、normalizeChildren、simpleNormalizeChildren\n\n我们简单的看一下执行步骤\n\n首先判断了 tag 是否存在，如果不存在则调用 `src/core/vdom/vnode.js`目录下的 createEmptyVNode 方法创建空的 vnode 节点\n\n如果传递了children，由于其是任意类型，所以根据 normalizationType 去调用`src/core/vdom/helpers/normalzie-children.js` 目录下的 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法进行递归遍历，把整个 children 打平，让它变成深度只有一层的 vnode 数组\n\n最后通过 对参数 tag 的判断，如果是一个普通的 html 标签，则实例化一个普通 vnode 节点，否则通过 `src/core/vdom/create-component.js`目录下的 createComponent 方法创建一个组件的 vnode\n\n因为除了组件的 vnode 没有 children，其他通过 createElement 创建的每个 vnode 都有 children，children 每个元素也是一个 vnode，这样就形成了一个 vnode tree，这样我们就知道 vm._render 阶段是如何创建的 vnode，那么接下来我们就通过 vm._update，将 vnode 渲染成真实的 dom。\n\n## vm._update\n\nvm._update 也是一个私有方法，作用是把 vnode 渲染成真实的 dom 在 `src/core/instance/lifecycle.js` 文件中定义\n\n### _update <hr/>\n\n```js\n\n  // ...\n\n\n  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    restoreActiveInstance()\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  }\n\n  // ...\n```\n\n通过上面代码我们知道 vm._update 的核心就是通过 vm.__patch__函数来实现将 vnode 转换成真实的 node 节点，而 vm.__patch__ 的实现是多平台的有weex、ssr、inBrowser，我们只查看在浏览器环境内的实现\n\n在 `src/platforms/web/runtime/index.js` 通过判断如果是浏览器环境调用 patch，否则创建一个空对象\n\n### __patch__ <hr/>\n\n```js\n// ...\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// ...\n```\n\n通过引用我们到 `src/platforms/web/runtime/patch.js` 目录看到调用了 createPatchFunction 方法的返回值\n\n```js\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\n```\n\n### createPatchFunction <hr>\n\n在通过查找文件 `src/core/vdom/patch.js` 中定义的 createPatchFunction 方法\n\n```js\n\n// ...\n\nexport function createPatchFunction (backend) {\n\n  // ...\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    // 如果 vnode 不存在但 oldVnode 存在，调用 invokeDestroyHook(oldVnode) 来进行销毁旧节点\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n      return\n    }\n\n    let isInitialPatch = false\n    const insertedVnodeQueue = []\n\n    // 如果oldVnode不存在，vnode存在，则创建新节点  \n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true\n      createElm(vnode, insertedVnodeQueue)\n    } else {\n\n      const isRealElement = isDef(oldVnode.nodeType)\n      // 如果 oldVnode 与 vnode 都存在判断是同一节点调用 patchVnode 处理去比较两个节点的差异\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n      } else {\n\n        if (isRealElement) {\n\n          // 如果存在真实的节点，存在data-server-rendered属性，将 hydrating 变为true\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR)\n            hydrating = true\n          }\n\n          // 用hydrate函数将虚拟DOM和真实DOM进行映射\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true)\n              return oldVnode\n            }\n            // ...\n          }\n\n          // 如果不是server-rendered 或者hydration失败\n          // 创建一个空VNode，代替oldVnode\n          oldVnode = emptyNodeAt(oldVnode)\n        }\n\n        // 将oldVnode设置为对应的虚拟dom，找到oldVnode.elm的父节点\n        // 根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置\n        const oldElm = oldVnode.elm\n        const parentElm = nodeOps.parentNode(oldElm)\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        )\n\n        // 递归更新父级占位节点元素，\n        if (isDef(vnode.parent)) {\n          let ancestor = vnode.parent\n          const patchable = isPatchable(vnode)\n          while (ancestor) {\n            for (let i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor)\n            }\n            ancestor.elm = vnode.elm\n            if (patchable) {\n              for (let i = 0; i < cbs.create.length; ++i) {\n                cbs.create[i](emptyNode, ancestor)\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              const insert = ancestor.data.hook.insert\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (let i = 1; i < insert.fns.length; i++) {\n                  insert.fns[i]()\n                }\n              }\n            } else {\n              registerRef(ancestor)\n            }\n            ancestor = ancestor.parent\n          }\n        }\n\n        // 销毁旧节点\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0)\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode)\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n\n    // 返回节点\n    return vnode.elm\n  }\n}\n\n```\n\n通过上面看到 patch 方法本身\n\n接收 4个参数\n\n- oldVnode 表示旧的 VNode 节点或者或者是一个 DOM 对象\n- vnode 表示执行 _render 后返回的 VNode 的节点\n- hydrating 表示是否是服务端渲染\n- removeOnly 是给 transition-group 用的，防止在 updateChildren 阶段，移动 vnode 节点\n\n关键调用三个方法\n\n- createElm 以当前旧节点为参考节点，创建新的节点，执行相关的 insert 钩子函数，并插入到 DOM 中，\n- sameVnode 通过对比 key 是否相同、tag、注释、data是否存在等判断2个节点，是否是同一个节点\n- patchVnode vdom 核心更新 node \n\npatchVode 中的几个核心方法 addVnodes、 removeVnodes，updateChildren，具体是怎么增加、删除，更新 vnode 和 dom 节点的，dom-diff 比较复杂，我们会在分析响应式原理的时候具体查看细节\n\n\n### 主流程总结<hr>\n\n下面我们通过一张图来总结 vue 主线流程\n\n<img src=\"/images/vue-process.png\" />\n\n上面的图中能够直观的看到 vue 主干的执行流程，但是缺少核心部分，也就是 vue 的响应式原理，下篇文章我们也是通过文件的执行过程来分析 vue 响应式原理的实现\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                \n","source":"_posts/vue/vuePrinciple.md","raw":"---\ntitle: vue 原理解析之主线流程\ndate: 2019-08-27 23:12:09\ntop: true\ncover: false\npassword:\ntoc: true\nmathjax: false\nsummary: \ntags:\n- vue\ncategories:\n- vue\n---\n\n\n<div align=\"middle\">\n  <iframe \n    frameborder=\"no\" \n    border=\"0\" \n    marginwidth=\"0\" \n    marginheight=\"0\" \n    width=330 \n    height=86 \n    src=\"//music.163.com/outchain/player?type=2&id=436394160&auto=1&height=66\">\n  </iframe>\n</div>\n\n\n## 源码架构\n\nvue 一直以简单，快速著称，也自称为渐进式框架今天我们来分析一下vue的源码，这样我们也能了解其中的思想，帮助我们在工作中很好的应用和解决问题。当然我们并不可能把源码很细致的分析个遍，那样没什么意义。\n附上 git 仓库<a href=\"https://github.com/vuejs/vue\">vue源码</a>地址。\n\n我们看一下 vue 源码的核心目录方便大家去对应查找\n\n``` md\nsrc\n├── compiler/        # 模版编译目录 \n├── core/            # 核心代码 \n├── platforms/       # 跨平台的支持\n├── server/          # 处理服务端渲染\n├── sfc/             # .vue 文件的解析\n├── shared/          # 全局用到的工具函数\n```\n\n### compiler<hr>\n\nvue 所有编译相关的代码。包括把模版解析成抽象语法树（AST）,编译、生成等功能\n\n### core<hr>\n\nvue 核心代码，包括内置组件，指令、全局API、Observer、虚拟DOM、全局工具函数等，这个目录也是vue的灵魂，也是我们重点关注分析的地方，compiler 会在后续文章中分析\n\n###  platform<hr>\n\n最初 vue 是跑在 web 上的mvvm架构, 后期增加了 阿里团队的 weex 入口，配合 weex 也可以运行在 native 客户端上\n\n### server <hr>\n\n服务端渲染入口，这是是vue2.0 之后更新的功能，所谓的服务端渲染是把相对应的组件渲染为服务端的 html 字符串，然后发送给客户端，客户端进行处理。这样做能提高客户体验\n\n### sfc<hr>\n\n将 .vue 文件内容解析成JavaScript的对象\n\n\n## 源码构建\n\nvue 源码是基于 <a href=\"https://rollupjs.org/guide/en/\">Rollup </a>构建的，构建的配置在 scripts 目录下\n\n``` md\nscripts\n├── git-hook/           # git-hook配置文件\n├── alias               # 混入文件目录别名配置\n├── build               # 构建的入口文件\n├── config              # 构建全局配置文件\n├── feature-flags       # weex 环境 flag\n├── gen-release-note    # 生成 Change log\n├── get-weex-version    # 生成 weexBaseVersion\n├── release-weex        # weex发布的脚本\n├── release             # 发布脚本\n├── verify-commit-msg   # 检查 Commit message 是否符合格式\n```\n\n### 构建脚本<hr>\n\n基于 npm 托管的项目都会有一个 package.json 文件，这个文件当中的 script 描述符中一般配置的基本都是启动项目、打包、测试等相关命令, 看一下 vue 项目根目录的 package.json,由于只做 build 环境中的分析，所以我们去掉 dev、test等执行命令\n\n``` json\n{\n  \"scripts\": {\n    \"build\": \"node scripts/build.js\",\n    \"build:ssr\": \"npm run build -- web-runtime-cjs,web-server-renderer\",\n    \"build:weex\": \"npm run build -- weex\",\n  } \n}\n```\n\n\n上面三个命令在执行的时候通过环境参数来区分不同的平台，当执行 `npm run build` 命令的时候就会执行 `node scripts/build.js` 这个文件\n\n### 构建过程<hr>\n\n接下来来查看一下 `node scripts/build.js` 这个文件看看执行过程\n\n```js\nlet builds = require('./config').getAllBuilds()\n// filter builds via command line arg\nif (process.argv[2]) {\n  const filters = process.argv[2].split(',')\n  builds = builds.filter(b => {\n    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)\n  })\n} else {\n  // filter out weex builds by default\n  builds = builds.filter(b => {\n    return b.output.file.indexOf('weex') === -1\n  })\n}\n\nbuild(builds)\n// ...\n\n\n```\n\n通过上面的代码片段了解到主要引用了 `./config` getAllBuilds 文件下面的方法，进入这个文件\n\n```js\nconst builds = {\n  // ...\n\n  const aliases = require('./alias')\n  const resolve = p => {\n    const base = p.split('/')[0]\n    if (aliases[base]) {\n      return path.resolve(aliases[base], p.slice(base.length + 1))\n    } else {\n      return path.resolve(__dirname, '../', p)\n    }\n  }\n\n\n  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify\n  'web-runtime-cjs-prod': {\n    entry: resolve('web/entry-runtime.js'),\n    dest: resolve('dist/vue.runtime.common.prod.js'),\n    format: 'cjs',\n    env: 'production',\n    banner\n  },\n  // runtime-only production build (Browser)\n  'web-runtime-prod': {\n    entry: resolve('web/entry-runtime.js'),\n    dest: resolve('dist/vue.runtime.min.js'),\n    format: 'umd',\n    env: 'production',\n    banner\n  },\n  // Runtime+compiler CommonJS build (CommonJS)\n  'web-full-prod': {\n    entry: resolve('web/entry-runtime-with-compiler.js'),\n    dest: resolve('dist/vue.min.js'),\n    format: 'umd',\n    env: 'production',\n    alias: { he: './entity-decoder' },\n    banner\n  },\n\n  // ...\n}\n\nfunction genConfig (name) {\n  const opts = builds[name]\n  const config = {\n    input: opts.entry,\n    external: opts.external,\n    plugins: [\n      flow(),\n      alias(Object.assign({}, aliases, opts.alias))\n    ].concat(opts.plugins || []),\n    output: {\n      file: opts.dest,\n      format: opts.format,\n      banner: opts.banner,\n      name: opts.moduleName || 'Vue'\n    }\n    // ...\n  }\n  // ...\n  Object.defineProperty(config, '_name', {\n    enumerable: false,\n    value: name\n  })\n  return config\n\n}\n\n```\n\n通过这里的代码片面大概了解到 vue 通过当前web、服务端渲染、webpack插件、weex等配置来进行打包，每一个配置都遵循 rollup 的构建规则\n\n```json\n{\n  \"entry\": \"构建的入口文件\",\n  \"dest\": \"构建后的文件地址\",\n  \"format\": \"构建规范\",\n  \"alias\": \"别名设置\" \n  // ...\n}\n\n```\n\n那么在打包的过程中进行了路径别名设置，通过别名设置能代码能够更清晰整洁。\n\n```js\nconst path = require('path')\n\nconst resolve = p => path.resolve(__dirname, '../', p)\n\nmodule.exports = {\n  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),\n  compiler: resolve('src/compiler'),\n  core: resolve('src/core'),\n  shared: resolve('src/shared'),\n  web: resolve('src/platforms/web'),\n  weex: resolve('src/platforms/weex'),\n  server: resolve('src/server'),\n  sfc: resolve('src/sfc')\n}\n```\n\n看到这个别名设置，我们就应该很清楚 vue 的核心构建文件都在 src 目录，具体作用在文章开头就已经介绍过了。那么我们主要看 web 别名下的目录，其它的目录有兴趣的同学可以了解一下实现规则\n\n```js\nimport Vue from 'core/index'\nimport config from 'core/config'\nimport { extend, noop } from 'shared/util'\nimport { mountComponent } from 'core/instance/lifecycle'\nimport { devtools, inBrowser } from 'core/util/index'\n\n// ...\n\nimport { patch } from './patch'\nimport platformDirectives from './directives/index'\nimport platformComponents from './components/index'\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives)\nextend(Vue.options.components, platformComponents)\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\n\n```\n\n终于看到了 Vue 构造函数和核心代码的入口`core/index`，并在构造函数和原型上面挂载了一些方法，通过执行的上述构建过程我们总结到\n\nVue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成(独立构建和运行时构建 只是 platforms 下 web 平台的两种选择)\n\n<img src=\"/images/vue-init.png\" width=\"50%\">\n\n\n## new Vue\n\n\n通过 vue 的核心目录，我们知道 Vue 实际上是一个构造函数，上面挂满了大大小小的各种方法我们在用的时候传一定的参数即可\n\n```js\nnew Vue({\n  el: 'xxxx',\n  data: xxxx,\n  ...\n})\n```\n\n### initGlobalAPI<hr/>\n\n那么在 vue 实例化的过程中到底发生了什么，打开核心代码 `src/core` 目录下面的 index\n\n\n```js\nsrc/core/index.js\n\n// vue初始化的核心文件--创建Vue构造函数，将构造函数传入五个方法中\nimport Vue from './instance/index'\n// 初始化全局API\nimport { initGlobalAPI } from './global-api/index'\n// 获得一些环境判断，和是否是服务端渲染\nimport { isServerRendering } from 'core/util/env'\n// ssr 环境加载此方法\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\n\n//初始化全局API变量\ninitGlobalAPI(Vue)\n\n//为vue的原型定义$isServer属性\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\n//为vue的原型定义$ssrContext\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n//为vue原型定义当为ssr环境时加载FunctionalRenderContext方法\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\n//添加版本号\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n\n总结一下这个文件加载的方法\n\n```md\n\ncore/index\n├── Vue            # 初始化构造函数\n├── initGlobalAPI  # 初始化全局API\n├── $isServer      # 判断环境的工具函数\n├── $ssrContext    # ssr 环境加载此方法也可用于操作状态\n├── FunctionalRenderContext  # ssr 环境加载此方法\n├── 添加版本号\n```\n### new Vue <hr/>\n\n初始化文件后，进入导出 Vue 构造函数的文件 `src/core/instance/index.js `\n\n```js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n上面我们看到了 Vue 实际上就是一个用 Function 实现的类，通过 new 关键字初始化，然后会调用 this._init 方法。\n\n```js\n// ...\n Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n\n    // 对参数进行 merge 操作  \n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n\n    // 通过判断 Proxy 为 vue的实例属性赋值\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    vm._self = vm\n\n    // 初始化生命周期相关\n    initLifecycle(vm)\n\n    // 输初始化事件监听相关\n    initEvents(vm)\n\n    // 初始化编译render\n    initRender(vm)\n\n    // 调用beforeCreate钩子函数并且触发beforeCreate钩子事件\n    callHook(vm, 'beforeCreate')\n\n    initInjections(vm)\n\n    // 初始化props、methods、data、computed与watch\n    initState(vm)\n\n    initProvide(vm)\n\n    // 调用created钩子函数并且触发created钩子事件\n    callHook(vm, 'created')\n\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      // 格式化组件名\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n\n\n    // 挂载组件方法触发组件的DOM渲染\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n\n// ...\n```\n通过上面代码的注释了解到 Vue 初始化主要就干了几件事情，合并配置操作，初始化生命周期，初始化事件监听，初始化render，初始化 data、props、computed、watcher 等，在最后调用vm.$mount 方法挂载 vm ，把模版渲染成DOM。当然这里面还有很多细节需要知道例如上面初始化合并配置，生命周期初始化等，会在后面清楚的梳理 vue 整理流程之后，进入细节\n\n## vm.$mount\n\n通过 $mount 实例方法去挂载 vm ，但 $mount 方法是由于多平台编译处理不太一样，所以在多个文件中定义。我们进入 `src/platform` 这个目录可以观察到有 web 和 weex 目录，我们直接抛掉 weex，只分析 web 目录，在 vue 官网教程中介绍了vue的完整版`web/entry-runtime-with-compiler.js`和runtime版本`web/runtime/index.js`\n\n完整版\n\n- 包含编译和运行是的版本\n- html字符串 → render函数 → vnode → 真实dom节点\n\nruntime版本\n\n- 创建 Vue 实例、render、更新 DOM 等的操作的代码，没有编译器编译模版字符串代码\n- render函数 → vnode → 真实dom节点\n\n\n### 完整版 $mount<hr>\n\n```js\n// ...\n\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      \n      // ...\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== 'production',\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      // ..\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n\n// ...\n```\n\n上面代码逻辑很清晰，将执行以下过程\n\n- 首先在原型上定义了 $mount 这个方法\n- 对传入的 el 做限制不能将节点挂载在 body 和 html 这种跟节点上\n- 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法\n- 模版或字符串转换 render 方法（调用 compileToFunctions 进行编译转换）\n\n\n### runtime 版本 $mount<hr>\n\n```js\n// ...\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\n\n```\n\n执行过程\n- 挂载的元素，可以是字符串，也可以是DOM对象，如果是字符串通过 query 方法转换成DOM\n- 执行 mountComponent 函数传入三个参数\n \n通过上面代码可以看出并没有经过 compileToFunctions方法 进行转换编译阶段，而直接是 render --> VNode 过程。\n\n接下来我们接着查看 mountComponent方法调用，打开文件`src/core/instance/lifecycle.js`\n\n```js\nexport function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    // ...\n  }\n  callHook(vm, 'beforeMount')\n\n  let updateComponent\n  \n  // ...\n\n  updateComponent = () => {\n    vm._update(vm._render(), hydrating)\n  }\n\n  // ...\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n```\n\n通过上面代码很直观的看见 mountComponent 方法主要作用\n\n- 判断 render 函数是不是存在如果不存在调用创建 createEmptyVNode 方法创建一个空VNode节点\n- 检测完 render 开始挂载 beforeMount 钩子\n- 执行 new Watcher方法()\n- _isMounted状态设置true， 开始挂载mounted\n\n\nWatcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM\n\nWatcher 初始化的时候会执行回调函数，当 vm 实例中的监测的数据发生变化的时候也会执行回调函数，这就是我们说的观察者进行依赖收集的过程,当然这也是 vue 核心原理的一部分。new Watcher到底做了什么我们在后面的单独整理，先以主线程为主\n\n\n## vm._render\n\n上文中提到 Watcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM，那么就出现 私有方法 vm._render 和 vm._update 两个最核心的方法。\n \n_render 定义在 `src/core/instance/render.js` 中\n\n```js\n\n  // ...\n  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    const { render, _parentVnode } = vm.$options\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      )\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      handleError(e, vm, `render`)\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n        } catch (e) {\n          handleError(e, vm, `renderError`)\n          vnode = vm._vnode\n        }\n      } else {\n        vnode = vm._vnode\n      }\n    } finally {\n      currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        )\n      }\n      vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }\n```\n\n\n上面这段代码最关键的地方就是调用 render 方法 `render.call(vm._renderProxy, vm.$createElement)`，在上面说过在 mounted 方法中会把 template 和 string 经过 compileToFunctions 编译最后形成 render方法进行渲染，但是这是用字符串模版的形式，如果用字符串模板的代替方案 render 方法呢\n\n\n```js\nnew Vue({\n  render: function (createElement) {\n   return createElement('div', {\n     attrs: {\n        id: 'app'\n      },\n  }, this.message)\n  },\n  renderError: function(createElement, err) {\n    return createElement('pre', { style: { color: 'red' }}, err.stack)\n  }\n}).$mount('#app')\n```\n\n我们可以看出render 方法的参数 createElement 实际上就是 vm.$createElement,然而 vm.$createElement 在初始化中就已经执行过了\n\n```js\nexport function initRender (vm: Component) {\n  \n  // ...\n\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  const parentData = parentVnode && parentVnode.data\n\n  // ...\n\n}\n```\n\n所以在 initRender 方法的时候，除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，但 vm.$createElement 是我们用原生写的 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。\n\n官网中一句话说的很清楚 **Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。**\n\n通过上述总结到 render 函数最终是执行 createElement 方法 返回 vnode 节点，这是一个虚拟 node 而 vue2.0 的 另一个核心就是利用了Virtual DOM，实际上 Vue.js 中 Virtual DOM 是借鉴了开源库 <a href=\"https://github.com/snabbdom/snabbdom\">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西, 这部分源码就在 `src/core/vdom/vnode.js` 中我们暂时不去查看，待后续文章写到 Virtual DOM 的时候我们在做分析。 \n\n那么在面试中我们经常被问到是 操作 Virtual DOM 快还是真实 DOM 快\n\n答案是相对的在数据量大的情况下，肯定是 Virtual DOM 快，因为通过对比 node 减少频繁的去更新DOM， 如果数据量相对较小的情况还是直接操作 DOM 较快，因为少了编译、遍历、对比的过程\n\n## vm.$createElement\n\n上面文章提到 render 的时候内部调用了 createElement 方法，创建了vnode，该方法定义在 src/core/vdom/create-elemenet.js 中\n\n```js\n// ...\n\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n\n   /**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */   \n  if (isDef(data) && isDef((data: any).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n      'Always create fresh vnode data objects in each render!',\n      context\n    )\n    return createEmptyVNode()\n  }\n\n  // 当通过 :is 动态设置组件时\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n\n\n  // ...\n\n  // 作用域插槽\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {}\n    data.scopedSlots = { default: children[0] }\n    children.length = 0\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n  }\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {\n        warn(\n          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,\n          context\n        )\n      }\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns)\n    if (isDef(data)) registerDeepBindings(data)\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\n// ...\n\n```\n\n通过上面代码我们看到 主要调用了几个方法 createEmptyVNode 和 createComponent、normalizeChildren、simpleNormalizeChildren\n\n我们简单的看一下执行步骤\n\n首先判断了 tag 是否存在，如果不存在则调用 `src/core/vdom/vnode.js`目录下的 createEmptyVNode 方法创建空的 vnode 节点\n\n如果传递了children，由于其是任意类型，所以根据 normalizationType 去调用`src/core/vdom/helpers/normalzie-children.js` 目录下的 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法进行递归遍历，把整个 children 打平，让它变成深度只有一层的 vnode 数组\n\n最后通过 对参数 tag 的判断，如果是一个普通的 html 标签，则实例化一个普通 vnode 节点，否则通过 `src/core/vdom/create-component.js`目录下的 createComponent 方法创建一个组件的 vnode\n\n因为除了组件的 vnode 没有 children，其他通过 createElement 创建的每个 vnode 都有 children，children 每个元素也是一个 vnode，这样就形成了一个 vnode tree，这样我们就知道 vm._render 阶段是如何创建的 vnode，那么接下来我们就通过 vm._update，将 vnode 渲染成真实的 dom。\n\n## vm._update\n\nvm._update 也是一个私有方法，作用是把 vnode 渲染成真实的 dom 在 `src/core/instance/lifecycle.js` 文件中定义\n\n### _update <hr/>\n\n```js\n\n  // ...\n\n\n  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    restoreActiveInstance()\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  }\n\n  // ...\n```\n\n通过上面代码我们知道 vm._update 的核心就是通过 vm.__patch__函数来实现将 vnode 转换成真实的 node 节点，而 vm.__patch__ 的实现是多平台的有weex、ssr、inBrowser，我们只查看在浏览器环境内的实现\n\n在 `src/platforms/web/runtime/index.js` 通过判断如果是浏览器环境调用 patch，否则创建一个空对象\n\n### __patch__ <hr/>\n\n```js\n// ...\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// ...\n```\n\n通过引用我们到 `src/platforms/web/runtime/patch.js` 目录看到调用了 createPatchFunction 方法的返回值\n\n```js\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\n```\n\n### createPatchFunction <hr>\n\n在通过查找文件 `src/core/vdom/patch.js` 中定义的 createPatchFunction 方法\n\n```js\n\n// ...\n\nexport function createPatchFunction (backend) {\n\n  // ...\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    // 如果 vnode 不存在但 oldVnode 存在，调用 invokeDestroyHook(oldVnode) 来进行销毁旧节点\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n      return\n    }\n\n    let isInitialPatch = false\n    const insertedVnodeQueue = []\n\n    // 如果oldVnode不存在，vnode存在，则创建新节点  \n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true\n      createElm(vnode, insertedVnodeQueue)\n    } else {\n\n      const isRealElement = isDef(oldVnode.nodeType)\n      // 如果 oldVnode 与 vnode 都存在判断是同一节点调用 patchVnode 处理去比较两个节点的差异\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n      } else {\n\n        if (isRealElement) {\n\n          // 如果存在真实的节点，存在data-server-rendered属性，将 hydrating 变为true\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR)\n            hydrating = true\n          }\n\n          // 用hydrate函数将虚拟DOM和真实DOM进行映射\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true)\n              return oldVnode\n            }\n            // ...\n          }\n\n          // 如果不是server-rendered 或者hydration失败\n          // 创建一个空VNode，代替oldVnode\n          oldVnode = emptyNodeAt(oldVnode)\n        }\n\n        // 将oldVnode设置为对应的虚拟dom，找到oldVnode.elm的父节点\n        // 根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置\n        const oldElm = oldVnode.elm\n        const parentElm = nodeOps.parentNode(oldElm)\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        )\n\n        // 递归更新父级占位节点元素，\n        if (isDef(vnode.parent)) {\n          let ancestor = vnode.parent\n          const patchable = isPatchable(vnode)\n          while (ancestor) {\n            for (let i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor)\n            }\n            ancestor.elm = vnode.elm\n            if (patchable) {\n              for (let i = 0; i < cbs.create.length; ++i) {\n                cbs.create[i](emptyNode, ancestor)\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              const insert = ancestor.data.hook.insert\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (let i = 1; i < insert.fns.length; i++) {\n                  insert.fns[i]()\n                }\n              }\n            } else {\n              registerRef(ancestor)\n            }\n            ancestor = ancestor.parent\n          }\n        }\n\n        // 销毁旧节点\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0)\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode)\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n\n    // 返回节点\n    return vnode.elm\n  }\n}\n\n```\n\n通过上面看到 patch 方法本身\n\n接收 4个参数\n\n- oldVnode 表示旧的 VNode 节点或者或者是一个 DOM 对象\n- vnode 表示执行 _render 后返回的 VNode 的节点\n- hydrating 表示是否是服务端渲染\n- removeOnly 是给 transition-group 用的，防止在 updateChildren 阶段，移动 vnode 节点\n\n关键调用三个方法\n\n- createElm 以当前旧节点为参考节点，创建新的节点，执行相关的 insert 钩子函数，并插入到 DOM 中，\n- sameVnode 通过对比 key 是否相同、tag、注释、data是否存在等判断2个节点，是否是同一个节点\n- patchVnode vdom 核心更新 node \n\npatchVode 中的几个核心方法 addVnodes、 removeVnodes，updateChildren，具体是怎么增加、删除，更新 vnode 和 dom 节点的，dom-diff 比较复杂，我们会在分析响应式原理的时候具体查看细节\n\n\n### 主流程总结<hr>\n\n下面我们通过一张图来总结 vue 主线流程\n\n<img src=\"/images/vue-process.png\" />\n\n上面的图中能够直观的看到 vue 主干的执行流程，但是缺少核心部分，也就是 vue 的响应式原理，下篇文章我们也是通过文件的执行过程来分析 vue 响应式原理的实现\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                \n","slug":"vue/vuePrinciple","published":1,"updated":"2019-10-15T01:29:42.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sw8ox9009zb0u69zmgovlx","content":"<div align=\"middle\">\n  <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=436394160&auto=1&height=66\">\n  </iframe>\n</div>\n\n\n<h2 id=\"源码架构\"><a href=\"#源码架构\" class=\"headerlink\" title=\"源码架构\"></a>源码架构</h2><p>vue 一直以简单，快速著称，也自称为渐进式框架今天我们来分析一下vue的源码，这样我们也能了解其中的思想，帮助我们在工作中很好的应用和解决问题。当然我们并不可能把源码很细致的分析个遍，那样没什么意义。<br>附上 git 仓库<a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"noopener\">vue源码</a>地址。</p>\n<p>我们看一下 vue 源码的核心目录方便大家去对应查找</p>\n<pre class=\"line-numbers language-md\"><code class=\"language-md\">src\n├── compiler/        # 模版编译目录 \n├── core/            # 核心代码 \n├── platforms/       # 跨平台的支持\n├── server/          # 处理服务端渲染\n├── sfc/             # .vue 文件的解析\n├── shared/          # 全局用到的工具函数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"compiler\"><a href=\"#compiler\" class=\"headerlink\" title=\"compiler\"></a>compiler<hr></h3><p>vue 所有编译相关的代码。包括把模版解析成抽象语法树（AST）,编译、生成等功能</p>\n<h3 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core<hr></h3><p>vue 核心代码，包括内置组件，指令、全局API、Observer、虚拟DOM、全局工具函数等，这个目录也是vue的灵魂，也是我们重点关注分析的地方，compiler 会在后续文章中分析</p>\n<h3 id=\"platform\"><a href=\"#platform\" class=\"headerlink\" title=\"platform\"></a>platform<hr></h3><p>最初 vue 是跑在 web 上的mvvm架构, 后期增加了 阿里团队的 weex 入口，配合 weex 也可以运行在 native 客户端上</p>\n<h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server \"></a>server <hr></h3><p>服务端渲染入口，这是是vue2.0 之后更新的功能，所谓的服务端渲染是把相对应的组件渲染为服务端的 html 字符串，然后发送给客户端，客户端进行处理。这样做能提高客户体验</p>\n<h3 id=\"sfc\"><a href=\"#sfc\" class=\"headerlink\" title=\"sfc\"></a>sfc<hr></h3><p>将 .vue 文件内容解析成JavaScript的对象</p>\n<h2 id=\"源码构建\"><a href=\"#源码构建\" class=\"headerlink\" title=\"源码构建\"></a>源码构建</h2><p>vue 源码是基于 <a href=\"https://rollupjs.org/guide/en/\" target=\"_blank\" rel=\"noopener\">Rollup </a>构建的，构建的配置在 scripts 目录下</p>\n<pre class=\"line-numbers language-md\"><code class=\"language-md\">scripts\n├── git-hook/           # git-hook配置文件\n├── alias               # 混入文件目录别名配置\n├── build               # 构建的入口文件\n├── config              # 构建全局配置文件\n├── feature-flags       # weex 环境 flag\n├── gen-release-note    # 生成 Change log\n├── get-weex-version    # 生成 weexBaseVersion\n├── release-weex        # weex发布的脚本\n├── release             # 发布脚本\n├── verify-commit-msg   # 检查 Commit message 是否符合格式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"构建脚本\"><a href=\"#构建脚本\" class=\"headerlink\" title=\"构建脚本\"></a>构建脚本<hr></h3><p>基于 npm 托管的项目都会有一个 package.json 文件，这个文件当中的 script 描述符中一般配置的基本都是启动项目、打包、测试等相关命令, 看一下 vue 项目根目录的 package.json,由于只做 build 环境中的分析，所以我们去掉 dev、test等执行命令</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"build\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node scripts/build.js\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"build:ssr\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm run build -- web-runtime-cjs,web-server-renderer\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"build:weex\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm run build -- weex\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面三个命令在执行的时候通过环境参数来区分不同的平台，当执行 <code>npm run build</code> 命令的时候就会执行 <code>node scripts/build.js</code> 这个文件</p>\n<h3 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"构建过程\"></a>构建过程<hr></h3><p>接下来来查看一下 <code>node scripts/build.js</code> 这个文件看看执行过程</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> builds <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./config'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAllBuilds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">// filter builds via command line arg</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> filters <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span>\n  builds <span class=\"token operator\">=</span> builds<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> filters<span class=\"token punctuation\">.</span><span class=\"token function\">some</span><span class=\"token punctuation\">(</span>f <span class=\"token operator\">=</span><span class=\"token operator\">></span> b<span class=\"token punctuation\">.</span>output<span class=\"token punctuation\">.</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> b<span class=\"token punctuation\">.</span>_name<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// filter out weex builds by default</span>\n  builds <span class=\"token operator\">=</span> builds<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span>output<span class=\"token punctuation\">.</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'weex'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">build</span><span class=\"token punctuation\">(</span>builds<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的代码片段了解到主要引用了 <code>./config</code> getAllBuilds 文件下面的方法，进入这个文件</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> builds <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n  <span class=\"token keyword\">const</span> aliases <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./alias'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> resolve <span class=\"token operator\">=</span> p <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> base <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>aliases<span class=\"token punctuation\">[</span>base<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>aliases<span class=\"token punctuation\">[</span>base<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'../'</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span>\n  <span class=\"token string\">'web-runtime-cjs-prod'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'web/entry-runtime.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    dest<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dist/vue.runtime.common.prod.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    format<span class=\"token punctuation\">:</span> <span class=\"token string\">'cjs'</span><span class=\"token punctuation\">,</span>\n    env<span class=\"token punctuation\">:</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span>\n    banner\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// runtime-only production build (Browser)</span>\n  <span class=\"token string\">'web-runtime-prod'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'web/entry-runtime.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    dest<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dist/vue.runtime.min.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    format<span class=\"token punctuation\">:</span> <span class=\"token string\">'umd'</span><span class=\"token punctuation\">,</span>\n    env<span class=\"token punctuation\">:</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span>\n    banner\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// Runtime+compiler CommonJS build (CommonJS)</span>\n  <span class=\"token string\">'web-full-prod'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    entry<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'web/entry-runtime-with-compiler.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    dest<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'dist/vue.min.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    format<span class=\"token punctuation\">:</span> <span class=\"token string\">'umd'</span><span class=\"token punctuation\">,</span>\n    env<span class=\"token punctuation\">:</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span>\n    alias<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> he<span class=\"token punctuation\">:</span> <span class=\"token string\">'./entity-decoder'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    banner\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> genConfig <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> opts <span class=\"token operator\">=</span> builds<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    input<span class=\"token punctuation\">:</span> opts<span class=\"token punctuation\">.</span>entry<span class=\"token punctuation\">,</span>\n    external<span class=\"token punctuation\">:</span> opts<span class=\"token punctuation\">.</span>external<span class=\"token punctuation\">,</span>\n    plugins<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token function\">flow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function\">alias</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> aliases<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">.</span>alias<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">.</span>plugins <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    output<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      file<span class=\"token punctuation\">:</span> opts<span class=\"token punctuation\">.</span>dest<span class=\"token punctuation\">,</span>\n      format<span class=\"token punctuation\">:</span> opts<span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">,</span>\n      banner<span class=\"token punctuation\">:</span> opts<span class=\"token punctuation\">.</span>banner<span class=\"token punctuation\">,</span>\n      name<span class=\"token punctuation\">:</span> opts<span class=\"token punctuation\">.</span>moduleName <span class=\"token operator\">||</span> <span class=\"token string\">'Vue'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">,</span> <span class=\"token string\">'_name'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> name\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> config\n\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过这里的代码片面大概了解到 vue 通过当前web、服务端渲染、webpack插件、weex等配置来进行打包，每一个配置都遵循 rollup 的构建规则</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"entry\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"构建的入口文件\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dest\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"构建后的文件地址\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"format\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"构建规范\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"alias\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"别名设置\"</span> \n  // ...\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>那么在打包的过程中进行了路径别名设置，通过别名设置能代码能够更清晰整洁。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> resolve <span class=\"token operator\">=</span> p <span class=\"token operator\">=</span><span class=\"token operator\">></span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'../'</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  vue<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/platforms/web/entry-runtime-with-compiler'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  compiler<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/compiler'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  core<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/core'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  shared<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/shared'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  web<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/platforms/web'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  weex<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/platforms/weex'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  server<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/server'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  sfc<span class=\"token punctuation\">:</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'src/sfc'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>看到这个别名设置，我们就应该很清楚 vue 的核心构建文件都在 src 目录，具体作用在文章开头就已经介绍过了。那么我们主要看 web 别名下的目录，其它的目录有兴趣的同学可以了解一下实现规则</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'core/index'</span>\n<span class=\"token keyword\">import</span> config <span class=\"token keyword\">from</span> <span class=\"token string\">'core/config'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> extend<span class=\"token punctuation\">,</span> noop <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'shared/util'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mountComponent <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'core/instance/lifecycle'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> devtools<span class=\"token punctuation\">,</span> inBrowser <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'core/util/index'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> patch <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./patch'</span>\n<span class=\"token keyword\">import</span> platformDirectives <span class=\"token keyword\">from</span> <span class=\"token string\">'./directives/index'</span>\n<span class=\"token keyword\">import</span> platformComponents <span class=\"token keyword\">from</span> <span class=\"token string\">'./components/index'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// install platform runtime directives &amp; components</span>\n<span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>directives<span class=\"token punctuation\">,</span> platformDirectives<span class=\"token punctuation\">)</span>\n<span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>components<span class=\"token punctuation\">,</span> platformComponents<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// install platform patch function</span>\nVue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__patch__ <span class=\"token operator\">=</span> inBrowser <span class=\"token operator\">?</span> patch <span class=\"token punctuation\">:</span> noop\n\n<span class=\"token comment\" spellcheck=\"true\">// public mount method</span>\nVue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>$mount <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>\n  el<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Element<span class=\"token punctuation\">,</span>\n  hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Component <span class=\"token punctuation\">{</span>\n  el <span class=\"token operator\">=</span> el <span class=\"token operator\">&amp;&amp;</span> inBrowser <span class=\"token operator\">?</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> undefined\n  <span class=\"token keyword\">return</span> <span class=\"token function\">mountComponent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> el<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>终于看到了 Vue 构造函数和核心代码的入口<code>core/index</code>，并在构造函数和原型上面挂载了一些方法，通过执行的上述构建过程我们总结到</p>\n<p>Vue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成(独立构建和运行时构建 只是 platforms 下 web 平台的两种选择)</p>\n<img src=\"/images/vue-init.png\" width=\"50%\">\n\n\n<h2 id=\"new-Vue\"><a href=\"#new-Vue\" class=\"headerlink\" title=\"new Vue\"></a>new Vue</h2><p>通过 vue 的核心目录，我们知道 Vue 实际上是一个构造函数，上面挂满了大大小小的各种方法我们在用的时候传一定的参数即可</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token string\">'xxxx'</span><span class=\"token punctuation\">,</span>\n  data<span class=\"token punctuation\">:</span> xxxx<span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"initGlobalAPI\"><a href=\"#initGlobalAPI\" class=\"headerlink\" title=\"initGlobalAPI\"></a>initGlobalAPI<hr></h3><p>那么在 vue 实例化的过程中到底发生了什么，打开核心代码 <code>src/core</code> 目录下面的 index</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">src<span class=\"token operator\">/</span>core<span class=\"token operator\">/</span>index<span class=\"token punctuation\">.</span>js\n\n<span class=\"token comment\" spellcheck=\"true\">// vue初始化的核心文件--创建Vue构造函数，将构造函数传入五个方法中</span>\n<span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'./instance/index'</span>\n<span class=\"token comment\" spellcheck=\"true\">// 初始化全局API</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> initGlobalAPI <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./global-api/index'</span>\n<span class=\"token comment\" spellcheck=\"true\">// 获得一些环境判断，和是否是服务端渲染</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> isServerRendering <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'core/util/env'</span>\n<span class=\"token comment\" spellcheck=\"true\">// ssr 环境加载此方法</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> FunctionalRenderContext <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'core/vdom/create-functional-component'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//初始化全局API变量</span>\n<span class=\"token function\">initGlobalAPI</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//为vue的原型定义$isServer属性</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token string\">'$isServer'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> isServerRendering\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//为vue的原型定义$ssrContext</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token string\">'$ssrContext'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">get</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore next */</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$vnode<span class=\"token punctuation\">.</span>ssrContext\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//为vue原型定义当为ssr环境时加载FunctionalRenderContext方法</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>Vue<span class=\"token punctuation\">,</span> <span class=\"token string\">'FunctionalRenderContext'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> FunctionalRenderContext\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//添加版本号</span>\nVue<span class=\"token punctuation\">.</span>version <span class=\"token operator\">=</span> <span class=\"token string\">'__VERSION__'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Vue<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>总结一下这个文件加载的方法</p>\n<pre class=\"line-numbers language-md\"><code class=\"language-md\">\ncore/index\n├── Vue            # 初始化构造函数\n├── initGlobalAPI  # 初始化全局API\n├── $isServer      # 判断环境的工具函数\n├── $ssrContext    # ssr 环境加载此方法也可用于操作状态\n├── FunctionalRenderContext  # ssr 环境加载此方法\n├── 添加版本号<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"new-Vue-1\"><a href=\"#new-Vue-1\" class=\"headerlink\" title=\"new Vue \"></a>new Vue <hr></h3><p>初始化文件后，进入导出 Vue 构造函数的文件 <code>src/core/instance/index.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> Vue <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Vue is a constructor and should be called with the `new` keyword'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_init</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面我们看到了 Vue 实际上就是一个用 Function 实现的类，通过 new 关键字初始化，然后会调用 this._init 方法。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_init <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>options<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> Object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> vm<span class=\"token punctuation\">:</span> Component <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token comment\" spellcheck=\"true\">// a uid</span>\n    vm<span class=\"token punctuation\">.</span>_uid <span class=\"token operator\">=</span> uid<span class=\"token operator\">++</span>\n\n    <span class=\"token keyword\">let</span> startTag<span class=\"token punctuation\">,</span> endTag\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> config<span class=\"token punctuation\">.</span>performance <span class=\"token operator\">&amp;&amp;</span> mark<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      startTag <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`vue-perf-start:</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>vm<span class=\"token punctuation\">.</span>_uid<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span>\n      endTag <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`vue-perf-end:</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>vm<span class=\"token punctuation\">.</span>_uid<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span>\n      <span class=\"token function\">mark</span><span class=\"token punctuation\">(</span>startTag<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果是Vue的实例，则不需要被observe</span>\n    vm<span class=\"token punctuation\">.</span>_isVue <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 对参数进行 merge 操作  </span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options <span class=\"token operator\">&amp;&amp;</span> options<span class=\"token punctuation\">.</span>_isComponent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// optimize internal component instantiation</span>\n      <span class=\"token comment\" spellcheck=\"true\">// since dynamic options merging is pretty slow, and none of the</span>\n      <span class=\"token comment\" spellcheck=\"true\">// internal component options needs special treatment.</span>\n      <span class=\"token function\">initInternalComponent</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>$options <span class=\"token operator\">=</span> <span class=\"token function\">mergeOptions</span><span class=\"token punctuation\">(</span>\n        <span class=\"token function\">resolveConstructorOptions</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        options <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        vm\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 通过判断 Proxy 为 vue的实例属性赋值</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore else */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">initProxy</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>_renderProxy <span class=\"token operator\">=</span> vm\n    <span class=\"token punctuation\">}</span>\n\n    vm<span class=\"token punctuation\">.</span>_self <span class=\"token operator\">=</span> vm\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化生命周期相关</span>\n    <span class=\"token function\">initLifecycle</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 输初始化事件监听相关</span>\n    <span class=\"token function\">initEvents</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化编译render</span>\n    <span class=\"token function\">initRender</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 调用beforeCreate钩子函数并且触发beforeCreate钩子事件</span>\n    <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeCreate'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">initInjections</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化props、methods、data、computed与watch</span>\n    <span class=\"token function\">initState</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">initProvide</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 调用created钩子函数并且触发created钩子事件</span>\n    <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'created'</span><span class=\"token punctuation\">)</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> config<span class=\"token punctuation\">.</span>performance <span class=\"token operator\">&amp;&amp;</span> mark<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 格式化组件名</span>\n      vm<span class=\"token punctuation\">.</span>_name <span class=\"token operator\">=</span> <span class=\"token function\">formatComponentName</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n      <span class=\"token function\">mark</span><span class=\"token punctuation\">(</span>endTag<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">measure</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`vue </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>vm<span class=\"token punctuation\">.</span>_name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> init`</span></span><span class=\"token punctuation\">,</span> startTag<span class=\"token punctuation\">,</span> endTag<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">// 挂载组件方法触发组件的DOM渲染</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span><span class=\"token function\">$mount</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码的注释了解到 Vue 初始化主要就干了几件事情，合并配置操作，初始化生命周期，初始化事件监听，初始化render，初始化 data、props、computed、watcher 等，在最后调用vm.$mount 方法挂载 vm ，把模版渲染成DOM。当然这里面还有很多细节需要知道例如上面初始化合并配置，生命周期初始化等，会在后面清楚的梳理 vue 整理流程之后，进入细节</p>\n<h2 id=\"vm-mount\"><a href=\"#vm-mount\" class=\"headerlink\" title=\"vm.$mount\"></a>vm.$mount</h2><p>通过 $mount 实例方法去挂载 vm ，但 $mount 方法是由于多平台编译处理不太一样，所以在多个文件中定义。我们进入 <code>src/platform</code> 这个目录可以观察到有 web 和 weex 目录，我们直接抛掉 weex，只分析 web 目录，在 vue 官网教程中介绍了vue的完整版<code>web/entry-runtime-with-compiler.js</code>和runtime版本<code>web/runtime/index.js</code></p>\n<p>完整版</p>\n<ul>\n<li>包含编译和运行是的版本</li>\n<li>html字符串 → render函数 → vnode → 真实dom节点</li>\n</ul>\n<p>runtime版本</p>\n<ul>\n<li>创建 Vue 实例、render、更新 DOM 等的操作的代码，没有编译器编译模版字符串代码</li>\n<li>render函数 → vnode → 真实dom节点</li>\n</ul>\n<h3 id=\"完整版-mount\"><a href=\"#完整版-mount\" class=\"headerlink\" title=\"完整版 $mount\"></a>完整版 $mount<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token keyword\">const</span> mount <span class=\"token operator\">=</span> Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>$mount\nVue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>$mount <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>\n  el<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Element<span class=\"token punctuation\">,</span>\n  hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Component <span class=\"token punctuation\">{</span>\n  el <span class=\"token operator\">=</span> el <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el <span class=\"token operator\">===</span> document<span class=\"token punctuation\">.</span>body <span class=\"token operator\">||</span> el <span class=\"token operator\">===</span> document<span class=\"token punctuation\">.</span>documentElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token string\">`Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.`</span></span>\n    <span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$options\n  <span class=\"token comment\" spellcheck=\"true\">// resolve template/el and convert to render function</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> template <span class=\"token operator\">=</span> options<span class=\"token punctuation\">.</span>template\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> template <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'#'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          template <span class=\"token operator\">=</span> <span class=\"token function\">idToTemplate</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">)</span>\n          <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore if */</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>template<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n              <span class=\"token template-string\"><span class=\"token string\">`Template element not found or is empty: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>options<span class=\"token punctuation\">.</span>template<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">,</span>\n              <span class=\"token keyword\">this</span>\n            <span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">.</span>nodeType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        template <span class=\"token operator\">=</span> template<span class=\"token punctuation\">.</span>innerHTML\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'invalid template option:'</span> <span class=\"token operator\">+</span> template<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      template <span class=\"token operator\">=</span> <span class=\"token function\">getOuterHTML</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> render<span class=\"token punctuation\">,</span> staticRenderFns <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">compileToFunctions</span><span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        outputSourceRange<span class=\"token punctuation\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span>\n        shouldDecodeNewlines<span class=\"token punctuation\">,</span>\n        shouldDecodeNewlinesForHref<span class=\"token punctuation\">,</span>\n        delimiters<span class=\"token punctuation\">:</span> options<span class=\"token punctuation\">.</span>delimiters<span class=\"token punctuation\">,</span>\n        comments<span class=\"token punctuation\">:</span> options<span class=\"token punctuation\">.</span>comments\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n      options<span class=\"token punctuation\">.</span>render <span class=\"token operator\">=</span> render\n      options<span class=\"token punctuation\">.</span>staticRenderFns <span class=\"token operator\">=</span> staticRenderFns\n\n      <span class=\"token comment\" spellcheck=\"true\">// ..</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> mount<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> el<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面代码逻辑很清晰，将执行以下过程</p>\n<ul>\n<li>首先在原型上定义了 $mount 这个方法</li>\n<li>对传入的 el 做限制不能将节点挂载在 body 和 html 这种跟节点上</li>\n<li>如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法</li>\n<li>模版或字符串转换 render 方法（调用 compileToFunctions 进行编译转换）</li>\n</ul>\n<h3 id=\"runtime-版本-mount\"><a href=\"#runtime-版本-mount\" class=\"headerlink\" title=\"runtime 版本 $mount\"></a>runtime 版本 $mount<hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// public mount method</span>\nVue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>$mount <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>\n  el<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Element<span class=\"token punctuation\">,</span>\n  hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Component <span class=\"token punctuation\">{</span>\n  el <span class=\"token operator\">=</span> el <span class=\"token operator\">&amp;&amp;</span> inBrowser <span class=\"token operator\">?</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> undefined\n  <span class=\"token keyword\">return</span> <span class=\"token function\">mountComponent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> el<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行过程</p>\n<ul>\n<li>挂载的元素，可以是字符串，也可以是DOM对象，如果是字符串通过 query 方法转换成DOM</li>\n<li>执行 mountComponent 函数传入三个参数</li>\n</ul>\n<p>通过上面代码可以看出并没有经过 compileToFunctions方法 进行转换编译阶段，而直接是 render –&gt; VNode 过程。</p>\n<p>接下来我们接着查看 mountComponent方法调用，打开文件<code>src/core/instance/lifecycle.js</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> mountComponent <span class=\"token punctuation\">(</span>\n  vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token operator\">?</span>Element<span class=\"token punctuation\">,</span>\n  hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Component <span class=\"token punctuation\">{</span>\n  vm<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> el\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>render<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>render <span class=\"token operator\">=</span> createEmptyVNode\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeMount'</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">let</span> updateComponent\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n  updateComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span><span class=\"token function\">_update</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">_render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// we set this to vm._watcher inside the watcher's constructor</span>\n  <span class=\"token comment\" spellcheck=\"true\">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span>\n  <span class=\"token comment\" spellcheck=\"true\">// component's mounted hook), which relies on vm._watcher being already defined</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Watcher</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> updateComponent<span class=\"token punctuation\">,</span> noop<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    before <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>vm<span class=\"token punctuation\">.</span>_isDestroyed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'beforeUpdate'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">/* isRenderWatcher */</span><span class=\"token punctuation\">)</span>\n  hydrating <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// manually mounted instance, call mounted on self</span>\n  <span class=\"token comment\" spellcheck=\"true\">// mounted is called for render-created child components in its inserted hook</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vm<span class=\"token punctuation\">.</span>_isMounted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token function\">callHook</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> <span class=\"token string\">'mounted'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> vm\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码很直观的看见 mountComponent 方法主要作用</p>\n<ul>\n<li>判断 render 函数是不是存在如果不存在调用创建 createEmptyVNode 方法创建一个空VNode节点</li>\n<li>检测完 render 开始挂载 beforeMount 钩子</li>\n<li>执行 new Watcher方法()</li>\n<li>_isMounted状态设置true， 开始挂载mounted</li>\n</ul>\n<p>Watcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM</p>\n<p>Watcher 初始化的时候会执行回调函数，当 vm 实例中的监测的数据发生变化的时候也会执行回调函数，这就是我们说的观察者进行依赖收集的过程,当然这也是 vue 核心原理的一部分。new Watcher到底做了什么我们在后面的单独整理，先以主线程为主</p>\n<h2 id=\"vm-render\"><a href=\"#vm-render\" class=\"headerlink\" title=\"vm._render\"></a>vm._render</h2><p>上文中提到 Watcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM，那么就出现 私有方法 vm._render 和 vm._update 两个最核心的方法。</p>\n<p>_render 定义在 <code>src/core/instance/render.js</code> 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_render <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> VNode <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> vm<span class=\"token punctuation\">:</span> Component <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> render<span class=\"token punctuation\">,</span> _parentVnode <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_parentVnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>$scopedSlots <span class=\"token operator\">=</span> <span class=\"token function\">normalizeScopedSlots</span><span class=\"token punctuation\">(</span>\n        _parentVnode<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>scopedSlots<span class=\"token punctuation\">,</span>\n        vm<span class=\"token punctuation\">.</span>$slots<span class=\"token punctuation\">,</span>\n        vm<span class=\"token punctuation\">.</span>$scopedSlots\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// set parent vnode. this allows render functions to have access</span>\n    <span class=\"token comment\" spellcheck=\"true\">// to the data on the placeholder node.</span>\n    vm<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">=</span> _parentVnode\n    <span class=\"token comment\" spellcheck=\"true\">// render self</span>\n    <span class=\"token keyword\">let</span> vnode\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// There's no need to maintain a stack because all render fns are called</span>\n      <span class=\"token comment\" spellcheck=\"true\">// separately from one another. Nested component's render fns are called</span>\n      <span class=\"token comment\" spellcheck=\"true\">// when parent component is patched.</span>\n      currentRenderingInstance <span class=\"token operator\">=</span> vm\n      vnode <span class=\"token operator\">=</span> render<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_renderProxy<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">.</span>$createElement<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">handleError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`render`</span></span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// return error render result,</span>\n      <span class=\"token comment\" spellcheck=\"true\">// or previous vnode to prevent render error causing blank component</span>\n      <span class=\"token comment\" spellcheck=\"true\">/* istanbul ignore else */</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>renderError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n          vnode <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">.</span>renderError<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>_renderProxy<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">.</span>$createElement<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">handleError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> vm<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`renderError`</span></span><span class=\"token punctuation\">)</span>\n          vnode <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_vnode\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        vnode <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_vnode\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      currentRenderingInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// if the returned array contains only a single node, allow it</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> vnode<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vnode <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// return empty vnode in case the render function errored out</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>vnode <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">VNode</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token string\">'Multiple root nodes returned from render function. Render function '</span> <span class=\"token operator\">+</span>\n          <span class=\"token string\">'should return a single root node.'</span><span class=\"token punctuation\">,</span>\n          vm\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      vnode <span class=\"token operator\">=</span> <span class=\"token function\">createEmptyVNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// set parent</span>\n    vnode<span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> _parentVnode\n    <span class=\"token keyword\">return</span> vnode\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面这段代码最关键的地方就是调用 render 方法 <code>render.call(vm._renderProxy, vm.$createElement)</code>，在上面说过在 mounted 方法中会把 template 和 string 经过 compileToFunctions 编译最后形成 render方法进行渲染，但是这是用字符串模版的形式，如果用字符串模板的代替方案 render 方法呢</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  render<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>createElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n     attrs<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        id<span class=\"token punctuation\">:</span> <span class=\"token string\">'app'</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  renderError<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>createElement<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'pre'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> style<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> color<span class=\"token punctuation\">:</span> <span class=\"token string\">'red'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">$mount</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#app'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以看出render 方法的参数 createElement 实际上就是 vm.$createElement,然而 vm.$createElement 在初始化中就已经执行过了</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> initRender <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n  vm<span class=\"token punctuation\">.</span>_c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// normalization is always applied for the public version, used in</span>\n  <span class=\"token comment\" spellcheck=\"true\">// user-written render functions.</span>\n  vm<span class=\"token punctuation\">.</span>$createElement <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// $attrs &amp; $listeners are exposed for easier HOC creation.</span>\n  <span class=\"token comment\" spellcheck=\"true\">// they need to be reactive so that HOCs using them are always updated</span>\n  <span class=\"token keyword\">const</span> parentData <span class=\"token operator\">=</span> parentVnode <span class=\"token operator\">&amp;&amp;</span> parentVnode<span class=\"token punctuation\">.</span>data\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>所以在 initRender 方法的时候，除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，但 vm.$createElement 是我们用原生写的 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。</p>\n<p>官网中一句话说的很清楚 <strong>Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</strong></p>\n<p>通过上述总结到 render 函数最终是执行 createElement 方法 返回 vnode 节点，这是一个虚拟 node 而 vue2.0 的 另一个核心就是利用了Virtual DOM，实际上 Vue.js 中 Virtual DOM 是借鉴了开源库 <a href=\"https://github.com/snabbdom/snabbdom\" target=\"_blank\" rel=\"noopener\">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西, 这部分源码就在 <code>src/core/vdom/vnode.js</code> 中我们暂时不去查看，待后续文章写到 Virtual DOM 的时候我们在做分析。 </p>\n<p>那么在面试中我们经常被问到是 操作 Virtual DOM 快还是真实 DOM 快</p>\n<p>答案是相对的在数据量大的情况下，肯定是 Virtual DOM 快，因为通过对比 node 减少频繁的去更新DOM， 如果数据量相对较小的情况还是直接操作 DOM 较快，因为少了编译、遍历、对比的过程</p>\n<h2 id=\"vm-createElement\"><a href=\"#vm-createElement\" class=\"headerlink\" title=\"vm.$createElement\"></a>vm.$createElement</h2><p>上面文章提到 render 的时候内部调用了 createElement 方法，创建了vnode，该方法定义在 src/core/vdom/create-elemenet.js 中</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> _createElement <span class=\"token punctuation\">(</span>\n  context<span class=\"token punctuation\">:</span> Component<span class=\"token punctuation\">,</span>\n  tag<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> string <span class=\"token operator\">|</span> Class<span class=\"token operator\">&lt;</span>Component<span class=\"token operator\">></span> <span class=\"token operator\">|</span> Function <span class=\"token operator\">|</span> Object<span class=\"token punctuation\">,</span>\n  data<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> VNodeData<span class=\"token punctuation\">,</span>\n  children<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">,</span>\n  normalizationType<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> number\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> VNode <span class=\"token operator\">|</span> Array<span class=\"token operator\">&lt;</span>VNode<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n\n   <span class=\"token comment\" spellcheck=\"true\">/**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */</span>   \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">:</span> any<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__ob__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token string\">`Avoid using observed data object as vnode data: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\n`</span></span> <span class=\"token operator\">+</span>\n      <span class=\"token string\">'Always create fresh vnode data objects in each render!'</span><span class=\"token punctuation\">,</span>\n      context\n    <span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">createEmptyVNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 当通过 :is 动态设置组件时</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>is<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    tag <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>is\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>tag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// in case of component :is set to falsy value</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">createEmptyVNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 作用域插槽</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token keyword\">typeof</span> children<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    data <span class=\"token operator\">=</span> data <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    data<span class=\"token punctuation\">.</span>scopedSlots <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span> children<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n    children<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>normalizationType <span class=\"token operator\">===</span> ALWAYS_NORMALIZE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    children <span class=\"token operator\">=</span> <span class=\"token function\">normalizeChildren</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>normalizationType <span class=\"token operator\">===</span> SIMPLE_NORMALIZE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    children <span class=\"token operator\">=</span> <span class=\"token function\">simpleNormalizeChildren</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> vnode<span class=\"token punctuation\">,</span> ns\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> tag <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> Ctor\n    ns <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">&amp;&amp;</span> context<span class=\"token punctuation\">.</span>$vnode<span class=\"token punctuation\">.</span>ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> config<span class=\"token punctuation\">.</span><span class=\"token function\">getTagNamespace</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span><span class=\"token function\">isReservedTag</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// platform built-in elements</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span>NODE_ENV <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>nativeOn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n          <span class=\"token template-string\"><span class=\"token string\">`The .native modifier for v-on is only valid on components but it was used on &lt;</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>tag<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">>.`</span></span><span class=\"token punctuation\">,</span>\n          context\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      vnode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">VNode</span><span class=\"token punctuation\">(</span>\n        config<span class=\"token punctuation\">.</span><span class=\"token function\">parsePlatformTagName</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">,</span>\n        undefined<span class=\"token punctuation\">,</span> undefined<span class=\"token punctuation\">,</span> context\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>data<span class=\"token punctuation\">.</span>pre<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>Ctor <span class=\"token operator\">=</span> <span class=\"token function\">resolveAsset</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>$options<span class=\"token punctuation\">,</span> <span class=\"token string\">'components'</span><span class=\"token punctuation\">,</span> tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// component</span>\n      vnode <span class=\"token operator\">=</span> <span class=\"token function\">createComponent</span><span class=\"token punctuation\">(</span>Ctor<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">,</span> tag<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// unknown or unlisted namespaced elements</span>\n      <span class=\"token comment\" spellcheck=\"true\">// check at runtime because it may get assigned a namespace when its</span>\n      <span class=\"token comment\" spellcheck=\"true\">// parent normalizes children</span>\n      vnode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">VNode</span><span class=\"token punctuation\">(</span>\n        tag<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">,</span>\n        undefined<span class=\"token punctuation\">,</span> undefined<span class=\"token punctuation\">,</span> context\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// direct component options / constructor</span>\n    vnode <span class=\"token operator\">=</span> <span class=\"token function\">createComponent</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> vnode\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>ns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">applyNS</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> ns<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">registerDeepBindings</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> vnode\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">createEmptyVNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码我们看到 主要调用了几个方法 createEmptyVNode 和 createComponent、normalizeChildren、simpleNormalizeChildren</p>\n<p>我们简单的看一下执行步骤</p>\n<p>首先判断了 tag 是否存在，如果不存在则调用 <code>src/core/vdom/vnode.js</code>目录下的 createEmptyVNode 方法创建空的 vnode 节点</p>\n<p>如果传递了children，由于其是任意类型，所以根据 normalizationType 去调用<code>src/core/vdom/helpers/normalzie-children.js</code> 目录下的 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法进行递归遍历，把整个 children 打平，让它变成深度只有一层的 vnode 数组</p>\n<p>最后通过 对参数 tag 的判断，如果是一个普通的 html 标签，则实例化一个普通 vnode 节点，否则通过 <code>src/core/vdom/create-component.js</code>目录下的 createComponent 方法创建一个组件的 vnode</p>\n<p>因为除了组件的 vnode 没有 children，其他通过 createElement 创建的每个 vnode 都有 children，children 每个元素也是一个 vnode，这样就形成了一个 vnode tree，这样我们就知道 vm._render 阶段是如何创建的 vnode，那么接下来我们就通过 vm._update，将 vnode 渲染成真实的 dom。</p>\n<h2 id=\"vm-update\"><a href=\"#vm-update\" class=\"headerlink\" title=\"vm._update\"></a>vm._update</h2><p>vm._update 也是一个私有方法，作用是把 vnode 渲染成真实的 dom 在 <code>src/core/instance/lifecycle.js</code> 文件中定义</p>\n<h3 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"_update \"></a>_update <hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\">\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n\n  Vue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_update <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">:</span> VNode<span class=\"token punctuation\">,</span> hydrating<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> vm<span class=\"token punctuation\">:</span> Component <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n    <span class=\"token keyword\">const</span> prevEl <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$el\n    <span class=\"token keyword\">const</span> prevVnode <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>_vnode\n    <span class=\"token keyword\">const</span> restoreActiveInstance <span class=\"token operator\">=</span> <span class=\"token function\">setActiveInstance</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">)</span>\n    vm<span class=\"token punctuation\">.</span>_vnode <span class=\"token operator\">=</span> vnode\n    <span class=\"token comment\" spellcheck=\"true\">// Vue.prototype.__patch__ is injected in entry points</span>\n    <span class=\"token comment\" spellcheck=\"true\">// based on the rendering backend used.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>prevVnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// initial render</span>\n      vm<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span><span class=\"token function\">__patch__</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$el<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span> <span class=\"token comment\" spellcheck=\"true\">/* removeOnly */</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// updates</span>\n      vm<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span><span class=\"token function\">__patch__</span><span class=\"token punctuation\">(</span>prevVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">restoreActiveInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// update __vue__ reference</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevEl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      prevEl<span class=\"token punctuation\">.</span>__vue__ <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>$el<span class=\"token punctuation\">.</span>__vue__ <span class=\"token operator\">=</span> vm\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// if parent is an HOC, update its $el as well</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">&amp;&amp;</span> vm<span class=\"token punctuation\">.</span>$parent <span class=\"token operator\">&amp;&amp;</span> vm<span class=\"token punctuation\">.</span>$vnode <span class=\"token operator\">===</span> vm<span class=\"token punctuation\">.</span>$parent<span class=\"token punctuation\">.</span>_vnode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      vm<span class=\"token punctuation\">.</span>$parent<span class=\"token punctuation\">.</span>$el <span class=\"token operator\">=</span> vm<span class=\"token punctuation\">.</span>$el\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// updated hook is called by the scheduler to ensure that children are</span>\n    <span class=\"token comment\" spellcheck=\"true\">// updated in a parent's updated hook.</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面代码我们知道 vm.<em>update 的核心就是通过 vm.<strong>patch</strong>函数来实现将 vnode 转换成真实的 node 节点，而 vm.<em>_patch</em></em> 的实现是多平台的有weex、ssr、inBrowser，我们只查看在浏览器环境内的实现</p>\n<p>在 <code>src/platforms/web/runtime/index.js</code> 通过判断如果是浏览器环境调用 patch，否则创建一个空对象</p>\n<h3 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch \"></a><strong>patch</strong> <hr></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// install platform patch function</span>\nVue<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__patch__ <span class=\"token operator\">=</span> inBrowser <span class=\"token operator\">?</span> patch <span class=\"token punctuation\">:</span> noop\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过引用我们到 <code>src/platforms/web/runtime/patch.js</code> 目录看到调用了 createPatchFunction 方法的返回值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> patch<span class=\"token punctuation\">:</span> Function <span class=\"token operator\">=</span> <span class=\"token function\">createPatchFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> nodeOps<span class=\"token punctuation\">,</span> modules <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"createPatchFunction\"><a href=\"#createPatchFunction\" class=\"headerlink\" title=\"createPatchFunction \"></a>createPatchFunction <hr></h3><p>在通过查找文件 <code>src/core/vdom/patch.js</code> 中定义的 createPatchFunction 方法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> createPatchFunction <span class=\"token punctuation\">(</span>backend<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> patch <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> hydrating<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果 vnode 不存在但 oldVnode 存在，调用 invokeDestroyHook(oldVnode) 来进行销毁旧节点</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> isInitialPatch <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">const</span> insertedVnodeQueue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果oldVnode不存在，vnode存在，则创建新节点  </span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isUndef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// empty mount (likely as component), create new root element</span>\n      isInitialPatch <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">const</span> isRealElement <span class=\"token operator\">=</span> <span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>nodeType<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果 oldVnode 与 vnode 都存在判断是同一节点调用 patchVnode 处理去比较两个节点的差异</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isRealElement <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sameVnode</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// patch existing root node</span>\n        <span class=\"token function\">patchVnode</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> removeOnly<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isRealElement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 如果存在真实的节点，存在data-server-rendered属性，将 hydrating 变为true</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>nodeType <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> oldVnode<span class=\"token punctuation\">.</span><span class=\"token function\">hasAttribute</span><span class=\"token punctuation\">(</span>SSR_ATTR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            oldVnode<span class=\"token punctuation\">.</span><span class=\"token function\">removeAttribute</span><span class=\"token punctuation\">(</span>SSR_ATTR<span class=\"token punctuation\">)</span>\n            hydrating <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 用hydrate函数将虚拟DOM和真实DOM进行映射</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>hydrating<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hydrate</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">invokeInsertHook</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">return</span> oldVnode\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 如果不是server-rendered 或者hydration失败</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 创建一个空VNode，代替oldVnode</span>\n          oldVnode <span class=\"token operator\">=</span> <span class=\"token function\">emptyNodeAt</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 将oldVnode设置为对应的虚拟dom，找到oldVnode.elm的父节点</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置</span>\n        <span class=\"token keyword\">const</span> oldElm <span class=\"token operator\">=</span> oldVnode<span class=\"token punctuation\">.</span>elm\n        <span class=\"token keyword\">const</span> parentElm <span class=\"token operator\">=</span> nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">parentNode</span><span class=\"token punctuation\">(</span>oldElm<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">createElm</span><span class=\"token punctuation\">(</span>\n          vnode<span class=\"token punctuation\">,</span>\n          insertedVnodeQueue<span class=\"token punctuation\">,</span>\n          oldElm<span class=\"token punctuation\">.</span>_leaveCb <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">:</span> parentElm<span class=\"token punctuation\">,</span>\n          nodeOps<span class=\"token punctuation\">.</span><span class=\"token function\">nextSibling</span><span class=\"token punctuation\">(</span>oldElm<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 递归更新父级占位节点元素，</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">let</span> ancestor <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>parent\n          <span class=\"token keyword\">const</span> patchable <span class=\"token operator\">=</span> <span class=\"token function\">isPatchable</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              cbs<span class=\"token punctuation\">.</span>destroy<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            ancestor<span class=\"token punctuation\">.</span>elm <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>elm\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>patchable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cbs<span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                cbs<span class=\"token punctuation\">.</span>create<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>emptyNode<span class=\"token punctuation\">,</span> ancestor<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n              <span class=\"token comment\" spellcheck=\"true\">// #6513</span>\n              <span class=\"token comment\" spellcheck=\"true\">// invoke insert hooks that may have been merged by create hooks.</span>\n              <span class=\"token comment\" spellcheck=\"true\">// e.g. for directives that uses the \"inserted\" hook.</span>\n              <span class=\"token keyword\">const</span> insert <span class=\"token operator\">=</span> ancestor<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>hook<span class=\"token punctuation\">.</span>insert\n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>insert<span class=\"token punctuation\">.</span>merged<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// start at index 1 to avoid re-invoking component mounted hook</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> insert<span class=\"token punctuation\">.</span>fns<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  insert<span class=\"token punctuation\">.</span>fns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">registerRef</span><span class=\"token punctuation\">(</span>ancestor<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            ancestor <span class=\"token operator\">=</span> ancestor<span class=\"token punctuation\">.</span>parent\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 销毁旧节点</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">removeVnodes</span><span class=\"token punctuation\">(</span>parentElm<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>oldVnode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isDef</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">invokeDestroyHook</span><span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">invokeInsertHook</span><span class=\"token punctuation\">(</span>vnode<span class=\"token punctuation\">,</span> insertedVnodeQueue<span class=\"token punctuation\">,</span> isInitialPatch<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 返回节点</span>\n    <span class=\"token keyword\">return</span> vnode<span class=\"token punctuation\">.</span>elm\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面看到 patch 方法本身</p>\n<p>接收 4个参数</p>\n<ul>\n<li>oldVnode 表示旧的 VNode 节点或者或者是一个 DOM 对象</li>\n<li>vnode 表示执行 _render 后返回的 VNode 的节点</li>\n<li>hydrating 表示是否是服务端渲染</li>\n<li>removeOnly 是给 transition-group 用的，防止在 updateChildren 阶段，移动 vnode 节点</li>\n</ul>\n<p>关键调用三个方法</p>\n<ul>\n<li>createElm 以当前旧节点为参考节点，创建新的节点，执行相关的 insert 钩子函数，并插入到 DOM 中，</li>\n<li>sameVnode 通过对比 key 是否相同、tag、注释、data是否存在等判断2个节点，是否是同一个节点</li>\n<li>patchVnode vdom 核心更新 node </li>\n</ul>\n<p>patchVode 中的几个核心方法 addVnodes、 removeVnodes，updateChildren，具体是怎么增加、删除，更新 vnode 和 dom 节点的，dom-diff 比较复杂，我们会在分析响应式原理的时候具体查看细节</p>\n<h3 id=\"主流程总结\"><a href=\"#主流程总结\" class=\"headerlink\" title=\"主流程总结\"></a>主流程总结<hr></h3><p>下面我们通过一张图来总结 vue 主线流程</p>\n<img src=\"/images/vue-process.png\">\n\n<p>上面的图中能够直观的看到 vue 主干的执行流程，但是缺少核心部分，也就是 vue 的响应式原理，下篇文章我们也是通过文件的执行过程来分析 vue 响应式原理的实现</p>\n","site":{"data":{"musics":[{"name":"画","artist":"赵雷","url":"/medias/music/hua.mp3","cover":"/medias/music/avatars/zhaolei.jpg"},{"name":"多想在平庸的生活拥抱你","artist":"隔壁老樊","url":"/medias/music/yongbaoni.mp3","cover":"/medias/music/avatars/laofan.jpg"},{"name":"往后余生","artist":"马良","url":"/medias/music/wanghouyusheng.mp3","cover":"/medias/music/avatars/maliang.jpg"},{"name":"理想三寻","artist":"陈鸿宇","url":"/medias/music/lixiangsanxun.mp3","cover":"/medias/music/avatars/chenhouyu.jpg"}]}},"excerpt":"","more":"<div align=\"middle\">\n  <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=436394160&auto=1&height=66\">\n  </iframe>\n</div>\n\n\n<h2 id=\"源码架构\"><a href=\"#源码架构\" class=\"headerlink\" title=\"源码架构\"></a>源码架构</h2><p>vue 一直以简单，快速著称，也自称为渐进式框架今天我们来分析一下vue的源码，这样我们也能了解其中的思想，帮助我们在工作中很好的应用和解决问题。当然我们并不可能把源码很细致的分析个遍，那样没什么意义。<br>附上 git 仓库<a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"noopener\">vue源码</a>地址。</p>\n<p>我们看一下 vue 源码的核心目录方便大家去对应查找</p>\n<pre><code class=\"md\">src\n├── compiler/        # 模版编译目录 \n├── core/            # 核心代码 \n├── platforms/       # 跨平台的支持\n├── server/          # 处理服务端渲染\n├── sfc/             # .vue 文件的解析\n├── shared/          # 全局用到的工具函数</code></pre>\n<h3 id=\"compiler\"><a href=\"#compiler\" class=\"headerlink\" title=\"compiler\"></a>compiler<hr></h3><p>vue 所有编译相关的代码。包括把模版解析成抽象语法树（AST）,编译、生成等功能</p>\n<h3 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core<hr></h3><p>vue 核心代码，包括内置组件，指令、全局API、Observer、虚拟DOM、全局工具函数等，这个目录也是vue的灵魂，也是我们重点关注分析的地方，compiler 会在后续文章中分析</p>\n<h3 id=\"platform\"><a href=\"#platform\" class=\"headerlink\" title=\"platform\"></a>platform<hr></h3><p>最初 vue 是跑在 web 上的mvvm架构, 后期增加了 阿里团队的 weex 入口，配合 weex 也可以运行在 native 客户端上</p>\n<h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server \"></a>server <hr></h3><p>服务端渲染入口，这是是vue2.0 之后更新的功能，所谓的服务端渲染是把相对应的组件渲染为服务端的 html 字符串，然后发送给客户端，客户端进行处理。这样做能提高客户体验</p>\n<h3 id=\"sfc\"><a href=\"#sfc\" class=\"headerlink\" title=\"sfc\"></a>sfc<hr></h3><p>将 .vue 文件内容解析成JavaScript的对象</p>\n<h2 id=\"源码构建\"><a href=\"#源码构建\" class=\"headerlink\" title=\"源码构建\"></a>源码构建</h2><p>vue 源码是基于 <a href=\"https://rollupjs.org/guide/en/\" target=\"_blank\" rel=\"noopener\">Rollup </a>构建的，构建的配置在 scripts 目录下</p>\n<pre><code class=\"md\">scripts\n├── git-hook/           # git-hook配置文件\n├── alias               # 混入文件目录别名配置\n├── build               # 构建的入口文件\n├── config              # 构建全局配置文件\n├── feature-flags       # weex 环境 flag\n├── gen-release-note    # 生成 Change log\n├── get-weex-version    # 生成 weexBaseVersion\n├── release-weex        # weex发布的脚本\n├── release             # 发布脚本\n├── verify-commit-msg   # 检查 Commit message 是否符合格式</code></pre>\n<h3 id=\"构建脚本\"><a href=\"#构建脚本\" class=\"headerlink\" title=\"构建脚本\"></a>构建脚本<hr></h3><p>基于 npm 托管的项目都会有一个 package.json 文件，这个文件当中的 script 描述符中一般配置的基本都是启动项目、打包、测试等相关命令, 看一下 vue 项目根目录的 package.json,由于只做 build 环境中的分析，所以我们去掉 dev、test等执行命令</p>\n<pre><code class=\"json\">{\n  &quot;scripts&quot;: {\n    &quot;build&quot;: &quot;node scripts/build.js&quot;,\n    &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;,\n    &quot;build:weex&quot;: &quot;npm run build -- weex&quot;,\n  } \n}</code></pre>\n<p>上面三个命令在执行的时候通过环境参数来区分不同的平台，当执行 <code>npm run build</code> 命令的时候就会执行 <code>node scripts/build.js</code> 这个文件</p>\n<h3 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"构建过程\"></a>构建过程<hr></h3><p>接下来来查看一下 <code>node scripts/build.js</code> 这个文件看看执行过程</p>\n<pre><code class=\"js\">let builds = require(&#39;./config&#39;).getAllBuilds()\n// filter builds via command line arg\nif (process.argv[2]) {\n  const filters = process.argv[2].split(&#39;,&#39;)\n  builds = builds.filter(b =&gt; {\n    return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1)\n  })\n} else {\n  // filter out weex builds by default\n  builds = builds.filter(b =&gt; {\n    return b.output.file.indexOf(&#39;weex&#39;) === -1\n  })\n}\n\nbuild(builds)\n// ...\n\n</code></pre>\n<p>通过上面的代码片段了解到主要引用了 <code>./config</code> getAllBuilds 文件下面的方法，进入这个文件</p>\n<pre><code class=\"js\">const builds = {\n  // ...\n\n  const aliases = require(&#39;./alias&#39;)\n  const resolve = p =&gt; {\n    const base = p.split(&#39;/&#39;)[0]\n    if (aliases[base]) {\n      return path.resolve(aliases[base], p.slice(base.length + 1))\n    } else {\n      return path.resolve(__dirname, &#39;../&#39;, p)\n    }\n  }\n\n\n  // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify\n  &#39;web-runtime-cjs-prod&#39;: {\n    entry: resolve(&#39;web/entry-runtime.js&#39;),\n    dest: resolve(&#39;dist/vue.runtime.common.prod.js&#39;),\n    format: &#39;cjs&#39;,\n    env: &#39;production&#39;,\n    banner\n  },\n  // runtime-only production build (Browser)\n  &#39;web-runtime-prod&#39;: {\n    entry: resolve(&#39;web/entry-runtime.js&#39;),\n    dest: resolve(&#39;dist/vue.runtime.min.js&#39;),\n    format: &#39;umd&#39;,\n    env: &#39;production&#39;,\n    banner\n  },\n  // Runtime+compiler CommonJS build (CommonJS)\n  &#39;web-full-prod&#39;: {\n    entry: resolve(&#39;web/entry-runtime-with-compiler.js&#39;),\n    dest: resolve(&#39;dist/vue.min.js&#39;),\n    format: &#39;umd&#39;,\n    env: &#39;production&#39;,\n    alias: { he: &#39;./entity-decoder&#39; },\n    banner\n  },\n\n  // ...\n}\n\nfunction genConfig (name) {\n  const opts = builds[name]\n  const config = {\n    input: opts.entry,\n    external: opts.external,\n    plugins: [\n      flow(),\n      alias(Object.assign({}, aliases, opts.alias))\n    ].concat(opts.plugins || []),\n    output: {\n      file: opts.dest,\n      format: opts.format,\n      banner: opts.banner,\n      name: opts.moduleName || &#39;Vue&#39;\n    }\n    // ...\n  }\n  // ...\n  Object.defineProperty(config, &#39;_name&#39;, {\n    enumerable: false,\n    value: name\n  })\n  return config\n\n}\n</code></pre>\n<p>通过这里的代码片面大概了解到 vue 通过当前web、服务端渲染、webpack插件、weex等配置来进行打包，每一个配置都遵循 rollup 的构建规则</p>\n<pre><code class=\"json\">{\n  &quot;entry&quot;: &quot;构建的入口文件&quot;,\n  &quot;dest&quot;: &quot;构建后的文件地址&quot;,\n  &quot;format&quot;: &quot;构建规范&quot;,\n  &quot;alias&quot;: &quot;别名设置&quot; \n  // ...\n}\n</code></pre>\n<p>那么在打包的过程中进行了路径别名设置，通过别名设置能代码能够更清晰整洁。</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\n\nconst resolve = p =&gt; path.resolve(__dirname, &#39;../&#39;, p)\n\nmodule.exports = {\n  vue: resolve(&#39;src/platforms/web/entry-runtime-with-compiler&#39;),\n  compiler: resolve(&#39;src/compiler&#39;),\n  core: resolve(&#39;src/core&#39;),\n  shared: resolve(&#39;src/shared&#39;),\n  web: resolve(&#39;src/platforms/web&#39;),\n  weex: resolve(&#39;src/platforms/weex&#39;),\n  server: resolve(&#39;src/server&#39;),\n  sfc: resolve(&#39;src/sfc&#39;)\n}</code></pre>\n<p>看到这个别名设置，我们就应该很清楚 vue 的核心构建文件都在 src 目录，具体作用在文章开头就已经介绍过了。那么我们主要看 web 别名下的目录，其它的目录有兴趣的同学可以了解一下实现规则</p>\n<pre><code class=\"js\">import Vue from &#39;core/index&#39;\nimport config from &#39;core/config&#39;\nimport { extend, noop } from &#39;shared/util&#39;\nimport { mountComponent } from &#39;core/instance/lifecycle&#39;\nimport { devtools, inBrowser } from &#39;core/util/index&#39;\n\n// ...\n\nimport { patch } from &#39;./patch&#39;\nimport platformDirectives from &#39;./directives/index&#39;\nimport platformComponents from &#39;./components/index&#39;\n\n// install platform runtime directives &amp; components\nextend(Vue.options.directives, platformDirectives)\nextend(Vue.options.components, platformComponents)\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\n</code></pre>\n<p>终于看到了 Vue 构造函数和核心代码的入口<code>core/index</code>，并在构造函数和原型上面挂载了一些方法，通过执行的上述构建过程我们总结到</p>\n<p>Vue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成(独立构建和运行时构建 只是 platforms 下 web 平台的两种选择)</p>\n<img src=\"/images/vue-init.png\" width=\"50%\">\n\n\n<h2 id=\"new-Vue\"><a href=\"#new-Vue\" class=\"headerlink\" title=\"new Vue\"></a>new Vue</h2><p>通过 vue 的核心目录，我们知道 Vue 实际上是一个构造函数，上面挂满了大大小小的各种方法我们在用的时候传一定的参数即可</p>\n<pre><code class=\"js\">new Vue({\n  el: &#39;xxxx&#39;,\n  data: xxxx,\n  ...\n})</code></pre>\n<h3 id=\"initGlobalAPI\"><a href=\"#initGlobalAPI\" class=\"headerlink\" title=\"initGlobalAPI\"></a>initGlobalAPI<hr></h3><p>那么在 vue 实例化的过程中到底发生了什么，打开核心代码 <code>src/core</code> 目录下面的 index</p>\n<pre><code class=\"js\">src/core/index.js\n\n// vue初始化的核心文件--创建Vue构造函数，将构造函数传入五个方法中\nimport Vue from &#39;./instance/index&#39;\n// 初始化全局API\nimport { initGlobalAPI } from &#39;./global-api/index&#39;\n// 获得一些环境判断，和是否是服务端渲染\nimport { isServerRendering } from &#39;core/util/env&#39;\n// ssr 环境加载此方法\nimport { FunctionalRenderContext } from &#39;core/vdom/create-functional-component&#39;\n\n//初始化全局API变量\ninitGlobalAPI(Vue)\n\n//为vue的原型定义$isServer属性\nObject.defineProperty(Vue.prototype, &#39;$isServer&#39;, {\n  get: isServerRendering\n})\n\n//为vue的原型定义$ssrContext\nObject.defineProperty(Vue.prototype, &#39;$ssrContext&#39;, {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode &amp;&amp; this.$vnode.ssrContext\n  }\n})\n\n//为vue原型定义当为ssr环境时加载FunctionalRenderContext方法\nObject.defineProperty(Vue, &#39;FunctionalRenderContext&#39;, {\n  value: FunctionalRenderContext\n})\n\n//添加版本号\nVue.version = &#39;__VERSION__&#39;\n\nexport default Vue</code></pre>\n<p>总结一下这个文件加载的方法</p>\n<pre><code class=\"md\">\ncore/index\n├── Vue            # 初始化构造函数\n├── initGlobalAPI  # 初始化全局API\n├── $isServer      # 判断环境的工具函数\n├── $ssrContext    # ssr 环境加载此方法也可用于操作状态\n├── FunctionalRenderContext  # ssr 环境加载此方法\n├── 添加版本号</code></pre>\n<h3 id=\"new-Vue-1\"><a href=\"#new-Vue-1\" class=\"headerlink\" title=\"new Vue \"></a>new Vue <hr></h3><p>初始化文件后，进入导出 Vue 构造函数的文件 <code>src/core/instance/index.js</code></p>\n<pre><code class=\"js\">function Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)\n  ) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)\n}</code></pre>\n<p>上面我们看到了 Vue 实际上就是一个用 Function 实现的类，通过 new 关键字初始化，然后会调用 this._init 方法。</p>\n<pre><code class=\"js\">// ...\n Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // 如果是Vue的实例，则不需要被observe\n    vm._isVue = true\n\n    // 对参数进行 merge 操作  \n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n\n    // 通过判断 Proxy 为 vue的实例属性赋值\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    vm._self = vm\n\n    // 初始化生命周期相关\n    initLifecycle(vm)\n\n    // 输初始化事件监听相关\n    initEvents(vm)\n\n    // 初始化编译render\n    initRender(vm)\n\n    // 调用beforeCreate钩子函数并且触发beforeCreate钩子事件\n    callHook(vm, &#39;beforeCreate&#39;)\n\n    initInjections(vm)\n\n    // 初始化props、methods、data、computed与watch\n    initState(vm)\n\n    initProvide(vm)\n\n    // 调用created钩子函数并且触发created钩子事件\n    callHook(vm, &#39;created&#39;)\n\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) {\n      // 格式化组件名\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n\n\n    // 挂载组件方法触发组件的DOM渲染\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n\n// ...</code></pre>\n<p>通过上面代码的注释了解到 Vue 初始化主要就干了几件事情，合并配置操作，初始化生命周期，初始化事件监听，初始化render，初始化 data、props、computed、watcher 等，在最后调用vm.$mount 方法挂载 vm ，把模版渲染成DOM。当然这里面还有很多细节需要知道例如上面初始化合并配置，生命周期初始化等，会在后面清楚的梳理 vue 整理流程之后，进入细节</p>\n<h2 id=\"vm-mount\"><a href=\"#vm-mount\" class=\"headerlink\" title=\"vm.$mount\"></a>vm.$mount</h2><p>通过 $mount 实例方法去挂载 vm ，但 $mount 方法是由于多平台编译处理不太一样，所以在多个文件中定义。我们进入 <code>src/platform</code> 这个目录可以观察到有 web 和 weex 目录，我们直接抛掉 weex，只分析 web 目录，在 vue 官网教程中介绍了vue的完整版<code>web/entry-runtime-with-compiler.js</code>和runtime版本<code>web/runtime/index.js</code></p>\n<p>完整版</p>\n<ul>\n<li>包含编译和运行是的版本</li>\n<li>html字符串 → render函数 → vnode → 真实dom节点</li>\n</ul>\n<p>runtime版本</p>\n<ul>\n<li>创建 Vue 实例、render、更新 DOM 等的操作的代码，没有编译器编译模版字符串代码</li>\n<li>render函数 → vnode → 真实dom节点</li>\n</ul>\n<h3 id=\"完整版-mount\"><a href=\"#完整版-mount\" class=\"headerlink\" title=\"完整版 $mount\"></a>完整版 $mount<hr></h3><pre><code class=\"js\">// ...\n\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; query(el)\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === &#39;string&#39;) {\n        if (template.charAt(0) === &#39;#&#39;) {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          warn(&#39;invalid template option:&#39; + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n\n      // ...\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        outputSourceRange: process.env.NODE_ENV !== &#39;production&#39;,\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      // ..\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n\n// ...</code></pre>\n<p>上面代码逻辑很清晰，将执行以下过程</p>\n<ul>\n<li>首先在原型上定义了 $mount 这个方法</li>\n<li>对传入的 el 做限制不能将节点挂载在 body 和 html 这种跟节点上</li>\n<li>如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法</li>\n<li>模版或字符串转换 render 方法（调用 compileToFunctions 进行编译转换）</li>\n</ul>\n<h3 id=\"runtime-版本-mount\"><a href=\"#runtime-版本-mount\" class=\"headerlink\" title=\"runtime 版本 $mount\"></a>runtime 版本 $mount<hr></h3><pre><code class=\"js\">// ...\n\n// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating)\n}\n\n// ...\n</code></pre>\n<p>执行过程</p>\n<ul>\n<li>挂载的元素，可以是字符串，也可以是DOM对象，如果是字符串通过 query 方法转换成DOM</li>\n<li>执行 mountComponent 函数传入三个参数</li>\n</ul>\n<p>通过上面代码可以看出并没有经过 compileToFunctions方法 进行转换编译阶段，而直接是 render –&gt; VNode 过程。</p>\n<p>接下来我们接着查看 mountComponent方法调用，打开文件<code>src/core/instance/lifecycle.js</code></p>\n<pre><code class=\"js\">export function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    // ...\n  }\n  callHook(vm, &#39;beforeMount&#39;)\n\n  let updateComponent\n\n  // ...\n\n  updateComponent = () =&gt; {\n    vm._update(vm._render(), hydrating)\n  }\n\n  // ...\n\n  // we set this to vm._watcher inside the watcher&#39;s constructor\n  // since the watcher&#39;s initial patch may call $forceUpdate (e.g. inside child\n  // component&#39;s mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {\n        callHook(vm, &#39;beforeUpdate&#39;)\n      }\n    }\n  }, true /* isRenderWatcher */)\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, &#39;mounted&#39;)\n  }\n  return vm\n}</code></pre>\n<p>通过上面代码很直观的看见 mountComponent 方法主要作用</p>\n<ul>\n<li>判断 render 函数是不是存在如果不存在调用创建 createEmptyVNode 方法创建一个空VNode节点</li>\n<li>检测完 render 开始挂载 beforeMount 钩子</li>\n<li>执行 new Watcher方法()</li>\n<li>_isMounted状态设置true， 开始挂载mounted</li>\n</ul>\n<p>Watcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM</p>\n<p>Watcher 初始化的时候会执行回调函数，当 vm 实例中的监测的数据发生变化的时候也会执行回调函数，这就是我们说的观察者进行依赖收集的过程,当然这也是 vue 核心原理的一部分。new Watcher到底做了什么我们在后面的单独整理，先以主线程为主</p>\n<h2 id=\"vm-render\"><a href=\"#vm-render\" class=\"headerlink\" title=\"vm._render\"></a>vm._render</h2><p>上文中提到 Watcher 在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法生成虚拟 Node节点，最后调用 vm._update 更新 DOM，那么就出现 私有方法 vm._render 和 vm._update 两个最核心的方法。</p>\n<p>_render 定义在 <code>src/core/instance/render.js</code> 中</p>\n<pre><code class=\"js\">\n  // ...\n  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    const { render, _parentVnode } = vm.$options\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      )\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n      // There&#39;s no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component&#39;s render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      handleError(e, vm, `render`)\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n        } catch (e) {\n          handleError(e, vm, `renderError`)\n          vnode = vm._vnode\n        }\n      } else {\n        vnode = vm._vnode\n      }\n    } finally {\n      currentRenderingInstance = null\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) {\n      vnode = vnode[0]\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; Array.isArray(vnode)) {\n        warn(\n          &#39;Multiple root nodes returned from render function. Render function &#39; +\n          &#39;should return a single root node.&#39;,\n          vm\n        )\n      }\n      vnode = createEmptyVNode()\n    }\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }</code></pre>\n<p>上面这段代码最关键的地方就是调用 render 方法 <code>render.call(vm._renderProxy, vm.$createElement)</code>，在上面说过在 mounted 方法中会把 template 和 string 经过 compileToFunctions 编译最后形成 render方法进行渲染，但是这是用字符串模版的形式，如果用字符串模板的代替方案 render 方法呢</p>\n<pre><code class=\"js\">new Vue({\n  render: function (createElement) {\n   return createElement(&#39;div&#39;, {\n     attrs: {\n        id: &#39;app&#39;\n      },\n  }, this.message)\n  },\n  renderError: function(createElement, err) {\n    return createElement(&#39;pre&#39;, { style: { color: &#39;red&#39; }}, err.stack)\n  }\n}).$mount(&#39;#app&#39;)</code></pre>\n<p>我们可以看出render 方法的参数 createElement 实际上就是 vm.$createElement,然而 vm.$createElement 在初始化中就已经执行过了</p>\n<pre><code class=\"js\">export function initRender (vm: Component) {\n\n  // ...\n\n  vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)\n\n  // $attrs &amp; $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  const parentData = parentVnode &amp;&amp; parentVnode.data\n\n  // ...\n\n}</code></pre>\n<p>所以在 initRender 方法的时候，除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，但 vm.$createElement 是我们用原生写的 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。</p>\n<p>官网中一句话说的很清楚 <strong>Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</strong></p>\n<p>通过上述总结到 render 函数最终是执行 createElement 方法 返回 vnode 节点，这是一个虚拟 node 而 vue2.0 的 另一个核心就是利用了Virtual DOM，实际上 Vue.js 中 Virtual DOM 是借鉴了开源库 <a href=\"https://github.com/snabbdom/snabbdom\" target=\"_blank\" rel=\"noopener\">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西, 这部分源码就在 <code>src/core/vdom/vnode.js</code> 中我们暂时不去查看，待后续文章写到 Virtual DOM 的时候我们在做分析。 </p>\n<p>那么在面试中我们经常被问到是 操作 Virtual DOM 快还是真实 DOM 快</p>\n<p>答案是相对的在数据量大的情况下，肯定是 Virtual DOM 快，因为通过对比 node 减少频繁的去更新DOM， 如果数据量相对较小的情况还是直接操作 DOM 较快，因为少了编译、遍历、对比的过程</p>\n<h2 id=\"vm-createElement\"><a href=\"#vm-createElement\" class=\"headerlink\" title=\"vm.$createElement\"></a>vm.$createElement</h2><p>上面文章提到 render 的时候内部调用了 createElement 方法，创建了vnode，该方法定义在 src/core/vdom/create-elemenet.js 中</p>\n<pre><code class=\"js\">// ...\n\nexport function _createElement (\n  context: Component,\n  tag?: string | Class&lt;Component&gt; | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array&lt;VNode&gt; {\n\n   /**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */   \n  if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) {\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n      &#39;Always create fresh vnode data objects in each render!&#39;,\n      context\n    )\n    return createEmptyVNode()\n  }\n\n  // 当通过 :is 动态设置组件时\n  if (isDef(data) &amp;&amp; isDef(data.is)) {\n    tag = data.is\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n\n\n  // ...\n\n  // 作用域插槽\n  if (Array.isArray(children) &amp;&amp;\n    typeof children[0] === &#39;function&#39;\n  ) {\n    data = data || {}\n    data.scopedSlots = { default: children[0] }\n    children.length = 0\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n  }\n  let vnode, ns\n  if (typeof tag === &#39;string&#39;) {\n    let Ctor\n    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn)) {\n        warn(\n          `The .native modifier for v-on is only valid on components but it was used on &lt;${tag}&gt;.`,\n          context\n        )\n      }\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n    } else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#39;components&#39;, tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns)\n    if (isDef(data)) registerDeepBindings(data)\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\n// ...\n</code></pre>\n<p>通过上面代码我们看到 主要调用了几个方法 createEmptyVNode 和 createComponent、normalizeChildren、simpleNormalizeChildren</p>\n<p>我们简单的看一下执行步骤</p>\n<p>首先判断了 tag 是否存在，如果不存在则调用 <code>src/core/vdom/vnode.js</code>目录下的 createEmptyVNode 方法创建空的 vnode 节点</p>\n<p>如果传递了children，由于其是任意类型，所以根据 normalizationType 去调用<code>src/core/vdom/helpers/normalzie-children.js</code> 目录下的 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法进行递归遍历，把整个 children 打平，让它变成深度只有一层的 vnode 数组</p>\n<p>最后通过 对参数 tag 的判断，如果是一个普通的 html 标签，则实例化一个普通 vnode 节点，否则通过 <code>src/core/vdom/create-component.js</code>目录下的 createComponent 方法创建一个组件的 vnode</p>\n<p>因为除了组件的 vnode 没有 children，其他通过 createElement 创建的每个 vnode 都有 children，children 每个元素也是一个 vnode，这样就形成了一个 vnode tree，这样我们就知道 vm._render 阶段是如何创建的 vnode，那么接下来我们就通过 vm._update，将 vnode 渲染成真实的 dom。</p>\n<h2 id=\"vm-update\"><a href=\"#vm-update\" class=\"headerlink\" title=\"vm._update\"></a>vm._update</h2><p>vm._update 也是一个私有方法，作用是把 vnode 渲染成真实的 dom 在 <code>src/core/instance/lifecycle.js</code> 文件中定义</p>\n<h3 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"_update \"></a>_update <hr></h3><pre><code class=\"js\">\n  // ...\n\n\n  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const restoreActiveInstance = setActiveInstance(vm)\n    vm._vnode = vnode\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    restoreActiveInstance()\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent&#39;s updated hook.\n  }\n\n  // ...</code></pre>\n<p>通过上面代码我们知道 vm.<em>update 的核心就是通过 vm.<strong>patch</strong>函数来实现将 vnode 转换成真实的 node 节点，而 vm.<em>_patch</em></em> 的实现是多平台的有weex、ssr、inBrowser，我们只查看在浏览器环境内的实现</p>\n<p>在 <code>src/platforms/web/runtime/index.js</code> 通过判断如果是浏览器环境调用 patch，否则创建一个空对象</p>\n<h3 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch \"></a><strong>patch</strong> <hr></h3><pre><code class=\"js\">// ...\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop\n\n// ...</code></pre>\n<p>通过引用我们到 <code>src/platforms/web/runtime/patch.js</code> 目录看到调用了 createPatchFunction 方法的返回值</p>\n<pre><code class=\"js\">export const patch: Function = createPatchFunction({ nodeOps, modules })</code></pre>\n<h3 id=\"createPatchFunction\"><a href=\"#createPatchFunction\" class=\"headerlink\" title=\"createPatchFunction \"></a>createPatchFunction <hr></h3><p>在通过查找文件 <code>src/core/vdom/patch.js</code> 中定义的 createPatchFunction 方法</p>\n<pre><code class=\"js\">\n// ...\n\nexport function createPatchFunction (backend) {\n\n  // ...\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    // 如果 vnode 不存在但 oldVnode 存在，调用 invokeDestroyHook(oldVnode) 来进行销毁旧节点\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)\n      return\n    }\n\n    let isInitialPatch = false\n    const insertedVnodeQueue = []\n\n    // 如果oldVnode不存在，vnode存在，则创建新节点  \n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true\n      createElm(vnode, insertedVnodeQueue)\n    } else {\n\n      const isRealElement = isDef(oldVnode.nodeType)\n      // 如果 oldVnode 与 vnode 都存在判断是同一节点调用 patchVnode 处理去比较两个节点的差异\n      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n      } else {\n\n        if (isRealElement) {\n\n          // 如果存在真实的节点，存在data-server-rendered属性，将 hydrating 变为true\n          if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR)\n            hydrating = true\n          }\n\n          // 用hydrate函数将虚拟DOM和真实DOM进行映射\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true)\n              return oldVnode\n            }\n            // ...\n          }\n\n          // 如果不是server-rendered 或者hydration失败\n          // 创建一个空VNode，代替oldVnode\n          oldVnode = emptyNodeAt(oldVnode)\n        }\n\n        // 将oldVnode设置为对应的虚拟dom，找到oldVnode.elm的父节点\n        // 根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置\n        const oldElm = oldVnode.elm\n        const parentElm = nodeOps.parentNode(oldElm)\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        )\n\n        // 递归更新父级占位节点元素，\n        if (isDef(vnode.parent)) {\n          let ancestor = vnode.parent\n          const patchable = isPatchable(vnode)\n          while (ancestor) {\n            for (let i = 0; i &lt; cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor)\n            }\n            ancestor.elm = vnode.elm\n            if (patchable) {\n              for (let i = 0; i &lt; cbs.create.length; ++i) {\n                cbs.create[i](emptyNode, ancestor)\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the &quot;inserted&quot; hook.\n              const insert = ancestor.data.hook.insert\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (let i = 1; i &lt; insert.fns.length; i++) {\n                  insert.fns[i]()\n                }\n              }\n            } else {\n              registerRef(ancestor)\n            }\n            ancestor = ancestor.parent\n          }\n        }\n\n        // 销毁旧节点\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0)\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode)\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)\n\n    // 返回节点\n    return vnode.elm\n  }\n}\n</code></pre>\n<p>通过上面看到 patch 方法本身</p>\n<p>接收 4个参数</p>\n<ul>\n<li>oldVnode 表示旧的 VNode 节点或者或者是一个 DOM 对象</li>\n<li>vnode 表示执行 _render 后返回的 VNode 的节点</li>\n<li>hydrating 表示是否是服务端渲染</li>\n<li>removeOnly 是给 transition-group 用的，防止在 updateChildren 阶段，移动 vnode 节点</li>\n</ul>\n<p>关键调用三个方法</p>\n<ul>\n<li>createElm 以当前旧节点为参考节点，创建新的节点，执行相关的 insert 钩子函数，并插入到 DOM 中，</li>\n<li>sameVnode 通过对比 key 是否相同、tag、注释、data是否存在等判断2个节点，是否是同一个节点</li>\n<li>patchVnode vdom 核心更新 node </li>\n</ul>\n<p>patchVode 中的几个核心方法 addVnodes、 removeVnodes，updateChildren，具体是怎么增加、删除，更新 vnode 和 dom 节点的，dom-diff 比较复杂，我们会在分析响应式原理的时候具体查看细节</p>\n<h3 id=\"主流程总结\"><a href=\"#主流程总结\" class=\"headerlink\" title=\"主流程总结\"></a>主流程总结<hr></h3><p>下面我们通过一张图来总结 vue 主线流程</p>\n<img src=\"/images/vue-process.png\">\n\n<p>上面的图中能够直观的看到 vue 主干的执行流程，但是缺少核心部分，也就是 vue 的响应式原理，下篇文章我们也是通过文件的执行过程来分析 vue 响应式原理的实现</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck1sw8oqa000ab0u6l7vpb3jz","category_id":"ck1sw8oqd000cb0u6dodaqxk3","_id":"ck1sw8oqq000mb0u6a2dqbyyo"},{"post_id":"ck1sw8oqn000kb0u6cft7pcd2","category_id":"ck1sw8oqm000hb0u683dyw1ok","_id":"ck1sw8oqy000tb0u6yccpcwjf"},{"post_id":"ck1sw8oqb000bb0u6kjtobw4s","category_id":"ck1sw8oqm000hb0u683dyw1ok","_id":"ck1sw8or1000xb0u6xw7jnt48"},{"post_id":"ck1sw8oqi000eb0u6fe826zpm","category_id":"ck1sw8oqm000hb0u683dyw1ok","_id":"ck1sw8or40011b0u671waaexl"},{"post_id":"ck1sw8oqk000fb0u6srakrzub","category_id":"ck1sw8oqm000hb0u683dyw1ok","_id":"ck1sw8or80017b0u6fxly6igq"},{"post_id":"ck1sw8oql000gb0u62o3iq9vh","category_id":"ck1sw8oqm000hb0u683dyw1ok","_id":"ck1sw8orb001cb0u6h7qfpd03"},{"post_id":"ck1sw8oqp000lb0u6ephvtx5u","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8orh001jb0u6qn32dibi"},{"post_id":"ck1sw8ord001fb0u6aaeyzzra","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8orm001pb0u6mgsu5utn"},{"post_id":"ck1sw8oqu000qb0u6369hutby","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8orp001ub0u6igj628od"},{"post_id":"ck1sw8orf001hb0u69c8mqojw","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8ors001xb0u6jx83gzz2"},{"post_id":"ck1sw8orj001mb0u61k5dtizf","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8oru0022b0u68snjobat"},{"post_id":"ck1sw8oqw000sb0u6zxxdqvxo","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8orw0025b0u6wujjuvd2"},{"post_id":"ck1sw8orl001ob0u6h1v00ljx","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8orz002ab0u63946o7dw"},{"post_id":"ck1sw8orn001tb0u67t2cu9x3","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8os1002db0u62wf7fpbp"},{"post_id":"ck1sw8or0000wb0u6ieov23d5","category_id":"ck1sw8orm001qb0u65qjvy206","_id":"ck1sw8os4002ib0u6uh1701wf"},{"post_id":"ck1sw8orq001wb0u6v55qp0xc","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8os7002lb0u63psgmir9"},{"post_id":"ck1sw8ort0021b0u6bq43jabe","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8os9002qb0u6b6znkxnb"},{"post_id":"ck1sw8or2000zb0u6kbnyyutt","category_id":"ck1sw8orm001qb0u65qjvy206","_id":"ck1sw8osb002tb0u6q3p4b4dk"},{"post_id":"ck1sw8or50013b0u6510twzy4","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8osd002yb0u6lvahovie"},{"post_id":"ck1sw8or70015b0u6en5azt3s","category_id":"ck1sw8orm001qb0u65qjvy206","_id":"ck1sw8osf0031b0u6qn551xn0"},{"post_id":"ck1sw8or90019b0u6ty5zoaht","category_id":"ck1sw8orm001qb0u65qjvy206","_id":"ck1sw8osh0035b0u6qsoupqss"},{"post_id":"ck1sw8ora001bb0u6jwzyur5t","category_id":"ck1sw8orm001qb0u65qjvy206","_id":"ck1sw8osi0038b0u61hdlxso9"},{"post_id":"ck1sw8orv0024b0u6azbikh0k","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8oso003gb0u6curq5m4m"},{"post_id":"ck1sw8ory0029b0u6m9z4o23n","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8oss003mb0u6hcqf05ra"},{"post_id":"ck1sw8os0002cb0u6sbs1qma6","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8osw003sb0u652tzhpfq"},{"post_id":"ck1sw8os3002hb0u67006nywb","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8ot4003yb0u6wg8tjp5d"},{"post_id":"ck1sw8os6002kb0u6qxwz5ijm","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8ota0044b0u6lr7o5upr"},{"post_id":"ck1sw8os8002pb0u6pmjh5w1s","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8otg004ab0u60fmedy9h"},{"post_id":"ck1sw8osa002sb0u63dogfmp5","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8otk004gb0u6cj2j6y9c"},{"post_id":"ck1sw8osc002xb0u6ab4vzqjz","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8otn004mb0u63e0dyr7s"},{"post_id":"ck1sw8ose0030b0u6xblhun6o","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8ott004sb0u66r3im8q8"},{"post_id":"ck1sw8osf0034b0u6h0b6ukg5","category_id":"ck1sw8osf0032b0u6yxprhui1","_id":"ck1sw8otz004xb0u6trw8t75q"},{"post_id":"ck1sw8osh0037b0u68yhnczld","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8ou40054b0u6gxnd5wvk"},{"post_id":"ck1sw8osj0039b0u6our1cj0q","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8ou9005ab0u6gsxhzale"},{"post_id":"ck1sw8osl003db0u6i42te42w","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8ouf005gb0u6cenv1k4v"},{"post_id":"ck1sw8osn003eb0u6rz4jtir2","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8ouk005mb0u6a0wvf1v7"},{"post_id":"ck1sw8osp003jb0u6s5aimczx","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8oun005qb0u6ogvaz35v"},{"post_id":"ck1sw8osq003kb0u6b24v69dj","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8ouo005ub0u64hb39ut7"},{"post_id":"ck1sw8ost003pb0u67j1ruk40","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8our005yb0u6yo1f6c64"},{"post_id":"ck1sw8osv003qb0u6gb7ca8dc","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8out0062b0u6oi7gtq8o"},{"post_id":"ck1sw8osx003vb0u6o3ty8qzg","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8out0065b0u6rwgdzcqx"},{"post_id":"ck1sw8ot3003wb0u60zu9ql2w","category_id":"ck1sw8ous0061b0u6ficyswcn","_id":"ck1sw8ouv006ab0u61psgeggv"},{"post_id":"ck1sw8ot60041b0u60mpp1egk","category_id":"ck1sw8ous0061b0u6ficyswcn","_id":"ck1sw8ouv006db0u6ix7g45ml"},{"post_id":"ck1sw8ot80042b0u6k8qvub2h","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8oux006ib0u6pwg6qyt3"},{"post_id":"ck1sw8otc0047b0u6hascztsz","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ouz006mb0u6rfqcg3jx"},{"post_id":"ck1sw8ote0048b0u6opgkiztk","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ov0006qb0u6p0dk0hw9"},{"post_id":"ck1sw8oth004db0u60y4sgcii","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ov2006ub0u6vjocoh3y"},{"post_id":"ck1sw8oti004eb0u6eh6kaj7w","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ov3006yb0u6vdoocsen"},{"post_id":"ck1sw8otl004jb0u69detbx24","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ov50072b0u6lqdswvv5"},{"post_id":"ck1sw8otm004kb0u6tc9aela9","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ov70076b0u6h4v1e6j6"},{"post_id":"ck1sw8otp004pb0u6rxm2ssng","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ov9007ab0u6ji2k48b0"},{"post_id":"ck1sw8otr004qb0u6ne0nwoh9","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ova007eb0u65gdlqqxf"},{"post_id":"ck1sw8otu004vb0u6mwkt7eug","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ovc007ib0u6rdotuips"},{"post_id":"ck1sw8otv004wb0u6gx0ceine","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ovf007mb0u6hzeij57t"},{"post_id":"ck1sw8ou10050b0u6nt7v4t4r","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ovg007qb0u6z0d9r2a2"},{"post_id":"ck1sw8ou30052b0u6y6nc2ojl","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ovi007ub0u660sqpnn2"},{"post_id":"ck1sw8ou60056b0u66ksmlfsl","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ovl007yb0u6je1pn0as"},{"post_id":"ck1sw8ou80058b0u6ayo9ztga","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8ovm0081b0u6kq84mc0j"},{"post_id":"ck1sw8oub005cb0u644djvslp","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ovo0086b0u6kzvgox52"},{"post_id":"ck1sw8oud005eb0u6ax7s18ii","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ovp008ab0u69ore3btl"},{"post_id":"ck1sw8oug005ib0u6g8ane8vh","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ovq008db0u6eql6zmnx"},{"post_id":"ck1sw8ouh005kb0u6hsb9qqc8","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ovr008fb0u67o9mda3m"},{"post_id":"ck1sw8ow3008gb0u65cfsosrv","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8ow8008mb0u6neq7cwt4"},{"post_id":"ck1sw8ow4008hb0u6y7l8au2s","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8owa008pb0u65sqigae8"},{"post_id":"ck1sw8ow6008jb0u6a8wavkli","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8owe008sb0u6btgmpe0e"},{"post_id":"ck1sw8ow7008lb0u66j7f4bq9","category_id":"ck1sw8ots004rb0u69u8bynhk","_id":"ck1sw8owg008vb0u6je521nzj"},{"post_id":"ck1sw8ow9008ob0u6ma9gs42x","category_id":"ck1sw8ous0061b0u6ficyswcn","_id":"ck1sw8owj008zb0u6i08p8vap"},{"post_id":"ck1sw8owi008yb0u6vlrh14db","category_id":"ck1sw8ouv0069b0u620t9e9zs","_id":"ck1sw8owp0097b0u6nall2oqt"},{"post_id":"ck1sw8owk0090b0u6crtm3zhq","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8owp0099b0u6a2oz5zkd"},{"post_id":"ck1sw8owb008rb0u6p1vqlgh5","category_id":"ck1sw8owg008wb0u6gtg9ritb","_id":"ck1sw8owq009bb0u6myegkj1z"},{"post_id":"ck1sw8owl0092b0u63eah0ie9","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8owq009db0u6fbqy31iz"},{"post_id":"ck1sw8owo0096b0u6mxmfbppr","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8owr009fb0u653d4cpq3"},{"post_id":"ck1sw8owf008ub0u6mvsoi8j2","category_id":"ck1sw8owg008wb0u6gtg9ritb","_id":"ck1sw8owr009gb0u6jn00903o"},{"post_id":"ck1sw8owt009hb0u6gtfpkiv7","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8owy009mb0u6qih2tmmf"},{"post_id":"ck1sw8owv009ib0u6vejhfjlc","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8owz009ob0u6i3cgrv64"},{"post_id":"ck1sw8oww009kb0u6c70rfbzv","category_id":"ck1sw8or80016b0u6x7f8rcq4","_id":"ck1sw8owz009pb0u6bki7ddb7"},{"post_id":"ck1sw8ox2009qb0u6rv67qi18","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ox6009vb0u6ytzrfmuc"},{"post_id":"ck1sw8ox3009rb0u6bze14zlm","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ox7009xb0u6uxrasuzv"},{"post_id":"ck1sw8ox5009tb0u6y6tyjhtz","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8ox7009yb0u6w65axtxk"},{"post_id":"ck1sw8ox9009zb0u69zmgovlx","category_id":"ck1sw8ovk007xb0u65wftd6te","_id":"ck1sw8oxb00a1b0u6cvrlo13b"}],"PostTag":[{"post_id":"ck1sw8oqa000ab0u6l7vpb3jz","tag_id":"ck1sw8oqh000db0u6nflgc2jb","_id":"ck1sw8oqn000jb0u6am2anujh"},{"post_id":"ck1sw8oqn000kb0u6cft7pcd2","tag_id":"ck1sw8oqm000ib0u607jaghto","_id":"ck1sw8oqt000pb0u6flfc5rlt"},{"post_id":"ck1sw8oqb000bb0u6kjtobw4s","tag_id":"ck1sw8oqm000ib0u607jaghto","_id":"ck1sw8oqw000rb0u6pmyeepy8"},{"post_id":"ck1sw8oqi000eb0u6fe826zpm","tag_id":"ck1sw8oqm000ib0u607jaghto","_id":"ck1sw8or1000yb0u67wboo77a"},{"post_id":"ck1sw8oqk000fb0u6srakrzub","tag_id":"ck1sw8oqm000ib0u607jaghto","_id":"ck1sw8or60014b0u6r0ntey3e"},{"post_id":"ck1sw8oql000gb0u62o3iq9vh","tag_id":"ck1sw8oqm000ib0u607jaghto","_id":"ck1sw8ora001ab0u620r0ilz1"},{"post_id":"ck1sw8oqp000lb0u6ephvtx5u","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8ore001gb0u61bbzc166"},{"post_id":"ck1sw8ord001fb0u6aaeyzzra","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8ori001lb0u6szpo8h15"},{"post_id":"ck1sw8oqu000qb0u6369hutby","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8orl001nb0u6wwaeiilb"},{"post_id":"ck1sw8orf001hb0u69c8mqojw","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8orn001sb0u6m8myjrhd"},{"post_id":"ck1sw8orj001mb0u61k5dtizf","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8orp001vb0u668bur0kj"},{"post_id":"ck1sw8oqw000sb0u6zxxdqvxo","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8ors001yb0u6i3ll8xca"},{"post_id":"ck1sw8orl001ob0u6h1v00ljx","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8orv0023b0u6efq0eghh"},{"post_id":"ck1sw8orn001tb0u67t2cu9x3","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8orx0026b0u6sduu97cx"},{"post_id":"ck1sw8or0000wb0u6ieov23d5","tag_id":"ck1sw8orn001rb0u650pae6js","_id":"ck1sw8os0002bb0u6994bwqi4"},{"post_id":"ck1sw8orq001wb0u6v55qp0xc","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8os2002eb0u618hfnbgr"},{"post_id":"ck1sw8ort0021b0u6bq43jabe","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8os5002jb0u6gg4q0za5"},{"post_id":"ck1sw8or2000zb0u6kbnyyutt","tag_id":"ck1sw8orn001rb0u650pae6js","_id":"ck1sw8os7002mb0u6s0xqllk8"},{"post_id":"ck1sw8or50013b0u6510twzy4","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8osa002rb0u6bytt7062"},{"post_id":"ck1sw8or70015b0u6en5azt3s","tag_id":"ck1sw8orn001rb0u650pae6js","_id":"ck1sw8osb002ub0u6ke1bptfg"},{"post_id":"ck1sw8or90019b0u6ty5zoaht","tag_id":"ck1sw8orn001rb0u650pae6js","_id":"ck1sw8ose002zb0u6lazlslj4"},{"post_id":"ck1sw8ora001bb0u6jwzyur5t","tag_id":"ck1sw8orn001rb0u650pae6js","_id":"ck1sw8osh0036b0u6t2bzxlf1"},{"post_id":"ck1sw8orv0024b0u6azbikh0k","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8osl003cb0u6mxqnl6vp"},{"post_id":"ck1sw8ory0029b0u6m9z4o23n","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8osp003ib0u6tvbkkmib"},{"post_id":"ck1sw8os0002cb0u6sbs1qma6","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8ost003ob0u6bib1ctld"},{"post_id":"ck1sw8os3002hb0u67006nywb","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8osx003ub0u6ue0yrv2x"},{"post_id":"ck1sw8os6002kb0u6qxwz5ijm","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8ot60040b0u6vub97uyh"},{"post_id":"ck1sw8os8002pb0u6pmjh5w1s","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8otb0046b0u6gfi5ofqq"},{"post_id":"ck1sw8osa002sb0u63dogfmp5","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8oth004cb0u695qrp8lt"},{"post_id":"ck1sw8osc002xb0u6ab4vzqjz","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8otl004ib0u6oqimzp01"},{"post_id":"ck1sw8ose0030b0u6xblhun6o","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8oto004ob0u61y7oavi4"},{"post_id":"ck1sw8osf0034b0u6h0b6ukg5","tag_id":"ck1sw8osf0033b0u6rukpt5hm","_id":"ck1sw8ott004ub0u6lo63dse0"},{"post_id":"ck1sw8osh0037b0u68yhnczld","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8ou20051b0u631s5bk8y"},{"post_id":"ck1sw8osj0039b0u6our1cj0q","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8ou70057b0u6hft0sqcx"},{"post_id":"ck1sw8osl003db0u6i42te42w","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8oud005db0u6vucseeha"},{"post_id":"ck1sw8osn003eb0u6rz4jtir2","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8ouh005jb0u60rbjjkcg"},{"post_id":"ck1sw8osp003jb0u6s5aimczx","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8oul005ob0u6w1lpbhs0"},{"post_id":"ck1sw8osq003kb0u6b24v69dj","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8ouo005sb0u6v4fvwkh2"},{"post_id":"ck1sw8ost003pb0u67j1ruk40","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8ouq005wb0u6tfta8xk3"},{"post_id":"ck1sw8osv003qb0u6gb7ca8dc","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8ous0060b0u66a1utunl"},{"post_id":"ck1sw8osx003vb0u6o3ty8qzg","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8out0064b0u67isjg6ga"},{"post_id":"ck1sw8ot3003wb0u60zu9ql2w","tag_id":"ck1sw8out0063b0u6x5unj00f","_id":"ck1sw8ouu0068b0u6bm7r7lvx"},{"post_id":"ck1sw8ot60041b0u60mpp1egk","tag_id":"ck1sw8out0063b0u6x5unj00f","_id":"ck1sw8ouv006cb0u6axut9omd"},{"post_id":"ck1sw8ot80042b0u6k8qvub2h","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ouw006gb0u629kw3dou"},{"post_id":"ck1sw8otc0047b0u6hascztsz","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ouy006kb0u6sa3rm8h3"},{"post_id":"ck1sw8ote0048b0u6opgkiztk","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ov0006ob0u62yhi92yo"},{"post_id":"ck1sw8oth004db0u60y4sgcii","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ov1006sb0u6emaxham3"},{"post_id":"ck1sw8oti004eb0u6eh6kaj7w","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ov3006wb0u6265003px"},{"post_id":"ck1sw8otl004jb0u69detbx24","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ov40070b0u6gjh5sycb"},{"post_id":"ck1sw8otm004kb0u6tc9aela9","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ov60074b0u6ce017ihk"},{"post_id":"ck1sw8otp004pb0u6rxm2ssng","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ov80078b0u6x5iqgcar"},{"post_id":"ck1sw8otr004qb0u6ne0nwoh9","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ova007cb0u6ubt2bug9"},{"post_id":"ck1sw8otu004vb0u6mwkt7eug","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ovb007gb0u6l3e1gnt7"},{"post_id":"ck1sw8otv004wb0u6gx0ceine","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ovc007kb0u6wtvttxbl"},{"post_id":"ck1sw8ou10050b0u6nt7v4t4r","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ovg007ob0u6uwg6ly56"},{"post_id":"ck1sw8ou30052b0u6y6nc2ojl","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ovh007sb0u681lq879e"},{"post_id":"ck1sw8ou60056b0u66ksmlfsl","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ovj007wb0u6hkt8ykxz"},{"post_id":"ck1sw8ou80058b0u6ayo9ztga","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8ovm0080b0u68iap7wau"},{"post_id":"ck1sw8oub005cb0u644djvslp","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ovn0084b0u6txhmw41z"},{"post_id":"ck1sw8oud005eb0u6ax7s18ii","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ovo0088b0u6wou3xrqo"},{"post_id":"ck1sw8oug005ib0u6g8ane8vh","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ovq008cb0u61ullglyq"},{"post_id":"ck1sw8ouh005kb0u6hsb9qqc8","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ovr008eb0u6cpocg5b6"},{"post_id":"ck1sw8ow3008gb0u65cfsosrv","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8ow5008ib0u6c4plikc5"},{"post_id":"ck1sw8ow4008hb0u6y7l8au2s","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8ow7008kb0u672xrapsh"},{"post_id":"ck1sw8ow6008jb0u6a8wavkli","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8ow9008nb0u60m1vbpmd"},{"post_id":"ck1sw8ow7008lb0u66j7f4bq9","tag_id":"ck1sw8ott004tb0u60cwt31kb","_id":"ck1sw8owb008qb0u65fz7k3sz"},{"post_id":"ck1sw8ow9008ob0u6ma9gs42x","tag_id":"ck1sw8out0063b0u6x5unj00f","_id":"ck1sw8owe008tb0u6g7jpvayg"},{"post_id":"ck1sw8owi008yb0u6vlrh14db","tag_id":"ck1sw8ouv006bb0u6hipfvt6p","_id":"ck1sw8owl0091b0u63tf818y7"},{"post_id":"ck1sw8owk0090b0u6crtm3zhq","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8owo0095b0u60u7ro1la"},{"post_id":"ck1sw8owb008rb0u6p1vqlgh5","tag_id":"ck1sw8owg008xb0u645sso00b","_id":"ck1sw8owp0098b0u6nnum65ot"},{"post_id":"ck1sw8owl0092b0u63eah0ie9","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8owq009ab0u6bohkyfey"},{"post_id":"ck1sw8owo0096b0u6mxmfbppr","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8owq009cb0u6jx4sl78n"},{"post_id":"ck1sw8owf008ub0u6mvsoi8j2","tag_id":"ck1sw8owg008xb0u645sso00b","_id":"ck1sw8owq009eb0u6wdkopaef"},{"post_id":"ck1sw8owt009hb0u6gtfpkiv7","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8oww009jb0u67ybv2iq8"},{"post_id":"ck1sw8owv009ib0u6vejhfjlc","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8owy009lb0u6ksp8kftc"},{"post_id":"ck1sw8oww009kb0u6c70rfbzv","tag_id":"ck1sw8or80018b0u6fqrr6c7i","_id":"ck1sw8owy009nb0u679rowf91"},{"post_id":"ck1sw8ox2009qb0u6rv67qi18","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ox4009sb0u6ubro6bcx"},{"post_id":"ck1sw8ox3009rb0u6bze14zlm","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ox6009ub0u6c54fosum"},{"post_id":"ck1sw8ox5009tb0u6y6tyjhtz","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8ox7009wb0u6qrq1f4vh"},{"post_id":"ck1sw8ox9009zb0u69zmgovlx","tag_id":"ck1sw8ovl007zb0u6ok0wbdgz","_id":"ck1sw8oxb00a0b0u6ah5s9oe8"}],"Tag":[{"name":"HTML","_id":"ck1sw8oqh000db0u6nflgc2jb"},{"name":"CSS","_id":"ck1sw8oqm000ib0u607jaghto"},{"name":"JavaScript","_id":"ck1sw8or80018b0u6fqrr6c7i"},{"name":"函数式编程","_id":"ck1sw8orn001rb0u650pae6js"},{"name":"Linux","_id":"ck1sw8osf0033b0u6rukpt5hm"},{"name":"Node","_id":"ck1sw8ott004tb0u60cwt31kb"},{"name":"PHP","_id":"ck1sw8out0063b0u6x5unj00f"},{"name":"TypeScript","_id":"ck1sw8ouv006bb0u6hipfvt6p"},{"name":"vue","_id":"ck1sw8ovl007zb0u6ok0wbdgz"},{"name":"react","_id":"ck1sw8owg008xb0u645sso00b"}]}}