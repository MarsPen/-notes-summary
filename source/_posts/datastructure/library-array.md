---
title: 基本概念
date: 2019-11-25 21:20:12
top: false
cover: false
password:
toc: true
mathjax: false
summary:
tags:
  - 数据结构与算法
categories:
  - 数据结构与算法
---

### 基本概念和术语 🚩<hr>

**数据🍎** 

在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称，是对客观事物的符合表示。

**数据元素🍎**

数据的基本单位，一个数据元素可由若干个`数据项`组成,`数据项`是数据不可分割的最小单位。

**数据单位🍎**

是性质相同的数据元素的集合，是数据的一个子集

**数据结构🍎**

相互间存在一种或多种特定关系的数据元素的集合，通常由4类基本结构 `集合`，`线性结构`、`树形结构`、`图状结构或网状结构`，如下图

<img src="/images/shuju01.jpg">

- 计算机中的数据结构表现形式称为数据的 `物理结构`，又称为存储结构。包括数据元素的表示和关系的表示。
- 计算机中表示信息的最小单位是二进制数的一`位（bit）`。
- 若干个位组合起来形成的一个位串表示一个`数据元素`，通常称这个位串为`元素（element）`，或者`节点（node）`。
- 当 `数据元素` 有若干个 `数据项` 组成时为，位串中对应的各个数据项的子位串称为 `数据域`。
- `数据元素` 之间的关系有两种不同的表示方法 `顺序映像（相邻的元素）` 和 `非顺序映像`（不一定相邻），因此得到两种不同的存储结构 `顺序存储结构` 和 `链式存储结构`
- `顺序存储结构` 的特点是借助元素在存储器中相对位置来表示数据元素之间的逻辑关系。
- `链式存储结构` 的特点是借助指示元素存储地址的`指针`表示数据元素之间的逻辑关系。
- 算法的设计取决于选定的逻辑结构，而实现则依赖于采用的存储结构。

**数据类型🍎**


**抽象数据类型🍎**

- 原子类型

- 固定聚合类型

- 可变聚合类型


**多形数据类型🍎**



### 算法和算法分析

**什么是算法🍎**

**算法的设计要求🍎**
**算法的效率🍎**

- 时间复杂度
- 空间复杂度






















栈(stack)是简单的数据结构，但在计算机中使用广泛。它是有序的元素集合





内存的区域，以后进先出（LIFO）的方式添加或删除数据。
在计算机系统中，每个线程都有一个保留的内存区域称其为栈，当函数执行时，它可能会将其一些局部状态数据添加到堆栈的顶部；当函数退出时，它负责从堆栈中删除该数据。至少，线程的堆栈用于存储调用方提供的返回地址的位置，以便允许return语句返回正确的位置。堆栈通常用于存储当前活动函数本地固定长度的变量。

优缺点：

因为数据是以先进先出的方式添加和删除的，所以栈的内存分配非常简单，并且通常比通过动态（malloc）内存分配内存快得多。

另一个功能是，当函数退出时，栈上的内存会自动高效地回收，如果数据需要以某种形式保存，则必须在函数退出之前将其从堆、栈复制到堆中。因此，基于栈的分配适用于临时数据或在当前函数退出后不再需要的数据。


在某些小型CPU上，线程分配的堆栈大小可能只有几个字节。在堆栈上分配的内存多于可用内存，可能由于堆栈溢出而导致崩溃。

基于栈的分配也会导致较小的性能问题：导致可变大小的堆栈帧，因此需要管理堆栈指针和帧指针（对于固定大小的堆栈帧，其中之一是冗余的）。通常，这比调用 malloc 和 free 无论如何都要便宜得多。特别是，如果当前函数同时包含对alloca的调用和包含可变长度的本地数据的块，则alloca尝试增加当前堆栈帧直到当前函数退出与编译器需要将可变长度的局部变量放入其中之间会发生冲突。堆栈框架中的相同位置。通常通过为每个alloca调用创建一个单独的堆存储链来解决此冲突（请参阅：https://code.woboq.org/gcc/libiberty/alloca.c.html）。该链记录发生每次分配的堆栈深度，随后在任何函数中对alloca的调用都会将该链修剪到当前堆栈深度，以最终（但不是立即）释放该链上的任何存储空间。对参数为零的alloca的调用也可以用于触发释放内存，而无需分配更多此类内存。由于alloca和局部变量存储之间的这种冲突，使用alloca可能不会比使用malloc更有效。



子例程
某个主程序的一部分代码，该代码执行特定的任务并且与主程序中的其他代码相对独立。
子例程又被称为子程序、过程、方法、函数等。在主程序中可以调用子例程来执行。
　　函数，是一种子程序，利用函数名称，可以接收回传值。

调用栈
在计算机科学中调用栈是一种栈数据结构，用于存储有关计算机活动的子例程的信息。



有调用栈的主要原因
1要跟踪每个活动子例程在完成执行后应返回控制的点。已被调用但尚未完成执行的子例程，应将控制权交还给调用点。


2本地数据存储
另请参阅：基于堆栈的内存分配
子例程经常需要存储空间来存储局部变量的值，这些局部变量仅在活动子例程中是已知的，并且在返回后不会保留值。通过简单地将堆栈顶部移动足够的空间来提供空间，通常可以方便地分配空间。与使用堆空间的动态内存分配相比，这非常快。请注意，子例程的每次单独激活都会在堆栈中为本地变量获得其自己的单独空间。



由于调用栈是作为一个栈组织的，因此调用方将返回地址压入堆栈，并且被调用子例程完成后，将返回地址从调用堆栈中拉出或弹出，并将控制权转移到该地址。如果被调用子例程又调用另一个子例程，它将把另一个返回地址压入调用堆栈，依此类推，信息将按照程序的指示进行堆积和堆积。如果推入消耗了为调用堆栈分配的所有空间，则会发生称为堆栈溢出的错误，通常会导致程序崩溃。将子例程的条目添加到调用堆栈有时被称为“缠绕”。相反，删除条目是“结束”。





一个典型的堆栈，用于存储本地数据和用于嵌套过程调用（不一定是嵌套过程）的调用信息。该堆栈从其原始位置开始向下生长。堆栈指针指向堆栈上的当前最上面的基准。推操作使指针递减并将数据复制到堆栈；弹出操作会从堆栈中复制数据，然后递增指针。程序中调用的每个过程通过将过程返回信息（以黄色显示）和本地数据（以其他颜色显示）存储到堆栈中来存储它们。





## 数组
数组是最简单的内存数据结构了，在前端也有数组类型下面我们看看关于数组的知识
### 什么是数组<hr>
数组是存储一系列同一种类型的值（js 中可以是不同类型的值）。定义的时候为其分配存储单元，此存储单元在内存中是一块连续的区域，在使用前要先申请占用的内存大小。
```js
// js 中声明数组的一种方式，也可以使用 new Array
var arr = [1,2,3,4,5,6]
```
<img src="/images/array-what.jpg" width="50%"></img>

上面我们在代码中初始化了一个名为 arr 的数组，数组中的元素为 1，2，3，4，5，6，可以通过数组的 length 属性知道数组里面存了多少个元素。因为数组都有自己的下标 从 0 开始（上图中的[0]-[5]），所以可以通过 [] 中括号下标的方式去得到对应的值

```js
arr.length // 6
arr[0] // 1
arr[1] // 2
...
```
### 数组的操作<hr>

在 javascript 中对数组的操作其实也很容易，因为操作数组的 api 太多，所以我们通过添加、删除、合并、迭代、搜索、排序这几个方面来了解数组的常规操作。当然这里不会将所有的 api 都用到。更多 api 介绍请移步 <a href="https://www.studyfe.cn/2019/03/20/javascript/api/">操作数组的 API 方法</a>

> 数组的添加

在 javaScript 中，数组是一个可以修改的对象，如果向末尾添加元素，只要把值赋给数组最后一个空位上的元素即可。它就会动态增长这点和 java 有一定的区别。在 java 中要添加元素就必须创建一个全新的数组。因为在数组定义的时候要定义其长度，为其分配内存空间。如果类似 javaScript 那么在 java 中可以用集合 ArrayList。 

```js
// javascript
var arr = [1, 2, 3, 4, 5];
arr.push(6) // [1,2,3,4,5,6]
arr.push(7,8) // [1,2,3,4,5,6,7,8]
```
```java
// java
int[] arr = {1, 2, 3, 4, 5}; // 初始化默认值为1-5，分配长度为5的int 类型数组arr(静态) 
int arr = new int[5]; // 声明并分配一个长度为 5 的 int 类型数组 arr（动态），
```

```java
// java
ArrayList<Integer> list = new ArrayList(); // 声明实例的一个 int 类型的数组集合
list.add(1); // 向集合中添加一个元素
```

上面的 javascript 代码中我们向数组末尾添加了一个元素。接下来我们向数组首位添加一个元素。如果向首位添加一个元素，就需要将腾出数组中第一个元素的位置，把所有元素向右移动一位。

```js
var arr = [1, 2, 3, 4, 5];

for (var i = arr.length; i >= 0; i--) {
  arr[i] = arr[i-1];
}
arr[0] = 0; // [0, 1, 2, 3, 4, 5]
```

这段代码中我们通过循环向数组的首位添加了一个为 0 的元素。当然只是为了更好的演示数组的操作，也可以直接通过 api unshift 来添加。

```js
var arr = [1, 2, 3, 4, 5];
arr.unshift(0);
console.log(arr); // [0, 1, 2, 3, 4, 5]
```

下面这张图很好的描述了我们刚才的操作过程

<img src="/images/array-unshift.jpg" width="50%"></img>

现在数组中输出的数字是 0-5 并且数组的长度从 5 变为 6，那么接下来看看数组的删除

> 数组的删除

还是跟上面的操作一样，这回我们还是用循环删除数组中第一个元素，当然也可以用api shift 来删除

```js
// 循环
var arr = [0, 1, 2, 3, 4, 5];
for (var i = 0; i < arr.length; i ++) {
  arr[i] = arr[i+1];
}
console.log(arr) // [1, 2, 3, 4, 5, undefined]

// shift
arr.shift(); // 返回删除的元素 0
console.log(arr) // [1, 2, 3, 4, 5]
```

下面这张图很好的描述的这段代码的执行过程

<img src="/images/array-shift.jpg" width="50%"></img>

我们将数组里的所有元素左移动了一位。数组的长度依然是17，所以数组的末尾有一个额外的 undefined，因为在最后一次循环 ， i+1 引用了一个数组里还未初始化的位置。

当然我们也可以删除数组内指定的元素可以用 splice,从数组的索引开始的几个元素（下面就是从数组的索引2开始的3元素）

```js
var arr = [0,1,2,3,4,5];
var newArr = arr.splice(2,3); //[2,3,4]
console.log(arr) // [0,1,5]
console.log(newArr) //[2,3,4]
```

> 数组的合并

数组的合并在实际开发的应用中经常会用到，将多个数组进行迭代，把每个元素加入定义好的数组中。在 JavaScript 中提供了 concat 的方法来实现合并

```js
// concat
var arr = [1, 2, 3];
var arr1 = 0;
var arr2 = [-3, -2, -1];
var arr3 = arr2.concat(arr1, arr2);
console.log(arr3) // [-3, -2, -1, 0, 1, 2, 3]
```
```js
var arr = [1, 2, 3];
var arr1 = 0;
var arr2 = [-3, -2, -1];
var arr3  = [];

for(var i = 0; i < arr2.length; i++) {
  arr3.push(arr2[i]);
}
arr3.push(arr1);
for (var j = 0; j < arr.length; j++) {
  arr3.push(arr[j])
}
console.log(arr3) // [-3, -2, -1, 0, 1, 2, 3]
```
> 数组的迭代

在 javaScript 中内置了很多数组迭代的方法，every、some、forEach、map、filter、reduce 具体的 api 使用请参考 <a href="https://www.studyfe.cn/2019/03/20/javascript/api/">操作数组的 API 方法</a>原生方法实现请参考<a href="https://juejin.im/post/5c0b7f03e51d452eec725729">map 和 filter 的实现</a>也可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">mdn 的 Polyfill</a>

> 数组的搜索

数组的搜索方法请参考 <a href="https://www.studyfe.cn/2019/03/20/javascript/api/#toc-heading-15">indexOf</a>

> 数组的排序

在 Javascript 中对数组的排序提供了 sort api ，下面我们来看看 sort

sort 是按照字符编码顺序进行排序，如果想要实现业务逻辑排序需要自定义比较函数

**数字升序排序**

```js
var arr = [15,18,10,9,8,11,6,7];
let newArr = arr.sort(function (a,b){
  return a - b;
})

console.log(newArr); // [6, 7, 8, 9, 10, 11, 15, 18]
```

**字符串进行排序**

```js
var names = ['Ana','ana','john','John'];
var newNames = names.sort(); 
console.log(newNames) // ["Ana", "John", "ana", "john"]
```
上面这样可定是不对的因为 Javascript 做字符串比较的时候是根据ASCII值来比较的 A,j,a,j对应的值为65，75，97，106。所以需要我们要自定义函数

```js
var names = ['Ana','ana','john','John'];
var newNames = names.sort(function (a, b) {
  return a-b;
})
console.log(newNames) // ['Ana','ana','john','John']
```

**数组对象排序**

下面按照年龄排序，实际项目中有可能会用 id 进行排序

```js
var friends = [
  {name: 'zhangsan', age:30},
  {name: 'lisi', age:28},
  {name: 'wangwu', age: 29}
]
var newFriends = friends.sort(function (a, b) {
  return a.age - b.age;
})
console.log(newFriends)

```

### 小结<hr>

数组是最常用的数据结构，我们在上面举例说明了什么是数组、数组的创建、以及一些操作数组的常用API。虽然过于简单，但有助于我们在后续编写自己的算法时能够更好的深入和理解。当然有很多优秀的库供我们使用例如 <a href="https://www.lodashjs.com/">Lodash</a>。




















