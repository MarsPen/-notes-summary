---
title: 闭包
date: 2019-2-25 12:32:09
top: false
cover: false
password:
toc: true
mathjax: false
summary: 
tags:
- JavaScript
categories:
- JavaScript
---
说到闭包我们先来了解一下 JS 的作用域

### 什么是作用域<hr>

作用域是根据名称查找变量的一套规则，负责收集并维护数据的声明和标识，通过一系列的声明和标识能够组成访问查询

### 分类<hr>
- 全局作用域
- 局部作用域
- 块级作用域

那么作用域到底在哪里呢？我们先来了解一下除作用域外在 JS 中另外两个比较重要的东西编译器和引擎

编译器：负责代码的编译等工作，它有三个阶段
  - 词法分析: 把咱们的代码分析成词法单元（token令牌的形式）
  - 语法分析: 将上一个阶段组成的词法单元组成，词法单元流的形式，形成逐级嵌套的形式这个阶段也叫（AST抽象语法树）
  - 代码生成: 将抽象语法树进行对比生成我们要执行的代码块

引擎：负责编译和代码的执行等工作，执行的过程是

- 在全局代码执行前, js引擎就会创建一个栈来存储管理所有的执行上下文对象
- 在全局执行环境(window)确定后, 将其push到栈中
- 在函数执行环境创建后, 将其push到栈中
- 在当前函数执行完后,将栈顶的对象pop
- 当所有的代码执行完后, 栈中只剩下window

js初始化执行的时候会首先生成 GC 全局执行上下文，，生成必要的对象[objects] 和 [function]。会对他进行压栈操作，放到栈底。如果有很多函数会生成很多个 EC（执行上下文），每一个 EC 进行压栈操作形成 ESC（上下执行栈）。


### 上下文执行环境（EC）<hr>

概念：执行环境定义了变量或者函数有权访问的其他数据，决定了各自的行为

组成部分：
- 变量对象（varible object）：存放当前执行环境中定义的变量和函数，**如果当前环境是函数则将活动对象（activation object）作为变量对象，但不包括函数表达式**
- 作用域链（scope）：当代码在执行环境中运行时，会创建**变量对象**的一个**作用域链（词法作用域）**，能够保证对执行环境中所有变量和函数有序访问
- this指向：根据调用的规则不同this指向不同产生的执行环境上下文不同

EC 的执行生命周期：

- 创建阶段
  - 创建变量对象阶段（存储的与上下相关的数据作用域，它是一个特殊的对象包含着上下文的变量、函数声明（函数表达式不再vo中）
  - 创建作用域链（scope）
  - 创建 this 指向（thisValue）
- 执行阶段
  创建活动对象 ao（是一个活动对象，当函数被调用者激活的时候，这个特殊的 ao 就被创建了（函数表达式不再ao中））
- 回收阶段
  执行完毕后垃圾回收机制进行回收


EC 和 Scope 的区别：
- 创建时机不同，全局执行上下文是在全局作用域确定后js代码执行前创建的而函数执行上下文是在调用函数时, 函数体代码执行之前创建
- 作用域是静态的，执行上下文是动态的

### 作用域链<hr>
- 从内到外多个作用域形成的链
- 包含父级(**[[scope]]**)变量对象与作用域链和自身的变量对象

### 闭包概念 <hr>

当函数可以记住并访问所在的词法作用域时就产生了闭包，即使是在作用域外执行

### 闭包作用 <hr>

匿名自执行函数,减少内存消耗

```js
(function ($) {})(jQuery);
```

缓存计算结果

```js
  var fun1 = function(){
    var a=1;
    return function fun2(){
      a++;
      alert(a)
    }
  }
  var b = fun1();
  b(); // 2       
  b(); // 3           
```

封装,管理私有方法和变量，避免全局变量冲突污染

```js
  var person = function(){    
    var name = "renbo";       
    return {    
      getName : function(){    
        return name;    
      },    
      setName : function(newName){    
        name = newName;    
      }    
    }    
  }() 
```
实现类和继承等等

### 应用场景 <hr>
- 定时器、事件监听器、Ajax 请求，跨窗口通信，DOM事件的点击等
- 常用的就是IIFE 能够防止变量污染等作用


### 闭包缺点 <hr>

-  由于变量对象（ao）一直在内存中被外部变量引用不能被垃圾回收机制释放，导致内存过高。
-  由于多个函数共享一个父级，当父级有变量更改时，所有子函数受影响


### 推荐阅读

<a href="https://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">汤姆大叔的博客</a>